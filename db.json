{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"source/about/index/a.png","path":"about/index/a.png","modified":0,"renderable":0},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1505875075874},{"_id":"themes/BlueLake/_config.yml","hash":"423482aee39590d96a2c10248cea35b926c65faa","modified":1506142503495},{"_id":"source/_posts/Keepalived-LVS-Nginx.md","hash":"51a547a5d8f380a3d15fbe844ae949dfb3996c33","modified":1506137583542},{"_id":"themes/BlueLake/README.md","hash":"66c3ef7a779b6d65bad90daa2e03bcb7a1bb742f","modified":1505875075874},{"_id":"source/_posts/redis-cluster-centos.md","hash":"5b78f15b63b41008002e7e2620e7a4736d44d5b9","modified":1505972868673},{"_id":"source/about/index.md","hash":"e3f4fa91e62fbda6fda728765c7f3ceedace178f","modified":1505879993212},{"_id":"themes/BlueLake/README.en.md","hash":"6cc6e346635bf26dd71030b9c3c6443507cd4108","modified":1505875075874},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"a127deb32d1df69bbe50a3824a5f90472513c9c3","modified":1505875075886},{"_id":"themes/BlueLake/languages/en.yml","hash":"95bac2c366505d016b5defc47370679b9f5f3c4b","modified":1505875075888},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"baa68725feeec6643f875a532a9d55ba8aacdb2c","modified":1505875075890},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"bd97d5e4b39d30da1644b90256dfc4e6b1d76988","modified":1505875075891},{"_id":"themes/BlueLake/languages/ko.yml","hash":"fc8826724f570136d9a2d3ec2705b7b7000e0f14","modified":1505875075893},{"_id":"themes/BlueLake/languages/tr.yml","hash":"5f13d55fdd5bdd1115075736e3e26a1ea1dd1dea","modified":1505875075895},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1505875075897},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"d4d587ba81864910715c0c3879605cc6a9362e09","modified":1505875075898},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1505875075937},{"_id":"source/_posts/distributed-id-snowflake.md","hash":"7e7225207976d2a10ebd5d52bf07cd6afcbb0b84","modified":1505965291751},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1505875075947},{"_id":"themes/BlueLake/layout/base.jade","hash":"3805aaa6e96916e810b22d6a20d995f1fd3bf365","modified":1505875075937},{"_id":"source/_posts/hello-world.md","hash":"029f91fccbe8f87c0f3ea10c4042300d2fa7edc0","modified":1505875075874},{"_id":"themes/BlueLake/layout/index.jade","hash":"dd81d9f7a6b388de2ab731b17b3ba55f70df4a5f","modified":1505875075937},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1505875075947},{"_id":"themes/BlueLake/layout/post.jade","hash":"0305258c33e4d02f977ee1aaf7f2429b993fda17","modified":1505875075947},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1505875075947},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","hash":"e91f2139090c702ae554fa2a62f492bc2e175941","modified":1506131495597},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1505875075937},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1505875075947},{"_id":"source/_posts/distributed-id-snowflake/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1505877393493},{"_id":"source/_posts/redis-cluster-centos/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1505877393493},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"3f11d2b5a4c647bf2b37c4d00bdc250cda80b770","modified":1505875075901},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"c1f1955d12aee22a931a3f4ad9d0e9a408e80f3c","modified":1505875075905},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1505875075903},{"_id":"source/about/index/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1505877393493},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e0aa5d7adc1218a324a484abe3513e9545f89067","modified":1505875075909},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1505875075913},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1505875075915},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1505875075917},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1505875075917},{"_id":"themes/BlueLake/source/favicon.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1505875075964},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"d970c81b5cdbd7c0348ee28e93bcbb006d613b6d","modified":1505875075907},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1505875075917},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1505875075917},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1505875075927},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1505875075927},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1505875075927},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1505875075927},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1505875075927},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1505875075937},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"ba0839518db2cb9dafee67ca5e471219bfba2e90","modified":1505875075917},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1505875075927},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1505875075917},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1505875075911},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1505875075967},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1505875075969},{"_id":"themes/BlueLake/source/css/style.styl","hash":"45776bc176bc8ed0d664e953e23d6a0a9a030929","modified":1505875075962},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1505875075972},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1505875075981},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1505875075979},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1505875075983},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1505875075976},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1505875075960},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1505875075971}],"Category":[{"name":"数据库","_id":"cj7wpx4gv0003o4rav9emyf0q"},{"name":"Nginx","_id":"cj7wpx4ha0007o4ra371iur30"},{"name":"分布式系统","_id":"cj7wpx4hd000bo4ralkqb40xh"}],"Data":[],"Page":[{"title":"关于","date":"2017-09-20T03:52:09.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-09-20 11:52:09\n---\n","updated":"2017-09-20T03:59:53.212Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj7wpx4gk0001o4ra8vug60cw","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"redis一主多从集群配置","date":"2017-09-21T05:46:08.000Z","_content":"","source":"_posts/redis-cluster-centos.md","raw":"---\ntitle: redis一主多从集群配置\ndate: 2017-09-21 13:46:08\ncategories: 数据库\ntags:   redis\n---\n","slug":"redis-cluster-centos","published":1,"updated":"2017-09-21T05:47:48.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7wpx4gb0000o4rammtxwagg","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Keepalived+LVS+Nginx负载均衡之高可用","date":"2017-09-23T01:48:19.000Z","_content":"### LVS项目介绍\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n#### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n#### LVS搭建\n","source":"_posts/Keepalived-LVS-Nginx.md","raw":"---\ntitle: Keepalived+LVS+Nginx负载均衡之高可用\ndate: 2017-09-23 09:48:19\ncategories: Nginx\ntags: nginx负载均衡\n---\n### LVS项目介绍\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n#### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n#### LVS搭建\n","slug":"Keepalived-LVS-Nginx","published":1,"updated":"2017-09-23T03:33:03.542Z","_id":"cj7wpx4gp0002o4rasvsj5avz","comments":1,"layout":"post","photos":[],"link":"","content":"<h3 id=\"LVS项目介绍\"><a href=\"#LVS项目介绍\" class=\"headerlink\" title=\"LVS项目介绍\"></a>LVS项目介绍</h3><p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"external\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"external\">官网</a></p>\n<h4 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h4><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<h4 id=\"LVS搭建\"><a href=\"#LVS搭建\" class=\"headerlink\" title=\"LVS搭建\"></a>LVS搭建</h4>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"LVS项目介绍\"><a href=\"#LVS项目介绍\" class=\"headerlink\" title=\"LVS项目介绍\"></a>LVS项目介绍</h3><p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"external\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"external\">官网</a></p>\n<h4 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h4><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<h4 id=\"LVS搭建\"><a href=\"#LVS搭建\" class=\"headerlink\" title=\"LVS搭建\"></a>LVS搭建</h4>"},{"title":"分布式ID生成-snowflake算法","date":"2017-09-20T03:06:57.000Z","_content":"## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","source":"_posts/distributed-id-snowflake.md","raw":"---\ntitle: 分布式ID生成-snowflake算法\ndate: 2017-09-20 11:06:57\ncategories: 分布式系统\ntags: snowflake算法\n---\n## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","slug":"distributed-id-snowflake","published":1,"updated":"2017-09-21T03:41:31.751Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj7wpx4gy0005o4ra42svkgok","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\" alt=\"a.png\" title=\"\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\" alt=\"a.png\" title=\"\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>"}],"PostAsset":[{"_id":"source/_posts/redis-cluster-centos/a.png","slug":"a.png","post":"cj7wpx4gb0000o4rammtxwagg","modified":0,"renderable":0},{"_id":"source/_posts/distributed-id-snowflake/a.png","slug":"a.png","post":"cj7wpx4gy0005o4ra42svkgok","modified":0,"renderable":0},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","slug":"a.png","post":"cj7wpx4gp0002o4rasvsj5avz","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cj7wpx4gb0000o4rammtxwagg","category_id":"cj7wpx4gv0003o4rav9emyf0q","_id":"cj7wpx4hd000ao4rauqw4yxfx"},{"post_id":"cj7wpx4gp0002o4rasvsj5avz","category_id":"cj7wpx4ha0007o4ra371iur30","_id":"cj7wpx4he000eo4rai2mhhiq6"},{"post_id":"cj7wpx4gy0005o4ra42svkgok","category_id":"cj7wpx4hd000bo4ralkqb40xh","_id":"cj7wpx4hf000go4rayqutaqd4"}],"PostTag":[{"post_id":"cj7wpx4gb0000o4rammtxwagg","tag_id":"cj7wpx4gx0004o4rah712gu8i","_id":"cj7wpx4hc0009o4rah8adg6ha"},{"post_id":"cj7wpx4gy0005o4ra42svkgok","tag_id":"cj7wpx4hd000co4raz20oj8bs","_id":"cj7wpx4he000fo4rawj6zjct7"},{"post_id":"cj7wpx4gp0002o4rasvsj5avz","tag_id":"cj7wpy8kg000ho4rahjlq3h3h","_id":"cj7wpy8kh000io4ravjy81vsp"}],"Tag":[{"name":"redis","_id":"cj7wpx4gx0004o4rah712gu8i"},{"name":"负载均衡","_id":"cj7wpx4ha0008o4ra49tqnxni"},{"name":"snowflake算法","_id":"cj7wpx4hd000co4raz20oj8bs"},{"name":"nginx负载均衡","_id":"cj7wpy8kg000ho4rahjlq3h3h"}]}}