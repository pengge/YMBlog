{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/favicon-1.ico","path":"favicon-1.ico","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":0,"renderable":1},{"_id":"source/about/index/a.png","path":"about/index/a.png","modified":0,"renderable":0},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":0,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":0,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/README.en.md","hash":"6cc6e346635bf26dd71030b9c3c6443507cd4108","modified":1541726431091},{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1541726431091},{"_id":"themes/BlueLake/README.md","hash":"66c3ef7a779b6d65bad90daa2e03bcb7a1bb742f","modified":1541726431091},{"_id":"themes/BlueLake/_config.yml","hash":"edf3d94e9f0078c982f487fa8be01189cb83b345","modified":1541726431091},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1541726431185},{"_id":"source/about/index.md","hash":"57df7860368f7ef928574c367758944a951c7c4d","modified":1541726431076},{"_id":"source/_posts/Keepalived-LVS-Nginx.md","hash":"58e4f6a4616d9762e74834dfb7ead98430cff2ae","modified":1541726429968},{"_id":"source/_posts/angular-start.md","hash":"c4f117746c6eec95d1f8e97ad7b534fcec1db460","modified":1541726429968},{"_id":"source/_posts/api-version.md","hash":"baf5901cede3dd8b1eb7b0d1358a4251b04a1a58","modified":1541726429968},{"_id":"source/_posts/aws-server.md","hash":"e8d810674fede4573beb3431c22c2648e0cd8202","modified":1541726429999},{"_id":"source/_posts/apidoc-java.md","hash":"3275ea6be4e1be2434129de9ca159bca92af2ea2","modified":1541726429984},{"_id":"source/_posts/blockchain-hash.md","hash":"66f999b5b2f8664550f77249623994f7320eed30","modified":1541726429999},{"_id":"source/_posts/centos-jdk8-install.md","hash":"e563c23d5ba2f32d0bb949a240afeb64ca0bf080","modified":1541726429999},{"_id":"source/_posts/centos-login-without-pwd.md","hash":"b75428d5c95beef4080f39cedc29cc9b136b76c5","modified":1541726429999},{"_id":"source/_posts/centos-maven-nexus.md","hash":"b109f6b924d2d03f155a8acf51a0d683649c9ae3","modified":1541726429999},{"_id":"source/_posts/concourse-tutorial.md","hash":"dccc7d12ac1d94b39da2b9624228fbd24d0b5cb7","modified":1541726430046},{"_id":"source/_posts/centos-mysql-install.md","hash":"e312419eab275f84d8b241768923a5960ff7cbb1","modified":1541726430046},{"_id":"source/_posts/cron-grammar.md","hash":"9b289b5f18187aa124447c81a583b91421c0f8fa","modified":1541726430046},{"_id":"source/_posts/distributed-difficulty.md","hash":"e3da47867669ce17645f4f4654b74eeff6c5865e","modified":1541726430046},{"_id":"source/_posts/distributed-id-snowflake.md","hash":"bc0fcf9cb5d5cb67f40e8ddb36ba83e1fcdffbae","modified":1541726430046},{"_id":"source/_posts/docker-app-install.md","hash":"1eb552ea4379ecbd0bd9a22f5d14b35ec12a19e7","modified":1541726430046},{"_id":"source/_posts/docker-install-centos7.md","hash":"58edb9bbb763363d6e9e798911f43f1aa685ef23","modified":1541726430046},{"_id":"source/_posts/docker-install-ubuntu16.md","hash":"51965be6399f656a93d94deb32551cf104d87815","modified":1541726430062},{"_id":"source/_posts/docker-lesson2.md","hash":"bbdae0019ef38d8455906853c2c17e63259cca91","modified":1541726430062},{"_id":"source/_posts/docker-lesson1.md","hash":"ba3453f67da1ad1df6264a68994b22e87886a85d","modified":1541726430062},{"_id":"source/_posts/docker-lesson3-images.md","hash":"4bf715dedcf715912fa86c44e0a136c182ae9ad7","modified":1541726430062},{"_id":"source/_posts/docker-lesson4-container.md","hash":"57a6f492d6033f67e189c1057602949e7f552a7c","modified":1541726430077},{"_id":"source/_posts/docker-lesson6-net.md","hash":"caafe0942b9f182e9df3fffe348b99e81026296f","modified":1541726430093},{"_id":"source/_posts/docker-lesson5-dv.md","hash":"5b27da0ee0881679383d5a734284bf1dfec73c0e","modified":1541726430077},{"_id":"source/_posts/docker-lesson7-compose.md","hash":"a81ef11cfc0ed6427ec437979233f8aa10bee6e0","modified":1542262979792},{"_id":"source/_posts/fastdfs-start.md","hash":"52bcc9a3283e4326384914c4dccd24b4017b7146","modified":1541726430093},{"_id":"source/_posts/git-branch.md","hash":"cee20d6a9d7a3e3fd098a35b2781796896d29c1c","modified":1541726430093},{"_id":"source/_posts/git-install-in-centos7.md","hash":"1508866cc2ba5b3b3c41bf6d78169252e3576577","modified":1542439799103},{"_id":"source/_posts/git-tag.md","hash":"148c058d5ef94fa1f7a83d3273e659fa0356e1df","modified":1541726430093},{"_id":"source/_posts/git-server-build.md","hash":"60a8320bca9568edd56fee8fb299ae1a44556ad9","modified":1541726430093},{"_id":"source/_posts/git-use.md","hash":"14a49632506b49d3ce4d07161bd4067c5471f861","modified":1541726430093},{"_id":"source/_posts/github-fork-repo-update.md","hash":"307a47abe89bac62b0ce2b6347832481049898ad","modified":1541726430108},{"_id":"source/_posts/hashicorp-vault.md","hash":"9174738ccc5a18381ed89e0e775168e2622f0ae9","modified":1541726430108},{"_id":"source/_posts/hibernate-relation-mapping.md","hash":"f5afc163cf2e5269217320c41d43eda3c4e9a836","modified":1541726430108},{"_id":"source/_posts/http-protocol-overview.md","hash":"a6c6882fb2c1ab271401a482fc3b6177b3552888","modified":1541726430108},{"_id":"source/_posts/idea-XRebel.md","hash":"12e23597add6ef46b8e36cbf324a1334753b2c9b","modified":1541726430124},{"_id":"source/_posts/idea-file-template.md","hash":"b2b5087aad0baa2dd6da16f5f97d28ad58f96c22","modified":1541726430124},{"_id":"source/_posts/idea-good-plug.md","hash":"6453c7b737a04e2d8e7d4f609b58b54d9b2f9d8f","modified":1541726430155},{"_id":"source/_posts/istio-start.md","hash":"4f8fde313d1df050bbbf530f4f9908b05e2517da","modified":1541726430155},{"_id":"source/_posts/jackson-show-time.md","hash":"f83b7c2899b17d623137555968f6ec3f017f4bf6","modified":1541726430155},{"_id":"source/_posts/javapoet-apt-annotation.md","hash":"80c183d82fbde10d5fe08a194f7ff272ae13a8d0","modified":1541726430155},{"_id":"source/_posts/javase-cglib.md","hash":"36d206936281ba5365b47510244c489d200cc0c5","modified":1541726430171},{"_id":"source/_posts/javase-nio-buffer.md","hash":"2b2af405ff739b06e59675ebcab5dd0b5401dc9f","modified":1541726430171},{"_id":"source/_posts/jenkins-java-maven.md","hash":"3b3ce34a5c474d85bb16af47c13499bc20f57ea3","modified":1541726430171},{"_id":"source/_posts/jvm-gc.md","hash":"50d8908e1924d2d9699d0c5eeefae4005f5d1d12","modified":1541726430233},{"_id":"source/_posts/jvm-look-tools.md","hash":"f3cf120a60f85ecabb87410bb7957965c8c56c52","modified":1541726430233},{"_id":"source/_posts/jwt-study.md","hash":"84849a2a64c143bf0353a70cdc6a98e39bdf121e","modified":1541726430233},{"_id":"source/_posts/k8s-start.md","hash":"407816e36d590bd127a37a218b04f6623e8873e3","modified":1541726430233},{"_id":"source/_posts/linux-centos-command.md","hash":"4371750fca8e4833dfa2578d86446d14905cc028","modified":1542252418350},{"_id":"source/_posts/linux-command-use.md","hash":"05147e0583318c7a0fe6e4648666f564f028c486","modified":1541726430249},{"_id":"source/_posts/linux-ubuntu-commom.md","hash":"a739cb134211484543262d3159b1a70e299fc3d2","modified":1541726430249},{"_id":"source/_posts/linux-ubuntu-navicat.md","hash":"322a1da2ef0db60e19a2a0a4918daae96fddca1e","modified":1541726430249},{"_id":"source/_posts/maven-ofen.md","hash":"1a2a9e034d4ff669ef8554fdb3ed7bc8749698b4","modified":1541726430249},{"_id":"source/_posts/maven-use-error-collect.md","hash":"1dc0e66221ae0ba38361831e83600b3817c0a88e","modified":1541726430264},{"_id":"source/_posts/microservice-think.md","hash":"857847b7b3953ddea45418c6383d2dc095b104fd","modified":1541726430264},{"_id":"source/_posts/mysql-copy.md","hash":"63720416a2ad3ae159ce3a1d0098fd7b0cfeb0be","modified":1541726430264},{"_id":"source/_posts/mysql-create.md","hash":"5699b0784010a2265148fc5e058bd9a0d6f7122c","modified":1541726430280},{"_id":"source/_posts/mysql-explain.md","hash":"d1c9629c03331300a29fd1aa0a4555d37f83fd0b","modified":1541726430280},{"_id":"source/_posts/mysql-practice.md","hash":"6f6076b5c6d2f0c73e53a4aa9f6285b030a5db0f","modified":1541726430280},{"_id":"source/_posts/nginx-study.md","hash":"def94d014d3cada2a7afd971291e9c72d52699b2","modified":1541726430280},{"_id":"source/_posts/ngrok-start.md","hash":"b0b59ff1dc970a66387265152e4a3366eca91543","modified":1541726430280},{"_id":"source/_posts/npm-use.md","hash":"bee6dbc4bd7594333301be6f3e78a786ca6a9820","modified":1541726430280},{"_id":"source/_posts/pivotal-web-service-start.md","hash":"b49bff609df5b2995516d5a81048282229f84d96","modified":1541726430280},{"_id":"source/_posts/rabbitmq-action.md","hash":"4ac52b96b2195490f8290496b7736f6f2be1f11d","modified":1541726430296},{"_id":"source/_posts/rabbitmq-install.md","hash":"270e4f854257e9aa402228c3a548edbd460bdb9c","modified":1541726430296},{"_id":"source/_posts/redis-cluster-centos.md","hash":"8b4ccbb05fdf6d26f62aea1e574cfd951c401d72","modified":1541726430311},{"_id":"source/_posts/redis-common.md","hash":"d7b10e651f5f4f7b6e5ac5425a54be3238d83fea","modified":1541726430311},{"_id":"source/_posts/redis-conf.md","hash":"db4b21dc750f90f6ba3a1577492726ffc7e6a193","modified":1541726430311},{"_id":"source/_posts/redis-install.md","hash":"353cea7d9f2daa0a3f1d9b90fc83f4abb0bd9514","modified":1541726430311},{"_id":"source/_posts/redis-distributed-lock.md","hash":"932fcec3a16bbf8bf24662d0555cf57810323824","modified":1541726430311},{"_id":"source/_posts/redis-sentinel.md","hash":"4831e2355b3badf79e10b83934482b4568265e5c","modified":1541726430311},{"_id":"source/_posts/redmine-plugins.md","hash":"17e6fc1dd3b0ec6852d106284c5a87a45f1d337f","modified":1543376520899},{"_id":"source/_posts/redmine-mongrel-nginx.md","hash":"fc05902043a3fa05aa6157c52d40590308e85ccc","modified":1542363357323},{"_id":"source/_posts/redmine-use-record.md","hash":"711e4cb6648f964e3811df29dc19c7e092f73b0e","modified":1543317132076},{"_id":"source/_posts/redmine-start.md","hash":"e30c722953c0282d92fb66935b11e365d730a03a","modified":1542359761227},{"_id":"source/_posts/restful-api-dev.md","hash":"2801e8a7e037d0b3992adc795ca8b1b11fcb8b21","modified":1541726430342},{"_id":"source/_posts/rocketmq-start.md","hash":"d1bcd1a37c4121a0f6972ed815e21439bf1cb32e","modified":1541726430342},{"_id":"source/_posts/sboot-change-contextpath.md","hash":"6c9153ebaac81b554dd7086f80b744e5e022438d","modified":1541726430342},{"_id":"source/_posts/scloud-feign-anyquestion.md","hash":"97cccd89fe7a037ac6d9a680492371cf25ea4323","modified":1541726430358},{"_id":"source/_posts/scloud-config-server-encrypt-decrypt.md","hash":"101fdad3cce861e99e026d726947c3142d0dac30","modified":1541726430358},{"_id":"source/_posts/scloud-feign-config.md","hash":"aafb8ae5facfd7154face2197fa7242646fd2b2c","modified":1541726430358},{"_id":"source/_posts/scloud-hystrix-dashboard.md","hash":"50bb75b4018555ea3c2d155f51ea8837e1eaabc9","modified":1541726430358},{"_id":"source/_posts/scloud-hystrix.md","hash":"b93a44ca9970fd7d3abc8a562979bdad31c3504f","modified":1541726430358},{"_id":"source/_posts/scloud-zuul-exception.md","hash":"338d5bdac28f1b324b0fbb4e60ccfd9861bf8f49","modified":1541726430358},{"_id":"source/_posts/scloud-zuul-filters.md","hash":"519299e5a981ecdfaa17930051f0511d7025165f","modified":1541726430374},{"_id":"source/_posts/scloud-zuul-start.md","hash":"b5c62dc5de4f85a221caffef1c258d4e996755c4","modified":1541726430374},{"_id":"source/_posts/shadowsocks-go.md","hash":"004642cbb4d79da733bf0476f8a60ff8a2bf0f59","modified":1541726430374},{"_id":"source/_posts/shiro-start.md","hash":"d93194b941f36e5e80da4b3e5888d1515695d459","modified":1541726430888},{"_id":"source/_posts/spring-boot-async.md","hash":"66637910cd5cc592a1bf0eebdc649d486aa2dd06","modified":1541726430904},{"_id":"source/_posts/spinnaker-start.md","hash":"3d7bbeba71eb3f99a5bf1bc24ad601b6cf80572b","modified":1541726430904},{"_id":"source/_posts/spring-boot-cache.md","hash":"fa2a229e3e0e238373a4fb0e056761f654d96782","modified":1541726430904},{"_id":"source/_posts/spring-boot-cors.md","hash":"ee83eea66c28a323f2979cec00340dba10e88297","modified":1541726430904},{"_id":"source/_posts/spring-boot-dev-error-show.md","hash":"631be620130ee80ea2ea4128336edf8205aad59e","modified":1541726430920},{"_id":"source/_posts/spring-boot-filter.md","hash":"d2e76899ae13f0f8ed636553e26e7b6ad8cd3a65","modified":1541726430920},{"_id":"source/_posts/spring-boot-messages.md","hash":"6fb63bd705e0a19c30802a8cce594aef87304e7b","modified":1541726430935},{"_id":"source/_posts/spring-boot-jar.md","hash":"ae0aa90ffdcb158055a351e203fd639dd8f83c88","modified":1541726430920},{"_id":"source/_posts/spring-jpa-multiple-datasource.md","hash":"bb6d61d0d3af82505a37fa2a08141847b34dd17d","modified":1541726430935},{"_id":"source/_posts/teamcity-use-start.md","hash":"78c25c1da41ec9d3087a036ef3204447f768fb32","modified":1541726430935},{"_id":"source/_posts/tslang-study-one.md","hash":"b81c8d6bdde2067462944f49647bbd6e00246e5d","modified":1541726430935},{"_id":"source/_posts/vagrant-Xshell.md","hash":"39b023e131b1aeaf084eb91effd2524121defc80","modified":1542268412612},{"_id":"source/_posts/vagrant-cli.md","hash":"bdd6b541af37c147a0db38261fd81b01efe13944","modified":1542275620673},{"_id":"source/_posts/vagrant-start.md","hash":"71536d3a1166139d6e9e12edc5fd0632b25e7e7b","modified":1541726430935},{"_id":"source/_posts/vagrant-vagrantfile.md","hash":"c13605203aa97aa91ac85517aee560325edbe1ca","modified":1542275795622},{"_id":"source/_posts/vault-study.md","hash":"98bf7f67c4b8a0aa0619a0348dee3c9025603dc2","modified":1541726430951},{"_id":"source/_posts/website-high-performance.md","hash":"f94d8e78434734bcf3e8e270cae6af3b74fe5bc1","modified":1541726430951},{"_id":"source/_posts/wkhtmltopdf.md","hash":"7af896adf3556871d53485fc5d2b20eaad51bd15","modified":1541726430966},{"_id":"source/_posts/redis-pub-sub.md","hash":"e94d9a58e89f4eb45828e9416a6311f52b6aa395","modified":1541726430311},{"_id":"source/_posts/zookeeper-curator.md","hash":"8ec9e2f31247ee2be67bf80a7c07014088270780","modified":1541726431076},{"_id":"source/_posts/zookeeper-start.md","hash":"ecc77a892c06aa259b9a56c63965eb414fd8f6b3","modified":1541726431076},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"a127deb32d1df69bbe50a3824a5f90472513c9c3","modified":1541726431091},{"_id":"themes/BlueLake/languages/en.yml","hash":"95bac2c366505d016b5defc47370679b9f5f3c4b","modified":1541726431091},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"baa68725feeec6643f875a532a9d55ba8aacdb2c","modified":1541726431107},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"bd97d5e4b39d30da1644b90256dfc4e6b1d76988","modified":1541726431107},{"_id":"themes/BlueLake/languages/ko.yml","hash":"fc8826724f570136d9a2d3ec2705b7b7000e0f14","modified":1541726431107},{"_id":"themes/BlueLake/languages/tr.yml","hash":"5f13d55fdd5bdd1115075736e3e26a1ea1dd1dea","modified":1541726431107},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1541726431107},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"d4d587ba81864910715c0c3879605cc6a9362e09","modified":1541726431107},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1541726431169},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1541726431169},{"_id":"themes/BlueLake/layout/base.jade","hash":"3805aaa6e96916e810b22d6a20d995f1fd3bf365","modified":1541726431169},{"_id":"themes/BlueLake/layout/index.jade","hash":"dd81d9f7a6b388de2ab731b17b3ba55f70df4a5f","modified":1541726431169},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1541726431169},{"_id":"themes/BlueLake/layout/post.jade","hash":"0305258c33e4d02f977ee1aaf7f2429b993fda17","modified":1541726431185},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1541726431185},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1541726431185},{"_id":"themes/BlueLake/source/favicon-1.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1541726431200},{"_id":"themes/BlueLake/source/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1541726431200},{"_id":"source/_posts/api-version/a.png","hash":"a20c7a7f6a7ff592a425625fc54d16f438c55e4e","modified":1541726429984},{"_id":"source/_posts/api-version/b.png","hash":"8571a75e4e87d975781b9e3ee105e89684b0e207","modified":1541726429984},{"_id":"source/_posts/api-version/c.png","hash":"c82a2265f368c807f4c215c1a77db2cb3d755013","modified":1541726429984},{"_id":"source/_posts/api-version/d.png","hash":"1e3b87d4365ce11477d699a2af6ce5522c07950e","modified":1541726429984},{"_id":"source/_posts/api-version/e.png","hash":"bb846b7dea9e424afad7c3bf245416f03f2407f6","modified":1541726429984},{"_id":"source/about/index/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726431076},{"_id":"source/_posts/architect-awesome.md","hash":"25b214b72f18894fa2397fff0b2b600936f64941","modified":1541726429999},{"_id":"source/_posts/centos-maven-nexus/a.png","hash":"5ae80ce14b4f22a0c5f4d79e1189800e1d98d85d","modified":1541726430015},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","hash":"e91f2139090c702ae554fa2a62f492bc2e175941","modified":1541726429968},{"_id":"source/_posts/distributed-id-snowflake/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430046},{"_id":"source/_posts/docker-install-centos7/a.png","hash":"53319885ee2b62298a8dd0bbf97e66e075d63c33","modified":1541726430062},{"_id":"source/_posts/docker-lesson3-images/a.png","hash":"127496e0d28b06a73bc5a0947c0cfc91dfb35bcd","modified":1541726430077},{"_id":"source/_posts/docker-lesson3-images/b.png","hash":"b8e0f05db2ca87f59e5b3b4360639abf6d595768","modified":1541726430077},{"_id":"source/_posts/docker-lesson3-images/yy.png","hash":"45afb92a7893aa9b8b1ae07254eb253d5c008957","modified":1541726430077},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1541726430108},{"_id":"source/_posts/hashicorp-vault/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430108},{"_id":"source/_posts/http-protocol-overview/b.png","hash":"d2158e4cc7c3129a86163fc087f3fdc70cc3f570","modified":1541726430124},{"_id":"source/_posts/idea-file-template/d.png","hash":"297c07f9361f15c4a75c2b0ff2d6f8ea35b76827","modified":1541726430140},{"_id":"source/_posts/docker-install-ubuntu16/a.png","hash":"c0c863a0be8921034af76f51a76c0d908735ed9d","modified":1541726430062},{"_id":"source/_posts/idea-file-template/j.png","hash":"81739226bb3fe7555e03210d8fe15790ba896376","modified":1541726430155},{"_id":"source/_posts/javapoet-apt-annotation/a.png","hash":"7a3629a2c00c64293346769a80fd3f2b4882eb33","modified":1541726430155},{"_id":"source/_posts/javapoet-apt-annotation/b.png","hash":"1f0698b9282cca313661656e1bfd9263f3d09bac","modified":1541726430155},{"_id":"source/_posts/jenkins-java-maven/1.png","hash":"c89c3f8f039bb7e3c7b1c8ba19aa421ae5857aba","modified":1541726430171},{"_id":"source/_posts/jenkins-java-maven/11.png","hash":"3d4d301aeb6a173b5681f47dbdefde4f3d91fc38","modified":1541726430171},{"_id":"source/_posts/jenkins-java-maven/13.png","hash":"17b95987316f24f5a4aaa69703b05fbfb52b3872","modified":1541726430186},{"_id":"source/_posts/jenkins-java-maven/14.png","hash":"5eb1accc639b0941b54e6e1c2ec81bcd4133b873","modified":1541726430186},{"_id":"source/_posts/jenkins-java-maven/15.png","hash":"9bdbf1d30b1e1f50df5148d71c69f78a584b522a","modified":1541726430186},{"_id":"source/_posts/jenkins-java-maven/4.png","hash":"7476872c0a08be7fbeda0ae5a52ebde940cfc0f6","modified":1541726430202},{"_id":"source/_posts/jenkins-java-maven/6.png","hash":"00ff2355e8986eb0014b5894230b6fd79462eeeb","modified":1541726430202},{"_id":"source/_posts/jenkins-java-maven/7.png","hash":"e16f5020b6038b856ea2a01301f03f305e5a5399","modified":1541726430202},{"_id":"source/_posts/jenkins-java-maven/8_1.png","hash":"3b6647cdf713816d9f60deced0a25f59a55798e5","modified":1541726430202},{"_id":"source/_posts/jenkins-java-maven/8.png","hash":"08b0b19249e2c677b6fc774655b586cbd8be8664","modified":1541726430202},{"_id":"source/_posts/jenkins-java-maven/b.png","hash":"4dd65c11f708e2e1feaf1c84b2f2a97c6baffb58","modified":1541726430218},{"_id":"source/_posts/jenkins-java-maven/9.png","hash":"dc3d500c3de6fc1c7c0d17c05628042f244c264b","modified":1541726430218},{"_id":"source/_posts/jenkins-java-maven/e.png","hash":"038c511df2eaaf6a578ed59860a4fba5f99c560f","modified":1541726430218},{"_id":"source/_posts/jenkins-java-maven/f.png","hash":"bcdfa5c4be7b749d533d2f78aeba07576a33e010","modified":1541726430218},{"_id":"source/_posts/jenkins-java-maven/g.png","hash":"e8b5ab0bc4de16515059f0d854fca3455713aa40","modified":1541726430233},{"_id":"source/_posts/linux-command-use/a.png","hash":"dc9aa307fe9221d90f71dfa95841ea3acbab18cc","modified":1541726430249},{"_id":"source/_posts/linux-command-use/b.png","hash":"12fb8951ab9e7361d775a1b0ceb7546cfae5c7fe","modified":1541726430249},{"_id":"source/_posts/maven-ofen/a.jpg","hash":"636125fa0cc1f01d7f341619c5822cdc1b420bb2","modified":1541726430264},{"_id":"source/_posts/microservice-think/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430264},{"_id":"source/_posts/pivotal-web-service-start/d.png","hash":"70fedd27e98b3d0b83af6ad4f9538a3fc8a83c05","modified":1541726430296},{"_id":"source/_posts/redis-cluster-centos/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430311},{"_id":"source/_posts/redmine-start/a.png","hash":"5e5759cf527bda7aacb0972daf9e6a38fce9b3e8","modified":1541726430327},{"_id":"source/_posts/redmine-start/d.png","hash":"5b09d3b1399d1a4c93277ef40179ae51c88323c8","modified":1541726430342},{"_id":"source/_posts/restful-api-dev/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430342},{"_id":"source/_posts/sboot-change-contextpath/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430342},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430358},{"_id":"source/_posts/scloud-zuul-exception/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430374},{"_id":"source/_posts/shadowsocks-go/a.png","hash":"85d77fc8a4bcd6f9bb73eaaaed4a69fbc171b1fa","modified":1541726430436},{"_id":"source/_posts/shadowsocks-go/b.png","hash":"a0dac0425805a400c38eeb20cdd920fb806d4fa0","modified":1541726430436},{"_id":"source/_posts/shiro-start/shiro-01.png","hash":"f1b5d1f08ae296adc08858f1e50382963636ea68","modified":1541726430888},{"_id":"source/_posts/shiro-start/shiro-02.png","hash":"05b764effd7132edb13b1780f71870bd1513b56c","modified":1541726430888},{"_id":"source/_posts/shiro-start/shiro-04.png","hash":"8260317b692da93a2d846bf07bcfbfc542749d47","modified":1541726430904},{"_id":"source/_posts/spring-boot-dev-error-show/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726430920},{"_id":"source/_posts/spring-boot-filter/b.png","hash":"07c9a6bba01baf00436ccb1414ba15c0a1ca570c","modified":1541726430920},{"_id":"source/_posts/vagrant-Xshell/a-1.png","hash":"058a5b9eedc81d3786795f17daa7b4dd1154ef10","modified":1542266738545},{"_id":"source/_posts/vagrant-Xshell/a-2.png","hash":"9e569992ffe988850057aebbbde603d9c807e3c9","modified":1542266981123},{"_id":"source/_posts/vagrant-Xshell/a-3.png","hash":"38bfdfd74aaf0c787c8ee0c8a15072e0895e3011","modified":1542267145594},{"_id":"source/_posts/vagrant-Xshell/b-1.png","hash":"1ed72d83fe9207c871f5ccf5014f4cd2278d67ac","modified":1542267598401},{"_id":"source/_posts/vagrant-Xshell/b-2.png","hash":"17930c0a8f61045a1a1981d1021f7ae4e7cc2a10","modified":1542267956559},{"_id":"source/_posts/spring-boot-filter/a.png","hash":"96b8176f66bf1e15643484e17f2228c42ef6c572","modified":1541726430920},{"_id":"source/_posts/website-high-performance/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1541726430951},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"3f11d2b5a4c647bf2b37c4d00bdc250cda80b770","modified":1541726431122},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1541726431122},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"c1f1955d12aee22a931a3f4ad9d0e9a408e80f3c","modified":1541726431122},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"d970c81b5cdbd7c0348ee28e93bcbb006d613b6d","modified":1541726431122},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e0aa5d7adc1218a324a484abe3513e9545f89067","modified":1541726431122},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1541726431122},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1541726431138},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1541726431138},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1541726431138},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1541726431138},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1541726431138},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"ba0839518db2cb9dafee67ca5e471219bfba2e90","modified":1541726431138},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1541726431138},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1541726431154},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1541726431154},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1541726431154},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1541726431154},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1541726431154},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1541726431169},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1541726431169},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1541726431154},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1541726431185},{"_id":"themes/BlueLake/source/css/style.styl","hash":"45776bc176bc8ed0d664e953e23d6a0a9a030929","modified":1541726431185},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1541726431200},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1541726431200},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1541726431216},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1541726431200},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1541726431216},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1541726431216},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1541726431232},{"_id":"source/_posts/apidoc-java/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1541726429999},{"_id":"source/_posts/centos-maven-nexus/c.png","hash":"0721cae59a5622f3dfcb6259c018f433598ae858","modified":1541726430015},{"_id":"source/_posts/centos-maven-nexus/d.png","hash":"4837ba62f9c498d52f0d516c33555909ff890419","modified":1541726430015},{"_id":"source/_posts/centos-maven-nexus/g.png","hash":"c0177448d5f462df7e3d759f29d14c3faf75eb1b","modified":1541726430030},{"_id":"source/_posts/centos-maven-nexus/h.png","hash":"119b973e074ab4069e934112e6daa5557023b704","modified":1541726430030},{"_id":"source/_posts/centos-maven-nexus/j.png","hash":"4c3771a7c674c70043a68f478bce1bdb18cb1844","modified":1541726430030},{"_id":"source/_posts/centos-maven-nexus/i.png","hash":"47e4f15afff60b872071c95fb23eaf5452e6329a","modified":1541726430030},{"_id":"source/_posts/centos-maven-nexus/e.png","hash":"42bf2cfd4787980d2fd0105ad3dd89afc0cf36fb","modified":1541726430015},{"_id":"source/_posts/centos-maven-nexus/f.png","hash":"696a68fdcf708980f808d0e09b604a71b774a37f","modified":1541726430030},{"_id":"source/_posts/http-protocol-overview/a.png","hash":"cdc1232c447bc61a7c3df4fd8ecf4c7947b7c739","modified":1541726430124},{"_id":"source/_posts/idea-file-template/c.png","hash":"510c42e232b3106a1b7628610d617f906887bcd0","modified":1541726430140},{"_id":"source/_posts/idea-file-template/e.png","hash":"c2e2b2c5c2e00052157cca5cce8790bd9a867b03","modified":1541726430140},{"_id":"source/_posts/docker-lesson3-images/c.png","hash":"2f3aa0341cfe8ff2c49a8cbca20e5f67a9c4f599","modified":1541726430077},{"_id":"source/_posts/jenkins-java-maven/3.png","hash":"6070bc84371a9ef3d9dbfc50767e9c47759815b3","modified":1541726430186},{"_id":"source/_posts/jenkins-java-maven/2.png","hash":"90cfb0af72732942f35b3455716b6ddd939f636a","modified":1541726430186},{"_id":"source/_posts/idea-file-template/f.png","hash":"0cf06ae696464acdbf9def1691e2343111879d9a","modified":1541726430140},{"_id":"source/_posts/jenkins-java-maven/10.png","hash":"29788dae623aaa45c8b30658d1c56bdab7fb0279","modified":1541726430171},{"_id":"source/_posts/jenkins-java-maven/12.png","hash":"d6626668fc9a71cf602657cd5170b17f6ad8d85e","modified":1541726430186},{"_id":"source/_posts/jenkins-java-maven/i.png","hash":"1cd3776d2fe4e8a2782c71895bff5254cfb3296b","modified":1541726430233},{"_id":"source/_posts/jenkins-java-maven/5.png","hash":"64a8107a2748e6ac2fe9d1a42287b53a7dafd314","modified":1541726430202},{"_id":"source/_posts/jenkins-java-maven/a.png","hash":"4aedb54123fd8918579a04102486d34a85762a0b","modified":1541726430218},{"_id":"source/_posts/jenkins-java-maven/h.png","hash":"c6a10c564bcd131aa20b15cfd5c46411e3a42ceb","modified":1541726430233},{"_id":"source/_posts/scloud-zuul-filters/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1541726430374},{"_id":"source/_posts/scloud-zuul-start/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1541726430374},{"_id":"source/_posts/idea-file-template/b.png","hash":"4d04d3e6dd87ba18162986e3a96d2c998f00338e","modified":1541726430124},{"_id":"source/_posts/maven-ofen/b.jpg","hash":"dabd4b5d5703c961214903633009a9a02ebc758e","modified":1541726430264},{"_id":"source/_posts/redmine-start/b.png","hash":"2550346d9f3763d8d78fdc753c5323c5189e476b","modified":1541726430327},{"_id":"source/_posts/pivotal-web-service-start/a.png","hash":"d6731486aa76a72a980706fda1735e5b7bc05942","modified":1541726430280},{"_id":"source/_posts/redmine-start/c.png","hash":"7d5cb64ba37fcdf576e91671ff4afc9efbffe667","modified":1541726430327},{"_id":"source/_posts/shiro-start/shiro-03.png","hash":"48c404db45c431da3166c8a2de72909868d27cd8","modified":1541726430904},{"_id":"source/_posts/shiro-start/shiro-05.png","hash":"553c65b1bc8529ff242c39791c8b4b22f4d480f7","modified":1541726430904},{"_id":"source/_posts/vagrant-start/a.png","hash":"c6c5faf834c1b1639632c1eada1ae5914054b0e0","modified":1541726430935},{"_id":"source/_posts/jenkins-java-maven/c.png","hash":"c0c740a0b1e6cd4cad1e8aa96cef96eabac51fcc","modified":1541726430218},{"_id":"source/_posts/vagrant-start/c.png","hash":"c060bb440446ba2ee026cadf9dc0b936e8d81c29","modified":1541726430951},{"_id":"source/_posts/vagrant-start/b.png","hash":"d840feedffece97290c93ce061561d0b42506664","modified":1541726430935},{"_id":"source/_posts/idea-file-template/a.png","hash":"1031c609ecca3600cab439e781daf45df27702c6","modified":1541726430124},{"_id":"source/_posts/centos-maven-nexus/b.png","hash":"b83a6edfb7e719a3f530c544111dcd93914a648b","modified":1541726430015},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1541726431216},{"_id":"source/_posts/vagrant-start/d.png","hash":"facf633ba8edaa1c06039fbcee79a96fdd4aa841","modified":1541726430951},{"_id":"source/_posts/vagrant-start/e.png","hash":"af1562c4e634e97f6529a56e9d08873e4145dafd","modified":1541726430951},{"_id":"source/_posts/idea-file-template/g.png","hash":"fc51c847dee563fca8425db6147670c8335551c2","modified":1541726430140},{"_id":"source/_posts/pivotal-web-service-start/c.png","hash":"222f2f53d4d37628d4d926c5da817e3a76f14458","modified":1541726430296},{"_id":"source/_posts/redmine-plugins/a.png","hash":"4931a50b80f1def71a168e8df2d0caaa16844503","modified":1541726430327},{"_id":"source/_posts/pivotal-web-service-start/b.png","hash":"2e35d944a620506caa3ab18f337d71c92fd391e0","modified":1541726430296},{"_id":"source/_posts/shadowsocks-go/Shadowsocks-4.0.6.zip","hash":"bde73f5175fe3eb5127651e4602f78dbd5a5aed9","modified":1541726430389},{"_id":"source/_posts/shadowsocks-go/client.tar.gz","hash":"96035ed9ab98329f6b95f13f214c8a35ead5987a","modified":1541726430452},{"_id":"source/_posts/shadowsocks-go/server.tar.gz","hash":"5cc6db5fa8f70dad1c7e3ca4fd95d120357c5ac4","modified":1541726430888},{"_id":"source/_posts/wkhtmltopdf/Arial.zip","hash":"f96dc4f283e8a2c67256f69c95d18c3c4816f5d1","modified":1541726430966},{"_id":"source/_posts/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk","hash":"08466b927332819300796822ab861c779eaf3af9","modified":1541726430436},{"_id":"source/_posts/wkhtmltopdf/simsun.ttc","hash":"56a1a93bebf5f8468bea1a9eac5393206b08cfd6","modified":1541726431076},{"_id":"source/_posts/shadowsocks-go/go1.9.2.linux-amd64.tar.gz","hash":"94c889e039e3d2e94ed95e8f8cb747c5bc1c2b58","modified":1541726430873},{"_id":"source/_posts/redmine-plugins/a-1.png","hash":"4dd40fad8f6176efc1e8f73eff291c9d90e22c00","modified":1543376370645}],"Category":[{"name":"Nginx","_id":"cjp0m38180003qcrg07yh8vk2"},{"name":"angular","_id":"cjp0m381g0008qcrgdckwjjwn"},{"name":"aws","_id":"cjp0m381l000eqcrghikgomvz"},{"name":"api-manage","_id":"cjp0m381n000kqcrgzer04ef4"},{"name":"区块链","_id":"cjp0m381r000qqcrgt50lerdr"},{"name":"CentOs","_id":"cjp0m381u000xqcrgscowws48"},{"name":"持续集成","_id":"cjp0m3826001eqcrgulh66g2g"},{"name":"java","_id":"cjp0m3829001lqcrg24eac8ma"},{"name":"分布式系统","_id":"cjp0m382c001rqcrgrmfm6c7n"},{"name":"docker","_id":"cjp0m382f001yqcrgzuyzubgz"},{"name":"git","_id":"cjp0m382u0031qcrgw1di0p63"},{"name":"文件存储系统","_id":"cjp0m382v0036qcrgdw88dvqr"},{"name":"github","_id":"cjp0m3831003pqcrg2ftbydok"},{"name":"security","_id":"cjp0m3833003uqcrg50bi8ssy"},{"name":"http协议","_id":"cjp0m3834003yqcrg883llmwr"},{"name":"idea","_id":"cjp0m38350042qcrgluefvgz8"},{"name":"服务网格","_id":"cjp0m3839004cqcrgy1xbja07"},{"name":"json","_id":"cjp0m383a004hqcrgpj5njwii"},{"name":"javapoet","_id":"cjp0m38lk0053qcrg6djfmsw9"},{"name":"jvm","_id":"cjp0m38lv005bqcrgnfe2cwtn"},{"name":"Kubernetes","_id":"cjp0m38m1005mqcrg5xkl036b"},{"name":"linux","_id":"cjp0m38m4005tqcrg7e0fu0tb"},{"name":"ubuntu","_id":"cjp0m38m6005zqcrgy79xsur5"},{"name":"maven","_id":"cjp0m38mb006bqcrgru6zcpfe"},{"name":"micro-service","_id":"cjp0m38me006iqcrgb34t1jww"},{"name":"mysql","_id":"cjp0m38mh006oqcrg4y80bmmm"},{"name":"ngrok","_id":"cjp0m38mr007aqcrgyeqod3kg"},{"name":"npm","_id":"cjp0m38mu007iqcrgrrehqmqu"},{"name":"Pivotal Web Service","_id":"cjp0m38my007pqcrgqht8v59g"},{"name":"rabbitmq","_id":"cjp0m38n0007vqcrggpo5i9bp"},{"name":"redis","_id":"cjp0m38n50086qcrgx1viyg6e"},{"name":"redmine","_id":"cjp0m38nt0097qcrg9juhq249"},{"name":"rocketmq","_id":"cjp0m38o0009nqcrgv8p33cci"},{"name":"spring-boot","_id":"cjp0m38o1009sqcrgjbvgzzpu"},{"name":"spring-cloud","_id":"cjp0m38o2009wqcrgfici4oms"},{"name":"shadowsocks","_id":"cjp0m38oa00aqqcrgzdgqg20b"},{"name":"teamcity","_id":"cjp0m38oi00bhqcrgwnnp4bmn"},{"name":"TypeScript","_id":"cjp0m38oj00bmqcrg27s008bw"},{"name":"vagrant","_id":"cjp0m38ok00bqqcrgngd73zxp"},{"name":"架构","_id":"cjp0m38on00c0qcrg0pli6iww"},{"name":"zookeeper","_id":"cjp0m38oo00c5qcrgw55j9zs9"},{"name":"pdf","_id":"cjp0m38oq00ccqcrg7xct8ylc"},{"name":"密码","_id":"cjp0m38pa00d3qcrgf2nuero1"},{"name":"jpa/hibernate","_id":"cjp0m38ry00dfqcrgwy82yce8"},{"name":"shiro","_id":"cjp0m38sz00dvqcrgfak2d6my"}],"Data":[],"Page":[{"title":"关于","date":"2017-09-20T03:52:09.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-09-20 11:52:09\n---\n","updated":"2018-11-09T01:20:31.076Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjp0m38100000qcrg4f2n4083","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"Keepalived+LVS+Nginx负载均衡之高可用","date":"2017-09-23T01:48:19.000Z","_content":"### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","source":"_posts/Keepalived-LVS-Nginx.md","raw":"---\ntitle: Keepalived+LVS+Nginx负载均衡之高可用\ndate: 2017-09-23 09:48:19\ncategories: Nginx\ntags: nginx负载均衡\n---\n### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","slug":"Keepalived-LVS-Nginx","published":1,"updated":"2018-11-09T01:20:29.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38120001qcrgbpimpoyi","content":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"noopener\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"noopener\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>"},{"title":"angular入门","date":"2018-06-23T02:32:10.000Z","_content":"\n本文介绍如何搭建angular开发环境……\n\n[中文官网](https://angular.cn)\n[英文官网](https://angular.io)\n\n## 环境安装\n\n### ubuntu下\n\n_nodejs、npm环境_\n\n下载：https://nodejs.org/en/download/\n\n`nodejs`自带`npm`。\n\n- 现在二进制包，解压到相关目录。\n- 配置`nodejs`环境变量。\n    \n    \n    export NODE_HOME=~/Desktop/work/tools/node\n    export PATH=${NODE_HOME}/bin:$PATH\n    \n- 检查安装是否成功\n\n\n    zmt@zmt-Lenovo:~$ node -v\n    v10.4.1\n    zmt@zmt-Lenovo:~$ npm -v\n    6.1.0\n\n- 安装`npm`淘宝镜像\n\n`npm install -g cnpm --registry=https://registry.npm.taobao.org`  \n\n\n_angular-cli_ 安装\n\n全局安装\n\n`cnpm install -g @angular/cli`\n\n## 跑起angular项目\n\n1. 创建新项目\n\n    `ng new my-app`\n\n2. 启动服务器\n\n    `cd my-app`\n    \n    `ng serve --open` 或者 `ng serve -o`\n    \n如果一切顺利，会自动打开浏览器显示网页。至此，一个`hello wold`项目完成了。    \n        ","source":"_posts/angular-start.md","raw":"---\ntitle: angular入门\ndate: 2018-06-23 10:32:10\ncategories: angular\ntags: angular入门\n---\n\n本文介绍如何搭建angular开发环境……\n\n[中文官网](https://angular.cn)\n[英文官网](https://angular.io)\n\n## 环境安装\n\n### ubuntu下\n\n_nodejs、npm环境_\n\n下载：https://nodejs.org/en/download/\n\n`nodejs`自带`npm`。\n\n- 现在二进制包，解压到相关目录。\n- 配置`nodejs`环境变量。\n    \n    \n    export NODE_HOME=~/Desktop/work/tools/node\n    export PATH=${NODE_HOME}/bin:$PATH\n    \n- 检查安装是否成功\n\n\n    zmt@zmt-Lenovo:~$ node -v\n    v10.4.1\n    zmt@zmt-Lenovo:~$ npm -v\n    6.1.0\n\n- 安装`npm`淘宝镜像\n\n`npm install -g cnpm --registry=https://registry.npm.taobao.org`  \n\n\n_angular-cli_ 安装\n\n全局安装\n\n`cnpm install -g @angular/cli`\n\n## 跑起angular项目\n\n1. 创建新项目\n\n    `ng new my-app`\n\n2. 启动服务器\n\n    `cd my-app`\n    \n    `ng serve --open` 或者 `ng serve -o`\n    \n如果一切顺利，会自动打开浏览器显示网页。至此，一个`hello wold`项目完成了。    \n        ","slug":"angular-start","published":1,"updated":"2018-11-09T01:20:29.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38160002qcrg95r5ftw7","content":"<p>本文介绍如何搭建angular开发环境……</p>\n<p><a href=\"https://angular.cn\" target=\"_blank\" rel=\"noopener\">中文官网</a><br><a href=\"https://angular.io\" target=\"_blank\" rel=\"noopener\">英文官网</a></p>\n<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><h3 id=\"ubuntu下\"><a href=\"#ubuntu下\" class=\"headerlink\" title=\"ubuntu下\"></a>ubuntu下</h3><p><em>nodejs、npm环境</em></p>\n<p>下载：<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/download/</a></p>\n<p><code>nodejs</code>自带<code>npm</code>。</p>\n<ul>\n<li>现在二进制包，解压到相关目录。</li>\n<li>配置<code>nodejs</code>环境变量。</li>\n</ul>\n<pre><code>export NODE_HOME=~/Desktop/work/tools/node\nexport PATH=${NODE_HOME}/bin:$PATH\n</code></pre><ul>\n<li>检查安装是否成功</li>\n</ul>\n<pre><code>zmt@zmt-Lenovo:~$ node -v\nv10.4.1\nzmt@zmt-Lenovo:~$ npm -v\n6.1.0\n</code></pre><ul>\n<li>安装<code>npm</code>淘宝镜像</li>\n</ul>\n<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  </p>\n<p><em>angular-cli</em> 安装</p>\n<p>全局安装</p>\n<p><code>cnpm install -g @angular/cli</code></p>\n<h2 id=\"跑起angular项目\"><a href=\"#跑起angular项目\" class=\"headerlink\" title=\"跑起angular项目\"></a>跑起angular项目</h2><ol>\n<li><p>创建新项目</p>\n<p> <code>ng new my-app</code></p>\n</li>\n<li><p>启动服务器</p>\n<p> <code>cd my-app</code></p>\n<p> <code>ng serve --open</code> 或者 <code>ng serve -o</code></p>\n</li>\n</ol>\n<p>如果一切顺利，会自动打开浏览器显示网页。至此，一个<code>hello wold</code>项目完成了。    </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍如何搭建angular开发环境……</p>\n<p><a href=\"https://angular.cn\" target=\"_blank\" rel=\"noopener\">中文官网</a><br><a href=\"https://angular.io\" target=\"_blank\" rel=\"noopener\">英文官网</a></p>\n<h2 id=\"环境安装\"><a href=\"#环境安装\" class=\"headerlink\" title=\"环境安装\"></a>环境安装</h2><h3 id=\"ubuntu下\"><a href=\"#ubuntu下\" class=\"headerlink\" title=\"ubuntu下\"></a>ubuntu下</h3><p><em>nodejs、npm环境</em></p>\n<p>下载：<a href=\"https://nodejs.org/en/download/\" target=\"_blank\" rel=\"noopener\">https://nodejs.org/en/download/</a></p>\n<p><code>nodejs</code>自带<code>npm</code>。</p>\n<ul>\n<li>现在二进制包，解压到相关目录。</li>\n<li>配置<code>nodejs</code>环境变量。</li>\n</ul>\n<pre><code>export NODE_HOME=~/Desktop/work/tools/node\nexport PATH=${NODE_HOME}/bin:$PATH\n</code></pre><ul>\n<li>检查安装是否成功</li>\n</ul>\n<pre><code>zmt@zmt-Lenovo:~$ node -v\nv10.4.1\nzmt@zmt-Lenovo:~$ npm -v\n6.1.0\n</code></pre><ul>\n<li>安装<code>npm</code>淘宝镜像</li>\n</ul>\n<p><code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code>  </p>\n<p><em>angular-cli</em> 安装</p>\n<p>全局安装</p>\n<p><code>cnpm install -g @angular/cli</code></p>\n<h2 id=\"跑起angular项目\"><a href=\"#跑起angular项目\" class=\"headerlink\" title=\"跑起angular项目\"></a>跑起angular项目</h2><ol>\n<li><p>创建新项目</p>\n<p> <code>ng new my-app</code></p>\n</li>\n<li><p>启动服务器</p>\n<p> <code>cd my-app</code></p>\n<p> <code>ng serve --open</code> 或者 <code>ng serve -o</code></p>\n</li>\n</ol>\n<p>如果一切顺利，会自动打开浏览器显示网页。至此，一个<code>hello wold</code>项目完成了。    </p>\n"},{"title":"aws云服务器使用","date":"2018-06-21T06:22:55.000Z","_content":"\n本文记录在使用亚马逊云服务器aws过程中遇到的一些问题……\n\n### 1.登录到aws云服务器\n\n- 下载私钥`*.pem`,放到指定目录下。\n-  给予私钥权限。`chmod 400 .pem`\n- ssh登录。`ssh -i ~/aws-server-key/Seoul-Server-Key.pem ubuntu@13.209.47.139`\n\n### 2.在安全组开放端口\n\n### 3.上传文件aws服务器\n\n- IPv4：\n\n        # chmod 400 /path/my-key-pair.pem\n        # scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~\n        \n- (仅限 IPv6) 或者,您可以使用实例的 IPv6 地址传输文件。IPv6 地址必须用方括号 ([]) 括起,方括号必\n  须转义 (\\)。\n  \n        scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@\n        \\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~\n\n                \n\n_小提示_:  \n对于 Amazon Linux,用户名为 ec2-user。对于 RHEL,用户名称是 ec2-user 或 root。\n对于 Ubuntu,用户名称是 ubuntu 或 root。对于 Centos,用户名称是 centos。对于\nFedora,用户名称是 ec2-user。对于 SUSE,用户名称是 ec2-user 或 root。另外,如果\nec2-user 和 root 无法使用,请与您的 AMI 供应商核实。\n\n### 4.下载文件到本机\n\n- IPv4：\n\n        scp -i /path/my-key-pair.pem ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~/\n        SampleFile.txt ~/SampleFile2.txt\n\n\n- (仅限 IPv6) 或者,您可以使用实例的 IPv6 地址反方向传输文件。\n\n        scp -i /path/my-key-pair.pem ec2-user@\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~/\n        SampleFile.txt ~/SampleFile2.txt\n","source":"_posts/aws-server.md","raw":"---\ntitle: aws云服务器使用\ndate: 2018-06-21 14:22:55\ncategories: aws\ntags: aws云服务器\n---\n\n本文记录在使用亚马逊云服务器aws过程中遇到的一些问题……\n\n### 1.登录到aws云服务器\n\n- 下载私钥`*.pem`,放到指定目录下。\n-  给予私钥权限。`chmod 400 .pem`\n- ssh登录。`ssh -i ~/aws-server-key/Seoul-Server-Key.pem ubuntu@13.209.47.139`\n\n### 2.在安全组开放端口\n\n### 3.上传文件aws服务器\n\n- IPv4：\n\n        # chmod 400 /path/my-key-pair.pem\n        # scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~\n        \n- (仅限 IPv6) 或者,您可以使用实例的 IPv6 地址传输文件。IPv6 地址必须用方括号 ([]) 括起,方括号必\n  须转义 (\\)。\n  \n        scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@\n        \\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~\n\n                \n\n_小提示_:  \n对于 Amazon Linux,用户名为 ec2-user。对于 RHEL,用户名称是 ec2-user 或 root。\n对于 Ubuntu,用户名称是 ubuntu 或 root。对于 Centos,用户名称是 centos。对于\nFedora,用户名称是 ec2-user。对于 SUSE,用户名称是 ec2-user 或 root。另外,如果\nec2-user 和 root 无法使用,请与您的 AMI 供应商核实。\n\n### 4.下载文件到本机\n\n- IPv4：\n\n        scp -i /path/my-key-pair.pem ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~/\n        SampleFile.txt ~/SampleFile2.txt\n\n\n- (仅限 IPv6) 或者,您可以使用实例的 IPv6 地址反方向传输文件。\n\n        scp -i /path/my-key-pair.pem ec2-user@\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~/\n        SampleFile.txt ~/SampleFile2.txt\n","slug":"aws-server","published":1,"updated":"2018-11-09T01:20:29.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381a0005qcrgj9xnrg3o","content":"<p>本文记录在使用亚马逊云服务器aws过程中遇到的一些问题……</p>\n<h3 id=\"1-登录到aws云服务器\"><a href=\"#1-登录到aws云服务器\" class=\"headerlink\" title=\"1.登录到aws云服务器\"></a>1.登录到aws云服务器</h3><ul>\n<li>下载私钥<code>*.pem</code>,放到指定目录下。</li>\n<li>给予私钥权限。<code>chmod 400 .pem</code></li>\n<li>ssh登录。<code>ssh -i ~/aws-server-key/Seoul-Server-Key.pem ubuntu@13.209.47.139</code></li>\n</ul>\n<h3 id=\"2-在安全组开放端口\"><a href=\"#2-在安全组开放端口\" class=\"headerlink\" title=\"2.在安全组开放端口\"></a>2.在安全组开放端口</h3><h3 id=\"3-上传文件aws服务器\"><a href=\"#3-上传文件aws服务器\" class=\"headerlink\" title=\"3.上传文件aws服务器\"></a>3.上传文件aws服务器</h3><ul>\n<li><p>IPv4：</p>\n<pre><code># chmod 400 /path/my-key-pair.pem\n# scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~\n</code></pre></li>\n<li><p>(仅限 IPv6) 或者,您可以使用实例的 IPv6 地址传输文件。IPv6 地址必须用方括号 ([]) 括起,方括号必<br>须转义 ()。</p>\n<pre><code>scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@\n\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~\n</code></pre></li>\n</ul>\n<p><em>小提示</em>:<br>对于 Amazon Linux,用户名为 ec2-user。对于 RHEL,用户名称是 ec2-user 或 root。<br>对于 Ubuntu,用户名称是 ubuntu 或 root。对于 Centos,用户名称是 centos。对于<br>Fedora,用户名称是 ec2-user。对于 SUSE,用户名称是 ec2-user 或 root。另外,如果<br>ec2-user 和 root 无法使用,请与您的 AMI 供应商核实。</p>\n<h3 id=\"4-下载文件到本机\"><a href=\"#4-下载文件到本机\" class=\"headerlink\" title=\"4.下载文件到本机\"></a>4.下载文件到本机</h3><ul>\n<li><p>IPv4：</p>\n<pre><code>scp -i /path/my-key-pair.pem ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~/\nSampleFile.txt ~/SampleFile2.txt\n</code></pre></li>\n</ul>\n<ul>\n<li><p>(仅限 IPv6) 或者,您可以使用实例的 IPv6 地址反方向传输文件。</p>\n<pre><code>scp -i /path/my-key-pair.pem ec2-user@\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~/\nSampleFile.txt ~/SampleFile2.txt\n</code></pre></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录在使用亚马逊云服务器aws过程中遇到的一些问题……</p>\n<h3 id=\"1-登录到aws云服务器\"><a href=\"#1-登录到aws云服务器\" class=\"headerlink\" title=\"1.登录到aws云服务器\"></a>1.登录到aws云服务器</h3><ul>\n<li>下载私钥<code>*.pem</code>,放到指定目录下。</li>\n<li>给予私钥权限。<code>chmod 400 .pem</code></li>\n<li>ssh登录。<code>ssh -i ~/aws-server-key/Seoul-Server-Key.pem ubuntu@13.209.47.139</code></li>\n</ul>\n<h3 id=\"2-在安全组开放端口\"><a href=\"#2-在安全组开放端口\" class=\"headerlink\" title=\"2.在安全组开放端口\"></a>2.在安全组开放端口</h3><h3 id=\"3-上传文件aws服务器\"><a href=\"#3-上传文件aws服务器\" class=\"headerlink\" title=\"3.上传文件aws服务器\"></a>3.上传文件aws服务器</h3><ul>\n<li><p>IPv4：</p>\n<pre><code># chmod 400 /path/my-key-pair.pem\n# scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~\n</code></pre></li>\n<li><p>(仅限 IPv6) 或者,您可以使用实例的 IPv6 地址传输文件。IPv6 地址必须用方括号 ([]) 括起,方括号必<br>须转义 ()。</p>\n<pre><code>scp -i /path/my-key-pair.pem /path/SampleFile.txt ec2-user@\n\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~\n</code></pre></li>\n</ul>\n<p><em>小提示</em>:<br>对于 Amazon Linux,用户名为 ec2-user。对于 RHEL,用户名称是 ec2-user 或 root。<br>对于 Ubuntu,用户名称是 ubuntu 或 root。对于 Centos,用户名称是 centos。对于<br>Fedora,用户名称是 ec2-user。对于 SUSE,用户名称是 ec2-user 或 root。另外,如果<br>ec2-user 和 root 无法使用,请与您的 AMI 供应商核实。</p>\n<h3 id=\"4-下载文件到本机\"><a href=\"#4-下载文件到本机\" class=\"headerlink\" title=\"4.下载文件到本机\"></a>4.下载文件到本机</h3><ul>\n<li><p>IPv4：</p>\n<pre><code>scp -i /path/my-key-pair.pem ec2-user@ec2-198-51-100-1.compute-1.amazonaws.com:~/\nSampleFile.txt ~/SampleFile2.txt\n</code></pre></li>\n</ul>\n<ul>\n<li><p>(仅限 IPv6) 或者,您可以使用实例的 IPv6 地址反方向传输文件。</p>\n<pre><code>scp -i /path/my-key-pair.pem ec2-user@\\[2001:db8:1234:1a00:9691:9503:25ad:1761\\]:~/\nSampleFile.txt ~/SampleFile2.txt\n</code></pre></li>\n</ul>\n"},{"title":"apidoc在spring-mvc中实践","date":"2017-09-24T15:01:49.000Z","_content":"\n官网：http://apidocjs.com/\n","source":"_posts/apidoc-java.md","raw":"---\ntitle: apidoc在spring-mvc中实践\ndate: 2017-09-24 23:01:49\ncategories: api-manage\ntags: apidoc\n---\n\n官网：http://apidocjs.com/\n","slug":"apidoc-java","published":1,"updated":"2018-11-09T01:20:29.984Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381c0006qcrgznqfv2u5","content":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"noopener\">http://apidocjs.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"noopener\">http://apidocjs.com/</a></p>\n"},{"title":"区块链之密码学-哈希函数","date":"2018-07-25T06:45:45.000Z","_content":"\n","source":"_posts/blockchain-hash.md","raw":"---\ntitle: 区块链之密码学-哈希函数\ndate: 2018-07-25 14:45:45\ncategories: 区块链\ntags: 区块链哈希函数\n---\n\n","slug":"blockchain-hash","published":1,"updated":"2018-11-09T01:20:29.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381f0007qcrgeqqww669","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"centos免密码登录","date":"2017-11-30T06:53:47.000Z","_content":"\n配置免密码登录服务器。不用每次都要输入密码。\n\n## 环境说明\n\n客户机:Mac OS X\n服务器:CentOS 7\n客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.\n\n## 客户机配置\n\n1. 查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  \n2. 生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.\n\n## 服务器配置\n\n1.修改sshd配置文件(/etc/ssh/sshd_config).  \n找到以下内容，并去掉注释符”#“\n\n> RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)\nPubkeyAuthentication yes\nAuthorizedKeysFile  .ssh/authorized_keys\n\n2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:\n\n    cat ~/.ssh/id_rsa.pub | ssh user@host “cat - >> ~/.ssh/authorized_keys”\n    \n>注意:\n1 .ssh目录的权限必须是700\n2 .ssh/authorized_keys文件权限必须是600\n\n重启ssh： service sshd restart   \n然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.\n\n-----------------------------------------------------------\n## 更简单方式\n\n1、执行命令：ssh-keygen -t rsa -C \"xx@qq.com\"(随便编个字符串，一般用邮箱）\n2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；\n3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件\n\n\n\nyutao@localhost ~]$ ssh-copy-id yutao@192.168.161.132 #把秘钥拷贝到远程服务器\n","source":"_posts/centos-login-without-pwd.md","raw":"---\ntitle: centos免密码登录\ndate: 2017-11-30 14:53:47\ncategories: CentOs\ntags: centos登录\n---\n\n配置免密码登录服务器。不用每次都要输入密码。\n\n## 环境说明\n\n客户机:Mac OS X\n服务器:CentOS 7\n客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.\n\n## 客户机配置\n\n1. 查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  \n2. 生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.\n\n## 服务器配置\n\n1.修改sshd配置文件(/etc/ssh/sshd_config).  \n找到以下内容，并去掉注释符”#“\n\n> RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)\nPubkeyAuthentication yes\nAuthorizedKeysFile  .ssh/authorized_keys\n\n2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:\n\n    cat ~/.ssh/id_rsa.pub | ssh user@host “cat - >> ~/.ssh/authorized_keys”\n    \n>注意:\n1 .ssh目录的权限必须是700\n2 .ssh/authorized_keys文件权限必须是600\n\n重启ssh： service sshd restart   \n然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.\n\n-----------------------------------------------------------\n## 更简单方式\n\n1、执行命令：ssh-keygen -t rsa -C \"xx@qq.com\"(随便编个字符串，一般用邮箱）\n2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；\n3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件\n\n\n\nyutao@localhost ~]$ ssh-copy-id yutao@192.168.161.132 #把秘钥拷贝到远程服务器\n","slug":"centos-login-without-pwd","published":1,"updated":"2018-11-09T01:20:29.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381i000bqcrgmhc5z0md","content":"<p>配置免密码登录服务器。不用每次都要输入密码。</p>\n<h2 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h2><p>客户机:Mac OS X<br>服务器:CentOS 7<br>客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.</p>\n<h2 id=\"客户机配置\"><a href=\"#客户机配置\" class=\"headerlink\" title=\"客户机配置\"></a>客户机配置</h2><ol>\n<li>查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  </li>\n<li>生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.</li>\n</ol>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>1.修改sshd配置文件(/etc/ssh/sshd_config).<br>找到以下内容，并去掉注释符”#“</p>\n<blockquote>\n<p>RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys</p>\n</blockquote>\n<p>2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:</p>\n<pre><code>cat ~/.ssh/id_rsa.pub | ssh user@host “cat - &gt;&gt; ~/.ssh/authorized_keys”\n</code></pre><blockquote>\n<p>注意:<br>1 .ssh目录的权限必须是700<br>2 .ssh/authorized_keys文件权限必须是600</p>\n</blockquote>\n<p>重启ssh： service sshd restart<br>然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.</p>\n<hr>\n<h2 id=\"更简单方式\"><a href=\"#更简单方式\" class=\"headerlink\" title=\"更简单方式\"></a>更简单方式</h2><p>1、执行命令：ssh-keygen -t rsa -C “<a href=\"mailto:xx@qq.com\" target=\"_blank\" rel=\"noopener\">xx@qq.com</a>“(随便编个字符串，一般用邮箱）<br>2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；<br>3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件</p>\n<p>yutao@localhost ~]$ ssh-copy-id <a href=\"mailto:yutao@192.168.161.132\" target=\"_blank\" rel=\"noopener\">yutao@192.168.161.132</a> #把秘钥拷贝到远程服务器</p>\n","site":{"data":{}},"excerpt":"","more":"<p>配置免密码登录服务器。不用每次都要输入密码。</p>\n<h2 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h2><p>客户机:Mac OS X<br>服务器:CentOS 7<br>客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.</p>\n<h2 id=\"客户机配置\"><a href=\"#客户机配置\" class=\"headerlink\" title=\"客户机配置\"></a>客户机配置</h2><ol>\n<li>查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  </li>\n<li>生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.</li>\n</ol>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>1.修改sshd配置文件(/etc/ssh/sshd_config).<br>找到以下内容，并去掉注释符”#“</p>\n<blockquote>\n<p>RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys</p>\n</blockquote>\n<p>2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:</p>\n<pre><code>cat ~/.ssh/id_rsa.pub | ssh user@host “cat - &gt;&gt; ~/.ssh/authorized_keys”\n</code></pre><blockquote>\n<p>注意:<br>1 .ssh目录的权限必须是700<br>2 .ssh/authorized_keys文件权限必须是600</p>\n</blockquote>\n<p>重启ssh： service sshd restart<br>然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.</p>\n<hr>\n<h2 id=\"更简单方式\"><a href=\"#更简单方式\" class=\"headerlink\" title=\"更简单方式\"></a>更简单方式</h2><p>1、执行命令：ssh-keygen -t rsa -C “<a href=\"mailto:xx@qq.com\" target=\"_blank\" rel=\"noopener\">xx@qq.com</a>“(随便编个字符串，一般用邮箱）<br>2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；<br>3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件</p>\n<p>yutao@localhost ~]$ ssh-copy-id <a href=\"mailto:yutao@192.168.161.132\" target=\"_blank\" rel=\"noopener\">yutao@192.168.161.132</a> #把秘钥拷贝到远程服务器</p>\n"},{"title":"centos7下jdk8安装","date":"2017-11-12T06:32:34.000Z","_content":"1、下载jdk(在官网找)\n如果还没安装axel，先安装axel：> yum -y install axel\n\n    > axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n\n2、新建安装目录\n\n    >  mkdir /usr/lib/jvm\n\n3、解压jdk到安装目录下\n\n    > tar xf jdk-8u131-linux-x64.tar.gz\n    > cd /usr/lib/jvm\n    > mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n    > mv jdk1.8.0_131/ jdk8 #更改名字\n\n4、配置环境变量\n\n    > vim /etc/profile\n    \n键盘按a键进入编辑模式，在末尾添加：\n#jdk\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n\n按Esc退出编辑模式\n按Shift+:,然后输入wq保存退出。\n\n5、使环境变量生效\n\n    > source /etc/profile\n\n6、验证安装是否成功\n\n    > java -version\n\n如果安装成功会看到：\n\n    java version \"1.8.0_131\"\n    Java(TM) SE Runtime Environment (build 1.8.0_131-b11)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)","source":"_posts/centos-jdk8-install.md","raw":"---\ntitle: centos7下jdk8安装\ndate: 2017-11-12 14:32:34\ncategories: CentOs\ntags: centos-jdk8-install\n---\n1、下载jdk(在官网找)\n如果还没安装axel，先安装axel：> yum -y install axel\n\n    > axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n\n2、新建安装目录\n\n    >  mkdir /usr/lib/jvm\n\n3、解压jdk到安装目录下\n\n    > tar xf jdk-8u131-linux-x64.tar.gz\n    > cd /usr/lib/jvm\n    > mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n    > mv jdk1.8.0_131/ jdk8 #更改名字\n\n4、配置环境变量\n\n    > vim /etc/profile\n    \n键盘按a键进入编辑模式，在末尾添加：\n#jdk\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n\n按Esc退出编辑模式\n按Shift+:,然后输入wq保存退出。\n\n5、使环境变量生效\n\n    > source /etc/profile\n\n6、验证安装是否成功\n\n    > java -version\n\n如果安装成功会看到：\n\n    java version \"1.8.0_131\"\n    Java(TM) SE Runtime Environment (build 1.8.0_131-b11)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)","slug":"centos-jdk8-install","published":1,"updated":"2018-11-09T01:20:29.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381k000cqcrgudhnuu3u","content":"<p>1、下载jdk(在官网找)<br>如果还没安装axel，先安装axel：&gt; yum -y install axel</p>\n<pre><code>&gt; axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n</code></pre><p>2、新建安装目录</p>\n<pre><code>&gt;  mkdir /usr/lib/jvm\n</code></pre><p>3、解压jdk到安装目录下</p>\n<pre><code>&gt; tar xf jdk-8u131-linux-x64.tar.gz\n&gt; cd /usr/lib/jvm\n&gt; mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n&gt; mv jdk1.8.0_131/ jdk8 #更改名字\n</code></pre><p>4、配置环境变量</p>\n<pre><code>&gt; vim /etc/profile\n</code></pre><p>键盘按a键进入编辑模式，在末尾添加：</p>\n<p>#jdk<br>export JAVA_HOME=/usr/lib/jvm/jdk8<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>\n<p>按Esc退出编辑模式<br>按Shift+:,然后输入wq保存退出。</p>\n<p>5、使环境变量生效</p>\n<pre><code>&gt; source /etc/profile\n</code></pre><p>6、验证安装是否成功</p>\n<pre><code>&gt; java -version\n</code></pre><p>如果安装成功会看到：</p>\n<pre><code>java version &quot;1.8.0_131&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1、下载jdk(在官网找)<br>如果还没安装axel，先安装axel：&gt; yum -y install axel</p>\n<pre><code>&gt; axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n</code></pre><p>2、新建安装目录</p>\n<pre><code>&gt;  mkdir /usr/lib/jvm\n</code></pre><p>3、解压jdk到安装目录下</p>\n<pre><code>&gt; tar xf jdk-8u131-linux-x64.tar.gz\n&gt; cd /usr/lib/jvm\n&gt; mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n&gt; mv jdk1.8.0_131/ jdk8 #更改名字\n</code></pre><p>4、配置环境变量</p>\n<pre><code>&gt; vim /etc/profile\n</code></pre><p>键盘按a键进入编辑模式，在末尾添加：</p>\n<p>#jdk<br>export JAVA_HOME=/usr/lib/jvm/jdk8<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>\n<p>按Esc退出编辑模式<br>按Shift+:,然后输入wq保存退出。</p>\n<p>5、使环境变量生效</p>\n<pre><code>&gt; source /etc/profile\n</code></pre><p>6、验证安装是否成功</p>\n<pre><code>&gt; java -version\n</code></pre><p>如果安装成功会看到：</p>\n<pre><code>java version &quot;1.8.0_131&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n</code></pre>"},{"title":"centos7下搭建maven私仓Nexus","date":"2017-11-12T06:47:38.000Z","_content":"\n项目组件化，共用jar包，统一获取墙外jar包…… \n\n官方文档 [sonatype](https://www.sonatype.com/)\n\n## 安装jdk\n参考其他文章……\n\n\n## 下载Nexus Repository OSS\n> 下载地址：http://www.sonatype.com/download-oss-sonatype\n\n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n\n解压：\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n    \n## 启动\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n    [root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n\n如果启动成功，可以看到：\n\n > Started Sonatype Nexus OSS 3.6.0-02\n\n防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。\n\n在浏览器访问：http://47.52.236.72:8081/\n可以看到：\n\n{% asset_img a.png %}\n\n## 配置为Linux Service\n\n1. 编辑`bin/nexus.rc`：\n\n`[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc`\n\n添加： \n> run_as_user=\"root\"\n\n2. 在`/etc/init.d`放nexus软连接\n\n` ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus`\n\n3. 设置服务随系统自启\n命令：*chkconfig*\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n    [root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n\n5. 启动\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\n    WARNING: ************************************************************\n    WARNING: Detected execution as \"root\" user.  This is NOT recommended!\n    WARNING: ************************************************************\n    Starting nexus\n\n## 界面操作\n\n*1. 登录*\n\n默认账号密码：\nusername: admin\npwd: admin123\n\n{% asset_img b.png %} \n\n*2. 修改admin密码*\n\n{% asset_img c.png %}\n\n点击`More`\n\n{% asset_img d.png %}\n    \n## 创建maven仓库\n\n{% asset_img e.png %}\n\n简单介绍下几种repository的类型:\n\n> - hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。\n> - proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。\n> - group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。\n\n这里我们选择创建本地仓库：\n{% asset_img f.png %}\n\n填写内容：\n{% asset_img g.png %}\n\n> version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。\n\n创建成功：\n{% asset_img h.png %}\n\n添加到maven-public仓库组：\n{% asset_img j.png %}\n\n## 查看仓库\n如果上传了项目，在Nexus用户界面，选择components -> xiaoming-host\n\n{% asset_img i.png %}\n\n\n\n\n    \n","source":"_posts/centos-maven-nexus.md","raw":"---\ntitle: centos7下搭建maven私仓Nexus\ndate: 2017-11-12 14:47:38\ncategories: CentOs\ntags: centos-nexus\n---\n\n项目组件化，共用jar包，统一获取墙外jar包…… \n\n官方文档 [sonatype](https://www.sonatype.com/)\n\n## 安装jdk\n参考其他文章……\n\n\n## 下载Nexus Repository OSS\n> 下载地址：http://www.sonatype.com/download-oss-sonatype\n\n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n\n解压：\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n    \n## 启动\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n    [root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n\n如果启动成功，可以看到：\n\n > Started Sonatype Nexus OSS 3.6.0-02\n\n防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。\n\n在浏览器访问：http://47.52.236.72:8081/\n可以看到：\n\n{% asset_img a.png %}\n\n## 配置为Linux Service\n\n1. 编辑`bin/nexus.rc`：\n\n`[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc`\n\n添加： \n> run_as_user=\"root\"\n\n2. 在`/etc/init.d`放nexus软连接\n\n` ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus`\n\n3. 设置服务随系统自启\n命令：*chkconfig*\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n    [root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n\n5. 启动\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\n    WARNING: ************************************************************\n    WARNING: Detected execution as \"root\" user.  This is NOT recommended!\n    WARNING: ************************************************************\n    Starting nexus\n\n## 界面操作\n\n*1. 登录*\n\n默认账号密码：\nusername: admin\npwd: admin123\n\n{% asset_img b.png %} \n\n*2. 修改admin密码*\n\n{% asset_img c.png %}\n\n点击`More`\n\n{% asset_img d.png %}\n    \n## 创建maven仓库\n\n{% asset_img e.png %}\n\n简单介绍下几种repository的类型:\n\n> - hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。\n> - proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。\n> - group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。\n\n这里我们选择创建本地仓库：\n{% asset_img f.png %}\n\n填写内容：\n{% asset_img g.png %}\n\n> version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。\n\n创建成功：\n{% asset_img h.png %}\n\n添加到maven-public仓库组：\n{% asset_img j.png %}\n\n## 查看仓库\n如果上传了项目，在Nexus用户界面，选择components -> xiaoming-host\n\n{% asset_img i.png %}\n\n\n\n\n    \n","slug":"centos-maven-nexus","published":1,"updated":"2018-11-09T01:20:29.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381m000gqcrge29afuy4","content":"<p>项目组件化，共用jar包，统一获取墙外jar包…… </p>\n<p>官方文档 <a href=\"https://www.sonatype.com/\" target=\"_blank\" rel=\"noopener\">sonatype</a></p>\n<h2 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h2><p>参考其他文章……</p>\n<h2 id=\"下载Nexus-Repository-OSS\"><a href=\"#下载Nexus-Repository-OSS\" class=\"headerlink\" title=\"下载Nexus Repository OSS\"></a>下载Nexus Repository OSS</h2><blockquote>\n<p>下载地址：<a href=\"http://www.sonatype.com/download-oss-sonatype\" target=\"_blank\" rel=\"noopener\">http://www.sonatype.com/download-oss-sonatype</a></p>\n</blockquote>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n</code></pre><p>解压：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n[root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n</code></pre><p>如果启动成功，可以看到：</p>\n<blockquote>\n<p>Started Sonatype Nexus OSS 3.6.0-02</p>\n</blockquote>\n<p>防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。</p>\n<p>在浏览器访问：<a href=\"http://47.52.236.72:8081/\" target=\"_blank\" rel=\"noopener\">http://47.52.236.72:8081/</a><br>可以看到：</p>\n<img src=\"/2017/11/12/centos-maven-nexus/a.png\">\n<h2 id=\"配置为Linux-Service\"><a href=\"#配置为Linux-Service\" class=\"headerlink\" title=\"配置为Linux Service\"></a>配置为Linux Service</h2><ol>\n<li>编辑<code>bin/nexus.rc</code>：</li>\n</ol>\n<p><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc</code></p>\n<p>添加： </p>\n<blockquote>\n<p>run_as_user=”root”</p>\n</blockquote>\n<ol start=\"2\">\n<li>在<code>/etc/init.d</code>放nexus软连接</li>\n</ol>\n<p><code>ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus</code></p>\n<ol start=\"3\">\n<li>设置服务随系统自启<br>命令：<em>chkconfig</em></li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n[root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n</code></pre><ol start=\"5\">\n<li>启动</li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\nWARNING: ************************************************************\nWARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!\nWARNING: ************************************************************\nStarting nexus\n</code></pre><h2 id=\"界面操作\"><a href=\"#界面操作\" class=\"headerlink\" title=\"界面操作\"></a>界面操作</h2><p><em>1. 登录</em></p>\n<p>默认账号密码：<br>username: admin<br>pwd: admin123</p>\n<img src=\"/2017/11/12/centos-maven-nexus/b.png\"> \n<p><em>2. 修改admin密码</em></p>\n<img src=\"/2017/11/12/centos-maven-nexus/c.png\">\n<p>点击<code>More</code></p>\n<img src=\"/2017/11/12/centos-maven-nexus/d.png\">\n<h2 id=\"创建maven仓库\"><a href=\"#创建maven仓库\" class=\"headerlink\" title=\"创建maven仓库\"></a>创建maven仓库</h2><img src=\"/2017/11/12/centos-maven-nexus/e.png\">\n<p>简单介绍下几种repository的类型:</p>\n<blockquote>\n<ul>\n<li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>\n<li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li>\n<li>group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li>\n</ul>\n</blockquote>\n<p>这里我们选择创建本地仓库：<br><img src=\"/2017/11/12/centos-maven-nexus/f.png\"></p>\n<p>填写内容：<br><img src=\"/2017/11/12/centos-maven-nexus/g.png\"></p>\n<blockquote>\n<p>version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。</p>\n</blockquote>\n<p>创建成功：<br><img src=\"/2017/11/12/centos-maven-nexus/h.png\"></p>\n<p>添加到maven-public仓库组：<br><img src=\"/2017/11/12/centos-maven-nexus/j.png\"></p>\n<h2 id=\"查看仓库\"><a href=\"#查看仓库\" class=\"headerlink\" title=\"查看仓库\"></a>查看仓库</h2><p>如果上传了项目，在Nexus用户界面，选择components -&gt; xiaoming-host</p>\n<img src=\"/2017/11/12/centos-maven-nexus/i.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>项目组件化，共用jar包，统一获取墙外jar包…… </p>\n<p>官方文档 <a href=\"https://www.sonatype.com/\" target=\"_blank\" rel=\"noopener\">sonatype</a></p>\n<h2 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h2><p>参考其他文章……</p>\n<h2 id=\"下载Nexus-Repository-OSS\"><a href=\"#下载Nexus-Repository-OSS\" class=\"headerlink\" title=\"下载Nexus Repository OSS\"></a>下载Nexus Repository OSS</h2><blockquote>\n<p>下载地址：<a href=\"http://www.sonatype.com/download-oss-sonatype\" target=\"_blank\" rel=\"noopener\">http://www.sonatype.com/download-oss-sonatype</a></p>\n</blockquote>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n</code></pre><p>解压：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n[root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n</code></pre><p>如果启动成功，可以看到：</p>\n<blockquote>\n<p>Started Sonatype Nexus OSS 3.6.0-02</p>\n</blockquote>\n<p>防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。</p>\n<p>在浏览器访问：<a href=\"http://47.52.236.72:8081/\" target=\"_blank\" rel=\"noopener\">http://47.52.236.72:8081/</a><br>可以看到：</p>\n<img src=\"/2017/11/12/centos-maven-nexus/a.png\">\n<h2 id=\"配置为Linux-Service\"><a href=\"#配置为Linux-Service\" class=\"headerlink\" title=\"配置为Linux Service\"></a>配置为Linux Service</h2><ol>\n<li>编辑<code>bin/nexus.rc</code>：</li>\n</ol>\n<p><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc</code></p>\n<p>添加： </p>\n<blockquote>\n<p>run_as_user=”root”</p>\n</blockquote>\n<ol start=\"2\">\n<li>在<code>/etc/init.d</code>放nexus软连接</li>\n</ol>\n<p><code>ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus</code></p>\n<ol start=\"3\">\n<li>设置服务随系统自启<br>命令：<em>chkconfig</em></li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n[root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n</code></pre><ol start=\"5\">\n<li>启动</li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\nWARNING: ************************************************************\nWARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!\nWARNING: ************************************************************\nStarting nexus\n</code></pre><h2 id=\"界面操作\"><a href=\"#界面操作\" class=\"headerlink\" title=\"界面操作\"></a>界面操作</h2><p><em>1. 登录</em></p>\n<p>默认账号密码：<br>username: admin<br>pwd: admin123</p>\n<img src=\"/2017/11/12/centos-maven-nexus/b.png\"> \n<p><em>2. 修改admin密码</em></p>\n<img src=\"/2017/11/12/centos-maven-nexus/c.png\">\n<p>点击<code>More</code></p>\n<img src=\"/2017/11/12/centos-maven-nexus/d.png\">\n<h2 id=\"创建maven仓库\"><a href=\"#创建maven仓库\" class=\"headerlink\" title=\"创建maven仓库\"></a>创建maven仓库</h2><img src=\"/2017/11/12/centos-maven-nexus/e.png\">\n<p>简单介绍下几种repository的类型:</p>\n<blockquote>\n<ul>\n<li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>\n<li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li>\n<li>group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li>\n</ul>\n</blockquote>\n<p>这里我们选择创建本地仓库：<br><img src=\"/2017/11/12/centos-maven-nexus/f.png\"></p>\n<p>填写内容：<br><img src=\"/2017/11/12/centos-maven-nexus/g.png\"></p>\n<blockquote>\n<p>version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。</p>\n</blockquote>\n<p>创建成功：<br><img src=\"/2017/11/12/centos-maven-nexus/h.png\"></p>\n<p>添加到maven-public仓库组：<br><img src=\"/2017/11/12/centos-maven-nexus/j.png\"></p>\n<h2 id=\"查看仓库\"><a href=\"#查看仓库\" class=\"headerlink\" title=\"查看仓库\"></a>查看仓库</h2><p>如果上传了项目，在Nexus用户界面，选择components -&gt; xiaoming-host</p>\n<img src=\"/2017/11/12/centos-maven-nexus/i.png\">\n"},{"title":"concourse持续集成使用教程","date":"2018-02-10T02:35:22.000Z","_content":"\n官网：https://concourse.ci/","source":"_posts/concourse-tutorial.md","raw":"---\ntitle: concourse持续集成使用教程\ndate: 2018-02-10 10:35:22\ncategories: 持续集成\ntags: concourse\n---\n\n官网：https://concourse.ci/","slug":"concourse-tutorial","published":1,"updated":"2018-11-09T01:20:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381n000iqcrgzxuhvdu4","content":"<p>官网：<a href=\"https://concourse.ci/\" target=\"_blank\" rel=\"noopener\">https://concourse.ci/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"https://concourse.ci/\" target=\"_blank\" rel=\"noopener\">https://concourse.ci/</a></p>\n"},{"title":"Cron 语法","date":"2017-10-24T02:23:19.000Z","_content":"\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]   \ncron语法主要用在定时任务上。linux系统有个类似的crontab。\n\n|   序号   |\t说明\t|是否必填|\t允许填写的值\t|允许的符号|\n|:---|:---|:---|:---|:---|\n|1\t|秒   |是\t|0－59\t|, - * /|\n |2\t|分\t    |是 |0－59\t|, - * /|\n |3\t|小时   |是\t |0－23 |\t, - * / |\n |4\t|日\t    |是\t |1－31\t|, - * ? / L W |\n |5\t|月\t    |是\t |1－12 or JAN-DEC\t|, - * /|\n |6\t|星期\t|是\t |1-7 or SUN-SAT\t|, - * ? / L #  |\n |7\t|年\t     |否\t|1970-2099\t|, - * / |\n \n> 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。\n\n_详细说明_\n\n“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。 \n“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。 \n“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。\n\n`*`表示所有值. 如在“分”上设置“`*`”，表示每分钟触发。 \n“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”\n\n“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同\n\n“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。 \n“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。 \n如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四\n\n> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n\nW表示离指定日期的最近那个工作日(周一至周五). \n例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。 \n如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。 \n如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。 \n如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。\n\n> 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；\n\n_常用示例_\n\n0 0 12 * * ? 每天12点触发\n\n0 15 10 ? * * 每天10点15分触发\n\n0 15 10 * * ? 每天10点15分触发\n\n0 15 10 * * ? * 每天10点15分触发\n\n0 15 10 * * ? 2005 2005年每天10点15分触发\n\n0 * 14 * * ? 每天14点到14点59分之间，每分钟触发一次\n\n0 0/5 14 * * ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）\n\n0 0/5 14，18 * * ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）\n\n0 0-5 14 * * ? 每天14点到14点05分之间，每分钟触发\n\n0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发\n\n0 15 10 ? * MON-FRI 周一到周五每天10点15分触发\n\n0 15 10 15 * ? 每月15号10点15分触发\n\n0 15 10 L * ? 每月最后一天的10点15分触发\n\n0 15 10 ? * 6L 每月最后一个周五的10点15分触发\n\n0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发\n\n0 15 10 ? * 6#3 每月第三个周五的10点15分触发\n\n0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次\n\n\n\n\n\n\n","source":"_posts/cron-grammar.md","raw":"---\ntitle:  Cron 语法\ndate: 2017-10-24 10:23:19\ncategories: java\ntags: cron-grammar\n---\n\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]   \ncron语法主要用在定时任务上。linux系统有个类似的crontab。\n\n|   序号   |\t说明\t|是否必填|\t允许填写的值\t|允许的符号|\n|:---|:---|:---|:---|:---|\n|1\t|秒   |是\t|0－59\t|, - * /|\n |2\t|分\t    |是 |0－59\t|, - * /|\n |3\t|小时   |是\t |0－23 |\t, - * / |\n |4\t|日\t    |是\t |1－31\t|, - * ? / L W |\n |5\t|月\t    |是\t |1－12 or JAN-DEC\t|, - * /|\n |6\t|星期\t|是\t |1-7 or SUN-SAT\t|, - * ? / L #  |\n |7\t|年\t     |否\t|1970-2099\t|, - * / |\n \n> 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。\n\n_详细说明_\n\n“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。 \n“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。 \n“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。\n\n`*`表示所有值. 如在“分”上设置“`*`”，表示每分钟触发。 \n“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”\n\n“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同\n\n“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。 \n“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。 \n如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四\n\n> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n\nW表示离指定日期的最近那个工作日(周一至周五). \n例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。 \n如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。 \n如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。 \n如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。\n\n> 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；\n\n_常用示例_\n\n0 0 12 * * ? 每天12点触发\n\n0 15 10 ? * * 每天10点15分触发\n\n0 15 10 * * ? 每天10点15分触发\n\n0 15 10 * * ? * 每天10点15分触发\n\n0 15 10 * * ? 2005 2005年每天10点15分触发\n\n0 * 14 * * ? 每天14点到14点59分之间，每分钟触发一次\n\n0 0/5 14 * * ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）\n\n0 0/5 14，18 * * ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）\n\n0 0-5 14 * * ? 每天14点到14点05分之间，每分钟触发\n\n0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发\n\n0 15 10 ? * MON-FRI 周一到周五每天10点15分触发\n\n0 15 10 15 * ? 每月15号10点15分触发\n\n0 15 10 L * ? 每月最后一天的10点15分触发\n\n0 15 10 ? * 6L 每月最后一个周五的10点15分触发\n\n0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发\n\n0 15 10 ? * 6#3 每月第三个周五的10点15分触发\n\n0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次\n\n\n\n\n\n\n","slug":"cron-grammar","published":1,"updated":"2018-11-09T01:20:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381o000mqcrg6opu8k5i","content":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]<br>cron语法主要用在定时任务上。linux系统有个类似的crontab。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">允许填写的值</th>\n<th style=\"text-align:left\">允许的符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">秒</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">分</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">小时</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－23</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">日</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－31</td>\n<td style=\"text-align:left\">, - * ? / L W</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">月</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－12 or JAN-DEC</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">星期</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1-7 or SUN-SAT</td>\n<td style=\"text-align:left\">, - * ? / L #</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">1970-2099</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。</p>\n</blockquote>\n<p><em>详细说明</em></p>\n<p>“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。<br>“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。<br>“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。</p>\n<p><code>*</code>表示所有值. 如在“分”上设置“<code>*</code>”，表示每分钟触发。<br>“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”</p>\n<p>“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同</p>\n<p>“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。<br>“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。<br>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四</p>\n<blockquote>\n<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>\n</blockquote>\n<p>W表示离指定日期的最近那个工作日(周一至周五).<br>例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。<br>如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。<br>如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。<br>如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。</p>\n<blockquote>\n<p>小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；</p>\n</blockquote>\n<p><em>常用示例</em></p>\n<p>0 0 12 <em> </em> ? 每天12点触发</p>\n<p>0 15 10 ? <em> </em> 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? * 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 2005 2005年每天10点15分触发</p>\n<p>0 <em> 14 </em> * ? 每天14点到14点59分之间，每分钟触发一次</p>\n<p>0 0/5 14 <em> </em> ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）</p>\n<p>0 0/5 14，18 <em> </em> ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）</p>\n<p>0 0-5 14 <em> </em> ? 每天14点到14点05分之间，每分钟触发</p>\n<p>0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发</p>\n<p>0 15 10 ? * MON-FRI 周一到周五每天10点15分触发</p>\n<p>0 15 10 15 * ? 每月15号10点15分触发</p>\n<p>0 15 10 L * ? 每月最后一天的10点15分触发</p>\n<p>0 15 10 ? * 6L 每月最后一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6#3 每月第三个周五的10点15分触发</p>\n<p>0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]<br>cron语法主要用在定时任务上。linux系统有个类似的crontab。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">允许填写的值</th>\n<th style=\"text-align:left\">允许的符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">秒</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">分</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">小时</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－23</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">日</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－31</td>\n<td style=\"text-align:left\">, - * ? / L W</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">月</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－12 or JAN-DEC</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">星期</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1-7 or SUN-SAT</td>\n<td style=\"text-align:left\">, - * ? / L #</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">1970-2099</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。</p>\n</blockquote>\n<p><em>详细说明</em></p>\n<p>“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。<br>“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。<br>“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。</p>\n<p><code>*</code>表示所有值. 如在“分”上设置“<code>*</code>”，表示每分钟触发。<br>“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”</p>\n<p>“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同</p>\n<p>“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。<br>“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。<br>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四</p>\n<blockquote>\n<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>\n</blockquote>\n<p>W表示离指定日期的最近那个工作日(周一至周五).<br>例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。<br>如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。<br>如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。<br>如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。</p>\n<blockquote>\n<p>小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；</p>\n</blockquote>\n<p><em>常用示例</em></p>\n<p>0 0 12 <em> </em> ? 每天12点触发</p>\n<p>0 15 10 ? <em> </em> 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? * 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 2005 2005年每天10点15分触发</p>\n<p>0 <em> 14 </em> * ? 每天14点到14点59分之间，每分钟触发一次</p>\n<p>0 0/5 14 <em> </em> ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）</p>\n<p>0 0/5 14，18 <em> </em> ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）</p>\n<p>0 0-5 14 <em> </em> ? 每天14点到14点05分之间，每分钟触发</p>\n<p>0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发</p>\n<p>0 15 10 ? * MON-FRI 周一到周五每天10点15分触发</p>\n<p>0 15 10 15 * ? 每月15号10点15分触发</p>\n<p>0 15 10 L * ? 每月最后一天的10点15分触发</p>\n<p>0 15 10 ? * 6L 每月最后一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6#3 每月第三个周五的10点15分触发</p>\n<p>0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次</p>\n"},{"title":"分布式系统几大难点","date":"2017-11-08T06:57:10.000Z","_content":"\n## 1. 分布式ID\n\n## 2. 分布式事务\n\n## 3. 分布式缓存以及缓存与数据库的同步\n\n## 4. 数据库集群同步延迟问题\n\n## 5. 分布式跨库连表查询\n\n## 6. 分布式定时任务","source":"_posts/distributed-difficulty.md","raw":"---\ntitle: 分布式系统几大难点\ndate: 2017-11-08 14:57:10\ncategories: 分布式系统\ntags: distributed-difficulty\n---\n\n## 1. 分布式ID\n\n## 2. 分布式事务\n\n## 3. 分布式缓存以及缓存与数据库的同步\n\n## 4. 数据库集群同步延迟问题\n\n## 5. 分布式跨库连表查询\n\n## 6. 分布式定时任务","slug":"distributed-difficulty","published":1,"updated":"2018-11-09T01:20:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381p000oqcrgp3vnrfay","content":"<h2 id=\"1-分布式ID\"><a href=\"#1-分布式ID\" class=\"headerlink\" title=\"1. 分布式ID\"></a>1. 分布式ID</h2><h2 id=\"2-分布式事务\"><a href=\"#2-分布式事务\" class=\"headerlink\" title=\"2. 分布式事务\"></a>2. 分布式事务</h2><h2 id=\"3-分布式缓存以及缓存与数据库的同步\"><a href=\"#3-分布式缓存以及缓存与数据库的同步\" class=\"headerlink\" title=\"3. 分布式缓存以及缓存与数据库的同步\"></a>3. 分布式缓存以及缓存与数据库的同步</h2><h2 id=\"4-数据库集群同步延迟问题\"><a href=\"#4-数据库集群同步延迟问题\" class=\"headerlink\" title=\"4. 数据库集群同步延迟问题\"></a>4. 数据库集群同步延迟问题</h2><h2 id=\"5-分布式跨库连表查询\"><a href=\"#5-分布式跨库连表查询\" class=\"headerlink\" title=\"5. 分布式跨库连表查询\"></a>5. 分布式跨库连表查询</h2><h2 id=\"6-分布式定时任务\"><a href=\"#6-分布式定时任务\" class=\"headerlink\" title=\"6. 分布式定时任务\"></a>6. 分布式定时任务</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-分布式ID\"><a href=\"#1-分布式ID\" class=\"headerlink\" title=\"1. 分布式ID\"></a>1. 分布式ID</h2><h2 id=\"2-分布式事务\"><a href=\"#2-分布式事务\" class=\"headerlink\" title=\"2. 分布式事务\"></a>2. 分布式事务</h2><h2 id=\"3-分布式缓存以及缓存与数据库的同步\"><a href=\"#3-分布式缓存以及缓存与数据库的同步\" class=\"headerlink\" title=\"3. 分布式缓存以及缓存与数据库的同步\"></a>3. 分布式缓存以及缓存与数据库的同步</h2><h2 id=\"4-数据库集群同步延迟问题\"><a href=\"#4-数据库集群同步延迟问题\" class=\"headerlink\" title=\"4. 数据库集群同步延迟问题\"></a>4. 数据库集群同步延迟问题</h2><h2 id=\"5-分布式跨库连表查询\"><a href=\"#5-分布式跨库连表查询\" class=\"headerlink\" title=\"5. 分布式跨库连表查询\"></a>5. 分布式跨库连表查询</h2><h2 id=\"6-分布式定时任务\"><a href=\"#6-分布式定时任务\" class=\"headerlink\" title=\"6. 分布式定时任务\"></a>6. 分布式定时任务</h2>"},{"title":"docker安装各种应用软件","date":"2018-07-19T07:49:39.000Z","_content":"\n本文记录在docker各种应用程序的安装以及使用……\n\ndocker仓库： [hub repo](https://hub.docker.com/)\n\n## 安装nginx\n\n参考：\n- http://www.runoob.com/docker/docker-install-redis.html\n\n\n## 安装redis\n\n参考：\n- http://www.runoob.com/docker/docker-install-redis.html\n\n\n## 安装mysql-server\n","source":"_posts/docker-app-install.md","raw":"---\ntitle: docker安装各种应用软件\ndate: 2018-07-19 15:49:39\ncategories: docker\ntags: docker安装应用\n---\n\n本文记录在docker各种应用程序的安装以及使用……\n\ndocker仓库： [hub repo](https://hub.docker.com/)\n\n## 安装nginx\n\n参考：\n- http://www.runoob.com/docker/docker-install-redis.html\n\n\n## 安装redis\n\n参考：\n- http://www.runoob.com/docker/docker-install-redis.html\n\n\n## 安装mysql-server\n","slug":"docker-app-install","published":1,"updated":"2018-11-09T01:20:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381r000sqcrg79qrb7ot","content":"<p>本文记录在docker各种应用程序的安装以及使用……</p>\n<p>docker仓库： <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">hub repo</a></p>\n<h2 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h2><p>参考：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/docker/docker-install-redis.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-install-redis.html</a></li>\n</ul>\n<h2 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装redis</h2><p>参考：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/docker/docker-install-redis.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-install-redis.html</a></li>\n</ul>\n<h2 id=\"安装mysql-server\"><a href=\"#安装mysql-server\" class=\"headerlink\" title=\"安装mysql-server\"></a>安装mysql-server</h2>","site":{"data":{}},"excerpt":"","more":"<p>本文记录在docker各种应用程序的安装以及使用……</p>\n<p>docker仓库： <a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">hub repo</a></p>\n<h2 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装nginx</h2><p>参考：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/docker/docker-install-redis.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-install-redis.html</a></li>\n</ul>\n<h2 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装redis</h2><p>参考：</p>\n<ul>\n<li><a href=\"http://www.runoob.com/docker/docker-install-redis.html\" target=\"_blank\" rel=\"noopener\">http://www.runoob.com/docker/docker-install-redis.html</a></li>\n</ul>\n<h2 id=\"安装mysql-server\"><a href=\"#安装mysql-server\" class=\"headerlink\" title=\"安装mysql-server\"></a>安装mysql-server</h2>"},{"title":"centos7安装docker-ce","date":"2017-11-15T05:55:39.000Z","_content":"\n本文介绍docker在centos7系统上的安装。\n参考：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\n\n## 1. 卸载旧版本docker\n\n    $ sudo yum remove docker \\\n                      docker-common \\\n                      docker-selinux \\\n                      docker-engine\n\n---\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n    >                   docker-common \\\n    >                   docker-selinux \\\n    >                   docker-engine\n    Loaded plugins: fastestmirror\n    No Match for argument: docker\n    No Match for argument: docker-common\n    No Match for argument: docker-selinux\n    No Match for argument: docker-engine\n    No Packages marked for removal\n    \n    ---\n    表明没有旧版本\n    \n旧版本的会安装在`/var/lib/docker/`，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。\n \n## 2. 安装docker-ce\n\n共有三种方式安装,根据自己喜欢方式选择一种安装：\n- 配置安装源，从安装源拉取安装。推荐，但是网络要好\n- 下载安装包，执行安装。网络不好，采用。\n- 下载脚本执行安装。开发环境这种方式方便。\n\n### 2.1 repository方式安装，推荐\n第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。\n1. 安装依赖包\n\n\n    $ sudo yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n\n\n2. 安装源\n        \n        \n    $ sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo                   \n                      \n3. 可选: 开启edge和test源\n\n\n    $ sudo yum-config-manager --enable docker-ce-edge\n    $ sudo yum-config-manager --enable docker-ce-test                     \n    -----\n    关闭：\n    $ sudo yum-config-manager --disable docker-ce-edge    \n    \n4. 安装docker\n\n4.1 安装最新版本\n\n    $ sudo yum install docker-ce\n    \n> Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.\n\n4.2 安装指定版本\n在生成环境，有时候要安装指定版本。\n\n- 查看所有可用版本\n\n        $ yum list docker-ce --showduplicates | sort -r\n        \n        docker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n        \nThe contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).\n> Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.\n\n    $ sudo yum install <FULLY-QUALIFIED-PACKAGE-NAME>\n    \n4.3 启动docker                 \n    \n    $ sudo systemctl start docker                      \n\n4.4 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n会下载docker镜像，然后执行，打印信息。\n\n4.5 更新docker\n根据上面安装过程，重新安装即可。\n\n### 2.2 安装包方式（更喜欢方式）\n\n如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。\n\n1. 下载安装包：\n\n打开网址 *https://download.docker.com/linux/centos/7/x86_64/stable/Packages/*，下载`.rpm`合适版本下载。\n\n> Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.\n\n2. 安装docker\n指向包所在路径，如果是更新，把`install`改成`update`\n\n\n    $ sudo yum install /path/to/package.rpm\n      \n      \n3. 启动docker\n\n    $ sudo systemctl start docker\n    \n4. 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n{% asset_img a.png %}\n\n看到红色标注部分说明安装成功。    \n    \n5. 更新docker-ce\n下载新的安装包，用`yum -y upgrade`替换`yum -y install`,指向新的安装包。    \n\n## 3. 卸载docker-ce\n\n1. 卸载docker安装包：\n\n\n    $ sudo yum remove docker-ce\n    \n2. 卸载docker安装包不会自动删除相关资源，要手动删除：\n\n\n    $ sudo rm -rf /var/lib/docker\n                                      ","source":"_posts/docker-install-centos7.md","raw":"---\ntitle: centos7安装docker-ce\ndate: 2017-11-15 13:55:39\ncategories: docker\ntags: centos-docker-install\n---\n\n本文介绍docker在centos7系统上的安装。\n参考：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\n\n## 1. 卸载旧版本docker\n\n    $ sudo yum remove docker \\\n                      docker-common \\\n                      docker-selinux \\\n                      docker-engine\n\n---\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n    >                   docker-common \\\n    >                   docker-selinux \\\n    >                   docker-engine\n    Loaded plugins: fastestmirror\n    No Match for argument: docker\n    No Match for argument: docker-common\n    No Match for argument: docker-selinux\n    No Match for argument: docker-engine\n    No Packages marked for removal\n    \n    ---\n    表明没有旧版本\n    \n旧版本的会安装在`/var/lib/docker/`，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。\n \n## 2. 安装docker-ce\n\n共有三种方式安装,根据自己喜欢方式选择一种安装：\n- 配置安装源，从安装源拉取安装。推荐，但是网络要好\n- 下载安装包，执行安装。网络不好，采用。\n- 下载脚本执行安装。开发环境这种方式方便。\n\n### 2.1 repository方式安装，推荐\n第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。\n1. 安装依赖包\n\n\n    $ sudo yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n\n\n2. 安装源\n        \n        \n    $ sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo                   \n                      \n3. 可选: 开启edge和test源\n\n\n    $ sudo yum-config-manager --enable docker-ce-edge\n    $ sudo yum-config-manager --enable docker-ce-test                     \n    -----\n    关闭：\n    $ sudo yum-config-manager --disable docker-ce-edge    \n    \n4. 安装docker\n\n4.1 安装最新版本\n\n    $ sudo yum install docker-ce\n    \n> Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.\n\n4.2 安装指定版本\n在生成环境，有时候要安装指定版本。\n\n- 查看所有可用版本\n\n        $ yum list docker-ce --showduplicates | sort -r\n        \n        docker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n        \nThe contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).\n> Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.\n\n    $ sudo yum install <FULLY-QUALIFIED-PACKAGE-NAME>\n    \n4.3 启动docker                 \n    \n    $ sudo systemctl start docker                      \n\n4.4 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n会下载docker镜像，然后执行，打印信息。\n\n4.5 更新docker\n根据上面安装过程，重新安装即可。\n\n### 2.2 安装包方式（更喜欢方式）\n\n如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。\n\n1. 下载安装包：\n\n打开网址 *https://download.docker.com/linux/centos/7/x86_64/stable/Packages/*，下载`.rpm`合适版本下载。\n\n> Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.\n\n2. 安装docker\n指向包所在路径，如果是更新，把`install`改成`update`\n\n\n    $ sudo yum install /path/to/package.rpm\n      \n      \n3. 启动docker\n\n    $ sudo systemctl start docker\n    \n4. 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n{% asset_img a.png %}\n\n看到红色标注部分说明安装成功。    \n    \n5. 更新docker-ce\n下载新的安装包，用`yum -y upgrade`替换`yum -y install`,指向新的安装包。    \n\n## 3. 卸载docker-ce\n\n1. 卸载docker安装包：\n\n\n    $ sudo yum remove docker-ce\n    \n2. 卸载docker安装包不会自动删除相关资源，要手动删除：\n\n\n    $ sudo rm -rf /var/lib/docker\n                                      ","slug":"docker-install-centos7","published":1,"updated":"2018-11-09T01:20:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381s000uqcrg3zk9i3qh","content":"<p>本文介绍docker在centos7系统上的安装。<br>参考：<a href=\"https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions</a></p>\n<h2 id=\"1-卸载旧版本docker\"><a href=\"#1-卸载旧版本docker\" class=\"headerlink\" title=\"1. 卸载旧版本docker\"></a>1. 卸载旧版本docker</h2><pre><code>$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n</code></pre><hr>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n&gt;                   docker-common \\\n&gt;                   docker-selinux \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror\nNo Match for argument: docker\nNo Match for argument: docker-common\nNo Match for argument: docker-selinux\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n---\n表明没有旧版本\n</code></pre><p>旧版本的会安装在<code>/var/lib/docker/</code>，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。</p>\n<h2 id=\"2-安装docker-ce\"><a href=\"#2-安装docker-ce\" class=\"headerlink\" title=\"2. 安装docker-ce\"></a>2. 安装docker-ce</h2><p>共有三种方式安装,根据自己喜欢方式选择一种安装：</p>\n<ul>\n<li>配置安装源，从安装源拉取安装。推荐，但是网络要好</li>\n<li>下载安装包，执行安装。网络不好，采用。</li>\n<li>下载脚本执行安装。开发环境这种方式方便。</li>\n</ul>\n<h3 id=\"2-1-repository方式安装，推荐\"><a href=\"#2-1-repository方式安装，推荐\" class=\"headerlink\" title=\"2.1 repository方式安装，推荐\"></a>2.1 repository方式安装，推荐</h3><p>第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。</p>\n<ol>\n<li>安装依赖包</li>\n</ol>\n<pre><code>$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre><ol start=\"2\">\n<li>安装源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo                   \n</code></pre><ol start=\"3\">\n<li>可选: 开启edge和test源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager --enable docker-ce-edge\n$ sudo yum-config-manager --enable docker-ce-test                     \n-----\n关闭：\n$ sudo yum-config-manager --disable docker-ce-edge    \n</code></pre><ol start=\"4\">\n<li>安装docker</li>\n</ol>\n<p>4.1 安装最新版本</p>\n<pre><code>$ sudo yum install docker-ce\n</code></pre><blockquote>\n<p>Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.</p>\n</blockquote>\n<p>4.2 安装指定版本<br>在生成环境，有时候要安装指定版本。</p>\n<ul>\n<li><p>查看所有可用版本</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n</code></pre></li>\n</ul>\n<p>The contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).</p>\n<blockquote>\n<p>Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.</p>\n</blockquote>\n<pre><code>$ sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt;\n</code></pre><p>4.3 启动docker                 </p>\n<pre><code>$ sudo systemctl start docker                      \n</code></pre><p>4.4 验证是否安装成功</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre><p>会下载docker镜像，然后执行，打印信息。</p>\n<p>4.5 更新docker<br>根据上面安装过程，重新安装即可。</p>\n<h3 id=\"2-2-安装包方式（更喜欢方式）\"><a href=\"#2-2-安装包方式（更喜欢方式）\" class=\"headerlink\" title=\"2.2 安装包方式（更喜欢方式）\"></a>2.2 安装包方式（更喜欢方式）</h3><p>如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。</p>\n<ol>\n<li>下载安装包：</li>\n</ol>\n<p>打开网址 <em><a href=\"https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></em>，下载<code>.rpm</code>合适版本下载。</p>\n<blockquote>\n<p>Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.</p>\n</blockquote>\n<ol start=\"2\">\n<li>安装docker<br>指向包所在路径，如果是更新，把<code>install</code>改成<code>update</code></li>\n</ol>\n<pre><code>$ sudo yum install /path/to/package.rpm\n</code></pre><ol start=\"3\">\n<li><p>启动docker</p>\n<p> $ sudo systemctl start docker</p>\n</li>\n<li><p>验证是否安装成功</p>\n<p> $ sudo docker run hello-world</p>\n</li>\n</ol>\n<img src=\"/2017/11/15/docker-install-centos7/a.png\">\n<p>看到红色标注部分说明安装成功。    </p>\n<ol start=\"5\">\n<li>更新docker-ce<br>下载新的安装包，用<code>yum -y upgrade</code>替换<code>yum -y install</code>,指向新的安装包。    </li>\n</ol>\n<h2 id=\"3-卸载docker-ce\"><a href=\"#3-卸载docker-ce\" class=\"headerlink\" title=\"3. 卸载docker-ce\"></a>3. 卸载docker-ce</h2><ol>\n<li>卸载docker安装包：</li>\n</ol>\n<pre><code>$ sudo yum remove docker-ce\n</code></pre><ol start=\"2\">\n<li>卸载docker安装包不会自动删除相关资源，要手动删除：</li>\n</ol>\n<pre><code>$ sudo rm -rf /var/lib/docker\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍docker在centos7系统上的安装。<br>参考：<a href=\"https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions</a></p>\n<h2 id=\"1-卸载旧版本docker\"><a href=\"#1-卸载旧版本docker\" class=\"headerlink\" title=\"1. 卸载旧版本docker\"></a>1. 卸载旧版本docker</h2><pre><code>$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n</code></pre><hr>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n&gt;                   docker-common \\\n&gt;                   docker-selinux \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror\nNo Match for argument: docker\nNo Match for argument: docker-common\nNo Match for argument: docker-selinux\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n---\n表明没有旧版本\n</code></pre><p>旧版本的会安装在<code>/var/lib/docker/</code>，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。</p>\n<h2 id=\"2-安装docker-ce\"><a href=\"#2-安装docker-ce\" class=\"headerlink\" title=\"2. 安装docker-ce\"></a>2. 安装docker-ce</h2><p>共有三种方式安装,根据自己喜欢方式选择一种安装：</p>\n<ul>\n<li>配置安装源，从安装源拉取安装。推荐，但是网络要好</li>\n<li>下载安装包，执行安装。网络不好，采用。</li>\n<li>下载脚本执行安装。开发环境这种方式方便。</li>\n</ul>\n<h3 id=\"2-1-repository方式安装，推荐\"><a href=\"#2-1-repository方式安装，推荐\" class=\"headerlink\" title=\"2.1 repository方式安装，推荐\"></a>2.1 repository方式安装，推荐</h3><p>第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。</p>\n<ol>\n<li>安装依赖包</li>\n</ol>\n<pre><code>$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre><ol start=\"2\">\n<li>安装源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo                   \n</code></pre><ol start=\"3\">\n<li>可选: 开启edge和test源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager --enable docker-ce-edge\n$ sudo yum-config-manager --enable docker-ce-test                     \n-----\n关闭：\n$ sudo yum-config-manager --disable docker-ce-edge    \n</code></pre><ol start=\"4\">\n<li>安装docker</li>\n</ol>\n<p>4.1 安装最新版本</p>\n<pre><code>$ sudo yum install docker-ce\n</code></pre><blockquote>\n<p>Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.</p>\n</blockquote>\n<p>4.2 安装指定版本<br>在生成环境，有时候要安装指定版本。</p>\n<ul>\n<li><p>查看所有可用版本</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n</code></pre></li>\n</ul>\n<p>The contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).</p>\n<blockquote>\n<p>Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.</p>\n</blockquote>\n<pre><code>$ sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt;\n</code></pre><p>4.3 启动docker                 </p>\n<pre><code>$ sudo systemctl start docker                      \n</code></pre><p>4.4 验证是否安装成功</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre><p>会下载docker镜像，然后执行，打印信息。</p>\n<p>4.5 更新docker<br>根据上面安装过程，重新安装即可。</p>\n<h3 id=\"2-2-安装包方式（更喜欢方式）\"><a href=\"#2-2-安装包方式（更喜欢方式）\" class=\"headerlink\" title=\"2.2 安装包方式（更喜欢方式）\"></a>2.2 安装包方式（更喜欢方式）</h3><p>如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。</p>\n<ol>\n<li>下载安装包：</li>\n</ol>\n<p>打开网址 <em><a href=\"https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></em>，下载<code>.rpm</code>合适版本下载。</p>\n<blockquote>\n<p>Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.</p>\n</blockquote>\n<ol start=\"2\">\n<li>安装docker<br>指向包所在路径，如果是更新，把<code>install</code>改成<code>update</code></li>\n</ol>\n<pre><code>$ sudo yum install /path/to/package.rpm\n</code></pre><ol start=\"3\">\n<li><p>启动docker</p>\n<p> $ sudo systemctl start docker</p>\n</li>\n<li><p>验证是否安装成功</p>\n<p> $ sudo docker run hello-world</p>\n</li>\n</ol>\n<img src=\"/2017/11/15/docker-install-centos7/a.png\">\n<p>看到红色标注部分说明安装成功。    </p>\n<ol start=\"5\">\n<li>更新docker-ce<br>下载新的安装包，用<code>yum -y upgrade</code>替换<code>yum -y install</code>,指向新的安装包。    </li>\n</ol>\n<h2 id=\"3-卸载docker-ce\"><a href=\"#3-卸载docker-ce\" class=\"headerlink\" title=\"3. 卸载docker-ce\"></a>3. 卸载docker-ce</h2><ol>\n<li>卸载docker安装包：</li>\n</ol>\n<pre><code>$ sudo yum remove docker-ce\n</code></pre><ol start=\"2\">\n<li>卸载docker安装包不会自动删除相关资源，要手动删除：</li>\n</ol>\n<pre><code>$ sudo rm -rf /var/lib/docker\n</code></pre>"},{"title":"Ubuntu16.0.4安装docker-ce","date":"2018-02-28T01:55:22.000Z","_content":"\n本文介绍在Ubuntu环境下安装Docker ce……\n\n参考：https://docs.docker.com/install/linux/docker-ce/ubuntu/\n\n##  卸载旧版本：\n\n    $ sudo apt-get remove docker docker-engine docker.io\n\n## 安装系统可选内核\n\n参考：\nhttps://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\n\n## 使用 APT 安装\n\n- *更新系统包*\n\n\n    $ sudo apt-get update\n    \n    \n- *添加ca证书*\n\n由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。\n\n    \n    $ sudo apt-get install \\\n        apt-transport-https \\\n        ca-certificates \\\n        curl \\\n        software-properties-common    \n   \n如果出现错误：\n\n    E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\n    E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n\n执行下面命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n    \n然后再重试。\n\n\n- *添加软件源的GPG密钥*\n\n为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。\n\n    $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n    \n\n验证密钥：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\n    pub   4096R/0EBFCD88 2017-02-22\n          Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n    uid                  Docker Release (CE deb) <docker@docker.com>\n    sub   4096R/F273FCD8 2017-02-22\n    \n    mutian@mutian-ThinkPad-T440p:~$ \n\n\n- *添加Docker软件源* \n\n然后,我们需要向source.list\t中添加Docker软件源\n\n    $ sudo add-apt-repository \\\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n       $(lsb_release -cs) \\\n       stable\"\n       \n>以上命令会添加稳定版本的\tDocker\tCE\tAPT\t镜像源,如果需要最新或者测试版本的\nDocker\tCE\t请将\tstable\t改为\tedge\t或者\ttest。从\tDocker\t17.06\t开始,edge\ttest\t版本的\nAPT\t镜像源也会包含稳定版本的\tDocker。 \n\n- *安装DOCKER CE*\n\n1.更新系统包\n\n    $ sudo apt-get update\n    \n2.安装\n\n    $ sudo apt-get install docker-ce    \n\n\n## 镜像加速\n      \n国内从Docker\tHub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker\t官方和国\n内很多云服务商都提供了国内加速器服务,例如:   \n\n- [Docker官方提供的中国registry mirror](https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror)\n- [阿里云加速器](https://cr.console.aliyun.com/#/accelerator)\n- [DaoCloud\t加速器](https://www.daocloud.io/mirror#accelerator-doc) \n\n我们以Docker官方加速器为例进行介绍。\n\nUbuntu16.04+、Debian\t8+、CentOS7环境下：\n\n对于使用\tsystemd\t的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存\n在请新建该文件)\n\n    {\n    \t\t\"registry-mirrors\":\t[\n    \t\t\t\t\"https://registry.docker-cn.com\"\n    \t\t]\n    }\n    \n>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 \n\n之后重新启动服务。\n\n    $\tsudo systemctl daemon-reload\n    $\tsudo systemctl restart docker\n    \n\n## 测试安装是否成功\n\n    $ sudo docker run hello-world\n    \n\n如图出现则表示安装成功：\n\n{% asset_img a.png %}    \n    \n           ","source":"_posts/docker-install-ubuntu16.md","raw":"---\ntitle: Ubuntu16.0.4安装docker-ce\ndate: 2018-02-28 09:55:22\ncategories: docker\ntags: docker ce安装\n---\n\n本文介绍在Ubuntu环境下安装Docker ce……\n\n参考：https://docs.docker.com/install/linux/docker-ce/ubuntu/\n\n##  卸载旧版本：\n\n    $ sudo apt-get remove docker docker-engine docker.io\n\n## 安装系统可选内核\n\n参考：\nhttps://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\n\n## 使用 APT 安装\n\n- *更新系统包*\n\n\n    $ sudo apt-get update\n    \n    \n- *添加ca证书*\n\n由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。\n\n    \n    $ sudo apt-get install \\\n        apt-transport-https \\\n        ca-certificates \\\n        curl \\\n        software-properties-common    \n   \n如果出现错误：\n\n    E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\n    E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n\n执行下面命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n    \n然后再重试。\n\n\n- *添加软件源的GPG密钥*\n\n为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。\n\n    $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n    \n\n验证密钥：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\n    pub   4096R/0EBFCD88 2017-02-22\n          Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n    uid                  Docker Release (CE deb) <docker@docker.com>\n    sub   4096R/F273FCD8 2017-02-22\n    \n    mutian@mutian-ThinkPad-T440p:~$ \n\n\n- *添加Docker软件源* \n\n然后,我们需要向source.list\t中添加Docker软件源\n\n    $ sudo add-apt-repository \\\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n       $(lsb_release -cs) \\\n       stable\"\n       \n>以上命令会添加稳定版本的\tDocker\tCE\tAPT\t镜像源,如果需要最新或者测试版本的\nDocker\tCE\t请将\tstable\t改为\tedge\t或者\ttest。从\tDocker\t17.06\t开始,edge\ttest\t版本的\nAPT\t镜像源也会包含稳定版本的\tDocker。 \n\n- *安装DOCKER CE*\n\n1.更新系统包\n\n    $ sudo apt-get update\n    \n2.安装\n\n    $ sudo apt-get install docker-ce    \n\n\n## 镜像加速\n      \n国内从Docker\tHub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker\t官方和国\n内很多云服务商都提供了国内加速器服务,例如:   \n\n- [Docker官方提供的中国registry mirror](https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror)\n- [阿里云加速器](https://cr.console.aliyun.com/#/accelerator)\n- [DaoCloud\t加速器](https://www.daocloud.io/mirror#accelerator-doc) \n\n我们以Docker官方加速器为例进行介绍。\n\nUbuntu16.04+、Debian\t8+、CentOS7环境下：\n\n对于使用\tsystemd\t的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存\n在请新建该文件)\n\n    {\n    \t\t\"registry-mirrors\":\t[\n    \t\t\t\t\"https://registry.docker-cn.com\"\n    \t\t]\n    }\n    \n>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 \n\n之后重新启动服务。\n\n    $\tsudo systemctl daemon-reload\n    $\tsudo systemctl restart docker\n    \n\n## 测试安装是否成功\n\n    $ sudo docker run hello-world\n    \n\n如图出现则表示安装成功：\n\n{% asset_img a.png %}    \n    \n           ","slug":"docker-install-ubuntu16","published":1,"updated":"2018-11-09T01:20:30.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381t000wqcrgds50tbhd","content":"<p>本文介绍在Ubuntu环境下安装Docker ce……</p>\n<p>参考：<a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>\n<h2 id=\"卸载旧版本：\"><a href=\"#卸载旧版本：\" class=\"headerlink\" title=\"卸载旧版本：\"></a>卸载旧版本：</h2><pre><code>$ sudo apt-get remove docker docker-engine docker.io\n</code></pre><h2 id=\"安装系统可选内核\"><a href=\"#安装系统可选内核\" class=\"headerlink\" title=\"安装系统可选内核\"></a>安装系统可选内核</h2><p>参考：<br><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers</a></p>\n<h2 id=\"使用-APT-安装\"><a href=\"#使用-APT-安装\" class=\"headerlink\" title=\"使用 APT 安装\"></a>使用 APT 安装</h2><ul>\n<li><em>更新系统包</em></li>\n</ul>\n<pre><code>$ sudo apt-get update\n</code></pre><ul>\n<li><em>添加ca证书</em></li>\n</ul>\n<p>由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p>\n<pre><code>$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common    \n</code></pre><p>如果出现错误：</p>\n<pre><code>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\nE: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n</code></pre><p>执行下面命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\nmutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n</code></pre><p>然后再重试。</p>\n<ul>\n<li><em>添加软件源的GPG密钥</em></li>\n</ul>\n<p>为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。</p>\n<pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre><p>验证密钥：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\npub   4096R/0EBFCD88 2017-02-22\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) &lt;docker@docker.com&gt;\nsub   4096R/F273FCD8 2017-02-22\n\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><ul>\n<li><em>添加Docker软件源</em> </li>\n</ul>\n<p>然后,我们需要向source.list    中添加Docker软件源</p>\n<pre><code>$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre><blockquote>\n<p>以上命令会添加稳定版本的    Docker    CE    APT    镜像源,如果需要最新或者测试版本的<br>Docker    CE    请将    stable    改为    edge    或者    test。从    Docker    17.06    开始,edge    test    版本的<br>APT    镜像源也会包含稳定版本的    Docker。 </p>\n</blockquote>\n<ul>\n<li><em>安装DOCKER CE</em></li>\n</ul>\n<p>1.更新系统包</p>\n<pre><code>$ sudo apt-get update\n</code></pre><p>2.安装</p>\n<pre><code>$ sudo apt-get install docker-ce    \n</code></pre><h2 id=\"镜像加速\"><a href=\"#镜像加速\" class=\"headerlink\" title=\"镜像加速\"></a>镜像加速</h2><p>国内从Docker    Hub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker    官方和国<br>内很多云服务商都提供了国内加速器服务,例如:   </p>\n<ul>\n<li><a href=\"https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror\" target=\"_blank\" rel=\"noopener\">Docker官方提供的中国registry mirror</a></li>\n<li><a href=\"https://cr.console.aliyun.com/#/accelerator\" target=\"_blank\" rel=\"noopener\">阿里云加速器</a></li>\n<li><a href=\"https://www.daocloud.io/mirror#accelerator-doc\" target=\"_blank\" rel=\"noopener\">DaoCloud    加速器</a> </li>\n</ul>\n<p>我们以Docker官方加速器为例进行介绍。</p>\n<p>Ubuntu16.04+、Debian    8+、CentOS7环境下：</p>\n<p>对于使用    systemd    的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存<br>在请新建该文件)</p>\n<pre><code>{\n        &quot;registry-mirrors&quot;:    [\n                &quot;https://registry.docker-cn.com&quot;\n        ]\n}\n</code></pre><blockquote>\n<p>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 </p>\n</blockquote>\n<p>之后重新启动服务。</p>\n<pre><code>$    sudo systemctl daemon-reload\n$    sudo systemctl restart docker\n</code></pre><h2 id=\"测试安装是否成功\"><a href=\"#测试安装是否成功\" class=\"headerlink\" title=\"测试安装是否成功\"></a>测试安装是否成功</h2><pre><code>$ sudo docker run hello-world\n</code></pre><p>如图出现则表示安装成功：</p>\n<img src=\"/2018/02/28/docker-install-ubuntu16/a.png\">    \n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在Ubuntu环境下安装Docker ce……</p>\n<p>参考：<a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>\n<h2 id=\"卸载旧版本：\"><a href=\"#卸载旧版本：\" class=\"headerlink\" title=\"卸载旧版本：\"></a>卸载旧版本：</h2><pre><code>$ sudo apt-get remove docker docker-engine docker.io\n</code></pre><h2 id=\"安装系统可选内核\"><a href=\"#安装系统可选内核\" class=\"headerlink\" title=\"安装系统可选内核\"></a>安装系统可选内核</h2><p>参考：<br><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers</a></p>\n<h2 id=\"使用-APT-安装\"><a href=\"#使用-APT-安装\" class=\"headerlink\" title=\"使用 APT 安装\"></a>使用 APT 安装</h2><ul>\n<li><em>更新系统包</em></li>\n</ul>\n<pre><code>$ sudo apt-get update\n</code></pre><ul>\n<li><em>添加ca证书</em></li>\n</ul>\n<p>由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p>\n<pre><code>$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common    \n</code></pre><p>如果出现错误：</p>\n<pre><code>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\nE: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n</code></pre><p>执行下面命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\nmutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n</code></pre><p>然后再重试。</p>\n<ul>\n<li><em>添加软件源的GPG密钥</em></li>\n</ul>\n<p>为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。</p>\n<pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre><p>验证密钥：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\npub   4096R/0EBFCD88 2017-02-22\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) &lt;docker@docker.com&gt;\nsub   4096R/F273FCD8 2017-02-22\n\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><ul>\n<li><em>添加Docker软件源</em> </li>\n</ul>\n<p>然后,我们需要向source.list    中添加Docker软件源</p>\n<pre><code>$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre><blockquote>\n<p>以上命令会添加稳定版本的    Docker    CE    APT    镜像源,如果需要最新或者测试版本的<br>Docker    CE    请将    stable    改为    edge    或者    test。从    Docker    17.06    开始,edge    test    版本的<br>APT    镜像源也会包含稳定版本的    Docker。 </p>\n</blockquote>\n<ul>\n<li><em>安装DOCKER CE</em></li>\n</ul>\n<p>1.更新系统包</p>\n<pre><code>$ sudo apt-get update\n</code></pre><p>2.安装</p>\n<pre><code>$ sudo apt-get install docker-ce    \n</code></pre><h2 id=\"镜像加速\"><a href=\"#镜像加速\" class=\"headerlink\" title=\"镜像加速\"></a>镜像加速</h2><p>国内从Docker    Hub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker    官方和国<br>内很多云服务商都提供了国内加速器服务,例如:   </p>\n<ul>\n<li><a href=\"https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror\" target=\"_blank\" rel=\"noopener\">Docker官方提供的中国registry mirror</a></li>\n<li><a href=\"https://cr.console.aliyun.com/#/accelerator\" target=\"_blank\" rel=\"noopener\">阿里云加速器</a></li>\n<li><a href=\"https://www.daocloud.io/mirror#accelerator-doc\" target=\"_blank\" rel=\"noopener\">DaoCloud    加速器</a> </li>\n</ul>\n<p>我们以Docker官方加速器为例进行介绍。</p>\n<p>Ubuntu16.04+、Debian    8+、CentOS7环境下：</p>\n<p>对于使用    systemd    的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存<br>在请新建该文件)</p>\n<pre><code>{\n        &quot;registry-mirrors&quot;:    [\n                &quot;https://registry.docker-cn.com&quot;\n        ]\n}\n</code></pre><blockquote>\n<p>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 </p>\n</blockquote>\n<p>之后重新启动服务。</p>\n<pre><code>$    sudo systemctl daemon-reload\n$    sudo systemctl restart docker\n</code></pre><h2 id=\"测试安装是否成功\"><a href=\"#测试安装是否成功\" class=\"headerlink\" title=\"测试安装是否成功\"></a>测试安装是否成功</h2><pre><code>$ sudo docker run hello-world\n</code></pre><p>如图出现则表示安装成功：</p>\n<img src=\"/2018/02/28/docker-install-ubuntu16/a.png\">    \n"},{"title":"docker学习-第二课：发布一个web应用","date":"2018-02-02T03:00:11.000Z","_content":"\n介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……\n\n参考网址：https://github.com/docker/labs/tree/master/beginner/\n\n\n","source":"_posts/docker-lesson2.md","raw":"---\ntitle: docker学习-第二课：发布一个web应用\ndate: 2018-02-02 11:00:11\ncategories: docker\ntags: docker镜像创建、docker容器启动、docker发布web应用\n---\n\n介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……\n\n参考网址：https://github.com/docker/labs/tree/master/beginner/\n\n\n","slug":"docker-lesson2","published":1,"updated":"2018-11-09T01:20:30.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381v0010qcrgep9e7wfd","content":"<p>介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……</p>\n<p>参考网址：<a href=\"https://github.com/docker/labs/tree/master/beginner/\" target=\"_blank\" rel=\"noopener\">https://github.com/docker/labs/tree/master/beginner/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……</p>\n<p>参考网址：<a href=\"https://github.com/docker/labs/tree/master/beginner/\" target=\"_blank\" rel=\"noopener\">https://github.com/docker/labs/tree/master/beginner/</a></p>\n"},{"title":"docker学习-第一课：基础概念理解","date":"2018-02-02T02:16:25.000Z","_content":"\nDocker\t包括三个基本概念\n镜像(Image)\n容器(Container)\n仓库(Repository)\n理解了这三个概念,就理解了\tDocker\t的整个生命周期。\n\n## Docker镜像\ndocker镜像就像是一个只读的模板。 \n\n例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 \n\n镜像可以用来创建容器。甚至多个容器。 \n\nDocker\t提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一\n个已经做好的镜像来直接使用。\n\n## Docker容器\ndocker利用容器来运行应用。 \n\n容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全\n的平台\n\n可以把容器看做是一个简易版的\tLinux\t环境(包括root用户权限、进程空间、用户空间和网络空间等)和运\n行在其中的应用程序。\n\n`注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。`\n\n## Docker仓库\n仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区\n分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的\n标签(tag)。\n\n仓库分为公开仓库(Public)和私有仓库(Private)两种形式。\n\n最大的公开仓库是[Docker\tHub](https://hub.docker.com/),存放了数量庞大的镜像供用户下载。\t国内的公开仓库包括[Docker Pool]()等,可以提供大陆用户更稳定快速的访问。\n\n当然,用户也可以在本地网络内创建一个私有仓库。\n\n当用户创建了自己的镜像之后就可以使用\t \tpush\t \t命令将它上传到公有或者私有仓库,这样下次在另外一台\n机器上使用这个镜像时候,只需要从仓库上\t \tpull\t \t下来就可以了。\n\n`注:Docker\t仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。`\n\n","source":"_posts/docker-lesson1.md","raw":"---\ntitle: docker学习-第一课：基础概念理解\ndate: 2018-02-02 10:16:25\ncategories: docker\ntags: 基础概念\n---\n\nDocker\t包括三个基本概念\n镜像(Image)\n容器(Container)\n仓库(Repository)\n理解了这三个概念,就理解了\tDocker\t的整个生命周期。\n\n## Docker镜像\ndocker镜像就像是一个只读的模板。 \n\n例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 \n\n镜像可以用来创建容器。甚至多个容器。 \n\nDocker\t提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一\n个已经做好的镜像来直接使用。\n\n## Docker容器\ndocker利用容器来运行应用。 \n\n容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全\n的平台\n\n可以把容器看做是一个简易版的\tLinux\t环境(包括root用户权限、进程空间、用户空间和网络空间等)和运\n行在其中的应用程序。\n\n`注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。`\n\n## Docker仓库\n仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区\n分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的\n标签(tag)。\n\n仓库分为公开仓库(Public)和私有仓库(Private)两种形式。\n\n最大的公开仓库是[Docker\tHub](https://hub.docker.com/),存放了数量庞大的镜像供用户下载。\t国内的公开仓库包括[Docker Pool]()等,可以提供大陆用户更稳定快速的访问。\n\n当然,用户也可以在本地网络内创建一个私有仓库。\n\n当用户创建了自己的镜像之后就可以使用\t \tpush\t \t命令将它上传到公有或者私有仓库,这样下次在另外一台\n机器上使用这个镜像时候,只需要从仓库上\t \tpull\t \t下来就可以了。\n\n`注:Docker\t仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。`\n\n","slug":"docker-lesson1","published":1,"updated":"2018-11-09T01:20:30.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m381z0011qcrgo1hcjmqf","content":"<p>Docker    包括三个基本概念<br>镜像(Image)<br>容器(Container)<br>仓库(Repository)<br>理解了这三个概念,就理解了    Docker    的整个生命周期。</p>\n<h2 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h2><p>docker镜像就像是一个只读的模板。 </p>\n<p>例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 </p>\n<p>镜像可以用来创建容器。甚至多个容器。 </p>\n<p>Docker    提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一<br>个已经做好的镜像来直接使用。</p>\n<h2 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h2><p>docker利用容器来运行应用。 </p>\n<p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全<br>的平台</p>\n<p>可以把容器看做是一个简易版的    Linux    环境(包括root用户权限、进程空间、用户空间和网络空间等)和运<br>行在其中的应用程序。</p>\n<p><code>注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。</code></p>\n<h2 id=\"Docker仓库\"><a href=\"#Docker仓库\" class=\"headerlink\" title=\"Docker仓库\"></a>Docker仓库</h2><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区<br>分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的<br>标签(tag)。</p>\n<p>仓库分为公开仓库(Public)和私有仓库(Private)两种形式。</p>\n<p>最大的公开仓库是<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker    Hub</a>,存放了数量庞大的镜像供用户下载。    国内的公开仓库包括<a href=\"\">Docker Pool</a>等,可以提供大陆用户更稳定快速的访问。</p>\n<p>当然,用户也可以在本地网络内创建一个私有仓库。</p>\n<p>当用户创建了自己的镜像之后就可以使用         push         命令将它上传到公有或者私有仓库,这样下次在另外一台<br>机器上使用这个镜像时候,只需要从仓库上         pull         下来就可以了。</p>\n<p><code>注:Docker    仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Docker    包括三个基本概念<br>镜像(Image)<br>容器(Container)<br>仓库(Repository)<br>理解了这三个概念,就理解了    Docker    的整个生命周期。</p>\n<h2 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h2><p>docker镜像就像是一个只读的模板。 </p>\n<p>例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 </p>\n<p>镜像可以用来创建容器。甚至多个容器。 </p>\n<p>Docker    提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一<br>个已经做好的镜像来直接使用。</p>\n<h2 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h2><p>docker利用容器来运行应用。 </p>\n<p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全<br>的平台</p>\n<p>可以把容器看做是一个简易版的    Linux    环境(包括root用户权限、进程空间、用户空间和网络空间等)和运<br>行在其中的应用程序。</p>\n<p><code>注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。</code></p>\n<h2 id=\"Docker仓库\"><a href=\"#Docker仓库\" class=\"headerlink\" title=\"Docker仓库\"></a>Docker仓库</h2><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区<br>分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的<br>标签(tag)。</p>\n<p>仓库分为公开仓库(Public)和私有仓库(Private)两种形式。</p>\n<p>最大的公开仓库是<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker    Hub</a>,存放了数量庞大的镜像供用户下载。    国内的公开仓库包括<a href=\"\">Docker Pool</a>等,可以提供大陆用户更稳定快速的访问。</p>\n<p>当然,用户也可以在本地网络内创建一个私有仓库。</p>\n<p>当用户创建了自己的镜像之后就可以使用         push         命令将它上传到公有或者私有仓库,这样下次在另外一台<br>机器上使用这个镜像时候,只需要从仓库上         pull         下来就可以了。</p>\n<p><code>注:Docker    仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。</code></p>\n"},{"title":"docker学习-第六课：使用网络","date":"2018-07-26T12:23:35.000Z","_content":"\n本节概述docker中与网络相关的一些操作，如docker与主机之间的网络互通，docker之间的网络互相访问等……\n\n参考网址： https://docs.docker.com/network/\n\n## 外部访问网络\n\n容器中可以运行一些网络应用，要让外部也可以访问这些网络应用，可以使用`-P`或者`-p`参数来指定端口映射。  \n\n当使用`-P`标记时，Docker会随机主机的一个49000~49900端口到容器的内部端口。   \n使用`docker container ps`可以查看到。 \n\n    docker run -d -P --name ngxin-net nginx\n\n创建容器`nginx-net`并后台启动。 \n\n       [vagrant@ymu ~]$ sudo docker run -d -P --name ngxin-net nginx\n       cfb84ca5f6837d14ea5f9c4d670ca4f9b126fbbe3e0d78f9cbaa949772f892be\n       [vagrant@ymu ~]$ sudo docker container ps\n       CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\n       cfb84ca5f683        nginx               \"nginx -g 'daemon of…\"   14 seconds ago      Up 13 seconds       0.0.0.0:32768->80/tcp   ngxin-net\n       d120d176e25c        nginx               \"nginx -g 'daemon of…\"   13 days ago         Up 3 minutes        0.0.0.0:80->80/tcp      nginx\n\n可以看到容器`ngxin-net`的端口映射信息，把主机32768端口映射到了容器的80端口。这样，在主机就可以访问：localhost:32768\n\n同样，可以查看应用访问日志： \n\n    [vagrant@ymu ~]$ sudo docker logs -f ngxin-net\n\n另外，小写`-p`可以明确指定主机和容器之间的端口映射。 并且,在一个指定端口上只可以绑定一个容器。      \n支持的格式： \n\n- ip:hostPort:containerPort\n- ip::containerPort \n- hostPort:containerPort\n\n前面一个为主机端口，后面一个为容器端口。 \n\n常用：\n\n`-p 80:80`\n\n将本地主机80端口映射到容器80端口。\n\n## 容器互联\n\n容器与容器之间的端口互通。 互相访问容器信息。 \n\n使用`--link`参数可以让容器之间安全的进行交互。  \n\n下面创建一个新的redis数据库容器：\n\n    docker run --name redis-test -d  redis\n    \n然后创建一个web容器：\n\n    docker run -d -p 80:80 --name nginx-web --link redis-test nginx \n    \n此时，redis-test容器和nginx-web容器建立了互联关系。  \n\n`--link` 参数格式 `--link name：alias`，其中name是容器名称，alias是这个连接的别名。 \n\n 可以通过`docker ps`查看连接信息。   \n 这样，nginx-web容器将可以访问redis-test容器中的信息。  \n \n Docker在两个容器之间建立起了一个安全隧道，而且不用映射它们的端口到宿主主机上。启动redis-test的时候，采用大写`-P`，从而避免了暴露数据库端口到外部网络上。  \n \n \n        \n\n","source":"_posts/docker-lesson6-net.md","raw":"---\ntitle: docker学习-第六课：使用网络\ndate: 2018-07-26 20:23:35\ncategories: docker\ntags: docker网络\n---\n\n本节概述docker中与网络相关的一些操作，如docker与主机之间的网络互通，docker之间的网络互相访问等……\n\n参考网址： https://docs.docker.com/network/\n\n## 外部访问网络\n\n容器中可以运行一些网络应用，要让外部也可以访问这些网络应用，可以使用`-P`或者`-p`参数来指定端口映射。  \n\n当使用`-P`标记时，Docker会随机主机的一个49000~49900端口到容器的内部端口。   \n使用`docker container ps`可以查看到。 \n\n    docker run -d -P --name ngxin-net nginx\n\n创建容器`nginx-net`并后台启动。 \n\n       [vagrant@ymu ~]$ sudo docker run -d -P --name ngxin-net nginx\n       cfb84ca5f6837d14ea5f9c4d670ca4f9b126fbbe3e0d78f9cbaa949772f892be\n       [vagrant@ymu ~]$ sudo docker container ps\n       CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\n       cfb84ca5f683        nginx               \"nginx -g 'daemon of…\"   14 seconds ago      Up 13 seconds       0.0.0.0:32768->80/tcp   ngxin-net\n       d120d176e25c        nginx               \"nginx -g 'daemon of…\"   13 days ago         Up 3 minutes        0.0.0.0:80->80/tcp      nginx\n\n可以看到容器`ngxin-net`的端口映射信息，把主机32768端口映射到了容器的80端口。这样，在主机就可以访问：localhost:32768\n\n同样，可以查看应用访问日志： \n\n    [vagrant@ymu ~]$ sudo docker logs -f ngxin-net\n\n另外，小写`-p`可以明确指定主机和容器之间的端口映射。 并且,在一个指定端口上只可以绑定一个容器。      \n支持的格式： \n\n- ip:hostPort:containerPort\n- ip::containerPort \n- hostPort:containerPort\n\n前面一个为主机端口，后面一个为容器端口。 \n\n常用：\n\n`-p 80:80`\n\n将本地主机80端口映射到容器80端口。\n\n## 容器互联\n\n容器与容器之间的端口互通。 互相访问容器信息。 \n\n使用`--link`参数可以让容器之间安全的进行交互。  \n\n下面创建一个新的redis数据库容器：\n\n    docker run --name redis-test -d  redis\n    \n然后创建一个web容器：\n\n    docker run -d -p 80:80 --name nginx-web --link redis-test nginx \n    \n此时，redis-test容器和nginx-web容器建立了互联关系。  \n\n`--link` 参数格式 `--link name：alias`，其中name是容器名称，alias是这个连接的别名。 \n\n 可以通过`docker ps`查看连接信息。   \n 这样，nginx-web容器将可以访问redis-test容器中的信息。  \n \n Docker在两个容器之间建立起了一个安全隧道，而且不用映射它们的端口到宿主主机上。启动redis-test的时候，采用大写`-P`，从而避免了暴露数据库端口到外部网络上。  \n \n \n        \n\n","slug":"docker-lesson6-net","published":1,"updated":"2018-11-09T01:20:30.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38210015qcrgnibsvhv6","content":"<p>本节概述docker中与网络相关的一些操作，如docker与主机之间的网络互通，docker之间的网络互相访问等……</p>\n<p>参考网址： <a href=\"https://docs.docker.com/network/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/network/</a></p>\n<h2 id=\"外部访问网络\"><a href=\"#外部访问网络\" class=\"headerlink\" title=\"外部访问网络\"></a>外部访问网络</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些网络应用，可以使用<code>-P</code>或者<code>-p</code>参数来指定端口映射。  </p>\n<p>当使用<code>-P</code>标记时，Docker会随机主机的一个49000~49900端口到容器的内部端口。<br>使用<code>docker container ps</code>可以查看到。 </p>\n<pre><code>docker run -d -P --name ngxin-net nginx\n</code></pre><p>创建容器<code>nginx-net</code>并后台启动。 </p>\n<pre><code>[vagrant@ymu ~]$ sudo docker run -d -P --name ngxin-net nginx\ncfb84ca5f6837d14ea5f9c4d670ca4f9b126fbbe3e0d78f9cbaa949772f892be\n[vagrant@ymu ~]$ sudo docker container ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\ncfb84ca5f683        nginx               &quot;nginx -g &apos;daemon of…&quot;   14 seconds ago      Up 13 seconds       0.0.0.0:32768-&gt;80/tcp   ngxin-net\nd120d176e25c        nginx               &quot;nginx -g &apos;daemon of…&quot;   13 days ago         Up 3 minutes        0.0.0.0:80-&gt;80/tcp      nginx\n</code></pre><p>可以看到容器<code>ngxin-net</code>的端口映射信息，把主机32768端口映射到了容器的80端口。这样，在主机就可以访问：localhost:32768</p>\n<p>同样，可以查看应用访问日志： </p>\n<pre><code>[vagrant@ymu ~]$ sudo docker logs -f ngxin-net\n</code></pre><p>另外，小写<code>-p</code>可以明确指定主机和容器之间的端口映射。 并且,在一个指定端口上只可以绑定一个容器。<br>支持的格式： </p>\n<ul>\n<li>ip:hostPort:containerPort</li>\n<li>ip::containerPort </li>\n<li>hostPort:containerPort</li>\n</ul>\n<p>前面一个为主机端口，后面一个为容器端口。 </p>\n<p>常用：</p>\n<p><code>-p 80:80</code></p>\n<p>将本地主机80端口映射到容器80端口。</p>\n<h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2><p>容器与容器之间的端口互通。 互相访问容器信息。 </p>\n<p>使用<code>--link</code>参数可以让容器之间安全的进行交互。  </p>\n<p>下面创建一个新的redis数据库容器：</p>\n<pre><code>docker run --name redis-test -d  redis\n</code></pre><p>然后创建一个web容器：</p>\n<pre><code>docker run -d -p 80:80 --name nginx-web --link redis-test nginx \n</code></pre><p>此时，redis-test容器和nginx-web容器建立了互联关系。  </p>\n<p><code>--link</code> 参数格式 <code>--link name：alias</code>，其中name是容器名称，alias是这个连接的别名。 </p>\n<p> 可以通过<code>docker ps</code>查看连接信息。<br> 这样，nginx-web容器将可以访问redis-test容器中的信息。  </p>\n<p> Docker在两个容器之间建立起了一个安全隧道，而且不用映射它们的端口到宿主主机上。启动redis-test的时候，采用大写<code>-P</code>，从而避免了暴露数据库端口到外部网络上。  </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本节概述docker中与网络相关的一些操作，如docker与主机之间的网络互通，docker之间的网络互相访问等……</p>\n<p>参考网址： <a href=\"https://docs.docker.com/network/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/network/</a></p>\n<h2 id=\"外部访问网络\"><a href=\"#外部访问网络\" class=\"headerlink\" title=\"外部访问网络\"></a>外部访问网络</h2><p>容器中可以运行一些网络应用，要让外部也可以访问这些网络应用，可以使用<code>-P</code>或者<code>-p</code>参数来指定端口映射。  </p>\n<p>当使用<code>-P</code>标记时，Docker会随机主机的一个49000~49900端口到容器的内部端口。<br>使用<code>docker container ps</code>可以查看到。 </p>\n<pre><code>docker run -d -P --name ngxin-net nginx\n</code></pre><p>创建容器<code>nginx-net</code>并后台启动。 </p>\n<pre><code>[vagrant@ymu ~]$ sudo docker run -d -P --name ngxin-net nginx\ncfb84ca5f6837d14ea5f9c4d670ca4f9b126fbbe3e0d78f9cbaa949772f892be\n[vagrant@ymu ~]$ sudo docker container ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                   NAMES\ncfb84ca5f683        nginx               &quot;nginx -g &apos;daemon of…&quot;   14 seconds ago      Up 13 seconds       0.0.0.0:32768-&gt;80/tcp   ngxin-net\nd120d176e25c        nginx               &quot;nginx -g &apos;daemon of…&quot;   13 days ago         Up 3 minutes        0.0.0.0:80-&gt;80/tcp      nginx\n</code></pre><p>可以看到容器<code>ngxin-net</code>的端口映射信息，把主机32768端口映射到了容器的80端口。这样，在主机就可以访问：localhost:32768</p>\n<p>同样，可以查看应用访问日志： </p>\n<pre><code>[vagrant@ymu ~]$ sudo docker logs -f ngxin-net\n</code></pre><p>另外，小写<code>-p</code>可以明确指定主机和容器之间的端口映射。 并且,在一个指定端口上只可以绑定一个容器。<br>支持的格式： </p>\n<ul>\n<li>ip:hostPort:containerPort</li>\n<li>ip::containerPort </li>\n<li>hostPort:containerPort</li>\n</ul>\n<p>前面一个为主机端口，后面一个为容器端口。 </p>\n<p>常用：</p>\n<p><code>-p 80:80</code></p>\n<p>将本地主机80端口映射到容器80端口。</p>\n<h2 id=\"容器互联\"><a href=\"#容器互联\" class=\"headerlink\" title=\"容器互联\"></a>容器互联</h2><p>容器与容器之间的端口互通。 互相访问容器信息。 </p>\n<p>使用<code>--link</code>参数可以让容器之间安全的进行交互。  </p>\n<p>下面创建一个新的redis数据库容器：</p>\n<pre><code>docker run --name redis-test -d  redis\n</code></pre><p>然后创建一个web容器：</p>\n<pre><code>docker run -d -p 80:80 --name nginx-web --link redis-test nginx \n</code></pre><p>此时，redis-test容器和nginx-web容器建立了互联关系。  </p>\n<p><code>--link</code> 参数格式 <code>--link name：alias</code>，其中name是容器名称，alias是这个连接的别名。 </p>\n<p> 可以通过<code>docker ps</code>查看连接信息。<br> 这样，nginx-web容器将可以访问redis-test容器中的信息。  </p>\n<p> Docker在两个容器之间建立起了一个安全隧道，而且不用映射它们的端口到宿主主机上。启动redis-test的时候，采用大写<code>-P</code>，从而避免了暴露数据库端口到外部网络上。  </p>\n"},{"title":"docker学习-第五课：数据管理","date":"2018-07-19T08:25:30.000Z","_content":"\n本文介绍docker中数据的管理，持久化。在docker中需要持久化应用程序产生的数据，或者需要多个容器之间共享数据。在容器中管理数据主要有两种方式： \n\n- 数据卷（Data volumes）\n- 数据卷容器（Data volumes containers） \n\n在新版本中，推荐使用`docker volume`子命令来管理`Docker`数据卷。   \n\n## 数据卷\n\n数据卷是一个特殊的目录，它将主机目录直接映射到容器，可供一个或者多个容器使用。它绕过`UFS`可以提供很多特性。 \n\n- 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。\n- 数据卷可以在多个容器之中共享和重用。 \n- 对数据卷的修改会立马生效。\n- 对数据卷的更新不会影响镜像。\n- 数据卷默认会一直存在，即使容器被删除。 \n\n_注_ : 使用docker中的数据卷，类似于系统使用`mount`挂载一个文件系统。 \n\n### 创建数据卷\n\n1. 使用`-v`创建一个数据卷挂载到容器中\n\n`docker run --name nginx-data -v /mydir nginx`\n\n执行如下命令即可查看容器构造的详情  \n`docker inspect 容器ID`  \n\n注： 也可以在`Dockerfile`中添加一个或者多个卷到由该镜像创建的任何容器中。\n\n### 删除数据卷\n\n数据卷是设计来做持久化的，它的生命周期独立于容器，Docker不会在容器删除后删除数据卷。所以，要手动明确删除某个数据卷。\n\n删除容器的时候同时想删除数据卷可以使用下面命令：\n\n    docker rm -v 容器ID\n    \n### 挂载宿主机目录作为数据卷\n\n同样，使用`-v`可以将宿主机目录挂载到容器中，如下：\n\n    docker run --name nginx-data2 -v /host-dir:/container-dir nginx\n\n上面命令，会将宿主机目录`/host-dir`挂载到容器的`/container-dir`目录。 \n\n- 本地目录的路径必须是绝对路径。  \n- 如果宿主机路径不存在，Docker会自动创建。 \n\n_注意_ : Dockerfile不支持这种形式。因为Dockerfile是用来传播和分享的，不同操作系统，路径表示不一样，所以目前暂时不支持。 \n\nDocker挂载的数据卷默认权限是可读写，如果要改为只读，可以通过`：ro`指定。 \n\n    docker run --name nginx-data2 -v /host-dir:/container-dir：ro nginx\n\n加了`：ro`之后，就挂载伟只读了。 这样，在容器就只能读取`/container-dir`目录中的文件，不能写。\n\n### 查看数据卷具体信息\n\n可以通过下面命令查看：\n\n    docker inspect web\n    \n从输出内容中可以看到数据卷相关的部分。 \n\n## 数据卷容器     \n\n如果有数据需要不断更新并在多个容器之间共享，那么你就需要建立数据卷容器了。\n\n数据卷容器首先是个正常的容器，专门提供数据卷供其它容器挂载的。  \n\n创建数据卷容器： \n    \n    docker run --name nginx-volume -v /data nginx\n    \n然后，就可以在其它容器中使用`-volumes-from`来挂载nginx-volume容器中的数据卷。   \n\n    docker run --name v1 --volumes-from nginx-volume nginx\n    docker run --name v2 --volumes-from nginx-volume nginx\n\n这样：  \n\n- v1、v2便可以共享nginx-volume容器中的数据卷。  \n- 即使nginx-volume容器停止，也不会有任何影响。   \n\n也可以使用超过一个的`-volumes-from`参数来指定从多个容器挂载不同的数据卷。也可以从其它挂载了数据卷的容器来级联挂载数据卷。 \n\n     docker run --name v3 --volumes-from v1 nginx\n     \n## 利用数据卷容器来备份、恢复、迁移数据卷 \n\n### 备份\n\n首先创建一个挂载容器卷`nginx-volume`的容器，并从主机挂载当前目录到容器`/backup`目录。如下： \n\n    docker run --name data-backup --volume-from nginx-volume -v  $(pwd):/backup centos/7 tar cvf /backup/backup.tar /nginx-volume\n    \n容器启动后，使用命令`tar`将容器卷`nginx-volume`备份为容器中/backup/backup.tar文件，也就主机当前目录下的名为backup.tar的文件。 \n\n### 恢复\n\n如果要恢复数据到一个容器，首先创建一个挂载空数据卷的容器`nginx-volume2`。 \n\n    docker run -v /dbdata --name nginx-volume2 ngxin /bin/bash\n    \n然后创建另一个容器,挂载nginx-volume2容器卷中的数据卷,并使用`untar`解压备份文件到挂载的容器卷中。 \n\n    docker run --vulume-from /nginx-volume2 -v $(pwd):/backup nginx untar xvf /backup/backup.tar\n    \n为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看  \n\n    dcoker run --volume-from nginx-volume2 nginx /bin/ls /dbdata    \n","source":"_posts/docker-lesson5-dv.md","raw":"---\ntitle: docker学习-第五课：数据管理\ndate: 2018-07-19 16:25:30\ncategories: docker\ntags: docker数据管理\n---\n\n本文介绍docker中数据的管理，持久化。在docker中需要持久化应用程序产生的数据，或者需要多个容器之间共享数据。在容器中管理数据主要有两种方式： \n\n- 数据卷（Data volumes）\n- 数据卷容器（Data volumes containers） \n\n在新版本中，推荐使用`docker volume`子命令来管理`Docker`数据卷。   \n\n## 数据卷\n\n数据卷是一个特殊的目录，它将主机目录直接映射到容器，可供一个或者多个容器使用。它绕过`UFS`可以提供很多特性。 \n\n- 数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。\n- 数据卷可以在多个容器之中共享和重用。 \n- 对数据卷的修改会立马生效。\n- 对数据卷的更新不会影响镜像。\n- 数据卷默认会一直存在，即使容器被删除。 \n\n_注_ : 使用docker中的数据卷，类似于系统使用`mount`挂载一个文件系统。 \n\n### 创建数据卷\n\n1. 使用`-v`创建一个数据卷挂载到容器中\n\n`docker run --name nginx-data -v /mydir nginx`\n\n执行如下命令即可查看容器构造的详情  \n`docker inspect 容器ID`  \n\n注： 也可以在`Dockerfile`中添加一个或者多个卷到由该镜像创建的任何容器中。\n\n### 删除数据卷\n\n数据卷是设计来做持久化的，它的生命周期独立于容器，Docker不会在容器删除后删除数据卷。所以，要手动明确删除某个数据卷。\n\n删除容器的时候同时想删除数据卷可以使用下面命令：\n\n    docker rm -v 容器ID\n    \n### 挂载宿主机目录作为数据卷\n\n同样，使用`-v`可以将宿主机目录挂载到容器中，如下：\n\n    docker run --name nginx-data2 -v /host-dir:/container-dir nginx\n\n上面命令，会将宿主机目录`/host-dir`挂载到容器的`/container-dir`目录。 \n\n- 本地目录的路径必须是绝对路径。  \n- 如果宿主机路径不存在，Docker会自动创建。 \n\n_注意_ : Dockerfile不支持这种形式。因为Dockerfile是用来传播和分享的，不同操作系统，路径表示不一样，所以目前暂时不支持。 \n\nDocker挂载的数据卷默认权限是可读写，如果要改为只读，可以通过`：ro`指定。 \n\n    docker run --name nginx-data2 -v /host-dir:/container-dir：ro nginx\n\n加了`：ro`之后，就挂载伟只读了。 这样，在容器就只能读取`/container-dir`目录中的文件，不能写。\n\n### 查看数据卷具体信息\n\n可以通过下面命令查看：\n\n    docker inspect web\n    \n从输出内容中可以看到数据卷相关的部分。 \n\n## 数据卷容器     \n\n如果有数据需要不断更新并在多个容器之间共享，那么你就需要建立数据卷容器了。\n\n数据卷容器首先是个正常的容器，专门提供数据卷供其它容器挂载的。  \n\n创建数据卷容器： \n    \n    docker run --name nginx-volume -v /data nginx\n    \n然后，就可以在其它容器中使用`-volumes-from`来挂载nginx-volume容器中的数据卷。   \n\n    docker run --name v1 --volumes-from nginx-volume nginx\n    docker run --name v2 --volumes-from nginx-volume nginx\n\n这样：  \n\n- v1、v2便可以共享nginx-volume容器中的数据卷。  \n- 即使nginx-volume容器停止，也不会有任何影响。   \n\n也可以使用超过一个的`-volumes-from`参数来指定从多个容器挂载不同的数据卷。也可以从其它挂载了数据卷的容器来级联挂载数据卷。 \n\n     docker run --name v3 --volumes-from v1 nginx\n     \n## 利用数据卷容器来备份、恢复、迁移数据卷 \n\n### 备份\n\n首先创建一个挂载容器卷`nginx-volume`的容器，并从主机挂载当前目录到容器`/backup`目录。如下： \n\n    docker run --name data-backup --volume-from nginx-volume -v  $(pwd):/backup centos/7 tar cvf /backup/backup.tar /nginx-volume\n    \n容器启动后，使用命令`tar`将容器卷`nginx-volume`备份为容器中/backup/backup.tar文件，也就主机当前目录下的名为backup.tar的文件。 \n\n### 恢复\n\n如果要恢复数据到一个容器，首先创建一个挂载空数据卷的容器`nginx-volume2`。 \n\n    docker run -v /dbdata --name nginx-volume2 ngxin /bin/bash\n    \n然后创建另一个容器,挂载nginx-volume2容器卷中的数据卷,并使用`untar`解压备份文件到挂载的容器卷中。 \n\n    docker run --vulume-from /nginx-volume2 -v $(pwd):/backup nginx untar xvf /backup/backup.tar\n    \n为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看  \n\n    dcoker run --volume-from nginx-volume2 nginx /bin/ls /dbdata    \n","slug":"docker-lesson5-dv","published":1,"updated":"2018-11-09T01:20:30.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38220017qcrglxzgtp4d","content":"<p>本文介绍docker中数据的管理，持久化。在docker中需要持久化应用程序产生的数据，或者需要多个容器之间共享数据。在容器中管理数据主要有两种方式： </p>\n<ul>\n<li>数据卷（Data volumes）</li>\n<li>数据卷容器（Data volumes containers） </li>\n</ul>\n<p>在新版本中，推荐使用<code>docker volume</code>子命令来管理<code>Docker</code>数据卷。   </p>\n<h2 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h2><p>数据卷是一个特殊的目录，它将主机目录直接映射到容器，可供一个或者多个容器使用。它绕过<code>UFS</code>可以提供很多特性。 </p>\n<ul>\n<li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。</li>\n<li>数据卷可以在多个容器之中共享和重用。 </li>\n<li>对数据卷的修改会立马生效。</li>\n<li>对数据卷的更新不会影响镜像。</li>\n<li>数据卷默认会一直存在，即使容器被删除。 </li>\n</ul>\n<p>_注_ : 使用docker中的数据卷，类似于系统使用<code>mount</code>挂载一个文件系统。 </p>\n<h3 id=\"创建数据卷\"><a href=\"#创建数据卷\" class=\"headerlink\" title=\"创建数据卷\"></a>创建数据卷</h3><ol>\n<li>使用<code>-v</code>创建一个数据卷挂载到容器中</li>\n</ol>\n<p><code>docker run --name nginx-data -v /mydir nginx</code></p>\n<p>执行如下命令即可查看容器构造的详情<br><code>docker inspect 容器ID</code>  </p>\n<p>注： 也可以在<code>Dockerfile</code>中添加一个或者多个卷到由该镜像创建的任何容器中。</p>\n<h3 id=\"删除数据卷\"><a href=\"#删除数据卷\" class=\"headerlink\" title=\"删除数据卷\"></a>删除数据卷</h3><p>数据卷是设计来做持久化的，它的生命周期独立于容器，Docker不会在容器删除后删除数据卷。所以，要手动明确删除某个数据卷。</p>\n<p>删除容器的时候同时想删除数据卷可以使用下面命令：</p>\n<pre><code>docker rm -v 容器ID\n</code></pre><h3 id=\"挂载宿主机目录作为数据卷\"><a href=\"#挂载宿主机目录作为数据卷\" class=\"headerlink\" title=\"挂载宿主机目录作为数据卷\"></a>挂载宿主机目录作为数据卷</h3><p>同样，使用<code>-v</code>可以将宿主机目录挂载到容器中，如下：</p>\n<pre><code>docker run --name nginx-data2 -v /host-dir:/container-dir nginx\n</code></pre><p>上面命令，会将宿主机目录<code>/host-dir</code>挂载到容器的<code>/container-dir</code>目录。 </p>\n<ul>\n<li>本地目录的路径必须是绝对路径。  </li>\n<li>如果宿主机路径不存在，Docker会自动创建。 </li>\n</ul>\n<p>_注意_ : Dockerfile不支持这种形式。因为Dockerfile是用来传播和分享的，不同操作系统，路径表示不一样，所以目前暂时不支持。 </p>\n<p>Docker挂载的数据卷默认权限是可读写，如果要改为只读，可以通过<code>：ro</code>指定。 </p>\n<pre><code>docker run --name nginx-data2 -v /host-dir:/container-dir：ro nginx\n</code></pre><p>加了<code>：ro</code>之后，就挂载伟只读了。 这样，在容器就只能读取<code>/container-dir</code>目录中的文件，不能写。</p>\n<h3 id=\"查看数据卷具体信息\"><a href=\"#查看数据卷具体信息\" class=\"headerlink\" title=\"查看数据卷具体信息\"></a>查看数据卷具体信息</h3><p>可以通过下面命令查看：</p>\n<pre><code>docker inspect web\n</code></pre><p>从输出内容中可以看到数据卷相关的部分。 </p>\n<h2 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h2><p>如果有数据需要不断更新并在多个容器之间共享，那么你就需要建立数据卷容器了。</p>\n<p>数据卷容器首先是个正常的容器，专门提供数据卷供其它容器挂载的。  </p>\n<p>创建数据卷容器： </p>\n<pre><code>docker run --name nginx-volume -v /data nginx\n</code></pre><p>然后，就可以在其它容器中使用<code>-volumes-from</code>来挂载nginx-volume容器中的数据卷。   </p>\n<pre><code>docker run --name v1 --volumes-from nginx-volume nginx\ndocker run --name v2 --volumes-from nginx-volume nginx\n</code></pre><p>这样：  </p>\n<ul>\n<li>v1、v2便可以共享nginx-volume容器中的数据卷。  </li>\n<li>即使nginx-volume容器停止，也不会有任何影响。   </li>\n</ul>\n<p>也可以使用超过一个的<code>-volumes-from</code>参数来指定从多个容器挂载不同的数据卷。也可以从其它挂载了数据卷的容器来级联挂载数据卷。 </p>\n<pre><code>docker run --name v3 --volumes-from v1 nginx\n</code></pre><h2 id=\"利用数据卷容器来备份、恢复、迁移数据卷\"><a href=\"#利用数据卷容器来备份、恢复、迁移数据卷\" class=\"headerlink\" title=\"利用数据卷容器来备份、恢复、迁移数据卷\"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>首先创建一个挂载容器卷<code>nginx-volume</code>的容器，并从主机挂载当前目录到容器<code>/backup</code>目录。如下： </p>\n<pre><code>docker run --name data-backup --volume-from nginx-volume -v  $(pwd):/backup centos/7 tar cvf /backup/backup.tar /nginx-volume\n</code></pre><p>容器启动后，使用命令<code>tar</code>将容器卷<code>nginx-volume</code>备份为容器中/backup/backup.tar文件，也就主机当前目录下的名为backup.tar的文件。 </p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个挂载空数据卷的容器<code>nginx-volume2</code>。 </p>\n<pre><code>docker run -v /dbdata --name nginx-volume2 ngxin /bin/bash\n</code></pre><p>然后创建另一个容器,挂载nginx-volume2容器卷中的数据卷,并使用<code>untar</code>解压备份文件到挂载的容器卷中。 </p>\n<pre><code>docker run --vulume-from /nginx-volume2 -v $(pwd):/backup nginx untar xvf /backup/backup.tar\n</code></pre><p>为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看  </p>\n<pre><code>dcoker run --volume-from nginx-volume2 nginx /bin/ls /dbdata    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍docker中数据的管理，持久化。在docker中需要持久化应用程序产生的数据，或者需要多个容器之间共享数据。在容器中管理数据主要有两种方式： </p>\n<ul>\n<li>数据卷（Data volumes）</li>\n<li>数据卷容器（Data volumes containers） </li>\n</ul>\n<p>在新版本中，推荐使用<code>docker volume</code>子命令来管理<code>Docker</code>数据卷。   </p>\n<h2 id=\"数据卷\"><a href=\"#数据卷\" class=\"headerlink\" title=\"数据卷\"></a>数据卷</h2><p>数据卷是一个特殊的目录，它将主机目录直接映射到容器，可供一个或者多个容器使用。它绕过<code>UFS</code>可以提供很多特性。 </p>\n<ul>\n<li>数据卷在容器启动时初始化，如果容器使用的镜像在挂载点包含了数据，这些数据会拷贝到新初始化的数据卷中。</li>\n<li>数据卷可以在多个容器之中共享和重用。 </li>\n<li>对数据卷的修改会立马生效。</li>\n<li>对数据卷的更新不会影响镜像。</li>\n<li>数据卷默认会一直存在，即使容器被删除。 </li>\n</ul>\n<p>_注_ : 使用docker中的数据卷，类似于系统使用<code>mount</code>挂载一个文件系统。 </p>\n<h3 id=\"创建数据卷\"><a href=\"#创建数据卷\" class=\"headerlink\" title=\"创建数据卷\"></a>创建数据卷</h3><ol>\n<li>使用<code>-v</code>创建一个数据卷挂载到容器中</li>\n</ol>\n<p><code>docker run --name nginx-data -v /mydir nginx</code></p>\n<p>执行如下命令即可查看容器构造的详情<br><code>docker inspect 容器ID</code>  </p>\n<p>注： 也可以在<code>Dockerfile</code>中添加一个或者多个卷到由该镜像创建的任何容器中。</p>\n<h3 id=\"删除数据卷\"><a href=\"#删除数据卷\" class=\"headerlink\" title=\"删除数据卷\"></a>删除数据卷</h3><p>数据卷是设计来做持久化的，它的生命周期独立于容器，Docker不会在容器删除后删除数据卷。所以，要手动明确删除某个数据卷。</p>\n<p>删除容器的时候同时想删除数据卷可以使用下面命令：</p>\n<pre><code>docker rm -v 容器ID\n</code></pre><h3 id=\"挂载宿主机目录作为数据卷\"><a href=\"#挂载宿主机目录作为数据卷\" class=\"headerlink\" title=\"挂载宿主机目录作为数据卷\"></a>挂载宿主机目录作为数据卷</h3><p>同样，使用<code>-v</code>可以将宿主机目录挂载到容器中，如下：</p>\n<pre><code>docker run --name nginx-data2 -v /host-dir:/container-dir nginx\n</code></pre><p>上面命令，会将宿主机目录<code>/host-dir</code>挂载到容器的<code>/container-dir</code>目录。 </p>\n<ul>\n<li>本地目录的路径必须是绝对路径。  </li>\n<li>如果宿主机路径不存在，Docker会自动创建。 </li>\n</ul>\n<p>_注意_ : Dockerfile不支持这种形式。因为Dockerfile是用来传播和分享的，不同操作系统，路径表示不一样，所以目前暂时不支持。 </p>\n<p>Docker挂载的数据卷默认权限是可读写，如果要改为只读，可以通过<code>：ro</code>指定。 </p>\n<pre><code>docker run --name nginx-data2 -v /host-dir:/container-dir：ro nginx\n</code></pre><p>加了<code>：ro</code>之后，就挂载伟只读了。 这样，在容器就只能读取<code>/container-dir</code>目录中的文件，不能写。</p>\n<h3 id=\"查看数据卷具体信息\"><a href=\"#查看数据卷具体信息\" class=\"headerlink\" title=\"查看数据卷具体信息\"></a>查看数据卷具体信息</h3><p>可以通过下面命令查看：</p>\n<pre><code>docker inspect web\n</code></pre><p>从输出内容中可以看到数据卷相关的部分。 </p>\n<h2 id=\"数据卷容器\"><a href=\"#数据卷容器\" class=\"headerlink\" title=\"数据卷容器\"></a>数据卷容器</h2><p>如果有数据需要不断更新并在多个容器之间共享，那么你就需要建立数据卷容器了。</p>\n<p>数据卷容器首先是个正常的容器，专门提供数据卷供其它容器挂载的。  </p>\n<p>创建数据卷容器： </p>\n<pre><code>docker run --name nginx-volume -v /data nginx\n</code></pre><p>然后，就可以在其它容器中使用<code>-volumes-from</code>来挂载nginx-volume容器中的数据卷。   </p>\n<pre><code>docker run --name v1 --volumes-from nginx-volume nginx\ndocker run --name v2 --volumes-from nginx-volume nginx\n</code></pre><p>这样：  </p>\n<ul>\n<li>v1、v2便可以共享nginx-volume容器中的数据卷。  </li>\n<li>即使nginx-volume容器停止，也不会有任何影响。   </li>\n</ul>\n<p>也可以使用超过一个的<code>-volumes-from</code>参数来指定从多个容器挂载不同的数据卷。也可以从其它挂载了数据卷的容器来级联挂载数据卷。 </p>\n<pre><code>docker run --name v3 --volumes-from v1 nginx\n</code></pre><h2 id=\"利用数据卷容器来备份、恢复、迁移数据卷\"><a href=\"#利用数据卷容器来备份、恢复、迁移数据卷\" class=\"headerlink\" title=\"利用数据卷容器来备份、恢复、迁移数据卷\"></a>利用数据卷容器来备份、恢复、迁移数据卷</h2><h3 id=\"备份\"><a href=\"#备份\" class=\"headerlink\" title=\"备份\"></a>备份</h3><p>首先创建一个挂载容器卷<code>nginx-volume</code>的容器，并从主机挂载当前目录到容器<code>/backup</code>目录。如下： </p>\n<pre><code>docker run --name data-backup --volume-from nginx-volume -v  $(pwd):/backup centos/7 tar cvf /backup/backup.tar /nginx-volume\n</code></pre><p>容器启动后，使用命令<code>tar</code>将容器卷<code>nginx-volume</code>备份为容器中/backup/backup.tar文件，也就主机当前目录下的名为backup.tar的文件。 </p>\n<h3 id=\"恢复\"><a href=\"#恢复\" class=\"headerlink\" title=\"恢复\"></a>恢复</h3><p>如果要恢复数据到一个容器，首先创建一个挂载空数据卷的容器<code>nginx-volume2</code>。 </p>\n<pre><code>docker run -v /dbdata --name nginx-volume2 ngxin /bin/bash\n</code></pre><p>然后创建另一个容器,挂载nginx-volume2容器卷中的数据卷,并使用<code>untar</code>解压备份文件到挂载的容器卷中。 </p>\n<pre><code>docker run --vulume-from /nginx-volume2 -v $(pwd):/backup nginx untar xvf /backup/backup.tar\n</code></pre><p>为了查看/验证恢复的数据,可以再启动一个容器挂载同样的容器卷来查看  </p>\n<pre><code>dcoker run --volume-from nginx-volume2 nginx /bin/ls /dbdata    \n</code></pre>"},{"title":"docker学习-第七课：三剑客之Docker Compose","date":"2018-08-01T12:33:32.000Z","_content":"\n在一个例如web应用中，除了应用本身之外，其还关联用到数据库等……，如果都采用docker化的话，那么就需要启动所有相关的docker容器。那么，有没有可能，按照某种顺序，对所有相关联的docker容器进行编排，然后按照一定的先后顺序依次启动。是的，Docker Compose就是这么一个工具，容器编排工具。定义和运行多个容器的应用。 \n\nCompose中有两个重要的概念：\n\n- 服务（Service）：一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。\n- 项目(project)：由一组关联的应用容器组成的一个完整业务单元,在\tdocker-compose.yml文件中定义。\n\nCompose\t的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n    ","source":"_posts/docker-lesson7-compose.md","raw":"---\ntitle: docker学习-第七课：三剑客之Docker Compose\ndate: 2018-08-01 20:33:32\ncategories: docker\ntags: docker-compose\n---\n\n在一个例如web应用中，除了应用本身之外，其还关联用到数据库等……，如果都采用docker化的话，那么就需要启动所有相关的docker容器。那么，有没有可能，按照某种顺序，对所有相关联的docker容器进行编排，然后按照一定的先后顺序依次启动。是的，Docker Compose就是这么一个工具，容器编排工具。定义和运行多个容器的应用。 \n\nCompose中有两个重要的概念：\n\n- 服务（Service）：一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。\n- 项目(project)：由一组关联的应用容器组成的一个完整业务单元,在\tdocker-compose.yml文件中定义。\n\nCompose\t的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。\n\n    ","slug":"docker-lesson7-compose","published":1,"updated":"2018-11-15T06:22:59.792Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m3824001bqcrg6456hvgm","content":"<p>在一个例如web应用中，除了应用本身之外，其还关联用到数据库等……，如果都采用docker化的话，那么就需要启动所有相关的docker容器。那么，有没有可能，按照某种顺序，对所有相关联的docker容器进行编排，然后按照一定的先后顺序依次启动。是的，Docker Compose就是这么一个工具，容器编排工具。定义和运行多个容器的应用。 </p>\n<p>Compose中有两个重要的概念：</p>\n<ul>\n<li>服务（Service）：一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目(project)：由一组关联的应用容器组成的一个完整业务单元,在    docker-compose.yml文件中定义。</li>\n</ul>\n<p>Compose    的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一个例如web应用中，除了应用本身之外，其还关联用到数据库等……，如果都采用docker化的话，那么就需要启动所有相关的docker容器。那么，有没有可能，按照某种顺序，对所有相关联的docker容器进行编排，然后按照一定的先后顺序依次启动。是的，Docker Compose就是这么一个工具，容器编排工具。定义和运行多个容器的应用。 </p>\n<p>Compose中有两个重要的概念：</p>\n<ul>\n<li>服务（Service）：一个应用的容器,实际上可以包括若干运行相同镜像的容器实例。</li>\n<li>项目(project)：由一组关联的应用容器组成的一个完整业务单元,在    docker-compose.yml文件中定义。</li>\n</ul>\n<p>Compose    的默认管理对象是项目,通过子命令对项目中的一组容器进行便捷地生命周期管理。</p>\n"},{"title":"git分支管理","date":"2018-06-23T07:29:33.000Z","_content":"\n在项目开发过程中，为了更好的开发，管理上需要对代码做版本管理。一般情况下，在开发之前就理应设定开发版本，然后开发人员在对应版本上编写代码，管理者再在某个时刻把分支`branch`代码合并回主分支。在最终稳定一个版本后，再打`tag`做版本永久保存。\n\n首先，要当前目录为`git`仓库。`git`仓库拉取下来默认是`master`分支。\n\n## 创建本地分支\n\n1. 查看有哪些分支\n\n    `git branch`\n\n2. 创建一个分支\n\n    `git branch name1` `name1`为分支名称。不能和`tag`的相同\n    \n3. 切换到分支\n\n    `git checkout name1`\n    \n实际上，2和3步骤也可以一步到位：`git checkout -b name`。创建并切换到分支\n\n下面，就可以在该分支上进行文件操作了。\n\n_注意_:如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。\n\n## 提交分支到服务器\n\n`git push origin name1`\n\n说明：提交分支到服务器后，在本地分支进行文件变更后，可以执行上面同样命令，将变更信息更新到服务器上的该分支。\n\n## 将分支变更的内容合并到master分支\n\n1. 切换到master分支： `git checkout master`\n\n2. 合并`name1`分支到当前`master`分支： `git merge name1`\n\n_注意_: 这个时候合并到`master`分支上的内容还没提交到服务器的，需要`push`提交。\n\n## 删除分支\n\n1. 删除本地分支：`git branch -d name1`\n2. 删除服务器上的分支： `git push origin :name   (分支名前的冒号代表删除)`  \n\n## clone分支\n\n`git`仓库拉取下来，默认会把所有内容`clone`下来。 \n但是默认只创建`master`分支，需要执行`git branch -r`才能看到所有分支名字。  \n想把其它分支拉取下来，执行： `git checkout 分支名`。这样就把远程的分支拉取下来了。  \n再执行`git branch`，就能看到本地所有的分支了。然后可以切换分支编辑。","source":"_posts/git-branch.md","raw":"---\ntitle: git分支管理\ndate: 2018-06-23 15:29:33\ncategories: git\ntags: git分支、github分支\n---\n\n在项目开发过程中，为了更好的开发，管理上需要对代码做版本管理。一般情况下，在开发之前就理应设定开发版本，然后开发人员在对应版本上编写代码，管理者再在某个时刻把分支`branch`代码合并回主分支。在最终稳定一个版本后，再打`tag`做版本永久保存。\n\n首先，要当前目录为`git`仓库。`git`仓库拉取下来默认是`master`分支。\n\n## 创建本地分支\n\n1. 查看有哪些分支\n\n    `git branch`\n\n2. 创建一个分支\n\n    `git branch name1` `name1`为分支名称。不能和`tag`的相同\n    \n3. 切换到分支\n\n    `git checkout name1`\n    \n实际上，2和3步骤也可以一步到位：`git checkout -b name`。创建并切换到分支\n\n下面，就可以在该分支上进行文件操作了。\n\n_注意_:如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。\n\n## 提交分支到服务器\n\n`git push origin name1`\n\n说明：提交分支到服务器后，在本地分支进行文件变更后，可以执行上面同样命令，将变更信息更新到服务器上的该分支。\n\n## 将分支变更的内容合并到master分支\n\n1. 切换到master分支： `git checkout master`\n\n2. 合并`name1`分支到当前`master`分支： `git merge name1`\n\n_注意_: 这个时候合并到`master`分支上的内容还没提交到服务器的，需要`push`提交。\n\n## 删除分支\n\n1. 删除本地分支：`git branch -d name1`\n2. 删除服务器上的分支： `git push origin :name   (分支名前的冒号代表删除)`  \n\n## clone分支\n\n`git`仓库拉取下来，默认会把所有内容`clone`下来。 \n但是默认只创建`master`分支，需要执行`git branch -r`才能看到所有分支名字。  \n想把其它分支拉取下来，执行： `git checkout 分支名`。这样就把远程的分支拉取下来了。  \n再执行`git branch`，就能看到本地所有的分支了。然后可以切换分支编辑。","slug":"git-branch","published":1,"updated":"2018-11-09T01:20:30.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m3825001dqcrgsdir0jko","content":"<p>在项目开发过程中，为了更好的开发，管理上需要对代码做版本管理。一般情况下，在开发之前就理应设定开发版本，然后开发人员在对应版本上编写代码，管理者再在某个时刻把分支<code>branch</code>代码合并回主分支。在最终稳定一个版本后，再打<code>tag</code>做版本永久保存。</p>\n<p>首先，要当前目录为<code>git</code>仓库。<code>git</code>仓库拉取下来默认是<code>master</code>分支。</p>\n<h2 id=\"创建本地分支\"><a href=\"#创建本地分支\" class=\"headerlink\" title=\"创建本地分支\"></a>创建本地分支</h2><ol>\n<li><p>查看有哪些分支</p>\n<p> <code>git branch</code></p>\n</li>\n<li><p>创建一个分支</p>\n<p> <code>git branch name1</code> <code>name1</code>为分支名称。不能和<code>tag</code>的相同</p>\n</li>\n<li><p>切换到分支</p>\n<p> <code>git checkout name1</code></p>\n</li>\n</ol>\n<p>实际上，2和3步骤也可以一步到位：<code>git checkout -b name</code>。创建并切换到分支</p>\n<p>下面，就可以在该分支上进行文件操作了。</p>\n<p>_注意_:如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。</p>\n<h2 id=\"提交分支到服务器\"><a href=\"#提交分支到服务器\" class=\"headerlink\" title=\"提交分支到服务器\"></a>提交分支到服务器</h2><p><code>git push origin name1</code></p>\n<p>说明：提交分支到服务器后，在本地分支进行文件变更后，可以执行上面同样命令，将变更信息更新到服务器上的该分支。</p>\n<h2 id=\"将分支变更的内容合并到master分支\"><a href=\"#将分支变更的内容合并到master分支\" class=\"headerlink\" title=\"将分支变更的内容合并到master分支\"></a>将分支变更的内容合并到master分支</h2><ol>\n<li><p>切换到master分支： <code>git checkout master</code></p>\n</li>\n<li><p>合并<code>name1</code>分支到当前<code>master</code>分支： <code>git merge name1</code></p>\n</li>\n</ol>\n<p>_注意_: 这个时候合并到<code>master</code>分支上的内容还没提交到服务器的，需要<code>push</code>提交。</p>\n<h2 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h2><ol>\n<li>删除本地分支：<code>git branch -d name1</code></li>\n<li>删除服务器上的分支： <code>git push origin :name   (分支名前的冒号代表删除)</code>  </li>\n</ol>\n<h2 id=\"clone分支\"><a href=\"#clone分支\" class=\"headerlink\" title=\"clone分支\"></a>clone分支</h2><p><code>git</code>仓库拉取下来，默认会把所有内容<code>clone</code>下来。<br>但是默认只创建<code>master</code>分支，需要执行<code>git branch -r</code>才能看到所有分支名字。<br>想把其它分支拉取下来，执行： <code>git checkout 分支名</code>。这样就把远程的分支拉取下来了。<br>再执行<code>git branch</code>，就能看到本地所有的分支了。然后可以切换分支编辑。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在项目开发过程中，为了更好的开发，管理上需要对代码做版本管理。一般情况下，在开发之前就理应设定开发版本，然后开发人员在对应版本上编写代码，管理者再在某个时刻把分支<code>branch</code>代码合并回主分支。在最终稳定一个版本后，再打<code>tag</code>做版本永久保存。</p>\n<p>首先，要当前目录为<code>git</code>仓库。<code>git</code>仓库拉取下来默认是<code>master</code>分支。</p>\n<h2 id=\"创建本地分支\"><a href=\"#创建本地分支\" class=\"headerlink\" title=\"创建本地分支\"></a>创建本地分支</h2><ol>\n<li><p>查看有哪些分支</p>\n<p> <code>git branch</code></p>\n</li>\n<li><p>创建一个分支</p>\n<p> <code>git branch name1</code> <code>name1</code>为分支名称。不能和<code>tag</code>的相同</p>\n</li>\n<li><p>切换到分支</p>\n<p> <code>git checkout name1</code></p>\n</li>\n</ol>\n<p>实际上，2和3步骤也可以一步到位：<code>git checkout -b name</code>。创建并切换到分支</p>\n<p>下面，就可以在该分支上进行文件操作了。</p>\n<p>_注意_:如果用 git checkout master切换到主分支，在当name分支下进行的文件变更的内容无法看到。当切回name分支后，又可以看到了。</p>\n<h2 id=\"提交分支到服务器\"><a href=\"#提交分支到服务器\" class=\"headerlink\" title=\"提交分支到服务器\"></a>提交分支到服务器</h2><p><code>git push origin name1</code></p>\n<p>说明：提交分支到服务器后，在本地分支进行文件变更后，可以执行上面同样命令，将变更信息更新到服务器上的该分支。</p>\n<h2 id=\"将分支变更的内容合并到master分支\"><a href=\"#将分支变更的内容合并到master分支\" class=\"headerlink\" title=\"将分支变更的内容合并到master分支\"></a>将分支变更的内容合并到master分支</h2><ol>\n<li><p>切换到master分支： <code>git checkout master</code></p>\n</li>\n<li><p>合并<code>name1</code>分支到当前<code>master</code>分支： <code>git merge name1</code></p>\n</li>\n</ol>\n<p>_注意_: 这个时候合并到<code>master</code>分支上的内容还没提交到服务器的，需要<code>push</code>提交。</p>\n<h2 id=\"删除分支\"><a href=\"#删除分支\" class=\"headerlink\" title=\"删除分支\"></a>删除分支</h2><ol>\n<li>删除本地分支：<code>git branch -d name1</code></li>\n<li>删除服务器上的分支： <code>git push origin :name   (分支名前的冒号代表删除)</code>  </li>\n</ol>\n<h2 id=\"clone分支\"><a href=\"#clone分支\" class=\"headerlink\" title=\"clone分支\"></a>clone分支</h2><p><code>git</code>仓库拉取下来，默认会把所有内容<code>clone</code>下来。<br>但是默认只创建<code>master</code>分支，需要执行<code>git branch -r</code>才能看到所有分支名字。<br>想把其它分支拉取下来，执行： <code>git checkout 分支名</code>。这样就把远程的分支拉取下来了。<br>再执行<code>git branch</code>，就能看到本地所有的分支了。然后可以切换分支编辑。</p>\n"},{"title":"fastdfs-分布式文件系统安装使用","date":"2018-02-01T02:51:36.000Z","_content":"\n本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……\n\n网址：https://github.com/happyfish100/fastdfs\n\n参考：\nhttp://blog.csdn.net/xyang81/article/details/52837974\nhttp://blog.csdn.net/playadota/article/details/78381109\n\n## centos下搭建\n\n### 第一步：安装依赖\n安装fastdfs之前，先要安装相关依赖包libfastcommon。 \n\n下载地址：https://github.com/happyfish100/libfastcommon.git\n\n`git clone https://github.com/happyfish100/libfastcommon.git`\n\n编译安装：\n\n    > cd libfastcommon\n    > ./make.sh\n    > ./make.sh install\n\n### 第二部：安装fastdfs\n下载：https://github.com/happyfish100/fastdfs\n\n- step 2. download FastDFS source package and unpack it, \ntar xzf FastDFS_v5.x.tar.gz\n\n- step 3. enter the FastDFS dir\n\n    `cd FastDFS`\n\n- step 4. execute:\n\n    `./make.sh`\n\n- step 5. make install\n\n    ./make.sh install`\n\n- step 6. edit/modify the config file of tracker and storage\n\n\n    cd /etc/fdfs/\n    cp tracker.conf.sample tracker.conf\n    cp storage.conf.sample storage.conf\n    mkdir -p /server/data/fdfs\n\n首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。\n\nbase_path=/server/data/fdfs/tracker  \n\n启动：\n    \n    #start the tracker server:\n    /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n    #in Linux, you can start fdfs_trackerd as a service:\n    /sbin/service fdfs_trackerd start \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_trackerd `    \n    \n设置tracker服务开启启动：\n    \n\n--------------\n修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。\n\n        # the base path to store data and log files\n        base_path=/server/data/fdfs/storeage\n        # tracker_server can ocur more than once, and tracker_server format is\n        #  \"host:port\", host can be hostname or ip address\n        tracker_server=192.168.1.36:22122\n        # store_path#, based 0, if store_path0 not exists, it's value is base_path\n        # the paths must be exist\n        store_path0=/server/data/fdfs/storeage\n        #store_path1=/home/yuqing/fastdfs2\n        \n启动：\n    \n    #start the storage server:\n    /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n    #in Linux, you can start fdfs_storaged as a service:\n    /sbin/service fdfs_storaged start  \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_storaged `  \n    \n停止:\n\n    `/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n    \n设置storage服务开机启动  \n\n停止：\n\n`/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop`       \n\n……\n\n## 测试\n更改`/etc/fdfs/下client.conf配置文件。\n\n`base_path=~/dev/fastdfs/data/client`   \n`tracker_server=192.168.147` _不能是`localhost`或者`127.0.0.1`_\n\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \n    This is FastDFS client test program v5.08\n    \n    Copyright (C) 2008, Happy Fish / YuQing\n    \n    FastDFS may be copied only under the terms of the GNU General\n    Public License V3, which may be found in the FastDFS source kit.\n    Please visit the FastDFS Home Page http://www.csource.org/ \n    for more detail.\n    \n    [2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n    \n    tracker_query_storage_store_list_without_group: \n    \tserver 1. group_name=, ip_addr=192.168.1.146, port=23000\n    \n    group_name=group1, ip_addr=192.168.1.146, port=23000\n    storage_upload_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    storage_upload_slave_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n    ####\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \n    group1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ cd\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \n    group1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n    \n\n## ubuntu下搭建\n\n验证过，上面过程适用…… \n\n## 集成nginx模块\n\n参考：https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\n\n1.下载`fastdfs-nginx-module`\n\n`git clone https://github.com/happyfish100/fastdfs-nginx-module.git`\n\n注意：安装的FastDFS版本 >= 5.11\n\n2.安装nginx-1.8.1\n\n下载：http://nginx.org/en/download.html\n\n    > ./configure --prefix=~/nginx \\\n     --add-module=/home/mutian/fastdfs-nginx-module/src\n    \n    > make; make install\n    \n3.更改nginx配置，添加一行。\n\n如果文件分组  \n        \n    location ~/group([0-9])/M00 {\n    \n        ngx_fastdfs_module;\n    \n    }\n\n如果没分组\n\n    location /M00 {\n        root /home/mutian/dev/fastdfs/data/storage/data;\n        ngx_fastdfs_module;\n    }\n    \n> 注意：\n A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。\n B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:\n location ~/group([0-9])/M00 {\n     ngx_fastdfs_module;\n }\n    \n    \n4.拷贝fdfs_storage的文件存储软链接\n\n`ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00`          \n\n5.更改配置`mod_fastdfs.conf`\n\n拷贝到相关目录：\n\n    cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n    \n更改内容：\n\n    connect_timeout=10\n    base_path=/tmp\n    tracker_server=ip01:22122\n    storage_server_port=23000\n    group_name=group1\n    url_have_group_name = true\n    store_path0=/home/mutian/dev/fastdfs/data/storage      \n    \n6.复制FastDFS 的部分配置文件到`/etc/fdfs`目录\n\n    mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\n    mutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\n    anti-steal.jpg  http.conf   storage.conf      tracker.conf\n    client.conf     mime.types  storage_ids.conf\n\n    cp http.conf mime.types /etc/fdfs/   \n    \n7.启动nginx\n\n`~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx` \n\n8.测试\n按上面步骤，上传个文件，然后在浏览器打开：\n\nhttp://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png \n\nor \n\nhttp://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png          ","source":"_posts/fastdfs-start.md","raw":"---\ntitle: fastdfs-分布式文件系统安装使用\ndate: 2018-02-01 10:51:36\ncategories: 文件存储系统\ntags: fastdfs-安装使用\n---\n\n本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……\n\n网址：https://github.com/happyfish100/fastdfs\n\n参考：\nhttp://blog.csdn.net/xyang81/article/details/52837974\nhttp://blog.csdn.net/playadota/article/details/78381109\n\n## centos下搭建\n\n### 第一步：安装依赖\n安装fastdfs之前，先要安装相关依赖包libfastcommon。 \n\n下载地址：https://github.com/happyfish100/libfastcommon.git\n\n`git clone https://github.com/happyfish100/libfastcommon.git`\n\n编译安装：\n\n    > cd libfastcommon\n    > ./make.sh\n    > ./make.sh install\n\n### 第二部：安装fastdfs\n下载：https://github.com/happyfish100/fastdfs\n\n- step 2. download FastDFS source package and unpack it, \ntar xzf FastDFS_v5.x.tar.gz\n\n- step 3. enter the FastDFS dir\n\n    `cd FastDFS`\n\n- step 4. execute:\n\n    `./make.sh`\n\n- step 5. make install\n\n    ./make.sh install`\n\n- step 6. edit/modify the config file of tracker and storage\n\n\n    cd /etc/fdfs/\n    cp tracker.conf.sample tracker.conf\n    cp storage.conf.sample storage.conf\n    mkdir -p /server/data/fdfs\n\n首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。\n\nbase_path=/server/data/fdfs/tracker  \n\n启动：\n    \n    #start the tracker server:\n    /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n    #in Linux, you can start fdfs_trackerd as a service:\n    /sbin/service fdfs_trackerd start \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_trackerd `    \n    \n设置tracker服务开启启动：\n    \n\n--------------\n修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。\n\n        # the base path to store data and log files\n        base_path=/server/data/fdfs/storeage\n        # tracker_server can ocur more than once, and tracker_server format is\n        #  \"host:port\", host can be hostname or ip address\n        tracker_server=192.168.1.36:22122\n        # store_path#, based 0, if store_path0 not exists, it's value is base_path\n        # the paths must be exist\n        store_path0=/server/data/fdfs/storeage\n        #store_path1=/home/yuqing/fastdfs2\n        \n启动：\n    \n    #start the storage server:\n    /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n    #in Linux, you can start fdfs_storaged as a service:\n    /sbin/service fdfs_storaged start  \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_storaged `  \n    \n停止:\n\n    `/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n    \n设置storage服务开机启动  \n\n停止：\n\n`/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop`       \n\n……\n\n## 测试\n更改`/etc/fdfs/下client.conf配置文件。\n\n`base_path=~/dev/fastdfs/data/client`   \n`tracker_server=192.168.147` _不能是`localhost`或者`127.0.0.1`_\n\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \n    This is FastDFS client test program v5.08\n    \n    Copyright (C) 2008, Happy Fish / YuQing\n    \n    FastDFS may be copied only under the terms of the GNU General\n    Public License V3, which may be found in the FastDFS source kit.\n    Please visit the FastDFS Home Page http://www.csource.org/ \n    for more detail.\n    \n    [2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n    \n    tracker_query_storage_store_list_without_group: \n    \tserver 1. group_name=, ip_addr=192.168.1.146, port=23000\n    \n    group_name=group1, ip_addr=192.168.1.146, port=23000\n    storage_upload_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    storage_upload_slave_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n    ####\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \n    group1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ cd\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \n    group1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n    \n\n## ubuntu下搭建\n\n验证过，上面过程适用…… \n\n## 集成nginx模块\n\n参考：https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\n\n1.下载`fastdfs-nginx-module`\n\n`git clone https://github.com/happyfish100/fastdfs-nginx-module.git`\n\n注意：安装的FastDFS版本 >= 5.11\n\n2.安装nginx-1.8.1\n\n下载：http://nginx.org/en/download.html\n\n    > ./configure --prefix=~/nginx \\\n     --add-module=/home/mutian/fastdfs-nginx-module/src\n    \n    > make; make install\n    \n3.更改nginx配置，添加一行。\n\n如果文件分组  \n        \n    location ~/group([0-9])/M00 {\n    \n        ngx_fastdfs_module;\n    \n    }\n\n如果没分组\n\n    location /M00 {\n        root /home/mutian/dev/fastdfs/data/storage/data;\n        ngx_fastdfs_module;\n    }\n    \n> 注意：\n A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。\n B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:\n location ~/group([0-9])/M00 {\n     ngx_fastdfs_module;\n }\n    \n    \n4.拷贝fdfs_storage的文件存储软链接\n\n`ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00`          \n\n5.更改配置`mod_fastdfs.conf`\n\n拷贝到相关目录：\n\n    cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n    \n更改内容：\n\n    connect_timeout=10\n    base_path=/tmp\n    tracker_server=ip01:22122\n    storage_server_port=23000\n    group_name=group1\n    url_have_group_name = true\n    store_path0=/home/mutian/dev/fastdfs/data/storage      \n    \n6.复制FastDFS 的部分配置文件到`/etc/fdfs`目录\n\n    mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\n    mutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\n    anti-steal.jpg  http.conf   storage.conf      tracker.conf\n    client.conf     mime.types  storage_ids.conf\n\n    cp http.conf mime.types /etc/fdfs/   \n    \n7.启动nginx\n\n`~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx` \n\n8.测试\n按上面步骤，上传个文件，然后在浏览器打开：\n\nhttp://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png \n\nor \n\nhttp://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png          ","slug":"fastdfs-start","published":1,"updated":"2018-11-09T01:20:30.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m3827001hqcrg2qcy4n0u","content":"<p>本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……</p>\n<p>网址：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xyang81/article/details/52837974\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xyang81/article/details/52837974</a><br><a href=\"http://blog.csdn.net/playadota/article/details/78381109\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/playadota/article/details/78381109</a></p>\n<h2 id=\"centos下搭建\"><a href=\"#centos下搭建\" class=\"headerlink\" title=\"centos下搭建\"></a>centos下搭建</h2><h3 id=\"第一步：安装依赖\"><a href=\"#第一步：安装依赖\" class=\"headerlink\" title=\"第一步：安装依赖\"></a>第一步：安装依赖</h3><p>安装fastdfs之前，先要安装相关依赖包libfastcommon。 </p>\n<p>下载地址：<a href=\"https://github.com/happyfish100/libfastcommon.git\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/libfastcommon.git</a></p>\n<p><code>git clone https://github.com/happyfish100/libfastcommon.git</code></p>\n<p>编译安装：</p>\n<pre><code>&gt; cd libfastcommon\n&gt; ./make.sh\n&gt; ./make.sh install\n</code></pre><h3 id=\"第二部：安装fastdfs\"><a href=\"#第二部：安装fastdfs\" class=\"headerlink\" title=\"第二部：安装fastdfs\"></a>第二部：安装fastdfs</h3><p>下载：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<ul>\n<li><p>step 2. download FastDFS source package and unpack it,<br>tar xzf FastDFS_v5.x.tar.gz</p>\n</li>\n<li><p>step 3. enter the FastDFS dir</p>\n<p>  <code>cd FastDFS</code></p>\n</li>\n<li><p>step 4. execute:</p>\n<p>  <code>./make.sh</code></p>\n</li>\n<li><p>step 5. make install</p>\n<p>  ./make.sh install`</p>\n</li>\n<li><p>step 6. edit/modify the config file of tracker and storage</p>\n</li>\n</ul>\n<pre><code>cd /etc/fdfs/\ncp tracker.conf.sample tracker.conf\ncp storage.conf.sample storage.conf\nmkdir -p /server/data/fdfs\n</code></pre><p>首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。</p>\n<p>base_path=/server/data/fdfs/tracker  </p>\n<p>启动：</p>\n<pre><code>#start the tracker server:\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n#in Linux, you can start fdfs_trackerd as a service:\n/sbin/service fdfs_trackerd start \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_trackerd</code>    </p>\n<p>设置tracker服务开启启动：</p>\n<hr>\n<p>修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。</p>\n<pre><code># the base path to store data and log files\nbase_path=/server/data/fdfs/storeage\n# tracker_server can ocur more than once, and tracker_server format is\n#  &quot;host:port&quot;, host can be hostname or ip address\ntracker_server=192.168.1.36:22122\n# store_path#, based 0, if store_path0 not exists, it&apos;s value is base_path\n# the paths must be exist\nstore_path0=/server/data/fdfs/storeage\n#store_path1=/home/yuqing/fastdfs2\n</code></pre><p>启动：</p>\n<pre><code>#start the storage server:\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n#in Linux, you can start fdfs_storaged as a service:\n/sbin/service fdfs_storaged start  \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_storaged</code>  </p>\n<p>停止:</p>\n<pre><code>`/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n</code></pre><p>设置storage服务开机启动  </p>\n<p>停止：</p>\n<p><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop</code>       </p>\n<p>……</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更改`/etc/fdfs/下client.conf配置文件。</p>\n<p><code>base_path=~/dev/fastdfs/data/client</code><br><code>tracker_server=192.168.147</code> <em>不能是<code>localhost</code>或者<code>127.0.0.1</code></em></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \nThis is FastDFS client test program v5.08\n\nCopyright (C) 2008, Happy Fish / YuQing\n\nFastDFS may be copied only under the terms of the GNU General\nPublic License V3, which may be found in the FastDFS source kit.\nPlease visit the FastDFS Home Page http://www.csource.org/ \nfor more detail.\n\n[2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n\ntracker_query_storage_store_list_without_group: \n    server 1. group_name=, ip_addr=192.168.1.146, port=23000\n\ngroup_name=group1, ip_addr=192.168.1.146, port=23000\nstorage_upload_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nstorage_upload_slave_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nmutian@mutian-ThinkPad-T440p:~$ \n\n####\nmutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \ngroup1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\nmutian@mutian-ThinkPad-T440p:~/Pictures$ cd\nmutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \ngroup1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n</code></pre><h2 id=\"ubuntu下搭建\"><a href=\"#ubuntu下搭建\" class=\"headerlink\" title=\"ubuntu下搭建\"></a>ubuntu下搭建</h2><p>验证过，上面过程适用…… </p>\n<h2 id=\"集成nginx模块\"><a href=\"#集成nginx模块\" class=\"headerlink\" title=\"集成nginx模块\"></a>集成nginx模块</h2><p>参考：<a href=\"https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL</a></p>\n<p>1.下载<code>fastdfs-nginx-module</code></p>\n<p><code>git clone https://github.com/happyfish100/fastdfs-nginx-module.git</code></p>\n<p>注意：安装的FastDFS版本 &gt;= 5.11</p>\n<p>2.安装nginx-1.8.1</p>\n<p>下载：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a></p>\n<pre><code>&gt; ./configure --prefix=~/nginx \\\n --add-module=/home/mutian/fastdfs-nginx-module/src\n\n&gt; make; make install\n</code></pre><p>3.更改nginx配置，添加一行。</p>\n<p>如果文件分组  </p>\n<pre><code>location ~/group([0-9])/M00 {\n\n    ngx_fastdfs_module;\n\n}\n</code></pre><p>如果没分组</p>\n<pre><code>location /M00 {\n    root /home/mutian/dev/fastdfs/data/storage/data;\n    ngx_fastdfs_module;\n}\n</code></pre><blockquote>\n<p>注意：<br> A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。<br> B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:<br> location ~/group([0-9])/M00 {<br>     ngx_fastdfs_module;<br> }</p>\n</blockquote>\n<p>4.拷贝fdfs_storage的文件存储软链接</p>\n<p><code>ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00</code>          </p>\n<p>5.更改配置<code>mod_fastdfs.conf</code></p>\n<p>拷贝到相关目录：</p>\n<pre><code>cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n</code></pre><p>更改内容：</p>\n<pre><code>connect_timeout=10\nbase_path=/tmp\ntracker_server=ip01:22122\nstorage_server_port=23000\ngroup_name=group1\nurl_have_group_name = true\nstore_path0=/home/mutian/dev/fastdfs/data/storage      \n</code></pre><p>6.复制FastDFS 的部分配置文件到<code>/etc/fdfs</code>目录</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\nmutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\nanti-steal.jpg  http.conf   storage.conf      tracker.conf\nclient.conf     mime.types  storage_ids.conf\n\ncp http.conf mime.types /etc/fdfs/   \n</code></pre><p>7.启动nginx</p>\n<p><code>~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx</code> </p>\n<p>8.测试<br>按上面步骤，上传个文件，然后在浏览器打开：</p>\n<p><a href=\"http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a> </p>\n<p>or </p>\n<p><a href=\"http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a>          </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……</p>\n<p>网址：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xyang81/article/details/52837974\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xyang81/article/details/52837974</a><br><a href=\"http://blog.csdn.net/playadota/article/details/78381109\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/playadota/article/details/78381109</a></p>\n<h2 id=\"centos下搭建\"><a href=\"#centos下搭建\" class=\"headerlink\" title=\"centos下搭建\"></a>centos下搭建</h2><h3 id=\"第一步：安装依赖\"><a href=\"#第一步：安装依赖\" class=\"headerlink\" title=\"第一步：安装依赖\"></a>第一步：安装依赖</h3><p>安装fastdfs之前，先要安装相关依赖包libfastcommon。 </p>\n<p>下载地址：<a href=\"https://github.com/happyfish100/libfastcommon.git\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/libfastcommon.git</a></p>\n<p><code>git clone https://github.com/happyfish100/libfastcommon.git</code></p>\n<p>编译安装：</p>\n<pre><code>&gt; cd libfastcommon\n&gt; ./make.sh\n&gt; ./make.sh install\n</code></pre><h3 id=\"第二部：安装fastdfs\"><a href=\"#第二部：安装fastdfs\" class=\"headerlink\" title=\"第二部：安装fastdfs\"></a>第二部：安装fastdfs</h3><p>下载：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<ul>\n<li><p>step 2. download FastDFS source package and unpack it,<br>tar xzf FastDFS_v5.x.tar.gz</p>\n</li>\n<li><p>step 3. enter the FastDFS dir</p>\n<p>  <code>cd FastDFS</code></p>\n</li>\n<li><p>step 4. execute:</p>\n<p>  <code>./make.sh</code></p>\n</li>\n<li><p>step 5. make install</p>\n<p>  ./make.sh install`</p>\n</li>\n<li><p>step 6. edit/modify the config file of tracker and storage</p>\n</li>\n</ul>\n<pre><code>cd /etc/fdfs/\ncp tracker.conf.sample tracker.conf\ncp storage.conf.sample storage.conf\nmkdir -p /server/data/fdfs\n</code></pre><p>首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。</p>\n<p>base_path=/server/data/fdfs/tracker  </p>\n<p>启动：</p>\n<pre><code>#start the tracker server:\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n#in Linux, you can start fdfs_trackerd as a service:\n/sbin/service fdfs_trackerd start \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_trackerd</code>    </p>\n<p>设置tracker服务开启启动：</p>\n<hr>\n<p>修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。</p>\n<pre><code># the base path to store data and log files\nbase_path=/server/data/fdfs/storeage\n# tracker_server can ocur more than once, and tracker_server format is\n#  &quot;host:port&quot;, host can be hostname or ip address\ntracker_server=192.168.1.36:22122\n# store_path#, based 0, if store_path0 not exists, it&apos;s value is base_path\n# the paths must be exist\nstore_path0=/server/data/fdfs/storeage\n#store_path1=/home/yuqing/fastdfs2\n</code></pre><p>启动：</p>\n<pre><code>#start the storage server:\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n#in Linux, you can start fdfs_storaged as a service:\n/sbin/service fdfs_storaged start  \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_storaged</code>  </p>\n<p>停止:</p>\n<pre><code>`/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n</code></pre><p>设置storage服务开机启动  </p>\n<p>停止：</p>\n<p><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop</code>       </p>\n<p>……</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更改`/etc/fdfs/下client.conf配置文件。</p>\n<p><code>base_path=~/dev/fastdfs/data/client</code><br><code>tracker_server=192.168.147</code> <em>不能是<code>localhost</code>或者<code>127.0.0.1</code></em></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \nThis is FastDFS client test program v5.08\n\nCopyright (C) 2008, Happy Fish / YuQing\n\nFastDFS may be copied only under the terms of the GNU General\nPublic License V3, which may be found in the FastDFS source kit.\nPlease visit the FastDFS Home Page http://www.csource.org/ \nfor more detail.\n\n[2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n\ntracker_query_storage_store_list_without_group: \n    server 1. group_name=, ip_addr=192.168.1.146, port=23000\n\ngroup_name=group1, ip_addr=192.168.1.146, port=23000\nstorage_upload_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nstorage_upload_slave_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nmutian@mutian-ThinkPad-T440p:~$ \n\n####\nmutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \ngroup1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\nmutian@mutian-ThinkPad-T440p:~/Pictures$ cd\nmutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \ngroup1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n</code></pre><h2 id=\"ubuntu下搭建\"><a href=\"#ubuntu下搭建\" class=\"headerlink\" title=\"ubuntu下搭建\"></a>ubuntu下搭建</h2><p>验证过，上面过程适用…… </p>\n<h2 id=\"集成nginx模块\"><a href=\"#集成nginx模块\" class=\"headerlink\" title=\"集成nginx模块\"></a>集成nginx模块</h2><p>参考：<a href=\"https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL</a></p>\n<p>1.下载<code>fastdfs-nginx-module</code></p>\n<p><code>git clone https://github.com/happyfish100/fastdfs-nginx-module.git</code></p>\n<p>注意：安装的FastDFS版本 &gt;= 5.11</p>\n<p>2.安装nginx-1.8.1</p>\n<p>下载：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a></p>\n<pre><code>&gt; ./configure --prefix=~/nginx \\\n --add-module=/home/mutian/fastdfs-nginx-module/src\n\n&gt; make; make install\n</code></pre><p>3.更改nginx配置，添加一行。</p>\n<p>如果文件分组  </p>\n<pre><code>location ~/group([0-9])/M00 {\n\n    ngx_fastdfs_module;\n\n}\n</code></pre><p>如果没分组</p>\n<pre><code>location /M00 {\n    root /home/mutian/dev/fastdfs/data/storage/data;\n    ngx_fastdfs_module;\n}\n</code></pre><blockquote>\n<p>注意：<br> A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。<br> B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:<br> location ~/group([0-9])/M00 {<br>     ngx_fastdfs_module;<br> }</p>\n</blockquote>\n<p>4.拷贝fdfs_storage的文件存储软链接</p>\n<p><code>ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00</code>          </p>\n<p>5.更改配置<code>mod_fastdfs.conf</code></p>\n<p>拷贝到相关目录：</p>\n<pre><code>cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n</code></pre><p>更改内容：</p>\n<pre><code>connect_timeout=10\nbase_path=/tmp\ntracker_server=ip01:22122\nstorage_server_port=23000\ngroup_name=group1\nurl_have_group_name = true\nstore_path0=/home/mutian/dev/fastdfs/data/storage      \n</code></pre><p>6.复制FastDFS 的部分配置文件到<code>/etc/fdfs</code>目录</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\nmutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\nanti-steal.jpg  http.conf   storage.conf      tracker.conf\nclient.conf     mime.types  storage_ids.conf\n\ncp http.conf mime.types /etc/fdfs/   \n</code></pre><p>7.启动nginx</p>\n<p><code>~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx</code> </p>\n<p>8.测试<br>按上面步骤，上传个文件，然后在浏览器打开：</p>\n<p><a href=\"http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a> </p>\n<p>or </p>\n<p><a href=\"http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a>          </p>\n"},{"title":"git在centos7下源码编译安装","date":"2017-10-14T02:04:31.000Z","_content":"\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>  ln -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version #两个横杆\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","source":"_posts/git-install-in-centos7.md","raw":"---\ntitle: git在centos7下源码编译安装\ndate: 2017-10-14 10:04:31\ncategories: git\ntags: git-install-in-centos\n---\n\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>  ln -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version #两个横杆\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","slug":"git-install-in-centos7","published":1,"updated":"2018-11-17T07:29:59.103Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m3828001jqcrg2vtctbbb","content":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br> ln -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version #两个横杆</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br> ln -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version #两个横杆</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>"},{"title":"git打标签封存版本","date":"2018-06-23T09:40:01.000Z","_content":"\n在开发项目中，当我们的项目测试通过，并准备发布到生产环境时候，那么这是一个稳定的版本，此时，我们就需要封存该版本代码。做一个版本管理。本文就是介绍git下如何封存版本……\n\n## 创建标签\n\n1. 创建本地标签\n\n    `git tag -a V1.0 -m '版本1.0，基于spring-boot 1.x'`\n    \n2. 查看标签\n\n    `git tag`\n    \n    只看到版本信息`V1.0`，没看到备注信息。可以执行下面命令查看更加详细信息：\n    \n        mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git show V1.0\n        tag V1.0\n        Tagger: xinxiamu <932852117@qq.com>\n        Date:   Sat Jun 23 17:45:17 2018 +0800\n        \n        版本1.0，基于spring-boot 1.x \n        \n            \n## 提交标签到服务器\n\n上面创建的`tag`只是本地`git`仓库。下面把它推送到远程服务器。\n\n    mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin --tags \n    Username for 'https://github.com': xinxiamu\n    Password for 'https://xinxiamu@github.com': \n    Counting objects: 1, done.\n    Writing objects: 100% (1/1), 192 bytes | 0 bytes/s, done.\n    Total 1 (delta 0), reused 0 (delta 0)\n    To https://github.com/xinxiamu/ymu-framework.git\n     * [new tag]         V1.0 -> V1.0\n\n## 回退版本，tag上修复紧急bug\n    \n这个时候，突然发现一个重大bug，需要重新打版本，可以按下面方法来出来：\n\n- 删除本地标签： `git tag -d V1.0`    \n\n- 推送同名的空的标签到远程服务器，达到删除的目的：\n    \n    `git push origin :refs/tags/V1.0`\n    \n\n    mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin :refs/tags/V1.0\n    Username for 'https://github.com': xinxiamu\n    Password for 'https://xinxiamu@github.com': \n    To https://github.com/xinxiamu/ymu-framework.git\n     - [deleted]         V1.0\n\n- 拉取并切换到对应分支，在该分支上修复bug。\n    \n    如果远程服务器没有该分支，则可以基于该`tag`创建分支。并在新建分支上修改bug。\n    \n    `git checkout -B test v0.1.0` 强制创建一个基于指定的tag的分支。\n    \n    `test`为分支名称，`v0.1.0`为标签。\n\n- 按照上面步骤重新打标签并推送到远程服务器封存。\n- 合并该分支修改到主干分支`master`上，否则下次该bug还是存在。\n\n## 获取远程指定的封存版本\n\n更适合运维，拉取指定稳定版本进行发布到生产环境。\n\n`git fetch origin tag V1.0`\n\n## 切换到tag\n\n`git checkout V1.0`\n\n## 删除tag\n\n`git tag -d V1.0`\n\n----------------------------------------------------------------\n\n## 特别提醒（来源网络）\ngit 获取指定的tag处代码\n\ntag是对历史提交的一个id的引用，如果理解这句话就明白了tag的含义\n\n使用git checkout tag即可切换到指定tag，例如：git checkout v0.1.0\n\n切换到tag历史记录 会使当前指针处在分离头指针状态，这个时候的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b test v0.1.0 这个时候就在这个test分支上进行开发，之后可以切换到主线合并。\n\n注意这时候的test分支的代码很多都是tag版本处的，但是test分支head节点在最前面，这时候切换到主线进行合并，要注意合并后的代码冲突问题，不要让旧代码覆盖了主线的新代码。\n\ngit checkout -B\n这个命令，可以强制创建新的分支，为什么加-B呢？如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的git checkout -b 这个命令，是会报错的，且同名分支无法创建。如果使用-B参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支。\n\ngit checkout -B test v0.1.0 强制创建一个基于指定的tag的分支。\n\n注：不要切换到tag上修改，否则切换回到`master`，可能造成代码丢失。切记切记……\n\n\n","source":"_posts/git-tag.md","raw":"---\ntitle: git打标签封存版本\ndate: 2018-06-23 17:40:01\ncategories: git\ntags: git-tag\n---\n\n在开发项目中，当我们的项目测试通过，并准备发布到生产环境时候，那么这是一个稳定的版本，此时，我们就需要封存该版本代码。做一个版本管理。本文就是介绍git下如何封存版本……\n\n## 创建标签\n\n1. 创建本地标签\n\n    `git tag -a V1.0 -m '版本1.0，基于spring-boot 1.x'`\n    \n2. 查看标签\n\n    `git tag`\n    \n    只看到版本信息`V1.0`，没看到备注信息。可以执行下面命令查看更加详细信息：\n    \n        mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git show V1.0\n        tag V1.0\n        Tagger: xinxiamu <932852117@qq.com>\n        Date:   Sat Jun 23 17:45:17 2018 +0800\n        \n        版本1.0，基于spring-boot 1.x \n        \n            \n## 提交标签到服务器\n\n上面创建的`tag`只是本地`git`仓库。下面把它推送到远程服务器。\n\n    mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin --tags \n    Username for 'https://github.com': xinxiamu\n    Password for 'https://xinxiamu@github.com': \n    Counting objects: 1, done.\n    Writing objects: 100% (1/1), 192 bytes | 0 bytes/s, done.\n    Total 1 (delta 0), reused 0 (delta 0)\n    To https://github.com/xinxiamu/ymu-framework.git\n     * [new tag]         V1.0 -> V1.0\n\n## 回退版本，tag上修复紧急bug\n    \n这个时候，突然发现一个重大bug，需要重新打版本，可以按下面方法来出来：\n\n- 删除本地标签： `git tag -d V1.0`    \n\n- 推送同名的空的标签到远程服务器，达到删除的目的：\n    \n    `git push origin :refs/tags/V1.0`\n    \n\n    mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin :refs/tags/V1.0\n    Username for 'https://github.com': xinxiamu\n    Password for 'https://xinxiamu@github.com': \n    To https://github.com/xinxiamu/ymu-framework.git\n     - [deleted]         V1.0\n\n- 拉取并切换到对应分支，在该分支上修复bug。\n    \n    如果远程服务器没有该分支，则可以基于该`tag`创建分支。并在新建分支上修改bug。\n    \n    `git checkout -B test v0.1.0` 强制创建一个基于指定的tag的分支。\n    \n    `test`为分支名称，`v0.1.0`为标签。\n\n- 按照上面步骤重新打标签并推送到远程服务器封存。\n- 合并该分支修改到主干分支`master`上，否则下次该bug还是存在。\n\n## 获取远程指定的封存版本\n\n更适合运维，拉取指定稳定版本进行发布到生产环境。\n\n`git fetch origin tag V1.0`\n\n## 切换到tag\n\n`git checkout V1.0`\n\n## 删除tag\n\n`git tag -d V1.0`\n\n----------------------------------------------------------------\n\n## 特别提醒（来源网络）\ngit 获取指定的tag处代码\n\ntag是对历史提交的一个id的引用，如果理解这句话就明白了tag的含义\n\n使用git checkout tag即可切换到指定tag，例如：git checkout v0.1.0\n\n切换到tag历史记录 会使当前指针处在分离头指针状态，这个时候的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b test v0.1.0 这个时候就在这个test分支上进行开发，之后可以切换到主线合并。\n\n注意这时候的test分支的代码很多都是tag版本处的，但是test分支head节点在最前面，这时候切换到主线进行合并，要注意合并后的代码冲突问题，不要让旧代码覆盖了主线的新代码。\n\ngit checkout -B\n这个命令，可以强制创建新的分支，为什么加-B呢？如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的git checkout -b 这个命令，是会报错的，且同名分支无法创建。如果使用-B参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支。\n\ngit checkout -B test v0.1.0 强制创建一个基于指定的tag的分支。\n\n注：不要切换到tag上修改，否则切换回到`master`，可能造成代码丢失。切记切记……\n\n\n","slug":"git-tag","published":1,"updated":"2018-11-09T01:20:30.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m3829001mqcrg2kwo5pm0","content":"<p>在开发项目中，当我们的项目测试通过，并准备发布到生产环境时候，那么这是一个稳定的版本，此时，我们就需要封存该版本代码。做一个版本管理。本文就是介绍git下如何封存版本……</p>\n<h2 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h2><ol>\n<li><p>创建本地标签</p>\n<p> <code>git tag -a V1.0 -m &#39;版本1.0，基于spring-boot 1.x&#39;</code></p>\n</li>\n<li><p>查看标签</p>\n<p> <code>git tag</code></p>\n<p> 只看到版本信息<code>V1.0</code>，没看到备注信息。可以执行下面命令查看更加详细信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git show V1.0\ntag V1.0\nTagger: xinxiamu &lt;932852117@qq.com&gt;\nDate:   Sat Jun 23 17:45:17 2018 +0800\n\n版本1.0，基于spring-boot 1.x \n</code></pre></li>\n</ol>\n<h2 id=\"提交标签到服务器\"><a href=\"#提交标签到服务器\" class=\"headerlink\" title=\"提交标签到服务器\"></a>提交标签到服务器</h2><p>上面创建的<code>tag</code>只是本地<code>git</code>仓库。下面把它推送到远程服务器。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin --tags \nUsername for &apos;https://github.com&apos;: xinxiamu\nPassword for &apos;https://xinxiamu@github.com&apos;: \nCounting objects: 1, done.\nWriting objects: 100% (1/1), 192 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo https://github.com/xinxiamu/ymu-framework.git\n * [new tag]         V1.0 -&gt; V1.0\n</code></pre><h2 id=\"回退版本，tag上修复紧急bug\"><a href=\"#回退版本，tag上修复紧急bug\" class=\"headerlink\" title=\"回退版本，tag上修复紧急bug\"></a>回退版本，tag上修复紧急bug</h2><p>这个时候，突然发现一个重大bug，需要重新打版本，可以按下面方法来出来：</p>\n<ul>\n<li><p>删除本地标签： <code>git tag -d V1.0</code>    </p>\n</li>\n<li><p>推送同名的空的标签到远程服务器，达到删除的目的：</p>\n<p>  <code>git push origin :refs/tags/V1.0</code></p>\n</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin :refs/tags/V1.0\nUsername for &apos;https://github.com&apos;: xinxiamu\nPassword for &apos;https://xinxiamu@github.com&apos;: \nTo https://github.com/xinxiamu/ymu-framework.git\n - [deleted]         V1.0\n</code></pre><ul>\n<li><p>拉取并切换到对应分支，在该分支上修复bug。</p>\n<p>  如果远程服务器没有该分支，则可以基于该<code>tag</code>创建分支。并在新建分支上修改bug。</p>\n<p>  <code>git checkout -B test v0.1.0</code> 强制创建一个基于指定的tag的分支。</p>\n<p>  <code>test</code>为分支名称，<code>v0.1.0</code>为标签。</p>\n</li>\n<li><p>按照上面步骤重新打标签并推送到远程服务器封存。</p>\n</li>\n<li>合并该分支修改到主干分支<code>master</code>上，否则下次该bug还是存在。</li>\n</ul>\n<h2 id=\"获取远程指定的封存版本\"><a href=\"#获取远程指定的封存版本\" class=\"headerlink\" title=\"获取远程指定的封存版本\"></a>获取远程指定的封存版本</h2><p>更适合运维，拉取指定稳定版本进行发布到生产环境。</p>\n<p><code>git fetch origin tag V1.0</code></p>\n<h2 id=\"切换到tag\"><a href=\"#切换到tag\" class=\"headerlink\" title=\"切换到tag\"></a>切换到tag</h2><p><code>git checkout V1.0</code></p>\n<h2 id=\"删除tag\"><a href=\"#删除tag\" class=\"headerlink\" title=\"删除tag\"></a>删除tag</h2><p><code>git tag -d V1.0</code></p>\n<hr>\n<h2 id=\"特别提醒（来源网络）\"><a href=\"#特别提醒（来源网络）\" class=\"headerlink\" title=\"特别提醒（来源网络）\"></a>特别提醒（来源网络）</h2><p>git 获取指定的tag处代码</p>\n<p>tag是对历史提交的一个id的引用，如果理解这句话就明白了tag的含义</p>\n<p>使用git checkout tag即可切换到指定tag，例如：git checkout v0.1.0</p>\n<p>切换到tag历史记录 会使当前指针处在分离头指针状态，这个时候的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b test v0.1.0 这个时候就在这个test分支上进行开发，之后可以切换到主线合并。</p>\n<p>注意这时候的test分支的代码很多都是tag版本处的，但是test分支head节点在最前面，这时候切换到主线进行合并，要注意合并后的代码冲突问题，不要让旧代码覆盖了主线的新代码。</p>\n<p>git checkout -B<br>这个命令，可以强制创建新的分支，为什么加-B呢？如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的git checkout -b 这个命令，是会报错的，且同名分支无法创建。如果使用-B参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支。</p>\n<p>git checkout -B test v0.1.0 强制创建一个基于指定的tag的分支。</p>\n<p>注：不要切换到tag上修改，否则切换回到<code>master</code>，可能造成代码丢失。切记切记……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在开发项目中，当我们的项目测试通过，并准备发布到生产环境时候，那么这是一个稳定的版本，此时，我们就需要封存该版本代码。做一个版本管理。本文就是介绍git下如何封存版本……</p>\n<h2 id=\"创建标签\"><a href=\"#创建标签\" class=\"headerlink\" title=\"创建标签\"></a>创建标签</h2><ol>\n<li><p>创建本地标签</p>\n<p> <code>git tag -a V1.0 -m &#39;版本1.0，基于spring-boot 1.x&#39;</code></p>\n</li>\n<li><p>查看标签</p>\n<p> <code>git tag</code></p>\n<p> 只看到版本信息<code>V1.0</code>，没看到备注信息。可以执行下面命令查看更加详细信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git show V1.0\ntag V1.0\nTagger: xinxiamu &lt;932852117@qq.com&gt;\nDate:   Sat Jun 23 17:45:17 2018 +0800\n\n版本1.0，基于spring-boot 1.x \n</code></pre></li>\n</ol>\n<h2 id=\"提交标签到服务器\"><a href=\"#提交标签到服务器\" class=\"headerlink\" title=\"提交标签到服务器\"></a>提交标签到服务器</h2><p>上面创建的<code>tag</code>只是本地<code>git</code>仓库。下面把它推送到远程服务器。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin --tags \nUsername for &apos;https://github.com&apos;: xinxiamu\nPassword for &apos;https://xinxiamu@github.com&apos;: \nCounting objects: 1, done.\nWriting objects: 100% (1/1), 192 bytes | 0 bytes/s, done.\nTotal 1 (delta 0), reused 0 (delta 0)\nTo https://github.com/xinxiamu/ymu-framework.git\n * [new tag]         V1.0 -&gt; V1.0\n</code></pre><h2 id=\"回退版本，tag上修复紧急bug\"><a href=\"#回退版本，tag上修复紧急bug\" class=\"headerlink\" title=\"回退版本，tag上修复紧急bug\"></a>回退版本，tag上修复紧急bug</h2><p>这个时候，突然发现一个重大bug，需要重新打版本，可以按下面方法来出来：</p>\n<ul>\n<li><p>删除本地标签： <code>git tag -d V1.0</code>    </p>\n</li>\n<li><p>推送同名的空的标签到远程服务器，达到删除的目的：</p>\n<p>  <code>git push origin :refs/tags/V1.0</code></p>\n</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/java/github/ymu-framework$ git push origin :refs/tags/V1.0\nUsername for &apos;https://github.com&apos;: xinxiamu\nPassword for &apos;https://xinxiamu@github.com&apos;: \nTo https://github.com/xinxiamu/ymu-framework.git\n - [deleted]         V1.0\n</code></pre><ul>\n<li><p>拉取并切换到对应分支，在该分支上修复bug。</p>\n<p>  如果远程服务器没有该分支，则可以基于该<code>tag</code>创建分支。并在新建分支上修改bug。</p>\n<p>  <code>git checkout -B test v0.1.0</code> 强制创建一个基于指定的tag的分支。</p>\n<p>  <code>test</code>为分支名称，<code>v0.1.0</code>为标签。</p>\n</li>\n<li><p>按照上面步骤重新打标签并推送到远程服务器封存。</p>\n</li>\n<li>合并该分支修改到主干分支<code>master</code>上，否则下次该bug还是存在。</li>\n</ul>\n<h2 id=\"获取远程指定的封存版本\"><a href=\"#获取远程指定的封存版本\" class=\"headerlink\" title=\"获取远程指定的封存版本\"></a>获取远程指定的封存版本</h2><p>更适合运维，拉取指定稳定版本进行发布到生产环境。</p>\n<p><code>git fetch origin tag V1.0</code></p>\n<h2 id=\"切换到tag\"><a href=\"#切换到tag\" class=\"headerlink\" title=\"切换到tag\"></a>切换到tag</h2><p><code>git checkout V1.0</code></p>\n<h2 id=\"删除tag\"><a href=\"#删除tag\" class=\"headerlink\" title=\"删除tag\"></a>删除tag</h2><p><code>git tag -d V1.0</code></p>\n<hr>\n<h2 id=\"特别提醒（来源网络）\"><a href=\"#特别提醒（来源网络）\" class=\"headerlink\" title=\"特别提醒（来源网络）\"></a>特别提醒（来源网络）</h2><p>git 获取指定的tag处代码</p>\n<p>tag是对历史提交的一个id的引用，如果理解这句话就明白了tag的含义</p>\n<p>使用git checkout tag即可切换到指定tag，例如：git checkout v0.1.0</p>\n<p>切换到tag历史记录 会使当前指针处在分离头指针状态，这个时候的修改是很危险的，在切换回主线时如果没有合并，之前的修改提交基本都会丢失，如果需要修改可以尝试git checkout -b branch tag创建一个基于指定tag的分支，例如：git checkout -b test v0.1.0 这个时候就在这个test分支上进行开发，之后可以切换到主线合并。</p>\n<p>注意这时候的test分支的代码很多都是tag版本处的，但是test分支head节点在最前面，这时候切换到主线进行合并，要注意合并后的代码冲突问题，不要让旧代码覆盖了主线的新代码。</p>\n<p>git checkout -B<br>这个命令，可以强制创建新的分支，为什么加-B呢？如果当前仓库中，已经存在一个跟你新建分支同名的分支，那么使用普通的git checkout -b 这个命令，是会报错的，且同名分支无法创建。如果使用-B参数，那么就可以强制创建新的分支，并会覆盖掉原来的分支。</p>\n<p>git checkout -B test v0.1.0 强制创建一个基于指定的tag的分支。</p>\n<p>注：不要切换到tag上修改，否则切换回到<code>master</code>，可能造成代码丢失。切记切记……</p>\n"},{"title":"git服务器使用","date":"2017-10-14T01:58:47.000Z","_content":"搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","source":"_posts/git-server-build.md","raw":"---\ntitle: git服务器使用\ndate: 2017-10-14 09:58:47\ncategories: git\ntags: git-server-build\n---\n搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","slug":"git-server-build","published":1,"updated":"2018-11-09T01:20:30.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382b001pqcrghxaxhfn9","content":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone <a href=\"mailto:git@119.23.78.160\" target=\"_blank\" rel=\"noopener\">git@119.23.78.160</a>:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br><a href=\"mailto:git@119.23.78.160\" target=\"_blank\" rel=\"noopener\">git@119.23.78.160</a>‘s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone <a href=\"mailto:git@119.23.78.160\" target=\"_blank\" rel=\"noopener\">git@119.23.78.160</a>:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br><a href=\"mailto:git@119.23.78.160\" target=\"_blank\" rel=\"noopener\">git@119.23.78.160</a>‘s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n"},{"title":"git使用","date":"2018-09-06T10:08:06.000Z","_content":"\n本文介绍git的使用方法以及一些问题……\n\n## 回滚版本库\n在`git commit`多次后，版本库又会记录，但是在某次提交当中，提交了错误的代码，或者过大的文件，这个时候，就要做撤销，回滚。\n\n方式一：    \n`git log`   #拿到版本库id    \n`git reset 版本库id`\n","source":"_posts/git-use.md","raw":"---\ntitle: git使用\ndate: 2018-09-06 18:08:06\ncategories: git\ntags: git问题\n---\n\n本文介绍git的使用方法以及一些问题……\n\n## 回滚版本库\n在`git commit`多次后，版本库又会记录，但是在某次提交当中，提交了错误的代码，或者过大的文件，这个时候，就要做撤销，回滚。\n\n方式一：    \n`git log`   #拿到版本库id    \n`git reset 版本库id`\n","slug":"git-use","published":1,"updated":"2018-11-09T01:20:30.093Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382c001sqcrgrbc6yqfc","content":"<p>本文介绍git的使用方法以及一些问题……</p>\n<h2 id=\"回滚版本库\"><a href=\"#回滚版本库\" class=\"headerlink\" title=\"回滚版本库\"></a>回滚版本库</h2><p>在<code>git commit</code>多次后，版本库又会记录，但是在某次提交当中，提交了错误的代码，或者过大的文件，这个时候，就要做撤销，回滚。</p>\n<p>方式一：<br><code>git log</code>   #拿到版本库id<br><code>git reset 版本库id</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍git的使用方法以及一些问题……</p>\n<h2 id=\"回滚版本库\"><a href=\"#回滚版本库\" class=\"headerlink\" title=\"回滚版本库\"></a>回滚版本库</h2><p>在<code>git commit</code>多次后，版本库又会记录，但是在某次提交当中，提交了错误的代码，或者过大的文件，这个时候，就要做撤销，回滚。</p>\n<p>方式一：<br><code>git log</code>   #拿到版本库id<br><code>git reset 版本库id</code></p>\n"},{"title":"如何直接在github网站上更新你fork的repo","date":"2017-10-13T01:39:58.000Z","_content":"玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","source":"_posts/github-fork-repo-update.md","raw":"---\ntitle: 如何直接在github网站上更新你fork的repo\ndate: 2017-10-13 09:39:58\ncategories: github\ntags: github-fork-repo-update\n---\n玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","slug":"github-fork-repo-update","published":1,"updated":"2018-11-09T01:20:30.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382d001uqcrgxftrihof","content":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>"},{"title":"HashiCorp Vault使用　","date":"2017-09-30T15:40:58.000Z","_content":"## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","source":"_posts/hashicorp-vault.md","raw":"---\ntitle: HashiCorp Vault使用　\ndate: 2017-09-30 23:40:58\ncategories: security\ntags: hashicorp-vault\n---\n## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","slug":"hashicorp-vault","published":1,"updated":"2018-11-09T01:20:30.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382e001xqcrg0vtnsryo","content":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n"},{"title":"http协议概述(学习笔记)","date":"2017-10-17T13:45:50.000Z","_content":"\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","source":"_posts/http-protocol-overview.md","raw":"---\ntitle: http协议概述(学习笔记)\ndate: 2017-10-17 21:45:50\ncategories: http协议\ntags: http-overview\n---\n\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","slug":"http-protocol-overview","published":1,"updated":"2018-11-09T01:20:30.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382f0020qcrgscqxu8lw","content":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>","site":{"data":{}},"excerpt":"","more":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>"},{"title":"idea集成XRebel分析web应用性能","date":"2017-12-04T07:50:14.000Z","_content":"XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。\n\nXRebel官方简明教程在这里 http://zeroturnaround.com/software/xrebel/quick-start/\n\n官方下载地址在这里 https://zeroturnaround.com/software/xrebel/download/#!/have-license","source":"_posts/idea-XRebel.md","raw":"---\ntitle: idea集成XRebel分析web应用性能\ndate: 2017-12-04 15:50:14\ncategories: idea\ntags: XRebel\n---\nXRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。\n\nXRebel官方简明教程在这里 http://zeroturnaround.com/software/xrebel/quick-start/\n\n官方下载地址在这里 https://zeroturnaround.com/software/xrebel/download/#!/have-license","slug":"idea-XRebel","published":1,"updated":"2018-11-09T01:20:30.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382g0022qcrg7eswvah9","content":"<p>XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。</p>\n<p>XRebel官方简明教程在这里 <a href=\"http://zeroturnaround.com/software/xrebel/quick-start/\" target=\"_blank\" rel=\"noopener\">http://zeroturnaround.com/software/xrebel/quick-start/</a></p>\n<p>官方下载地址在这里 <a href=\"https://zeroturnaround.com/software/xrebel/download/#!/have-license\" target=\"_blank\" rel=\"noopener\">https://zeroturnaround.com/software/xrebel/download/#!/have-license</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。</p>\n<p>XRebel官方简明教程在这里 <a href=\"http://zeroturnaround.com/software/xrebel/quick-start/\" target=\"_blank\" rel=\"noopener\">http://zeroturnaround.com/software/xrebel/quick-start/</a></p>\n<p>官方下载地址在这里 <a href=\"https://zeroturnaround.com/software/xrebel/download/#!/have-license\" target=\"_blank\" rel=\"noopener\">https://zeroturnaround.com/software/xrebel/download/#!/have-license</a></p>\n"},{"title":"idea创建类，方法注解提示模板","date":"2018-02-10T06:30:29.000Z","_content":"\n为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……\n\n## java类的注解模板\n\n1. 首先，打开设计：\n`File->Settings->file and code template` \n\n{% asset_img a.png %}\n\n`#parse(\"File Header.java\")` \n这句：include 名字为File Header的模板进来。 \n\n2. 定义如图： \n\n{% asset_img b.png %}\n\n模板内容：\n\n       /**\n        * 功能简述:<br> \n        * \n        *\n        * @author zmt\n        * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n        * @updateTime \n        * @since 1.0.0\n        */\n        \n## java方法模板\n\n在File->Settings->Editor->Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template\n\n- 创建mygroup的Template,并定义名为/**的template。如下图：\n\n{% asset_img c.png %}\n\n模板内容：\n\n    /**\n     * 功能描述: <br>\n     * 〈$END$〉\n     *\n     $param$\n     * @return: $return$\n     * @since: 1.0.0\n     * @author: $user$\n     * @date: $DATE$ $TIME$\n     */\n     \n- 编辑模板的变量内容：\n\n点击右边的Edit Variables: \n\n{% asset_img e.png %}\n\n添加变量内容，如图： \n\n{% asset_img f.png %}\n\n注意：$param$这么添加，否则无效：\n\n    groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {result+='* @param ' + params[i] + ((i < params.size() - 1) ? '\\\\n ' : '')}; return result\", methodParameters())\n\n- 选定作用域：\n\n是应用在类上，还是方法上\n\n{% asset_img g.png %}\n\n- 测试：\n\n在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。\n\n`注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效`\n\n{% asset_img j.png %}\n\n\n     \n\n","source":"_posts/idea-file-template.md","raw":"---\ntitle: idea创建类，方法注解提示模板\ndate: 2018-02-10 14:30:29\ncategories: idea\ntags: idea注解模板\n---\n\n为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……\n\n## java类的注解模板\n\n1. 首先，打开设计：\n`File->Settings->file and code template` \n\n{% asset_img a.png %}\n\n`#parse(\"File Header.java\")` \n这句：include 名字为File Header的模板进来。 \n\n2. 定义如图： \n\n{% asset_img b.png %}\n\n模板内容：\n\n       /**\n        * 功能简述:<br> \n        * \n        *\n        * @author zmt\n        * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n        * @updateTime \n        * @since 1.0.0\n        */\n        \n## java方法模板\n\n在File->Settings->Editor->Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template\n\n- 创建mygroup的Template,并定义名为/**的template。如下图：\n\n{% asset_img c.png %}\n\n模板内容：\n\n    /**\n     * 功能描述: <br>\n     * 〈$END$〉\n     *\n     $param$\n     * @return: $return$\n     * @since: 1.0.0\n     * @author: $user$\n     * @date: $DATE$ $TIME$\n     */\n     \n- 编辑模板的变量内容：\n\n点击右边的Edit Variables: \n\n{% asset_img e.png %}\n\n添加变量内容，如图： \n\n{% asset_img f.png %}\n\n注意：$param$这么添加，否则无效：\n\n    groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {result+='* @param ' + params[i] + ((i < params.size() - 1) ? '\\\\n ' : '')}; return result\", methodParameters())\n\n- 选定作用域：\n\n是应用在类上，还是方法上\n\n{% asset_img g.png %}\n\n- 测试：\n\n在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。\n\n`注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效`\n\n{% asset_img j.png %}\n\n\n     \n\n","slug":"idea-file-template","published":1,"updated":"2018-11-09T01:20:30.124Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382j0026qcrgh0hgrdd6","content":"<p>为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……</p>\n<h2 id=\"java类的注解模板\"><a href=\"#java类的注解模板\" class=\"headerlink\" title=\"java类的注解模板\"></a>java类的注解模板</h2><ol>\n<li>首先，打开设计：<br><code>File-&gt;Settings-&gt;file and code template</code> </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/a.png\">\n<p><code>#parse(&quot;File Header.java&quot;)</code><br>这句：include 名字为File Header的模板进来。 </p>\n<ol start=\"2\">\n<li>定义如图： </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/b.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能简述:&lt;br&gt; \n * \n *\n * @author zmt\n * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n * @updateTime \n * @since 1.0.0\n */\n</code></pre><h2 id=\"java方法模板\"><a href=\"#java方法模板\" class=\"headerlink\" title=\"java方法模板\"></a>java方法模板</h2><p>在File-&gt;Settings-&gt;Editor-&gt;Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template</p>\n<ul>\n<li>创建mygroup的Template,并定义名为/**的template。如下图：</li>\n</ul>\n<img src=\"/2018/02/10/idea-file-template/c.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能描述: &lt;br&gt;\n * 〈$END$〉\n *\n $param$\n * @return: $return$\n * @since: 1.0.0\n * @author: $user$\n * @date: $DATE$ $TIME$\n */\n</code></pre><ul>\n<li>编辑模板的变量内容：</li>\n</ul>\n<p>点击右边的Edit Variables: </p>\n<img src=\"/2018/02/10/idea-file-template/e.png\">\n<p>添加变量内容，如图： </p>\n<img src=\"/2018/02/10/idea-file-template/f.png\">\n<p>注意：$param$这么添加，否则无效：</p>\n<pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\\&quot;${_1}\\&quot;.replaceAll(&apos;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) {result+=&apos;* @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\\\n &apos; : &apos;&apos;)}; return result&quot;, methodParameters())\n</code></pre><ul>\n<li>选定作用域：</li>\n</ul>\n<p>是应用在类上，还是方法上</p>\n<img src=\"/2018/02/10/idea-file-template/g.png\">\n<ul>\n<li>测试：</li>\n</ul>\n<p>在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。</p>\n<p><code>注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效</code></p>\n<img src=\"/2018/02/10/idea-file-template/j.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……</p>\n<h2 id=\"java类的注解模板\"><a href=\"#java类的注解模板\" class=\"headerlink\" title=\"java类的注解模板\"></a>java类的注解模板</h2><ol>\n<li>首先，打开设计：<br><code>File-&gt;Settings-&gt;file and code template</code> </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/a.png\">\n<p><code>#parse(&quot;File Header.java&quot;)</code><br>这句：include 名字为File Header的模板进来。 </p>\n<ol start=\"2\">\n<li>定义如图： </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/b.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能简述:&lt;br&gt; \n * \n *\n * @author zmt\n * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n * @updateTime \n * @since 1.0.0\n */\n</code></pre><h2 id=\"java方法模板\"><a href=\"#java方法模板\" class=\"headerlink\" title=\"java方法模板\"></a>java方法模板</h2><p>在File-&gt;Settings-&gt;Editor-&gt;Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template</p>\n<ul>\n<li>创建mygroup的Template,并定义名为/**的template。如下图：</li>\n</ul>\n<img src=\"/2018/02/10/idea-file-template/c.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能描述: &lt;br&gt;\n * 〈$END$〉\n *\n $param$\n * @return: $return$\n * @since: 1.0.0\n * @author: $user$\n * @date: $DATE$ $TIME$\n */\n</code></pre><ul>\n<li>编辑模板的变量内容：</li>\n</ul>\n<p>点击右边的Edit Variables: </p>\n<img src=\"/2018/02/10/idea-file-template/e.png\">\n<p>添加变量内容，如图： </p>\n<img src=\"/2018/02/10/idea-file-template/f.png\">\n<p>注意：$param$这么添加，否则无效：</p>\n<pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\\&quot;${_1}\\&quot;.replaceAll(&apos;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) {result+=&apos;* @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\\\n &apos; : &apos;&apos;)}; return result&quot;, methodParameters())\n</code></pre><ul>\n<li>选定作用域：</li>\n</ul>\n<p>是应用在类上，还是方法上</p>\n<img src=\"/2018/02/10/idea-file-template/g.png\">\n<ul>\n<li>测试：</li>\n</ul>\n<p>在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。</p>\n<p><code>注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效</code></p>\n<img src=\"/2018/02/10/idea-file-template/j.png\">\n"},{"title":"idea插件利器","date":"2017-11-10T01:55:50.000Z","_content":"\n## 1. GsonFormat\n1. 作用：json字符串自动生成javabean工具。\n2. 使用：\n\n\n\n## 2.web开发利器emmet\n\n官网：https://emmet.io/","source":"_posts/idea-good-plug.md","raw":"---\ntitle: idea插件利器\ndate: 2017-11-10 09:55:50\ncategories: idea\ntags: idea插件利器\n---\n\n## 1. GsonFormat\n1. 作用：json字符串自动生成javabean工具。\n2. 使用：\n\n\n\n## 2.web开发利器emmet\n\n官网：https://emmet.io/","slug":"idea-good-plug","published":1,"updated":"2018-11-09T01:20:30.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382k0028qcrg5agw49t5","content":"<h2 id=\"1-GsonFormat\"><a href=\"#1-GsonFormat\" class=\"headerlink\" title=\"1. GsonFormat\"></a>1. GsonFormat</h2><ol>\n<li>作用：json字符串自动生成javabean工具。</li>\n<li>使用：</li>\n</ol>\n<h2 id=\"2-web开发利器emmet\"><a href=\"#2-web开发利器emmet\" class=\"headerlink\" title=\"2.web开发利器emmet\"></a>2.web开发利器emmet</h2><p>官网：<a href=\"https://emmet.io/\" target=\"_blank\" rel=\"noopener\">https://emmet.io/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-GsonFormat\"><a href=\"#1-GsonFormat\" class=\"headerlink\" title=\"1. GsonFormat\"></a>1. GsonFormat</h2><ol>\n<li>作用：json字符串自动生成javabean工具。</li>\n<li>使用：</li>\n</ol>\n<h2 id=\"2-web开发利器emmet\"><a href=\"#2-web开发利器emmet\" class=\"headerlink\" title=\"2.web开发利器emmet\"></a>2.web开发利器emmet</h2><p>官网：<a href=\"https://emmet.io/\" target=\"_blank\" rel=\"noopener\">https://emmet.io/</a></p>\n"},{"title":"服务网格istio入门","date":"2018-03-13T00:57:27.000Z","_content":"\n参考网址： http://www.servicemesher.com/blog/istio-service-mesh-tutorial/\n","source":"_posts/istio-start.md","raw":"---\ntitle: 服务网格istio入门\ndate: 2018-03-13 08:57:27\ncategories: 服务网格\ntags: istio\n---\n\n参考网址： http://www.servicemesher.com/blog/istio-service-mesh-tutorial/\n","slug":"istio-start","published":1,"updated":"2018-11-09T01:20:30.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382l002bqcrg34jbmh0x","content":"<p>参考网址： <a href=\"http://www.servicemesher.com/blog/istio-service-mesh-tutorial/\" target=\"_blank\" rel=\"noopener\">http://www.servicemesher.com/blog/istio-service-mesh-tutorial/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考网址： <a href=\"http://www.servicemesher.com/blog/istio-service-mesh-tutorial/\" target=\"_blank\" rel=\"noopener\">http://www.servicemesher.com/blog/istio-service-mesh-tutorial/</a></p>\n"},{"title":"jackson使用录","date":"2017-10-01T01:07:36.000Z","_content":"## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","source":"_posts/jackson-show-time.md","raw":"---\ntitle: jackson使用录\ndate: 2017-10-01 09:07:36\ncategories: json\ntags: jackson\n---\n## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","slug":"jackson-show-time","published":1,"updated":"2018-11-09T01:20:30.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382m002eqcrgtyqbhz9i","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>"},{"title":"CGLIB介绍与原理","date":"2017-10-26T07:57:08.000Z","_content":"http://blog.csdn.net/zghwaicsdn/article/details/50957474","source":"_posts/javase-cglib.md","raw":"---\ntitle: CGLIB介绍与原理\ndate: 2017-10-26 15:57:08\ncategories: java\ntags: cglib\n---\nhttp://blog.csdn.net/zghwaicsdn/article/details/50957474","slug":"javase-cglib","published":1,"updated":"2018-11-09T01:20:30.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382o002hqcrgr4mifs4k","content":"<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zghwaicsdn/article/details/50957474</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zghwaicsdn/article/details/50957474</a></p>\n"},{"title":"Java Nio 缓冲区","date":"2017-10-25T06:57:22.000Z","_content":"","source":"_posts/javase-nio-buffer.md","raw":"---\ntitle: Java Nio 缓冲区\ndate: 2017-10-25 14:57:22\ncategories: java\ntags: java-nio-buffer\n---\n","slug":"javase-nio-buffer","published":1,"updated":"2018-11-09T01:20:30.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m382p002jqcrg9z7g8jkk","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"centos7下安装mysql8","date":"2018-07-27T14:57:16.000Z","_content":"\n本文介绍在centos7.4下源码编译安装msyql8的步骤……\n\n参考：https://www.linuxidc.com/Linux/2018-04/152010.htm\n\n## 源码编译安装\n\n### 安装前清理\n\n1. 清理旧的mysql\n\n        rpm -pa | grep mysql\n        \n        yum remove mysql-xxx-xxx-\n        \n2. 删除旧的mysql配置文件，卸载不会自动删除。\n\n        find / -name mysql\n     \n显示： \n\n    /etc/logrotate.d/mysql\n    /etc/selinux/targeted/active/modules/100/mysql\n    /etc/selinux/targeted/tmp/modules/100/mysql\n    /var/lib/mysql\n    /var/lib/mysql/mysql\n    /usr/bin/mysql\n    /usr/lib64/mysql\n    /usr/local/mysql\n\n根据需求使用以下命令 依次 对配置文件进行删除\n\n    rm -rf /var/lib/mysql\n    \n3. 卸载当前系统中已安装的mariadb。centos7中默认安装，会和mysql冲突。\n\n\n    rpm -qa | grep mariadb  （查找）\n    \n    rpm -e mysql*/mariadb*\n    \n    rpm -e --nodeps mysql*/mariadb*  （强制删除）\n    \n    ----------------------\n    [root@ymu ~]# rpm -qa | grep mariadb\n    mariadb-libs-5.5.56-2.el7.x86_64\n    [root@ymu ~]# rpm -e mysql*/mariadb*\n    error: package mysql*/mariadb* is not installed\n    [root@ymu ~]# rpm -e --nodeps mysql*/mariadb*  \n    error: package mysql*/mariadb* is not installed\n    [root@ymu ~]# rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\n              \n\n### 准备工作\n\n1.安装依赖\n\n    yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel\n        \n2.下载源码包\n\n下载网址： https://dev.mysql.com\n\n    wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)\n     \n         \n3.创建mysql用户\n\n    groupadd mysql\n    useradd -r -g mysql -s /bin/false mysql\n    \n   \n4.创建安装目录和数据目录\n\n    mkdir -p /server/mysql\n    mkdir -p /server/data/mysql\n    \n### 安装mysql\n\n1.解压源码包\n\n    [root@ymu tools]# tar -zxvf mysql-boost-8.0.11.tar.gz \n    \n2.编译&安装\n\n    [root@ymu tools]# cd mysql-8.0.11/\n    [root@ymu mysql-8.0.11]# cmake .  -DCMAKE_INSTALL_PREFIX=/server/mysql \\\n    > -DMYSQL_DATADIR=/server/data/mysql/ \\\n    > -DDEFAULT_CHARSET=utf8mb4 \\\n    > -DDEFAULT_COLLATION=utf8mb4_general_ci \\\n    > -DWITH_BOOST=/server/tools/mysql-8.0.11/boost/\n       \n    [root@ymu mysql-8.0.11]# make && make install   \n    \n3.配置my.cnf文件\n\n可能找不到该文件，如果没有，新建一个。 \n\n          cat /etc/my.cnf\n          [mysqld]\n          server-id=1\n          port=3306\n          basedir=/server/mysql8\n          datadir=/server/data/mysql8\n    　　　 ##请根据实际情况添加参数\n    \n更改： \n\n    [client]\n    port = 3307\n    socket = /tmp/mysql.sock\n    default-character-set = utf8mb4\n    \n    [mysqld]\n    port=3307\n    socket=/tmp/mysql.sock\n    \n    [mysql.server]\n    server-id=1\n    basedir=/server/mysql\n    datadir=/server/data/mysql\n    pid-file=/server/data/mysql/mysql.pid\n    \n    character-set-server = utf8mb4\n    \n    slow_query_log=1\n    long_query_time=5\n    slow_query_log_file=/server/data/mysql/mysql-slow.log\n    \n    default_storage_engine=InnoDB\n    innodb_file_per_table = 1\n    innodb_open_files = 500\n    innodb_buffer_pool_size = 64M\n    innodb_write_io_threads = 4\n    innodb_read_io_threads = 4\n    innodb_thread_concurrency = 0\n    innodb_purge_threads = 1\n    innodb_flush_log_at_trx_commit = 2\n    innodb_log_buffer_size = 2M\n    innodb_log_file_size = 32M\n    innodb_log_files_in_group = 3\n    innodb_max_dirty_pages_pct = 90\n    innodb_lock_wait_timeout = 120\n\n    \n\n参考：\n\n    [client]\n    port = 3307\n    socket = ~/tmp/mysql.sock\n    default-character-set = utf8mb4\n    \n    [mysqld]\n    port = 3307\n    socket = /home/mutian/tmp/mysql.sock\n    \n    [mysql.server]\n    basedir = /home/mutian/dev/tools/mysql\n    datadir = /home/mutian/dev/data/mysql\n    pid-file = /home/mutian/dev/data/mysql/mysql.pid\n    user = mysql\n    bind-address = 0.0.0.0\n    server-id = 1\n    \n    init-connect = 'SET NAMES utf8mb4'\n    character-set-server = utf8mb4\n    \n    #skip-name-resolve\n    #skip-networking\n    back_log = 300\n    \n    max_connections = 1000\n    max_connect_errors = 6000\n    open_files_limit = 65535\n    table_open_cache = 128\n    max_allowed_packet = 4M\n    binlog_cache_size = 1M\n    max_heap_table_size = 8M\n    tmp_table_size = 16M\n    \n    read_buffer_size = 2M\n    read_rnd_buffer_size = 8M\n    sort_buffer_size = 8M\n    join_buffer_size = 8M\n    key_buffer_size = 4M\n    \n    thread_cache_size = 8\n    \n    query_cache_type = 1\n    query_cache_size = 8M\n    query_cache_limit = 2M\n    \n    ft_min_word_len = 4\n    \n    log_bin = mysql-bin\n    binlog_format = mixed\n    expire_logs_days = 30\n    \n    slow_query_log = 1\n    long_query_time = 1\n    slow_query_log_file = /home/mutian/dev/data/mysql/mysql-slow.log\n    \n    performance_schema = 0\n    explicit_defaults_for_timestamp\n    \n    #lower_case_table_names = 1\n    \n    skip-external-locking\n    \n    default_storage_engine = InnoDB\n    #default-storage-engine = MyISAM\n    innodb_file_per_table = 1\n    innodb_open_files = 500\n    innodb_buffer_pool_size = 64M\n    innodb_write_io_threads = 4\n    innodb_read_io_threads = 4\n    innodb_thread_concurrency = 0\n    innodb_purge_threads = 1\n    innodb_flush_log_at_trx_commit = 2\n    innodb_log_buffer_size = 2M\n    innodb_log_file_size = 32M\n    innodb_log_files_in_group = 3\n    innodb_max_dirty_pages_pct = 90\n    innodb_lock_wait_timeout = 120\n    \n    bulk_insert_buffer_size = 8M\n    myisam_sort_buffer_size = 8M\n    myisam_max_sort_file_size = 10G\n    myisam_repair_threads = 1\n    \n    interactive_timeout = 28800\n    wait_timeout = 28800\n    \n    [mysqldump]\n    quick\n    max_allowed_packet = 16M\n    \n    [myisamchk]\n    key_buffer_size = 8M\n    sort_buffer_size = 8M\n    read_buffer = 4M\n    write_buffer = 4M\n\n4.目录权限修改\n\n    chown -R mysql:mysql /server/mysql\n    chown -R mysql:mysql /server/data/mysql\n    chmod 755 /server/mysql -R\n    chmod 755 /server/data/mysql -R\n\n5.初始化\n\n    bin/mysqld --initialize --user=mysql\n    bin/mysql_ssl_rsa_setup\n\n6.启动mysql\n\n    bin/mysqld_safe --user=mysql &\n\n7.修改账号密码\n\n- 如果出现错误：\n\n       ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)\n       \n说明服务没启动成功。     \n\n- 错误： \n\n       [root@ymu mysql]# bin/mysql  -uroot -p\n       Enter password: \n       ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)\n\n空密码无法登录。\n\n处理（修改密码）： \n\n    bin/mysqld_safe --user=mysql --skip-grant-tables &\n     \n    mysql -uroot -p     //密码，直接按回车登录\n    use mysql;\n    select host, user, authentication_string, plugin from user; \n    update user set authentication_string='' where user='root';\n    flush privileges;\n    //更更改密码\n    ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    quit;\n    \n    ------------------------------\n    如果执行\n    ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    报错误。\n    \n    按下面处理，执行：flush privileges;然后在执行更改密码语句就ok了：\n    mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\n    mysql> \n    mysql> flush privileges;\n    Query OK, 0 rows affected (0.01 sec)\n    \n    mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    Query OK, 0 rows affected (0.06 sec)\n    \n    mysql>   \n    \n    如果报错如下信息：\n    Error: Cannot retrieve repository metadata (repomd.xml) for repository: InstallMedia. Please verify its path and try again\n     You could try using --skip-broken to work around the problem\n     You could try running: rpm -Va --nofiles --nodigest\n    \n    我们只要到/etc/yum.repo.s下面把packetxxxx.repo和redhat.repo两个文件删除掉，再启动就可以了， \n    \n    ------------------------------------------\n    查看密码是否已经重置：\n    mysql> select host, user, authentication_string, plugin from user;\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    | host      | user             | authentication_string                                                  | plugin                |\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    | localhost | mysql.infoschema | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | root             | $A$005$ }DQPo%'\u0004:5\u0006'_\u001d#-QhPn/ZULDCRuo2Xh8w2uhS1.zZ/U.W8d7zWwlmpTB3D5 | caching_sha2_password |\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    4 rows in set (0.00 sec)\n    \n    可以看到root用户的密码已经更改。然后重启mysql登录试试。\n    \n    --------------------------\n    客户端连接报错：客户端连接caching-sha2-password问题。\n    这是因为msyql8对密码加密的规则导致，navicat不支持。所以，需要更改加密规则：\n    \n    在服务器，通过mysql客户端登入：\n    [root@ymu ~]# mysql -uroot -p\n    \n    #修改加密规则  \n    ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; \n    或者：\n    ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; \n    \n    #更新密码（mysql_native_password模式）    \n    ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';\n    或者：\n    ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';\n\n    实际操作过程：\n    mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'ymu123@' PASSWORD EXPIRE NEVER;\n    ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'localhost'\n    mysql> ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;\n    Query OK, 0 rows affected (0.05 sec)\n    \n    mysql> ALTER USER 'root'@'*' IDENTIFIED WITH mysql_native_password BY 'ymu123@';\n    ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'*'\n    mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'ymu123@';\n    Query OK, 0 rows affected (0.10 sec)\n\n    \n设置密码不能是`123456`这些简单的密码，会通不过。所以设置复杂点`ymu123@`。     \n     \n表格中有以下信息：  \nhost: 允许用户登录的 ip ‘位置’ % 表示可以远程；  \nuser: 当前数据库的用户名；    \nauthentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）；  \nplugin： 密码加密方式；  \n\n然后重启就可以登录了。 \n\n参考： https://blog.csdn.net/xinpengfei521/article/details/80400142    \n     \n8.创建软链接（非必要）\n\n    ln -s /server/mysql/bin/* /usr/local/bin/\n\n9.添加到启动（非必要）\n\n开启自动启动mysql：\n\n    cp support-files/mysql.server /etc/init.d/mysql.server\n    chmod +x /etc/init.d/mysql.server\n    chkconfig --add mysql.server\n    chkconfig mysql.server on\n    \n    ------ 参考来源 ----\n    /bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n    chmod +x /etc/init.d/mysqld\n    chkconfig --add mysqld\n    chkconfig mysqld on\n    \n10.查看启动状态、启动、停止、重启\n\n`mysql.server`对应上面设置自启动的：`/etc/init.d/mysql.server`\n\n查看状态：\n\n`systemctl status mysql.server.service`  \n\n或者：\n`service mysql.server status`\n\n停止：`service mysql.server stop`\n\n启动：`service mysql.server start`\n\n重新启动：`service mysql.server reload`\n\n  \n    \n## 二进制安装包rpm安装（推荐）    \n                  ","source":"_posts/centos-mysql-install.md","raw":"---\ntitle: centos7下安装mysql8\ndate: 2018-07-27 22:57:16\ncategories: CentOs\ntags: mysql mysql8\n---\n\n本文介绍在centos7.4下源码编译安装msyql8的步骤……\n\n参考：https://www.linuxidc.com/Linux/2018-04/152010.htm\n\n## 源码编译安装\n\n### 安装前清理\n\n1. 清理旧的mysql\n\n        rpm -pa | grep mysql\n        \n        yum remove mysql-xxx-xxx-\n        \n2. 删除旧的mysql配置文件，卸载不会自动删除。\n\n        find / -name mysql\n     \n显示： \n\n    /etc/logrotate.d/mysql\n    /etc/selinux/targeted/active/modules/100/mysql\n    /etc/selinux/targeted/tmp/modules/100/mysql\n    /var/lib/mysql\n    /var/lib/mysql/mysql\n    /usr/bin/mysql\n    /usr/lib64/mysql\n    /usr/local/mysql\n\n根据需求使用以下命令 依次 对配置文件进行删除\n\n    rm -rf /var/lib/mysql\n    \n3. 卸载当前系统中已安装的mariadb。centos7中默认安装，会和mysql冲突。\n\n\n    rpm -qa | grep mariadb  （查找）\n    \n    rpm -e mysql*/mariadb*\n    \n    rpm -e --nodeps mysql*/mariadb*  （强制删除）\n    \n    ----------------------\n    [root@ymu ~]# rpm -qa | grep mariadb\n    mariadb-libs-5.5.56-2.el7.x86_64\n    [root@ymu ~]# rpm -e mysql*/mariadb*\n    error: package mysql*/mariadb* is not installed\n    [root@ymu ~]# rpm -e --nodeps mysql*/mariadb*  \n    error: package mysql*/mariadb* is not installed\n    [root@ymu ~]# rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\n              \n\n### 准备工作\n\n1.安装依赖\n\n    yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel\n        \n2.下载源码包\n\n下载网址： https://dev.mysql.com\n\n    wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)\n     \n         \n3.创建mysql用户\n\n    groupadd mysql\n    useradd -r -g mysql -s /bin/false mysql\n    \n   \n4.创建安装目录和数据目录\n\n    mkdir -p /server/mysql\n    mkdir -p /server/data/mysql\n    \n### 安装mysql\n\n1.解压源码包\n\n    [root@ymu tools]# tar -zxvf mysql-boost-8.0.11.tar.gz \n    \n2.编译&安装\n\n    [root@ymu tools]# cd mysql-8.0.11/\n    [root@ymu mysql-8.0.11]# cmake .  -DCMAKE_INSTALL_PREFIX=/server/mysql \\\n    > -DMYSQL_DATADIR=/server/data/mysql/ \\\n    > -DDEFAULT_CHARSET=utf8mb4 \\\n    > -DDEFAULT_COLLATION=utf8mb4_general_ci \\\n    > -DWITH_BOOST=/server/tools/mysql-8.0.11/boost/\n       \n    [root@ymu mysql-8.0.11]# make && make install   \n    \n3.配置my.cnf文件\n\n可能找不到该文件，如果没有，新建一个。 \n\n          cat /etc/my.cnf\n          [mysqld]\n          server-id=1\n          port=3306\n          basedir=/server/mysql8\n          datadir=/server/data/mysql8\n    　　　 ##请根据实际情况添加参数\n    \n更改： \n\n    [client]\n    port = 3307\n    socket = /tmp/mysql.sock\n    default-character-set = utf8mb4\n    \n    [mysqld]\n    port=3307\n    socket=/tmp/mysql.sock\n    \n    [mysql.server]\n    server-id=1\n    basedir=/server/mysql\n    datadir=/server/data/mysql\n    pid-file=/server/data/mysql/mysql.pid\n    \n    character-set-server = utf8mb4\n    \n    slow_query_log=1\n    long_query_time=5\n    slow_query_log_file=/server/data/mysql/mysql-slow.log\n    \n    default_storage_engine=InnoDB\n    innodb_file_per_table = 1\n    innodb_open_files = 500\n    innodb_buffer_pool_size = 64M\n    innodb_write_io_threads = 4\n    innodb_read_io_threads = 4\n    innodb_thread_concurrency = 0\n    innodb_purge_threads = 1\n    innodb_flush_log_at_trx_commit = 2\n    innodb_log_buffer_size = 2M\n    innodb_log_file_size = 32M\n    innodb_log_files_in_group = 3\n    innodb_max_dirty_pages_pct = 90\n    innodb_lock_wait_timeout = 120\n\n    \n\n参考：\n\n    [client]\n    port = 3307\n    socket = ~/tmp/mysql.sock\n    default-character-set = utf8mb4\n    \n    [mysqld]\n    port = 3307\n    socket = /home/mutian/tmp/mysql.sock\n    \n    [mysql.server]\n    basedir = /home/mutian/dev/tools/mysql\n    datadir = /home/mutian/dev/data/mysql\n    pid-file = /home/mutian/dev/data/mysql/mysql.pid\n    user = mysql\n    bind-address = 0.0.0.0\n    server-id = 1\n    \n    init-connect = 'SET NAMES utf8mb4'\n    character-set-server = utf8mb4\n    \n    #skip-name-resolve\n    #skip-networking\n    back_log = 300\n    \n    max_connections = 1000\n    max_connect_errors = 6000\n    open_files_limit = 65535\n    table_open_cache = 128\n    max_allowed_packet = 4M\n    binlog_cache_size = 1M\n    max_heap_table_size = 8M\n    tmp_table_size = 16M\n    \n    read_buffer_size = 2M\n    read_rnd_buffer_size = 8M\n    sort_buffer_size = 8M\n    join_buffer_size = 8M\n    key_buffer_size = 4M\n    \n    thread_cache_size = 8\n    \n    query_cache_type = 1\n    query_cache_size = 8M\n    query_cache_limit = 2M\n    \n    ft_min_word_len = 4\n    \n    log_bin = mysql-bin\n    binlog_format = mixed\n    expire_logs_days = 30\n    \n    slow_query_log = 1\n    long_query_time = 1\n    slow_query_log_file = /home/mutian/dev/data/mysql/mysql-slow.log\n    \n    performance_schema = 0\n    explicit_defaults_for_timestamp\n    \n    #lower_case_table_names = 1\n    \n    skip-external-locking\n    \n    default_storage_engine = InnoDB\n    #default-storage-engine = MyISAM\n    innodb_file_per_table = 1\n    innodb_open_files = 500\n    innodb_buffer_pool_size = 64M\n    innodb_write_io_threads = 4\n    innodb_read_io_threads = 4\n    innodb_thread_concurrency = 0\n    innodb_purge_threads = 1\n    innodb_flush_log_at_trx_commit = 2\n    innodb_log_buffer_size = 2M\n    innodb_log_file_size = 32M\n    innodb_log_files_in_group = 3\n    innodb_max_dirty_pages_pct = 90\n    innodb_lock_wait_timeout = 120\n    \n    bulk_insert_buffer_size = 8M\n    myisam_sort_buffer_size = 8M\n    myisam_max_sort_file_size = 10G\n    myisam_repair_threads = 1\n    \n    interactive_timeout = 28800\n    wait_timeout = 28800\n    \n    [mysqldump]\n    quick\n    max_allowed_packet = 16M\n    \n    [myisamchk]\n    key_buffer_size = 8M\n    sort_buffer_size = 8M\n    read_buffer = 4M\n    write_buffer = 4M\n\n4.目录权限修改\n\n    chown -R mysql:mysql /server/mysql\n    chown -R mysql:mysql /server/data/mysql\n    chmod 755 /server/mysql -R\n    chmod 755 /server/data/mysql -R\n\n5.初始化\n\n    bin/mysqld --initialize --user=mysql\n    bin/mysql_ssl_rsa_setup\n\n6.启动mysql\n\n    bin/mysqld_safe --user=mysql &\n\n7.修改账号密码\n\n- 如果出现错误：\n\n       ERROR 2002 (HY000): Can't connect to local MySQL server through socket '/tmp/mysql.sock' (2)\n       \n说明服务没启动成功。     \n\n- 错误： \n\n       [root@ymu mysql]# bin/mysql  -uroot -p\n       Enter password: \n       ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)\n\n空密码无法登录。\n\n处理（修改密码）： \n\n    bin/mysqld_safe --user=mysql --skip-grant-tables &\n     \n    mysql -uroot -p     //密码，直接按回车登录\n    use mysql;\n    select host, user, authentication_string, plugin from user; \n    update user set authentication_string='' where user='root';\n    flush privileges;\n    //更更改密码\n    ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    quit;\n    \n    ------------------------------\n    如果执行\n    ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    报错误。\n    \n    按下面处理，执行：flush privileges;然后在执行更改密码语句就ok了：\n    mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    ERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\n    mysql> \n    mysql> flush privileges;\n    Query OK, 0 rows affected (0.01 sec)\n    \n    mysql> ALTER user 'root'@'localhost' IDENTIFIED BY 'ymu123@';\n    Query OK, 0 rows affected (0.06 sec)\n    \n    mysql>   \n    \n    如果报错如下信息：\n    Error: Cannot retrieve repository metadata (repomd.xml) for repository: InstallMedia. Please verify its path and try again\n     You could try using --skip-broken to work around the problem\n     You could try running: rpm -Va --nofiles --nodigest\n    \n    我们只要到/etc/yum.repo.s下面把packetxxxx.repo和redhat.repo两个文件删除掉，再启动就可以了， \n    \n    ------------------------------------------\n    查看密码是否已经重置：\n    mysql> select host, user, authentication_string, plugin from user;\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    | host      | user             | authentication_string                                                  | plugin                |\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    | localhost | mysql.infoschema | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n    | localhost | root             | $A$005$ }DQPo%'\u0004:5\u0006'_\u001d#-QhPn/ZULDCRuo2Xh8w2uhS1.zZ/U.W8d7zWwlmpTB3D5 | caching_sha2_password |\n    +-----------+------------------+------------------------------------------------------------------------+-----------------------+\n    4 rows in set (0.00 sec)\n    \n    可以看到root用户的密码已经更改。然后重启mysql登录试试。\n    \n    --------------------------\n    客户端连接报错：客户端连接caching-sha2-password问题。\n    这是因为msyql8对密码加密的规则导致，navicat不支持。所以，需要更改加密规则：\n    \n    在服务器，通过mysql客户端登入：\n    [root@ymu ~]# mysql -uroot -p\n    \n    #修改加密规则  \n    ALTER USER 'root'@'localhost' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; \n    或者：\n    ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER; \n    \n    #更新密码（mysql_native_password模式）    \n    ALTER USER 'root'@'localhost' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';\n    或者：\n    ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY '{NewPassword}';\n\n    实际操作过程：\n    mysql> ALTER USER 'root'@'localhost' IDENTIFIED BY 'ymu123@' PASSWORD EXPIRE NEVER;\n    ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'localhost'\n    mysql> ALTER USER 'root'@'%' IDENTIFIED BY 'password' PASSWORD EXPIRE NEVER;\n    Query OK, 0 rows affected (0.05 sec)\n    \n    mysql> ALTER USER 'root'@'*' IDENTIFIED WITH mysql_native_password BY 'ymu123@';\n    ERROR 1396 (HY000): Operation ALTER USER failed for 'root'@'*'\n    mysql> ALTER USER 'root'@'%' IDENTIFIED WITH mysql_native_password BY 'ymu123@';\n    Query OK, 0 rows affected (0.10 sec)\n\n    \n设置密码不能是`123456`这些简单的密码，会通不过。所以设置复杂点`ymu123@`。     \n     \n表格中有以下信息：  \nhost: 允许用户登录的 ip ‘位置’ % 表示可以远程；  \nuser: 当前数据库的用户名；    \nauthentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）；  \nplugin： 密码加密方式；  \n\n然后重启就可以登录了。 \n\n参考： https://blog.csdn.net/xinpengfei521/article/details/80400142    \n     \n8.创建软链接（非必要）\n\n    ln -s /server/mysql/bin/* /usr/local/bin/\n\n9.添加到启动（非必要）\n\n开启自动启动mysql：\n\n    cp support-files/mysql.server /etc/init.d/mysql.server\n    chmod +x /etc/init.d/mysql.server\n    chkconfig --add mysql.server\n    chkconfig mysql.server on\n    \n    ------ 参考来源 ----\n    /bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\n    chmod +x /etc/init.d/mysqld\n    chkconfig --add mysqld\n    chkconfig mysqld on\n    \n10.查看启动状态、启动、停止、重启\n\n`mysql.server`对应上面设置自启动的：`/etc/init.d/mysql.server`\n\n查看状态：\n\n`systemctl status mysql.server.service`  \n\n或者：\n`service mysql.server status`\n\n停止：`service mysql.server stop`\n\n启动：`service mysql.server start`\n\n重新启动：`service mysql.server reload`\n\n  \n    \n## 二进制安装包rpm安装（推荐）    \n                  ","slug":"centos-mysql-install","published":1,"updated":"2018-11-09T01:20:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38kq004uqcrgzsk7wyao","content":"<p>本文介绍在centos7.4下源码编译安装msyql8的步骤……</p>\n<p>参考：<a href=\"https://www.linuxidc.com/Linux/2018-04/152010.htm\" target=\"_blank\" rel=\"noopener\">https://www.linuxidc.com/Linux/2018-04/152010.htm</a></p>\n<h2 id=\"源码编译安装\"><a href=\"#源码编译安装\" class=\"headerlink\" title=\"源码编译安装\"></a>源码编译安装</h2><h3 id=\"安装前清理\"><a href=\"#安装前清理\" class=\"headerlink\" title=\"安装前清理\"></a>安装前清理</h3><ol>\n<li><p>清理旧的mysql</p>\n<pre><code>rpm -pa | grep mysql\n\nyum remove mysql-xxx-xxx-\n</code></pre></li>\n<li><p>删除旧的mysql配置文件，卸载不会自动删除。</p>\n<pre><code>find / -name mysql\n</code></pre></li>\n</ol>\n<p>显示： </p>\n<pre><code>/etc/logrotate.d/mysql\n/etc/selinux/targeted/active/modules/100/mysql\n/etc/selinux/targeted/tmp/modules/100/mysql\n/var/lib/mysql\n/var/lib/mysql/mysql\n/usr/bin/mysql\n/usr/lib64/mysql\n/usr/local/mysql\n</code></pre><p>根据需求使用以下命令 依次 对配置文件进行删除</p>\n<pre><code>rm -rf /var/lib/mysql\n</code></pre><ol start=\"3\">\n<li>卸载当前系统中已安装的mariadb。centos7中默认安装，会和mysql冲突。</li>\n</ol>\n<pre><code>rpm -qa | grep mariadb  （查找）\n\nrpm -e mysql*/mariadb*\n\nrpm -e --nodeps mysql*/mariadb*  （强制删除）\n\n----------------------\n[root@ymu ~]# rpm -qa | grep mariadb\nmariadb-libs-5.5.56-2.el7.x86_64\n[root@ymu ~]# rpm -e mysql*/mariadb*\nerror: package mysql*/mariadb* is not installed\n[root@ymu ~]# rpm -e --nodeps mysql*/mariadb*  \nerror: package mysql*/mariadb* is not installed\n[root@ymu ~]# rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\n</code></pre><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>1.安装依赖</p>\n<pre><code>yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel\n</code></pre><p>2.下载源码包</p>\n<p>下载网址： <a href=\"https://dev.mysql.com\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com</a></p>\n<pre><code>wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)\n</code></pre><p>3.创建mysql用户</p>\n<pre><code>groupadd mysql\nuseradd -r -g mysql -s /bin/false mysql\n</code></pre><p>4.创建安装目录和数据目录</p>\n<pre><code>mkdir -p /server/mysql\nmkdir -p /server/data/mysql\n</code></pre><h3 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h3><p>1.解压源码包</p>\n<pre><code>[root@ymu tools]# tar -zxvf mysql-boost-8.0.11.tar.gz \n</code></pre><p>2.编译&amp;安装</p>\n<pre><code>[root@ymu tools]# cd mysql-8.0.11/\n[root@ymu mysql-8.0.11]# cmake .  -DCMAKE_INSTALL_PREFIX=/server/mysql \\\n&gt; -DMYSQL_DATADIR=/server/data/mysql/ \\\n&gt; -DDEFAULT_CHARSET=utf8mb4 \\\n&gt; -DDEFAULT_COLLATION=utf8mb4_general_ci \\\n&gt; -DWITH_BOOST=/server/tools/mysql-8.0.11/boost/\n\n[root@ymu mysql-8.0.11]# make &amp;&amp; make install   \n</code></pre><p>3.配置my.cnf文件</p>\n<p>可能找不到该文件，如果没有，新建一个。 </p>\n<pre><code>cat /etc/my.cnf\n[mysqld]\nserver-id=1\nport=3306\nbasedir=/server/mysql8\ndatadir=/server/data/mysql8\n　　　 ##请根据实际情况添加参数\n</code></pre><p>更改： </p>\n<pre><code>[client]\nport = 3307\nsocket = /tmp/mysql.sock\ndefault-character-set = utf8mb4\n\n[mysqld]\nport=3307\nsocket=/tmp/mysql.sock\n\n[mysql.server]\nserver-id=1\nbasedir=/server/mysql\ndatadir=/server/data/mysql\npid-file=/server/data/mysql/mysql.pid\n\ncharacter-set-server = utf8mb4\n\nslow_query_log=1\nlong_query_time=5\nslow_query_log_file=/server/data/mysql/mysql-slow.log\n\ndefault_storage_engine=InnoDB\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\n</code></pre><p>参考：</p>\n<pre><code>[client]\nport = 3307\nsocket = ~/tmp/mysql.sock\ndefault-character-set = utf8mb4\n\n[mysqld]\nport = 3307\nsocket = /home/mutian/tmp/mysql.sock\n\n[mysql.server]\nbasedir = /home/mutian/dev/tools/mysql\ndatadir = /home/mutian/dev/data/mysql\npid-file = /home/mutian/dev/data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1\n\ninit-connect = &apos;SET NAMES utf8mb4&apos;\ncharacter-set-server = utf8mb4\n\n#skip-name-resolve\n#skip-networking\nback_log = 300\n\nmax_connections = 1000\nmax_connect_errors = 6000\nopen_files_limit = 65535\ntable_open_cache = 128\nmax_allowed_packet = 4M\nbinlog_cache_size = 1M\nmax_heap_table_size = 8M\ntmp_table_size = 16M\n\nread_buffer_size = 2M\nread_rnd_buffer_size = 8M\nsort_buffer_size = 8M\njoin_buffer_size = 8M\nkey_buffer_size = 4M\n\nthread_cache_size = 8\n\nquery_cache_type = 1\nquery_cache_size = 8M\nquery_cache_limit = 2M\n\nft_min_word_len = 4\n\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30\n\nslow_query_log = 1\nlong_query_time = 1\nslow_query_log_file = /home/mutian/dev/data/mysql/mysql-slow.log\n\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n\n#lower_case_table_names = 1\n\nskip-external-locking\n\ndefault_storage_engine = InnoDB\n#default-storage-engine = MyISAM\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\n\nbulk_insert_buffer_size = 8M\nmyisam_sort_buffer_size = 8M\nmyisam_max_sort_file_size = 10G\nmyisam_repair_threads = 1\n\ninteractive_timeout = 28800\nwait_timeout = 28800\n\n[mysqldump]\nquick\nmax_allowed_packet = 16M\n\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\n</code></pre><p>4.目录权限修改</p>\n<pre><code>chown -R mysql:mysql /server/mysql\nchown -R mysql:mysql /server/data/mysql\nchmod 755 /server/mysql -R\nchmod 755 /server/data/mysql -R\n</code></pre><p>5.初始化</p>\n<pre><code>bin/mysqld --initialize --user=mysql\nbin/mysql_ssl_rsa_setup\n</code></pre><p>6.启动mysql</p>\n<pre><code>bin/mysqld_safe --user=mysql &amp;\n</code></pre><p>7.修改账号密码</p>\n<ul>\n<li><p>如果出现错误：</p>\n<pre><code>ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2)\n</code></pre></li>\n</ul>\n<p>说明服务没启动成功。     </p>\n<ul>\n<li><p>错误： </p>\n<pre><code>[root@ymu mysql]# bin/mysql  -uroot -p\nEnter password: \nERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)\n</code></pre></li>\n</ul>\n<p>空密码无法登录。</p>\n<p>处理（修改密码）： </p>\n<pre><code>bin/mysqld_safe --user=mysql --skip-grant-tables &amp;\n\nmysql -uroot -p     //密码，直接按回车登录\nuse mysql;\nselect host, user, authentication_string, plugin from user; \nupdate user set authentication_string=&apos;&apos; where user=&apos;root&apos;;\nflush privileges;\n//更更改密码\nALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nquit;\n\n------------------------------\n如果执行\nALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\n报错误。\n\n按下面处理，执行：flush privileges;然后在执行更改密码语句就ok了：\nmysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\nmysql&gt; \nmysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nQuery OK, 0 rows affected (0.06 sec)\n\nmysql&gt;   \n\n如果报错如下信息：\nError: Cannot retrieve repository metadata (repomd.xml) for repository: InstallMedia. Please verify its path and try again\n You could try using --skip-broken to work around the problem\n You could try running: rpm -Va --nofiles --nodigest\n\n我们只要到/etc/yum.repo.s下面把packetxxxx.repo和redhat.repo两个文件删除掉，再启动就可以了， \n\n------------------------------------------\n查看密码是否已经重置：\nmysql&gt; select host, user, authentication_string, plugin from user;\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n| host      | user             | authentication_string                                                  | plugin                |\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n| localhost | mysql.infoschema | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | root             | $A$005$ }DQPo%&apos;\u0004:5\u0006&apos;_\u001d#-QhPn/ZULDCRuo2Xh8w2uhS1.zZ/U.W8d7zWwlmpTB3D5 | caching_sha2_password |\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n4 rows in set (0.00 sec)\n\n可以看到root用户的密码已经更改。然后重启mysql登录试试。\n\n--------------------------\n客户端连接报错：客户端连接caching-sha2-password问题。\n这是因为msyql8对密码加密的规则导致，navicat不支持。所以，需要更改加密规则：\n\n在服务器，通过mysql客户端登入：\n[root@ymu ~]# mysql -uroot -p\n\n#修改加密规则  \nALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; \n或者：\nALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; \n\n#更新密码（mysql_native_password模式）    \nALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;{NewPassword}&apos;;\n或者：\nALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;{NewPassword}&apos;;\n\n实际操作过程：\nmysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos; PASSWORD EXPIRE NEVER;\nERROR 1396 (HY000): Operation ALTER USER failed for &apos;root&apos;@&apos;localhost&apos;\nmysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER;\nQuery OK, 0 rows affected (0.05 sec)\n\nmysql&gt; ALTER USER &apos;root&apos;@&apos;*&apos; IDENTIFIED WITH mysql_native_password BY &apos;ymu123@&apos;;\nERROR 1396 (HY000): Operation ALTER USER failed for &apos;root&apos;@&apos;*&apos;\nmysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;ymu123@&apos;;\nQuery OK, 0 rows affected (0.10 sec)\n</code></pre><p>设置密码不能是<code>123456</code>这些简单的密码，会通不过。所以设置复杂点<code>ymu123@</code>。     </p>\n<p>表格中有以下信息：<br>host: 允许用户登录的 ip ‘位置’ % 表示可以远程；<br>user: 当前数据库的用户名；<br>authentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）；<br>plugin： 密码加密方式；  </p>\n<p>然后重启就可以登录了。 </p>\n<p>参考： <a href=\"https://blog.csdn.net/xinpengfei521/article/details/80400142\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xinpengfei521/article/details/80400142</a>    </p>\n<p>8.创建软链接（非必要）</p>\n<pre><code>ln -s /server/mysql/bin/* /usr/local/bin/\n</code></pre><p>9.添加到启动（非必要）</p>\n<p>开启自动启动mysql：</p>\n<pre><code>cp support-files/mysql.server /etc/init.d/mysql.server\nchmod +x /etc/init.d/mysql.server\nchkconfig --add mysql.server\nchkconfig mysql.server on\n\n------ 参考来源 ----\n/bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\nchmod +x /etc/init.d/mysqld\nchkconfig --add mysqld\nchkconfig mysqld on\n</code></pre><p>10.查看启动状态、启动、停止、重启</p>\n<p><code>mysql.server</code>对应上面设置自启动的：<code>/etc/init.d/mysql.server</code></p>\n<p>查看状态：</p>\n<p><code>systemctl status mysql.server.service</code>  </p>\n<p>或者：<br><code>service mysql.server status</code></p>\n<p>停止：<code>service mysql.server stop</code></p>\n<p>启动：<code>service mysql.server start</code></p>\n<p>重新启动：<code>service mysql.server reload</code></p>\n<h2 id=\"二进制安装包rpm安装（推荐）\"><a href=\"#二进制安装包rpm安装（推荐）\" class=\"headerlink\" title=\"二进制安装包rpm安装（推荐）\"></a>二进制安装包rpm安装（推荐）</h2>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在centos7.4下源码编译安装msyql8的步骤……</p>\n<p>参考：<a href=\"https://www.linuxidc.com/Linux/2018-04/152010.htm\" target=\"_blank\" rel=\"noopener\">https://www.linuxidc.com/Linux/2018-04/152010.htm</a></p>\n<h2 id=\"源码编译安装\"><a href=\"#源码编译安装\" class=\"headerlink\" title=\"源码编译安装\"></a>源码编译安装</h2><h3 id=\"安装前清理\"><a href=\"#安装前清理\" class=\"headerlink\" title=\"安装前清理\"></a>安装前清理</h3><ol>\n<li><p>清理旧的mysql</p>\n<pre><code>rpm -pa | grep mysql\n\nyum remove mysql-xxx-xxx-\n</code></pre></li>\n<li><p>删除旧的mysql配置文件，卸载不会自动删除。</p>\n<pre><code>find / -name mysql\n</code></pre></li>\n</ol>\n<p>显示： </p>\n<pre><code>/etc/logrotate.d/mysql\n/etc/selinux/targeted/active/modules/100/mysql\n/etc/selinux/targeted/tmp/modules/100/mysql\n/var/lib/mysql\n/var/lib/mysql/mysql\n/usr/bin/mysql\n/usr/lib64/mysql\n/usr/local/mysql\n</code></pre><p>根据需求使用以下命令 依次 对配置文件进行删除</p>\n<pre><code>rm -rf /var/lib/mysql\n</code></pre><ol start=\"3\">\n<li>卸载当前系统中已安装的mariadb。centos7中默认安装，会和mysql冲突。</li>\n</ol>\n<pre><code>rpm -qa | grep mariadb  （查找）\n\nrpm -e mysql*/mariadb*\n\nrpm -e --nodeps mysql*/mariadb*  （强制删除）\n\n----------------------\n[root@ymu ~]# rpm -qa | grep mariadb\nmariadb-libs-5.5.56-2.el7.x86_64\n[root@ymu ~]# rpm -e mysql*/mariadb*\nerror: package mysql*/mariadb* is not installed\n[root@ymu ~]# rpm -e --nodeps mysql*/mariadb*  \nerror: package mysql*/mariadb* is not installed\n[root@ymu ~]# rpm -e --nodeps mariadb-libs-5.5.56-2.el7.x86_64\n</code></pre><h3 id=\"准备工作\"><a href=\"#准备工作\" class=\"headerlink\" title=\"准备工作\"></a>准备工作</h3><p>1.安装依赖</p>\n<pre><code>yum -y install wget  cmake gcc gcc-c++ ncurses  ncurses-devel  libaio-devel  openssl openssl-devel\n</code></pre><p>2.下载源码包</p>\n<p>下载网址： <a href=\"https://dev.mysql.com\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com</a></p>\n<pre><code>wget https://cdn.mysql.com//Downloads/MySQL-8.0/mysql-boost-8.0.11.tar.gz      (此版本带有boost)\n</code></pre><p>3.创建mysql用户</p>\n<pre><code>groupadd mysql\nuseradd -r -g mysql -s /bin/false mysql\n</code></pre><p>4.创建安装目录和数据目录</p>\n<pre><code>mkdir -p /server/mysql\nmkdir -p /server/data/mysql\n</code></pre><h3 id=\"安装mysql\"><a href=\"#安装mysql\" class=\"headerlink\" title=\"安装mysql\"></a>安装mysql</h3><p>1.解压源码包</p>\n<pre><code>[root@ymu tools]# tar -zxvf mysql-boost-8.0.11.tar.gz \n</code></pre><p>2.编译&amp;安装</p>\n<pre><code>[root@ymu tools]# cd mysql-8.0.11/\n[root@ymu mysql-8.0.11]# cmake .  -DCMAKE_INSTALL_PREFIX=/server/mysql \\\n&gt; -DMYSQL_DATADIR=/server/data/mysql/ \\\n&gt; -DDEFAULT_CHARSET=utf8mb4 \\\n&gt; -DDEFAULT_COLLATION=utf8mb4_general_ci \\\n&gt; -DWITH_BOOST=/server/tools/mysql-8.0.11/boost/\n\n[root@ymu mysql-8.0.11]# make &amp;&amp; make install   \n</code></pre><p>3.配置my.cnf文件</p>\n<p>可能找不到该文件，如果没有，新建一个。 </p>\n<pre><code>cat /etc/my.cnf\n[mysqld]\nserver-id=1\nport=3306\nbasedir=/server/mysql8\ndatadir=/server/data/mysql8\n　　　 ##请根据实际情况添加参数\n</code></pre><p>更改： </p>\n<pre><code>[client]\nport = 3307\nsocket = /tmp/mysql.sock\ndefault-character-set = utf8mb4\n\n[mysqld]\nport=3307\nsocket=/tmp/mysql.sock\n\n[mysql.server]\nserver-id=1\nbasedir=/server/mysql\ndatadir=/server/data/mysql\npid-file=/server/data/mysql/mysql.pid\n\ncharacter-set-server = utf8mb4\n\nslow_query_log=1\nlong_query_time=5\nslow_query_log_file=/server/data/mysql/mysql-slow.log\n\ndefault_storage_engine=InnoDB\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\n</code></pre><p>参考：</p>\n<pre><code>[client]\nport = 3307\nsocket = ~/tmp/mysql.sock\ndefault-character-set = utf8mb4\n\n[mysqld]\nport = 3307\nsocket = /home/mutian/tmp/mysql.sock\n\n[mysql.server]\nbasedir = /home/mutian/dev/tools/mysql\ndatadir = /home/mutian/dev/data/mysql\npid-file = /home/mutian/dev/data/mysql/mysql.pid\nuser = mysql\nbind-address = 0.0.0.0\nserver-id = 1\n\ninit-connect = &apos;SET NAMES utf8mb4&apos;\ncharacter-set-server = utf8mb4\n\n#skip-name-resolve\n#skip-networking\nback_log = 300\n\nmax_connections = 1000\nmax_connect_errors = 6000\nopen_files_limit = 65535\ntable_open_cache = 128\nmax_allowed_packet = 4M\nbinlog_cache_size = 1M\nmax_heap_table_size = 8M\ntmp_table_size = 16M\n\nread_buffer_size = 2M\nread_rnd_buffer_size = 8M\nsort_buffer_size = 8M\njoin_buffer_size = 8M\nkey_buffer_size = 4M\n\nthread_cache_size = 8\n\nquery_cache_type = 1\nquery_cache_size = 8M\nquery_cache_limit = 2M\n\nft_min_word_len = 4\n\nlog_bin = mysql-bin\nbinlog_format = mixed\nexpire_logs_days = 30\n\nslow_query_log = 1\nlong_query_time = 1\nslow_query_log_file = /home/mutian/dev/data/mysql/mysql-slow.log\n\nperformance_schema = 0\nexplicit_defaults_for_timestamp\n\n#lower_case_table_names = 1\n\nskip-external-locking\n\ndefault_storage_engine = InnoDB\n#default-storage-engine = MyISAM\ninnodb_file_per_table = 1\ninnodb_open_files = 500\ninnodb_buffer_pool_size = 64M\ninnodb_write_io_threads = 4\ninnodb_read_io_threads = 4\ninnodb_thread_concurrency = 0\ninnodb_purge_threads = 1\ninnodb_flush_log_at_trx_commit = 2\ninnodb_log_buffer_size = 2M\ninnodb_log_file_size = 32M\ninnodb_log_files_in_group = 3\ninnodb_max_dirty_pages_pct = 90\ninnodb_lock_wait_timeout = 120\n\nbulk_insert_buffer_size = 8M\nmyisam_sort_buffer_size = 8M\nmyisam_max_sort_file_size = 10G\nmyisam_repair_threads = 1\n\ninteractive_timeout = 28800\nwait_timeout = 28800\n\n[mysqldump]\nquick\nmax_allowed_packet = 16M\n\n[myisamchk]\nkey_buffer_size = 8M\nsort_buffer_size = 8M\nread_buffer = 4M\nwrite_buffer = 4M\n</code></pre><p>4.目录权限修改</p>\n<pre><code>chown -R mysql:mysql /server/mysql\nchown -R mysql:mysql /server/data/mysql\nchmod 755 /server/mysql -R\nchmod 755 /server/data/mysql -R\n</code></pre><p>5.初始化</p>\n<pre><code>bin/mysqld --initialize --user=mysql\nbin/mysql_ssl_rsa_setup\n</code></pre><p>6.启动mysql</p>\n<pre><code>bin/mysqld_safe --user=mysql &amp;\n</code></pre><p>7.修改账号密码</p>\n<ul>\n<li><p>如果出现错误：</p>\n<pre><code>ERROR 2002 (HY000): Can&apos;t connect to local MySQL server through socket &apos;/tmp/mysql.sock&apos; (2)\n</code></pre></li>\n</ul>\n<p>说明服务没启动成功。     </p>\n<ul>\n<li><p>错误： </p>\n<pre><code>[root@ymu mysql]# bin/mysql  -uroot -p\nEnter password: \nERROR 1045 (28000): Access denied for user &apos;root&apos;@&apos;localhost&apos; (using password: NO)\n</code></pre></li>\n</ul>\n<p>空密码无法登录。</p>\n<p>处理（修改密码）： </p>\n<pre><code>bin/mysqld_safe --user=mysql --skip-grant-tables &amp;\n\nmysql -uroot -p     //密码，直接按回车登录\nuse mysql;\nselect host, user, authentication_string, plugin from user; \nupdate user set authentication_string=&apos;&apos; where user=&apos;root&apos;;\nflush privileges;\n//更更改密码\nALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nquit;\n\n------------------------------\n如果执行\nALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\n报错误。\n\n按下面处理，执行：flush privileges;然后在执行更改密码语句就ok了：\nmysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nERROR 1290 (HY000): The MySQL server is running with the --skip-grant-tables option so it cannot execute this statement\nmysql&gt; \nmysql&gt; flush privileges;\nQuery OK, 0 rows affected (0.01 sec)\n\nmysql&gt; ALTER user &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos;;\nQuery OK, 0 rows affected (0.06 sec)\n\nmysql&gt;   \n\n如果报错如下信息：\nError: Cannot retrieve repository metadata (repomd.xml) for repository: InstallMedia. Please verify its path and try again\n You could try using --skip-broken to work around the problem\n You could try running: rpm -Va --nofiles --nodigest\n\n我们只要到/etc/yum.repo.s下面把packetxxxx.repo和redhat.repo两个文件删除掉，再启动就可以了， \n\n------------------------------------------\n查看密码是否已经重置：\nmysql&gt; select host, user, authentication_string, plugin from user;\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n| host      | user             | authentication_string                                                  | plugin                |\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n| localhost | mysql.infoschema | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | mysql.session    | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | mysql.sys        | *THISISNOTAVALIDPASSWORDTHATCANBEUSEDHERE                              | mysql_native_password |\n| localhost | root             | $A$005$ }DQPo%&apos;\u0004:5\u0006&apos;_\u001d#-QhPn/ZULDCRuo2Xh8w2uhS1.zZ/U.W8d7zWwlmpTB3D5 | caching_sha2_password |\n+-----------+------------------+------------------------------------------------------------------------+-----------------------+\n4 rows in set (0.00 sec)\n\n可以看到root用户的密码已经更改。然后重启mysql登录试试。\n\n--------------------------\n客户端连接报错：客户端连接caching-sha2-password问题。\n这是因为msyql8对密码加密的规则导致，navicat不支持。所以，需要更改加密规则：\n\n在服务器，通过mysql客户端登入：\n[root@ymu ~]# mysql -uroot -p\n\n#修改加密规则  \nALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; \n或者：\nALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER; \n\n#更新密码（mysql_native_password模式）    \nALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;{NewPassword}&apos;;\n或者：\nALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;{NewPassword}&apos;;\n\n实际操作过程：\nmysql&gt; ALTER USER &apos;root&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;ymu123@&apos; PASSWORD EXPIRE NEVER;\nERROR 1396 (HY000): Operation ALTER USER failed for &apos;root&apos;@&apos;localhost&apos;\nmysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED BY &apos;password&apos; PASSWORD EXPIRE NEVER;\nQuery OK, 0 rows affected (0.05 sec)\n\nmysql&gt; ALTER USER &apos;root&apos;@&apos;*&apos; IDENTIFIED WITH mysql_native_password BY &apos;ymu123@&apos;;\nERROR 1396 (HY000): Operation ALTER USER failed for &apos;root&apos;@&apos;*&apos;\nmysql&gt; ALTER USER &apos;root&apos;@&apos;%&apos; IDENTIFIED WITH mysql_native_password BY &apos;ymu123@&apos;;\nQuery OK, 0 rows affected (0.10 sec)\n</code></pre><p>设置密码不能是<code>123456</code>这些简单的密码，会通不过。所以设置复杂点<code>ymu123@</code>。     </p>\n<p>表格中有以下信息：<br>host: 允许用户登录的 ip ‘位置’ % 表示可以远程；<br>user: 当前数据库的用户名；<br>authentication_string: 用户密码（在mysql 5.7.9以后废弃了password字段和password()函数）；<br>plugin： 密码加密方式；  </p>\n<p>然后重启就可以登录了。 </p>\n<p>参考： <a href=\"https://blog.csdn.net/xinpengfei521/article/details/80400142\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/xinpengfei521/article/details/80400142</a>    </p>\n<p>8.创建软链接（非必要）</p>\n<pre><code>ln -s /server/mysql/bin/* /usr/local/bin/\n</code></pre><p>9.添加到启动（非必要）</p>\n<p>开启自动启动mysql：</p>\n<pre><code>cp support-files/mysql.server /etc/init.d/mysql.server\nchmod +x /etc/init.d/mysql.server\nchkconfig --add mysql.server\nchkconfig mysql.server on\n\n------ 参考来源 ----\n/bin/cp /usr/local/mysql/support-files/mysql.server /etc/init.d/mysqld\nchmod +x /etc/init.d/mysqld\nchkconfig --add mysqld\nchkconfig mysqld on\n</code></pre><p>10.查看启动状态、启动、停止、重启</p>\n<p><code>mysql.server</code>对应上面设置自启动的：<code>/etc/init.d/mysql.server</code></p>\n<p>查看状态：</p>\n<p><code>systemctl status mysql.server.service</code>  </p>\n<p>或者：<br><code>service mysql.server status</code></p>\n<p>停止：<code>service mysql.server stop</code></p>\n<p>启动：<code>service mysql.server start</code></p>\n<p>重新启动：<code>service mysql.server reload</code></p>\n<h2 id=\"二进制安装包rpm安装（推荐）\"><a href=\"#二进制安装包rpm安装（推荐）\" class=\"headerlink\" title=\"二进制安装包rpm安装（推荐）\"></a>二进制安装包rpm安装（推荐）</h2>"},{"title":"分布式ID生成-snowflake算法","date":"2017-09-20T03:06:57.000Z","_content":"## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","source":"_posts/distributed-id-snowflake.md","raw":"---\ntitle: 分布式ID生成-snowflake算法\ndate: 2017-09-20 11:06:57\ncategories: 分布式系统\ntags: snowflake算法\n---\n## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","slug":"distributed-id-snowflake","published":1,"updated":"2018-11-09T01:20:30.046Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38kr004vqcrgq7vgmmdt","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>"},{"title":"docker学习-第四课：容器","date":"2018-06-30T07:24:01.000Z","_content":"\n容器是`docker`的又一核心组件之一。  \n\n简单理解：容器就是独立运行的一个或者一组应用,以及一整套的运行态环境（提供运行态环境以及系统环境）。  \n\n## 启动容器：\n\n启动容器有两种方式：\n\n- 基于镜像创建一个容器并启动。\n- 将在终止状态(stopped)的容器重新启动。 \n\n新版本推荐使用子命令`\tdocker container` 。\n\n### 新建并启动容器\n\n使用命令：`docker run`\n\n输出hello world并终止容器：\n\n    $docker run ubuntu:14.04 /bin/echo 'Hello world'\n    Hello world\n    \n启动一个bash终端,允许用户进行交互。\n\n    $docker run -t -i ubuntu:14.04 /bin/bash\n    root@af8bae53bdd3:/#\n    \n其中, `-t`选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上,`-i`则让容器的标准输入保持打开。\n\n`docker\trun`启动容器流程：\n\n- 检查本地是否存在指定的镜像，没有则从仓库拉取。\n- 利用镜像创建一个容器并启动。\n- 分配一个文件系统，并且在添加一层可读写。\n- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。\n- 从地址池配置一个ip地址给容器。\n- 执行用户指定的应用程序。\n- 执行完毕后容器终止。\n\n### 启动已终止容器\n\n命令`docker\tstart`直接将一个已经终止的容器启动。\n\n容器的核心是，应用程序以及应用程序需要的资源。除此之外，并没有其它的资源。可以在伪终端中利用`ps`或`top`来查看进程信息。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run -t -i centos:latest /bin/bash\n    [root@b80715a7913e /]# ps\n      PID TTY          TIME CMD\n        1 pts/0    00:00:00 bash\n       15 pts/0    00:00:00 ps\n    [root@b80715a7913e /]# \n\n可以看到，容器只启动了`bash`，资源利用率极高，非常的轻量。以至于都可以随便删除，添加容器。\n\n### 容器管理`docker\tcontainer`\n\n在`Docker 1.13+`版本，推荐使用`docker container`来管理容器。\n\n    $ docker container run ubuntu:17.10 /bin/echo 'Hello world'\n    $ docker container start\n\n### 后台运行容器\n\n前台运行：\n\n    $docker\trun ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\n    hello\tworld\n    hello\tworld\n    hello\tworld\n    hello\tworld\n    \n输出信息一直在宿主中输出。\n\n后台运行，添加参数`-d`：  \n\n    $docker run -d ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\n    77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n    \n_注意_: 容器是否能长久运行，与`docker run`指定的命令有关，与`-d`无关。\n\n用命令`docker ps`查看容器信息。\n\n用命令`docker logs [container ID\tor NAMES]` 获取容器输出信息。\n\n-注_: 后面版本使用：\n\n    $\tdocker\tcontainer\trun\t-d\n    $\tdocker\tcontainer\tls\n    $\tdocker\tcontainer\tlogs   \n    \n## 终止容器\n\n命令`docker stop`可以终止一个运行中的容器。\n\n另外，当`Docker`中指定的应用程序终止时候，容器自动终止。 \n\n命令`docker ps -a`可以查看终止状态的容器。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker ps -a\n    [sudo] password for mutian: \n    CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS               NAMES\n    b80715a7913e        centos:latest               \"/bin/bash\"              About an hour ago   Up About an hour                              confident_colden\n    04288423a400        mysql/mysql-server:latest   \"/entrypoint.sh mysq…\"   6 weeks ago         Exited (0) 6 weeks ago                        mysql\n    37741b9edbd1        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web5\n    9e724b4f0f39        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Created                                       web4\n    a9d4f7554e91        nginx:v3                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web3\n    e28e7f69cbc8        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web2\n    c6074acec608        nginx                       \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       webserver\n    95088bff626d        hello-world                 \"/hello\"                 4 months ago        Exited (0) 4 months ago                       stupefied_mcnulty\n\n命令`docker start`可以重启终止状态下的容器。 \n命令`docker restart`将会终止一个一个运行的容器后并重启。\n\n- 强制停止容器\n\n可使用`docker kill` 命令停止一个或更多运行着的容器。\n\n格式：`docker kill [OPTIONS] CONTAINER [CONTAINER...]`\n\n例子：`docker kill 784fd3b294d7`\n\n\n_Doker 1.13+_:\n\n    docker container ls\n    docker container start\n    docker container restart\n    \n## 进入容器\n\n使用参数`-d`启动容器后，容器在后台执行了。有时候，需要进入容器操作。进入容器有多种方式：使用`docker\tattach`命令或者`nsenter`工具等。 \n    \n- attach命令\n\n命令格式：`docker attach [COMMAND]`  \n具体使用请百度……\n\n使用该命令有时候并不方便，当多个窗口同事通过`attach`命令进入到同一个容器的的时候，所有的窗口都会同步显示。这样，当有一个窗口阻塞的时候，所有的窗口都会阻塞。\n\n- nsenter进入容器\n\nnsenter工具包含在util-linux 2.23或更高版本中。  \n\n为了进入容器，你还需要找到容器的第一个进程的\tPID； \n\n    docker inspect --format \"{{.State.Pid}}\" $CONTAINER_ID\n\n通过这个PID就可以进入容器了：  \n`nsenter --target \"$PID\" --mount --uts --ipc --net --pid`\n\n完整例子： \n\n    [root@localhost ~]# docker ps\n    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\n    784fd3b294d7        nginx               \"nginx -g 'daemon off\"   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91->80/tcp   backstabbing_archimedes\n    [root@localhost ~]# docker inspect --format \"{{.State.Pid}}\" 784fd3b294d7\n    95492\n    [root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid\n    root@784fd3b294d7:/#\n    \n可以把以上命令封装程`shell`命令，简化操作。 \n\n- `docker exec`进入容器\n\n`docker exec -it 容器id /bin/bash`\n\n## 导出容器\n\n如果要导出本地的某个容器，可以使用命令`docker export`： \n命令格式： `docker export [OPTIONS] CONTAINER`    \n参数：\n  \t\t\n|  Name,shorthand  | Default | 将内容写到文件而非STDOUT |\n| :------: | :------: | :-----: |\n| --output, -o | - | 将内容写到文件而非STDOUT |\n\n示例：\n\n    docker export red_panda > latest.tar\n    docker export --output=\"latest.tar\" red_panda\n\n## 导入容器\n\n使用`docker import` 命令即可从归档文件导入内容并创建镜像。    \n命令格式： `docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]`  \n\n参数： \n\n|  Name,shorthand  | Default | 将内容写到文件而非STDOUT |\n| :------: | :------: | :-----: |\n| `--change, -c` | - | 将Dockerfile指令应用到创建的镜像 |\n| `--message, -m` | - | 为导入的镜像设置提交信息 |\n\n示例：\n\n    docker import nginx2.tar nginx\n\n## 删除容器\n\n可以使用命令`docker rm`来删除一个处于终止状态的容器。例如：\n\n    docker rm rusting_newton\n    \n如果要删除一个正在运行的容器，可以添加参数`-f`,Docker会发送`SIGKILL`信号给容器。 \n\n清理所有处于终止状态下容器： \n\n    $ docker ps -a\n    $ docker rm $(docker ps -a -q)    \n\n- Docker1.13+版本,使用命令：\n\n    docker container rm trusting_newton\n    docker container prune\n\n## 参考资源\n\n- http://itmuch.com/docker/05-docker-command-containers/    ","source":"_posts/docker-lesson4-container.md","raw":"---\ntitle: docker学习-第四课：容器\ndate: 2018-06-30 15:24:01\ncategories: docker\ntags: docker 容器\n---\n\n容器是`docker`的又一核心组件之一。  \n\n简单理解：容器就是独立运行的一个或者一组应用,以及一整套的运行态环境（提供运行态环境以及系统环境）。  \n\n## 启动容器：\n\n启动容器有两种方式：\n\n- 基于镜像创建一个容器并启动。\n- 将在终止状态(stopped)的容器重新启动。 \n\n新版本推荐使用子命令`\tdocker container` 。\n\n### 新建并启动容器\n\n使用命令：`docker run`\n\n输出hello world并终止容器：\n\n    $docker run ubuntu:14.04 /bin/echo 'Hello world'\n    Hello world\n    \n启动一个bash终端,允许用户进行交互。\n\n    $docker run -t -i ubuntu:14.04 /bin/bash\n    root@af8bae53bdd3:/#\n    \n其中, `-t`选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上,`-i`则让容器的标准输入保持打开。\n\n`docker\trun`启动容器流程：\n\n- 检查本地是否存在指定的镜像，没有则从仓库拉取。\n- 利用镜像创建一个容器并启动。\n- 分配一个文件系统，并且在添加一层可读写。\n- 从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。\n- 从地址池配置一个ip地址给容器。\n- 执行用户指定的应用程序。\n- 执行完毕后容器终止。\n\n### 启动已终止容器\n\n命令`docker\tstart`直接将一个已经终止的容器启动。\n\n容器的核心是，应用程序以及应用程序需要的资源。除此之外，并没有其它的资源。可以在伪终端中利用`ps`或`top`来查看进程信息。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run -t -i centos:latest /bin/bash\n    [root@b80715a7913e /]# ps\n      PID TTY          TIME CMD\n        1 pts/0    00:00:00 bash\n       15 pts/0    00:00:00 ps\n    [root@b80715a7913e /]# \n\n可以看到，容器只启动了`bash`，资源利用率极高，非常的轻量。以至于都可以随便删除，添加容器。\n\n### 容器管理`docker\tcontainer`\n\n在`Docker 1.13+`版本，推荐使用`docker container`来管理容器。\n\n    $ docker container run ubuntu:17.10 /bin/echo 'Hello world'\n    $ docker container start\n\n### 后台运行容器\n\n前台运行：\n\n    $docker\trun ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\n    hello\tworld\n    hello\tworld\n    hello\tworld\n    hello\tworld\n    \n输出信息一直在宿主中输出。\n\n后台运行，添加参数`-d`：  \n\n    $docker run -d ubuntu:14.04 /bin/sh -c \"while true; do echo hello world; sleep 1; done\"\n    77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n    \n_注意_: 容器是否能长久运行，与`docker run`指定的命令有关，与`-d`无关。\n\n用命令`docker ps`查看容器信息。\n\n用命令`docker logs [container ID\tor NAMES]` 获取容器输出信息。\n\n-注_: 后面版本使用：\n\n    $\tdocker\tcontainer\trun\t-d\n    $\tdocker\tcontainer\tls\n    $\tdocker\tcontainer\tlogs   \n    \n## 终止容器\n\n命令`docker stop`可以终止一个运行中的容器。\n\n另外，当`Docker`中指定的应用程序终止时候，容器自动终止。 \n\n命令`docker ps -a`可以查看终止状态的容器。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker ps -a\n    [sudo] password for mutian: \n    CONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS               NAMES\n    b80715a7913e        centos:latest               \"/bin/bash\"              About an hour ago   Up About an hour                              confident_colden\n    04288423a400        mysql/mysql-server:latest   \"/entrypoint.sh mysq…\"   6 weeks ago         Exited (0) 6 weeks ago                        mysql\n    37741b9edbd1        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web5\n    9e724b4f0f39        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Created                                       web4\n    a9d4f7554e91        nginx:v3                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web3\n    e28e7f69cbc8        nginx:v2                    \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       web2\n    c6074acec608        nginx                       \"nginx -g 'daemon of…\"   4 months ago        Exited (0) 4 months ago                       webserver\n    95088bff626d        hello-world                 \"/hello\"                 4 months ago        Exited (0) 4 months ago                       stupefied_mcnulty\n\n命令`docker start`可以重启终止状态下的容器。 \n命令`docker restart`将会终止一个一个运行的容器后并重启。\n\n- 强制停止容器\n\n可使用`docker kill` 命令停止一个或更多运行着的容器。\n\n格式：`docker kill [OPTIONS] CONTAINER [CONTAINER...]`\n\n例子：`docker kill 784fd3b294d7`\n\n\n_Doker 1.13+_:\n\n    docker container ls\n    docker container start\n    docker container restart\n    \n## 进入容器\n\n使用参数`-d`启动容器后，容器在后台执行了。有时候，需要进入容器操作。进入容器有多种方式：使用`docker\tattach`命令或者`nsenter`工具等。 \n    \n- attach命令\n\n命令格式：`docker attach [COMMAND]`  \n具体使用请百度……\n\n使用该命令有时候并不方便，当多个窗口同事通过`attach`命令进入到同一个容器的的时候，所有的窗口都会同步显示。这样，当有一个窗口阻塞的时候，所有的窗口都会阻塞。\n\n- nsenter进入容器\n\nnsenter工具包含在util-linux 2.23或更高版本中。  \n\n为了进入容器，你还需要找到容器的第一个进程的\tPID； \n\n    docker inspect --format \"{{.State.Pid}}\" $CONTAINER_ID\n\n通过这个PID就可以进入容器了：  \n`nsenter --target \"$PID\" --mount --uts --ipc --net --pid`\n\n完整例子： \n\n    [root@localhost ~]# docker ps\n    CONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\n    784fd3b294d7        nginx               \"nginx -g 'daemon off\"   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91->80/tcp   backstabbing_archimedes\n    [root@localhost ~]# docker inspect --format \"{{.State.Pid}}\" 784fd3b294d7\n    95492\n    [root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid\n    root@784fd3b294d7:/#\n    \n可以把以上命令封装程`shell`命令，简化操作。 \n\n- `docker exec`进入容器\n\n`docker exec -it 容器id /bin/bash`\n\n## 导出容器\n\n如果要导出本地的某个容器，可以使用命令`docker export`： \n命令格式： `docker export [OPTIONS] CONTAINER`    \n参数：\n  \t\t\n|  Name,shorthand  | Default | 将内容写到文件而非STDOUT |\n| :------: | :------: | :-----: |\n| --output, -o | - | 将内容写到文件而非STDOUT |\n\n示例：\n\n    docker export red_panda > latest.tar\n    docker export --output=\"latest.tar\" red_panda\n\n## 导入容器\n\n使用`docker import` 命令即可从归档文件导入内容并创建镜像。    \n命令格式： `docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]`  \n\n参数： \n\n|  Name,shorthand  | Default | 将内容写到文件而非STDOUT |\n| :------: | :------: | :-----: |\n| `--change, -c` | - | 将Dockerfile指令应用到创建的镜像 |\n| `--message, -m` | - | 为导入的镜像设置提交信息 |\n\n示例：\n\n    docker import nginx2.tar nginx\n\n## 删除容器\n\n可以使用命令`docker rm`来删除一个处于终止状态的容器。例如：\n\n    docker rm rusting_newton\n    \n如果要删除一个正在运行的容器，可以添加参数`-f`,Docker会发送`SIGKILL`信号给容器。 \n\n清理所有处于终止状态下容器： \n\n    $ docker ps -a\n    $ docker rm $(docker ps -a -q)    \n\n- Docker1.13+版本,使用命令：\n\n    docker container rm trusting_newton\n    docker container prune\n\n## 参考资源\n\n- http://itmuch.com/docker/05-docker-command-containers/    ","slug":"docker-lesson4-container","published":1,"updated":"2018-11-09T01:20:30.077Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38kt004xqcrg46faueqy","content":"<p>容器是<code>docker</code>的又一核心组件之一。  </p>\n<p>简单理解：容器就是独立运行的一个或者一组应用,以及一整套的运行态环境（提供运行态环境以及系统环境）。  </p>\n<h2 id=\"启动容器：\"><a href=\"#启动容器：\" class=\"headerlink\" title=\"启动容器：\"></a>启动容器：</h2><p>启动容器有两种方式：</p>\n<ul>\n<li>基于镜像创建一个容器并启动。</li>\n<li>将在终止状态(stopped)的容器重新启动。 </li>\n</ul>\n<p>新版本推荐使用子命令<code>docker container</code> 。</p>\n<h3 id=\"新建并启动容器\"><a href=\"#新建并启动容器\" class=\"headerlink\" title=\"新建并启动容器\"></a>新建并启动容器</h3><p>使用命令：<code>docker run</code></p>\n<p>输出hello world并终止容器：</p>\n<pre><code>$docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos;\nHello world\n</code></pre><p>启动一个bash终端,允许用户进行交互。</p>\n<pre><code>$docker run -t -i ubuntu:14.04 /bin/bash\nroot@af8bae53bdd3:/#\n</code></pre><p>其中, <code>-t</code>选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上,<code>-i</code>则让容器的标准输入保持打开。</p>\n<p><code>docker    run</code>启动容器流程：</p>\n<ul>\n<li>检查本地是否存在指定的镜像，没有则从仓库拉取。</li>\n<li>利用镜像创建一个容器并启动。</li>\n<li>分配一个文件系统，并且在添加一层可读写。</li>\n<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</li>\n<li>从地址池配置一个ip地址给容器。</li>\n<li>执行用户指定的应用程序。</li>\n<li>执行完毕后容器终止。</li>\n</ul>\n<h3 id=\"启动已终止容器\"><a href=\"#启动已终止容器\" class=\"headerlink\" title=\"启动已终止容器\"></a>启动已终止容器</h3><p>命令<code>docker    start</code>直接将一个已经终止的容器启动。</p>\n<p>容器的核心是，应用程序以及应用程序需要的资源。除此之外，并没有其它的资源。可以在伪终端中利用<code>ps</code>或<code>top</code>来查看进程信息。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run -t -i centos:latest /bin/bash\n[root@b80715a7913e /]# ps\n  PID TTY          TIME CMD\n    1 pts/0    00:00:00 bash\n   15 pts/0    00:00:00 ps\n[root@b80715a7913e /]# \n</code></pre><p>可以看到，容器只启动了<code>bash</code>，资源利用率极高，非常的轻量。以至于都可以随便删除，添加容器。</p>\n<h3 id=\"容器管理docker-container\"><a href=\"#容器管理docker-container\" class=\"headerlink\" title=\"容器管理docker    container\"></a>容器管理<code>docker    container</code></h3><p>在<code>Docker 1.13+</code>版本，推荐使用<code>docker container</code>来管理容器。</p>\n<pre><code>$ docker container run ubuntu:17.10 /bin/echo &apos;Hello world&apos;\n$ docker container start\n</code></pre><h3 id=\"后台运行容器\"><a href=\"#后台运行容器\" class=\"headerlink\" title=\"后台运行容器\"></a>后台运行容器</h3><p>前台运行：</p>\n<pre><code>$docker    run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\nhello    world\nhello    world\nhello    world\nhello    world\n</code></pre><p>输出信息一直在宿主中输出。</p>\n<p>后台运行，添加参数<code>-d</code>：  </p>\n<pre><code>$docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\n77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n</code></pre><p>_注意_: 容器是否能长久运行，与<code>docker run</code>指定的命令有关，与<code>-d</code>无关。</p>\n<p>用命令<code>docker ps</code>查看容器信息。</p>\n<p>用命令<code>docker logs [container ID    or NAMES]</code> 获取容器输出信息。</p>\n<p>-注_: 后面版本使用：</p>\n<pre><code>$    docker    container    run    -d\n$    docker    container    ls\n$    docker    container    logs   \n</code></pre><h2 id=\"终止容器\"><a href=\"#终止容器\" class=\"headerlink\" title=\"终止容器\"></a>终止容器</h2><p>命令<code>docker stop</code>可以终止一个运行中的容器。</p>\n<p>另外，当<code>Docker</code>中指定的应用程序终止时候，容器自动终止。 </p>\n<p>命令<code>docker ps -a</code>可以查看终止状态的容器。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker ps -a\n[sudo] password for mutian: \nCONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS               NAMES\nb80715a7913e        centos:latest               &quot;/bin/bash&quot;              About an hour ago   Up About an hour                              confident_colden\n04288423a400        mysql/mysql-server:latest   &quot;/entrypoint.sh mysq…&quot;   6 weeks ago         Exited (0) 6 weeks ago                        mysql\n37741b9edbd1        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web5\n9e724b4f0f39        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Created                                       web4\na9d4f7554e91        nginx:v3                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web3\ne28e7f69cbc8        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web2\nc6074acec608        nginx                       &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       webserver\n95088bff626d        hello-world                 &quot;/hello&quot;                 4 months ago        Exited (0) 4 months ago                       stupefied_mcnulty\n</code></pre><p>命令<code>docker start</code>可以重启终止状态下的容器。<br>命令<code>docker restart</code>将会终止一个一个运行的容器后并重启。</p>\n<ul>\n<li>强制停止容器</li>\n</ul>\n<p>可使用<code>docker kill</code> 命令停止一个或更多运行着的容器。</p>\n<p>格式：<code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code></p>\n<p>例子：<code>docker kill 784fd3b294d7</code></p>\n<p><em>Doker 1.13+</em>:</p>\n<pre><code>docker container ls\ndocker container start\ndocker container restart\n</code></pre><h2 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h2><p>使用参数<code>-d</code>启动容器后，容器在后台执行了。有时候，需要进入容器操作。进入容器有多种方式：使用<code>docker    attach</code>命令或者<code>nsenter</code>工具等。 </p>\n<ul>\n<li>attach命令</li>\n</ul>\n<p>命令格式：<code>docker attach [COMMAND]</code><br>具体使用请百度……</p>\n<p>使用该命令有时候并不方便，当多个窗口同事通过<code>attach</code>命令进入到同一个容器的的时候，所有的窗口都会同步显示。这样，当有一个窗口阻塞的时候，所有的窗口都会阻塞。</p>\n<ul>\n<li>nsenter进入容器</li>\n</ul>\n<p>nsenter工具包含在util-linux 2.23或更高版本中。  </p>\n<p>为了进入容器，你还需要找到容器的第一个进程的    PID； </p>\n<pre><code>docker inspect --format &quot;{{.State.Pid}}&quot; $CONTAINER_ID\n</code></pre><p>通过这个PID就可以进入容器了：<br><code>nsenter --target &quot;$PID&quot; --mount --uts --ipc --net --pid</code></p>\n<p>完整例子： </p>\n<pre><code>[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\n784fd3b294d7        nginx               &quot;nginx -g &apos;daemon off&quot;   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes\n[root@localhost ~]# docker inspect --format &quot;{{.State.Pid}}&quot; 784fd3b294d7\n95492\n[root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid\nroot@784fd3b294d7:/#\n</code></pre><p>可以把以上命令封装程<code>shell</code>命令，简化操作。 </p>\n<ul>\n<li><code>docker exec</code>进入容器</li>\n</ul>\n<p><code>docker exec -it 容器id /bin/bash</code></p>\n<h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出本地的某个容器，可以使用命令<code>docker export</code>：<br>命令格式： <code>docker export [OPTIONS] CONTAINER</code><br>参数：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Name,shorthand</th>\n<th style=\"text-align:center\">Default</th>\n<th style=\"text-align:center\">将内容写到文件而非STDOUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">–output, -o</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">将内容写到文件而非STDOUT</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>docker export red_panda &gt; latest.tar\ndocker export --output=&quot;latest.tar&quot; red_panda\n</code></pre><h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><p>使用<code>docker import</code> 命令即可从归档文件导入内容并创建镜像。<br>命令格式： <code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code>  </p>\n<p>参数： </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Name,shorthand</th>\n<th style=\"text-align:center\">Default</th>\n<th style=\"text-align:center\">将内容写到文件而非STDOUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>--change, -c</code></td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">将Dockerfile指令应用到创建的镜像</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>--message, -m</code></td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">为导入的镜像设置提交信息</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>docker import nginx2.tar nginx\n</code></pre><h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><p>可以使用命令<code>docker rm</code>来删除一个处于终止状态的容器。例如：</p>\n<pre><code>docker rm rusting_newton\n</code></pre><p>如果要删除一个正在运行的容器，可以添加参数<code>-f</code>,Docker会发送<code>SIGKILL</code>信号给容器。 </p>\n<p>清理所有处于终止状态下容器： </p>\n<pre><code>$ docker ps -a\n$ docker rm $(docker ps -a -q)    \n</code></pre><ul>\n<li><p>Docker1.13+版本,使用命令：</p>\n<p>  docker container rm trusting_newton<br>  docker container prune</p>\n</li>\n</ul>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><ul>\n<li><a href=\"http://itmuch.com/docker/05-docker-command-containers/\" target=\"_blank\" rel=\"noopener\">http://itmuch.com/docker/05-docker-command-containers/</a>    </li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>容器是<code>docker</code>的又一核心组件之一。  </p>\n<p>简单理解：容器就是独立运行的一个或者一组应用,以及一整套的运行态环境（提供运行态环境以及系统环境）。  </p>\n<h2 id=\"启动容器：\"><a href=\"#启动容器：\" class=\"headerlink\" title=\"启动容器：\"></a>启动容器：</h2><p>启动容器有两种方式：</p>\n<ul>\n<li>基于镜像创建一个容器并启动。</li>\n<li>将在终止状态(stopped)的容器重新启动。 </li>\n</ul>\n<p>新版本推荐使用子命令<code>docker container</code> 。</p>\n<h3 id=\"新建并启动容器\"><a href=\"#新建并启动容器\" class=\"headerlink\" title=\"新建并启动容器\"></a>新建并启动容器</h3><p>使用命令：<code>docker run</code></p>\n<p>输出hello world并终止容器：</p>\n<pre><code>$docker run ubuntu:14.04 /bin/echo &apos;Hello world&apos;\nHello world\n</code></pre><p>启动一个bash终端,允许用户进行交互。</p>\n<pre><code>$docker run -t -i ubuntu:14.04 /bin/bash\nroot@af8bae53bdd3:/#\n</code></pre><p>其中, <code>-t</code>选项让Docker分配一个伪终端(pseudo-tty)并绑定到容器的标准输入上,<code>-i</code>则让容器的标准输入保持打开。</p>\n<p><code>docker    run</code>启动容器流程：</p>\n<ul>\n<li>检查本地是否存在指定的镜像，没有则从仓库拉取。</li>\n<li>利用镜像创建一个容器并启动。</li>\n<li>分配一个文件系统，并且在添加一层可读写。</li>\n<li>从宿主主机配置的网桥接口中桥接一个虚拟接口到容器中去。</li>\n<li>从地址池配置一个ip地址给容器。</li>\n<li>执行用户指定的应用程序。</li>\n<li>执行完毕后容器终止。</li>\n</ul>\n<h3 id=\"启动已终止容器\"><a href=\"#启动已终止容器\" class=\"headerlink\" title=\"启动已终止容器\"></a>启动已终止容器</h3><p>命令<code>docker    start</code>直接将一个已经终止的容器启动。</p>\n<p>容器的核心是，应用程序以及应用程序需要的资源。除此之外，并没有其它的资源。可以在伪终端中利用<code>ps</code>或<code>top</code>来查看进程信息。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run -t -i centos:latest /bin/bash\n[root@b80715a7913e /]# ps\n  PID TTY          TIME CMD\n    1 pts/0    00:00:00 bash\n   15 pts/0    00:00:00 ps\n[root@b80715a7913e /]# \n</code></pre><p>可以看到，容器只启动了<code>bash</code>，资源利用率极高，非常的轻量。以至于都可以随便删除，添加容器。</p>\n<h3 id=\"容器管理docker-container\"><a href=\"#容器管理docker-container\" class=\"headerlink\" title=\"容器管理docker    container\"></a>容器管理<code>docker    container</code></h3><p>在<code>Docker 1.13+</code>版本，推荐使用<code>docker container</code>来管理容器。</p>\n<pre><code>$ docker container run ubuntu:17.10 /bin/echo &apos;Hello world&apos;\n$ docker container start\n</code></pre><h3 id=\"后台运行容器\"><a href=\"#后台运行容器\" class=\"headerlink\" title=\"后台运行容器\"></a>后台运行容器</h3><p>前台运行：</p>\n<pre><code>$docker    run ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\nhello    world\nhello    world\nhello    world\nhello    world\n</code></pre><p>输出信息一直在宿主中输出。</p>\n<p>后台运行，添加参数<code>-d</code>：  </p>\n<pre><code>$docker run -d ubuntu:14.04 /bin/sh -c &quot;while true; do echo hello world; sleep 1; done&quot;\n77b2dc01fe0f3f1265df143181e7b9af5e05279a884f4776ee75350ea9d8017a\n</code></pre><p>_注意_: 容器是否能长久运行，与<code>docker run</code>指定的命令有关，与<code>-d</code>无关。</p>\n<p>用命令<code>docker ps</code>查看容器信息。</p>\n<p>用命令<code>docker logs [container ID    or NAMES]</code> 获取容器输出信息。</p>\n<p>-注_: 后面版本使用：</p>\n<pre><code>$    docker    container    run    -d\n$    docker    container    ls\n$    docker    container    logs   \n</code></pre><h2 id=\"终止容器\"><a href=\"#终止容器\" class=\"headerlink\" title=\"终止容器\"></a>终止容器</h2><p>命令<code>docker stop</code>可以终止一个运行中的容器。</p>\n<p>另外，当<code>Docker</code>中指定的应用程序终止时候，容器自动终止。 </p>\n<p>命令<code>docker ps -a</code>可以查看终止状态的容器。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker ps -a\n[sudo] password for mutian: \nCONTAINER ID        IMAGE                       COMMAND                  CREATED             STATUS                    PORTS               NAMES\nb80715a7913e        centos:latest               &quot;/bin/bash&quot;              About an hour ago   Up About an hour                              confident_colden\n04288423a400        mysql/mysql-server:latest   &quot;/entrypoint.sh mysq…&quot;   6 weeks ago         Exited (0) 6 weeks ago                        mysql\n37741b9edbd1        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web5\n9e724b4f0f39        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Created                                       web4\na9d4f7554e91        nginx:v3                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web3\ne28e7f69cbc8        nginx:v2                    &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       web2\nc6074acec608        nginx                       &quot;nginx -g &apos;daemon of…&quot;   4 months ago        Exited (0) 4 months ago                       webserver\n95088bff626d        hello-world                 &quot;/hello&quot;                 4 months ago        Exited (0) 4 months ago                       stupefied_mcnulty\n</code></pre><p>命令<code>docker start</code>可以重启终止状态下的容器。<br>命令<code>docker restart</code>将会终止一个一个运行的容器后并重启。</p>\n<ul>\n<li>强制停止容器</li>\n</ul>\n<p>可使用<code>docker kill</code> 命令停止一个或更多运行着的容器。</p>\n<p>格式：<code>docker kill [OPTIONS] CONTAINER [CONTAINER...]</code></p>\n<p>例子：<code>docker kill 784fd3b294d7</code></p>\n<p><em>Doker 1.13+</em>:</p>\n<pre><code>docker container ls\ndocker container start\ndocker container restart\n</code></pre><h2 id=\"进入容器\"><a href=\"#进入容器\" class=\"headerlink\" title=\"进入容器\"></a>进入容器</h2><p>使用参数<code>-d</code>启动容器后，容器在后台执行了。有时候，需要进入容器操作。进入容器有多种方式：使用<code>docker    attach</code>命令或者<code>nsenter</code>工具等。 </p>\n<ul>\n<li>attach命令</li>\n</ul>\n<p>命令格式：<code>docker attach [COMMAND]</code><br>具体使用请百度……</p>\n<p>使用该命令有时候并不方便，当多个窗口同事通过<code>attach</code>命令进入到同一个容器的的时候，所有的窗口都会同步显示。这样，当有一个窗口阻塞的时候，所有的窗口都会阻塞。</p>\n<ul>\n<li>nsenter进入容器</li>\n</ul>\n<p>nsenter工具包含在util-linux 2.23或更高版本中。  </p>\n<p>为了进入容器，你还需要找到容器的第一个进程的    PID； </p>\n<pre><code>docker inspect --format &quot;{{.State.Pid}}&quot; $CONTAINER_ID\n</code></pre><p>通过这个PID就可以进入容器了：<br><code>nsenter --target &quot;$PID&quot; --mount --uts --ipc --net --pid</code></p>\n<p>完整例子： </p>\n<pre><code>[root@localhost ~]# docker ps\nCONTAINER ID        IMAGE               COMMAND                  CREATED             STATUS              PORTS                         NAMES\n784fd3b294d7        nginx               &quot;nginx -g &apos;daemon off&quot;   55 minutes ago      Up 3 minutes        443/tcp, 0.0.0.0:91-&gt;80/tcp   backstabbing_archimedes\n[root@localhost ~]# docker inspect --format &quot;{{.State.Pid}}&quot; 784fd3b294d7\n95492\n[root@localhost ~]# nsenter --target 95492 --mount --uts --ipc --net --pid\nroot@784fd3b294d7:/#\n</code></pre><p>可以把以上命令封装程<code>shell</code>命令，简化操作。 </p>\n<ul>\n<li><code>docker exec</code>进入容器</li>\n</ul>\n<p><code>docker exec -it 容器id /bin/bash</code></p>\n<h2 id=\"导出容器\"><a href=\"#导出容器\" class=\"headerlink\" title=\"导出容器\"></a>导出容器</h2><p>如果要导出本地的某个容器，可以使用命令<code>docker export</code>：<br>命令格式： <code>docker export [OPTIONS] CONTAINER</code><br>参数：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Name,shorthand</th>\n<th style=\"text-align:center\">Default</th>\n<th style=\"text-align:center\">将内容写到文件而非STDOUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">–output, -o</td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">将内容写到文件而非STDOUT</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>docker export red_panda &gt; latest.tar\ndocker export --output=&quot;latest.tar&quot; red_panda\n</code></pre><h2 id=\"导入容器\"><a href=\"#导入容器\" class=\"headerlink\" title=\"导入容器\"></a>导入容器</h2><p>使用<code>docker import</code> 命令即可从归档文件导入内容并创建镜像。<br>命令格式： <code>docker import [OPTIONS] file|URL|- [REPOSITORY[:TAG]]</code>  </p>\n<p>参数： </p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">Name,shorthand</th>\n<th style=\"text-align:center\">Default</th>\n<th style=\"text-align:center\">将内容写到文件而非STDOUT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\"><code>--change, -c</code></td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">将Dockerfile指令应用到创建的镜像</td>\n</tr>\n<tr>\n<td style=\"text-align:center\"><code>--message, -m</code></td>\n<td style=\"text-align:center\">-</td>\n<td style=\"text-align:center\">为导入的镜像设置提交信息</td>\n</tr>\n</tbody>\n</table>\n<p>示例：</p>\n<pre><code>docker import nginx2.tar nginx\n</code></pre><h2 id=\"删除容器\"><a href=\"#删除容器\" class=\"headerlink\" title=\"删除容器\"></a>删除容器</h2><p>可以使用命令<code>docker rm</code>来删除一个处于终止状态的容器。例如：</p>\n<pre><code>docker rm rusting_newton\n</code></pre><p>如果要删除一个正在运行的容器，可以添加参数<code>-f</code>,Docker会发送<code>SIGKILL</code>信号给容器。 </p>\n<p>清理所有处于终止状态下容器： </p>\n<pre><code>$ docker ps -a\n$ docker rm $(docker ps -a -q)    \n</code></pre><ul>\n<li><p>Docker1.13+版本,使用命令：</p>\n<p>  docker container rm trusting_newton<br>  docker container prune</p>\n</li>\n</ul>\n<h2 id=\"参考资源\"><a href=\"#参考资源\" class=\"headerlink\" title=\"参考资源\"></a>参考资源</h2><ul>\n<li><a href=\"http://itmuch.com/docker/05-docker-command-containers/\" target=\"_blank\" rel=\"noopener\">http://itmuch.com/docker/05-docker-command-containers/</a>    </li>\n</ul>\n"},{"title":"javapoet根据编译注解自动生成代码","date":"2018-05-03T12:54:06.000Z","_content":"\n本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……\n\n## 引入相关依赖包和插件\n\n1.依赖包\n\n    <!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service -->\n    <dependency>\n        <groupId>com.google.auto.service</groupId>\n        <artifactId>auto-service</artifactId>\n        <version>1.0-rc4</version>\n    </dependency>\n    <!--优雅生成代码-->\n    <!--https://github.com/square/javapoet-->\n    <dependency>\n        <groupId>com.squareup</groupId>\n        <artifactId>javapoet</artifactId>\n        <version>1.10.0</version>\n        <optional>true</optional>\n    </dependency>\n    \n- javapoet是square公司出品的用来优雅生成代码库。网址： https://github.com/square/javapoet\n\n- google auto-service是google公司的一个库，用来自动注册服务。\n\n2.apt插件\n\n    <plugin>\n        <groupId>com.mysema.maven</groupId>\n        <artifactId>apt-maven-plugin</artifactId>\n        <version>1.1.3</version>\n        <executions>\n            <execution>\n                <goals>\n                    <goal>process</goal>\n                </goals>\n                <phase>generate-sources</phase>\n                <configuration>\n                    <outputDirectory>${project.basedir}/target/generated-sources/java</outputDirectory>\n                    <processor>com.example.demo.HelloProcessor</processor>\n                    <processors>\n                        <processor>com.example.demo.HelloProcessor</processor>\n                    </processors>\n                    <showWarnings>true</showWarnings>\n                </configuration>\n            </execution>\n        </executions>\n    </plugin>\n    \n可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。\n\n## demo演示\n\n{% asset_img a.png %} \n\n1.新建注解类`HelloAnnotation`    \n\n    package com.example.demo;\n    \n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Retention(RetentionPolicy.CLASS)\n    @Target(ElementType.TYPE)\n    public @interface HelloAnnotation {\n    }\n\n\n2.新建注解处理类`HelloProcessor`\n\n    package com.example.demo;\n    \n    import com.google.auto.service.AutoService;\n    import com.squareup.javapoet.JavaFile;\n    import com.squareup.javapoet.MethodSpec;\n    import com.squareup.javapoet.TypeSpec;\n    \n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.Element;\n    import javax.lang.model.element.Modifier;\n    import javax.lang.model.element.Name;\n    import javax.lang.model.element.TypeElement;\n    import java.io.IOException;\n    import java.lang.reflect.Method;\n    import java.util.Collections;\n    import java.util.Set;\n    \n    @AutoService(Processor.class)\n    @SupportedAnnotationTypes(value = {\"com.example.demo.HelloAnnotation\"})\n    @SupportedSourceVersion(SourceVersion.RELEASE_8)\n    public final class HelloProcessor extends AbstractProcessor {\n    \n        private Filer filer;\n    \n        @Override\n        public synchronized void init(ProcessingEnvironment processingEnv) {\n            super.init(processingEnv);\n    \n            filer = processingEnv.getFiler(); // for creating file\n            System.out.println(\">>>processor init:\" + filer.toString());\n        }\n    \n        @Override\n        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n            System.out.println(\">>>> process:\" + annotations.size());\n            for (TypeElement element : annotations) {\n                /*Set<? extends Element> aa = roundEnv.getElementsAnnotatedWith(element);\n                for (Element e:\n                     aa) {\n                    String name = e.getClass().getTypeName();\n                    System.out.println(\">>>name:\" + name);\n                    Name s = e.getSimpleName();\n                    System.out.println(\">>>aa:\" + s.toString());\n    \n                    *//*Method[] m = e.getClass().getMethods();\n                    for (int i = 0; i < m.length; i++) {\n                        Method mm = m[i];\n                        System.out.println(mm.getName());\n                    }*//*\n                }*/\n                System.out.println(\">>>>>> process：\" + element.getQualifiedName().toString());\n                if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                    // main method\n                    MethodSpec main = MethodSpec.methodBuilder(\"main\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                            .returns(void.class)\n                            .addParameter(String[].class, \"args\")\n                            .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")\n                            .build();\n                    // HelloWorld class\n                    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                            .addMethod(main)\n                            .build();\n    \n                    try {\n                        // build com.example.HelloWorld.java\n                        JavaFile javaFile = JavaFile.builder(\"com.example\", helloWorld)\n                                .addFileComment(\" This codes are generated automatically. Do not modify!\")\n                                .build();\n                        // write to file\n                        javaFile.writeTo(filer);\n    \n                        javaFile.writeTo(System.out);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            return true;\n        }\n    \n        //采用注解\n        /*@Override\n        public Set<String> getSupportedAnnotationTypes() {\n            return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n        }*/\n    \n        //采用注解\n       /* @Override\n        public SourceVersion getSupportedSourceVersion() {\n            return SourceVersion.latestSupported();\n        }*/\n    }\n\n-  加上注解`@AutoService(Processor.class)`，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。\n\n{%asset_img b.png%}\n\n- 关键，覆盖方法`process`，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在`maven`插件中配置。\n\n3.定义使用类\n\n    package com.example.demo;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    @HelloAnnotation\n    @SpringBootApplication\n    public class DemoApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(DemoApplication.class, args);\n    //        HelloWorld.main(null);\n        }\n    }\n\n在类上添加注解`@HelloAnnotation`。  \n那么用`mvn install`或者运行该类编译代码时，将会调用注解处理类`HelloProcessor`进行代码生成。\n\n----------------------------------------------------------------------------------\n\n_注意_:   \n在引入apt插件后，要去掉java的编译时注解，只能二选其一，否则apt会生成一次代码，java编译时注解还会生成一次代码，将重复报错。  \n- 用apt插件，去掉processor中的`@AutoService(Processor.class)`注解。  \n- 用java编译时注解，在processor引入`@AutoService(Processor.class)`注解，不需要apt插件。\n\n------------------------------------------------------------------------------------------\n\n<<完>>","source":"_posts/javapoet-apt-annotation.md","raw":"---\ntitle: javapoet根据编译注解自动生成代码\ndate: 2018-05-03 20:54:06\ncategories: javapoet\ntags: javapoet-apt-annotation\n---\n\n本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……\n\n## 引入相关依赖包和插件\n\n1.依赖包\n\n    <!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service -->\n    <dependency>\n        <groupId>com.google.auto.service</groupId>\n        <artifactId>auto-service</artifactId>\n        <version>1.0-rc4</version>\n    </dependency>\n    <!--优雅生成代码-->\n    <!--https://github.com/square/javapoet-->\n    <dependency>\n        <groupId>com.squareup</groupId>\n        <artifactId>javapoet</artifactId>\n        <version>1.10.0</version>\n        <optional>true</optional>\n    </dependency>\n    \n- javapoet是square公司出品的用来优雅生成代码库。网址： https://github.com/square/javapoet\n\n- google auto-service是google公司的一个库，用来自动注册服务。\n\n2.apt插件\n\n    <plugin>\n        <groupId>com.mysema.maven</groupId>\n        <artifactId>apt-maven-plugin</artifactId>\n        <version>1.1.3</version>\n        <executions>\n            <execution>\n                <goals>\n                    <goal>process</goal>\n                </goals>\n                <phase>generate-sources</phase>\n                <configuration>\n                    <outputDirectory>${project.basedir}/target/generated-sources/java</outputDirectory>\n                    <processor>com.example.demo.HelloProcessor</processor>\n                    <processors>\n                        <processor>com.example.demo.HelloProcessor</processor>\n                    </processors>\n                    <showWarnings>true</showWarnings>\n                </configuration>\n            </execution>\n        </executions>\n    </plugin>\n    \n可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。\n\n## demo演示\n\n{% asset_img a.png %} \n\n1.新建注解类`HelloAnnotation`    \n\n    package com.example.demo;\n    \n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Retention(RetentionPolicy.CLASS)\n    @Target(ElementType.TYPE)\n    public @interface HelloAnnotation {\n    }\n\n\n2.新建注解处理类`HelloProcessor`\n\n    package com.example.demo;\n    \n    import com.google.auto.service.AutoService;\n    import com.squareup.javapoet.JavaFile;\n    import com.squareup.javapoet.MethodSpec;\n    import com.squareup.javapoet.TypeSpec;\n    \n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.Element;\n    import javax.lang.model.element.Modifier;\n    import javax.lang.model.element.Name;\n    import javax.lang.model.element.TypeElement;\n    import java.io.IOException;\n    import java.lang.reflect.Method;\n    import java.util.Collections;\n    import java.util.Set;\n    \n    @AutoService(Processor.class)\n    @SupportedAnnotationTypes(value = {\"com.example.demo.HelloAnnotation\"})\n    @SupportedSourceVersion(SourceVersion.RELEASE_8)\n    public final class HelloProcessor extends AbstractProcessor {\n    \n        private Filer filer;\n    \n        @Override\n        public synchronized void init(ProcessingEnvironment processingEnv) {\n            super.init(processingEnv);\n    \n            filer = processingEnv.getFiler(); // for creating file\n            System.out.println(\">>>processor init:\" + filer.toString());\n        }\n    \n        @Override\n        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n            System.out.println(\">>>> process:\" + annotations.size());\n            for (TypeElement element : annotations) {\n                /*Set<? extends Element> aa = roundEnv.getElementsAnnotatedWith(element);\n                for (Element e:\n                     aa) {\n                    String name = e.getClass().getTypeName();\n                    System.out.println(\">>>name:\" + name);\n                    Name s = e.getSimpleName();\n                    System.out.println(\">>>aa:\" + s.toString());\n    \n                    *//*Method[] m = e.getClass().getMethods();\n                    for (int i = 0; i < m.length; i++) {\n                        Method mm = m[i];\n                        System.out.println(mm.getName());\n                    }*//*\n                }*/\n                System.out.println(\">>>>>> process：\" + element.getQualifiedName().toString());\n                if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                    // main method\n                    MethodSpec main = MethodSpec.methodBuilder(\"main\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                            .returns(void.class)\n                            .addParameter(String[].class, \"args\")\n                            .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")\n                            .build();\n                    // HelloWorld class\n                    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                            .addMethod(main)\n                            .build();\n    \n                    try {\n                        // build com.example.HelloWorld.java\n                        JavaFile javaFile = JavaFile.builder(\"com.example\", helloWorld)\n                                .addFileComment(\" This codes are generated automatically. Do not modify!\")\n                                .build();\n                        // write to file\n                        javaFile.writeTo(filer);\n    \n                        javaFile.writeTo(System.out);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            return true;\n        }\n    \n        //采用注解\n        /*@Override\n        public Set<String> getSupportedAnnotationTypes() {\n            return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n        }*/\n    \n        //采用注解\n       /* @Override\n        public SourceVersion getSupportedSourceVersion() {\n            return SourceVersion.latestSupported();\n        }*/\n    }\n\n-  加上注解`@AutoService(Processor.class)`，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。\n\n{%asset_img b.png%}\n\n- 关键，覆盖方法`process`，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在`maven`插件中配置。\n\n3.定义使用类\n\n    package com.example.demo;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    @HelloAnnotation\n    @SpringBootApplication\n    public class DemoApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(DemoApplication.class, args);\n    //        HelloWorld.main(null);\n        }\n    }\n\n在类上添加注解`@HelloAnnotation`。  \n那么用`mvn install`或者运行该类编译代码时，将会调用注解处理类`HelloProcessor`进行代码生成。\n\n----------------------------------------------------------------------------------\n\n_注意_:   \n在引入apt插件后，要去掉java的编译时注解，只能二选其一，否则apt会生成一次代码，java编译时注解还会生成一次代码，将重复报错。  \n- 用apt插件，去掉processor中的`@AutoService(Processor.class)`注解。  \n- 用java编译时注解，在processor引入`@AutoService(Processor.class)`注解，不需要apt插件。\n\n------------------------------------------------------------------------------------------\n\n<<完>>","slug":"javapoet-apt-annotation","published":1,"updated":"2018-11-09T01:20:30.155Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38l3004yqcrgcacmokpl","content":"<p>本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……</p>\n<h2 id=\"引入相关依赖包和插件\"><a href=\"#引入相关依赖包和插件\" class=\"headerlink\" title=\"引入相关依赖包和插件\"></a>引入相关依赖包和插件</h2><p>1.依赖包</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n    &lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n    &lt;version&gt;1.0-rc4&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--优雅生成代码--&gt;\n&lt;!--https://github.com/square/javapoet--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup&lt;/groupId&gt;\n    &lt;artifactId&gt;javapoet&lt;/artifactId&gt;\n    &lt;version&gt;1.10.0&lt;/version&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><ul>\n<li><p>javapoet是square公司出品的用来优雅生成代码库。网址： <a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">https://github.com/square/javapoet</a></p>\n</li>\n<li><p>google auto-service是google公司的一个库，用来自动注册服务。</p>\n</li>\n</ul>\n<p>2.apt插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.1.3&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;process&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;phase&gt;generate-sources&lt;/phase&gt;\n            &lt;configuration&gt;\n                &lt;outputDirectory&gt;${project.basedir}/target/generated-sources/java&lt;/outputDirectory&gt;\n                &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;processors&gt;\n                    &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;/processors&gt;\n                &lt;showWarnings&gt;true&lt;/showWarnings&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。</p>\n<h2 id=\"demo演示\"><a href=\"#demo演示\" class=\"headerlink\" title=\"demo演示\"></a>demo演示</h2><img src=\"/2018/05/03/javapoet-apt-annotation/a.png\"> \n<p>1.新建注解类<code>HelloAnnotation</code>    </p>\n<pre><code>package com.example.demo;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface HelloAnnotation {\n}\n</code></pre><p>2.新建注解处理类<code>HelloProcessor</code></p>\n<pre><code>package com.example.demo;\n\nimport com.google.auto.service.AutoService;\nimport com.squareup.javapoet.JavaFile;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeSpec;\n\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.TypeElement;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Set;\n\n@AutoService(Processor.class)\n@SupportedAnnotationTypes(value = {&quot;com.example.demo.HelloAnnotation&quot;})\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\npublic final class HelloProcessor extends AbstractProcessor {\n\n    private Filer filer;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n\n        filer = processingEnv.getFiler(); // for creating file\n        System.out.println(&quot;&gt;&gt;&gt;processor init:&quot; + filer.toString());\n    }\n\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n        System.out.println(&quot;&gt;&gt;&gt;&gt; process:&quot; + annotations.size());\n        for (TypeElement element : annotations) {\n            /*Set&lt;? extends Element&gt; aa = roundEnv.getElementsAnnotatedWith(element);\n            for (Element e:\n                 aa) {\n                String name = e.getClass().getTypeName();\n                System.out.println(&quot;&gt;&gt;&gt;name:&quot; + name);\n                Name s = e.getSimpleName();\n                System.out.println(&quot;&gt;&gt;&gt;aa:&quot; + s.toString());\n\n                *//*Method[] m = e.getClass().getMethods();\n                for (int i = 0; i &lt; m.length; i++) {\n                    Method mm = m[i];\n                    System.out.println(mm.getName());\n                }*//*\n            }*/\n            System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt; process：&quot; + element.getQualifiedName().toString());\n            if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                // main method\n                MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                        .returns(void.class)\n                        .addParameter(String[].class, &quot;args&quot;)\n                        .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)\n                        .build();\n                // HelloWorld class\n                TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                        .addMethod(main)\n                        .build();\n\n                try {\n                    // build com.example.HelloWorld.java\n                    JavaFile javaFile = JavaFile.builder(&quot;com.example&quot;, helloWorld)\n                            .addFileComment(&quot; This codes are generated automatically. Do not modify!&quot;)\n                            .build();\n                    // write to file\n                    javaFile.writeTo(filer);\n\n                    javaFile.writeTo(System.out);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    //采用注解\n    /*@Override\n    public Set&lt;String&gt; getSupportedAnnotationTypes() {\n        return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n    }*/\n\n    //采用注解\n   /* @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }*/\n}\n</code></pre><ul>\n<li>加上注解<code>@AutoService(Processor.class)</code>，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。</li>\n</ul>\n<img src=\"/2018/05/03/javapoet-apt-annotation/b.png\">\n<ul>\n<li>关键，覆盖方法<code>process</code>，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在<code>maven</code>插件中配置。</li>\n</ul>\n<p>3.定义使用类</p>\n<pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@HelloAnnotation\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n//        HelloWorld.main(null);\n    }\n}\n</code></pre><p>在类上添加注解<code>@HelloAnnotation</code>。<br>那么用<code>mvn install</code>或者运行该类编译代码时，将会调用注解处理类<code>HelloProcessor</code>进行代码生成。</p>\n<hr>\n<p>_注意_:<br>在引入apt插件后，要去掉java的编译时注解，只能二选其一，否则apt会生成一次代码，java编译时注解还会生成一次代码，将重复报错。  </p>\n<ul>\n<li>用apt插件，去掉processor中的<code>@AutoService(Processor.class)</code>注解。  </li>\n<li>用java编译时注解，在processor引入<code>@AutoService(Processor.class)</code>注解，不需要apt插件。</li>\n</ul>\n<hr>\n<p>&lt;&lt;完&gt;&gt;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……</p>\n<h2 id=\"引入相关依赖包和插件\"><a href=\"#引入相关依赖包和插件\" class=\"headerlink\" title=\"引入相关依赖包和插件\"></a>引入相关依赖包和插件</h2><p>1.依赖包</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n    &lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n    &lt;version&gt;1.0-rc4&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--优雅生成代码--&gt;\n&lt;!--https://github.com/square/javapoet--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup&lt;/groupId&gt;\n    &lt;artifactId&gt;javapoet&lt;/artifactId&gt;\n    &lt;version&gt;1.10.0&lt;/version&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><ul>\n<li><p>javapoet是square公司出品的用来优雅生成代码库。网址： <a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">https://github.com/square/javapoet</a></p>\n</li>\n<li><p>google auto-service是google公司的一个库，用来自动注册服务。</p>\n</li>\n</ul>\n<p>2.apt插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;apt-maven-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.1.3&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;process&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;phase&gt;generate-sources&lt;/phase&gt;\n            &lt;configuration&gt;\n                &lt;outputDirectory&gt;${project.basedir}/target/generated-sources/java&lt;/outputDirectory&gt;\n                &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;processors&gt;\n                    &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;/processors&gt;\n                &lt;showWarnings&gt;true&lt;/showWarnings&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。</p>\n<h2 id=\"demo演示\"><a href=\"#demo演示\" class=\"headerlink\" title=\"demo演示\"></a>demo演示</h2><img src=\"/2018/05/03/javapoet-apt-annotation/a.png\"> \n<p>1.新建注解类<code>HelloAnnotation</code>    </p>\n<pre><code>package com.example.demo;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface HelloAnnotation {\n}\n</code></pre><p>2.新建注解处理类<code>HelloProcessor</code></p>\n<pre><code>package com.example.demo;\n\nimport com.google.auto.service.AutoService;\nimport com.squareup.javapoet.JavaFile;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeSpec;\n\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.TypeElement;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Set;\n\n@AutoService(Processor.class)\n@SupportedAnnotationTypes(value = {&quot;com.example.demo.HelloAnnotation&quot;})\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\npublic final class HelloProcessor extends AbstractProcessor {\n\n    private Filer filer;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n\n        filer = processingEnv.getFiler(); // for creating file\n        System.out.println(&quot;&gt;&gt;&gt;processor init:&quot; + filer.toString());\n    }\n\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n        System.out.println(&quot;&gt;&gt;&gt;&gt; process:&quot; + annotations.size());\n        for (TypeElement element : annotations) {\n            /*Set&lt;? extends Element&gt; aa = roundEnv.getElementsAnnotatedWith(element);\n            for (Element e:\n                 aa) {\n                String name = e.getClass().getTypeName();\n                System.out.println(&quot;&gt;&gt;&gt;name:&quot; + name);\n                Name s = e.getSimpleName();\n                System.out.println(&quot;&gt;&gt;&gt;aa:&quot; + s.toString());\n\n                *//*Method[] m = e.getClass().getMethods();\n                for (int i = 0; i &lt; m.length; i++) {\n                    Method mm = m[i];\n                    System.out.println(mm.getName());\n                }*//*\n            }*/\n            System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt; process：&quot; + element.getQualifiedName().toString());\n            if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                // main method\n                MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                        .returns(void.class)\n                        .addParameter(String[].class, &quot;args&quot;)\n                        .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)\n                        .build();\n                // HelloWorld class\n                TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                        .addMethod(main)\n                        .build();\n\n                try {\n                    // build com.example.HelloWorld.java\n                    JavaFile javaFile = JavaFile.builder(&quot;com.example&quot;, helloWorld)\n                            .addFileComment(&quot; This codes are generated automatically. Do not modify!&quot;)\n                            .build();\n                    // write to file\n                    javaFile.writeTo(filer);\n\n                    javaFile.writeTo(System.out);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    //采用注解\n    /*@Override\n    public Set&lt;String&gt; getSupportedAnnotationTypes() {\n        return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n    }*/\n\n    //采用注解\n   /* @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }*/\n}\n</code></pre><ul>\n<li>加上注解<code>@AutoService(Processor.class)</code>，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。</li>\n</ul>\n<img src=\"/2018/05/03/javapoet-apt-annotation/b.png\">\n<ul>\n<li>关键，覆盖方法<code>process</code>，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在<code>maven</code>插件中配置。</li>\n</ul>\n<p>3.定义使用类</p>\n<pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@HelloAnnotation\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n//        HelloWorld.main(null);\n    }\n}\n</code></pre><p>在类上添加注解<code>@HelloAnnotation</code>。<br>那么用<code>mvn install</code>或者运行该类编译代码时，将会调用注解处理类<code>HelloProcessor</code>进行代码生成。</p>\n<hr>\n<p>_注意_:<br>在引入apt插件后，要去掉java的编译时注解，只能二选其一，否则apt会生成一次代码，java编译时注解还会生成一次代码，将重复报错。  </p>\n<ul>\n<li>用apt插件，去掉processor中的<code>@AutoService(Processor.class)</code>注解。  </li>\n<li>用java编译时注解，在processor引入<code>@AutoService(Processor.class)</code>注解，不需要apt插件。</li>\n</ul>\n<hr>\n<p>&lt;&lt;完&gt;&gt;</p>\n"},{"title":"jenkins-java-maven持续集成（CentOs7）","date":"2017-11-28T01:15:26.000Z","_content":"\n传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。\n\n参考：  \nhttp://www.jianshu.com/p/a7d7df97fe4b\n\n## 1. 安装并运行jenkins-war\n- [下载](https://jenkins.io/download/)\n- 运行 `java -jar jenkins.war --httpPort=8080.`\n- 在浏览器访问 http://localhost:8080. 记得开防火墙。\n\n图一：\n{% asset_img a.png %}\n\n## 2. 初次访问配置\n- 按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。\n- 按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。\n- 创建管理员账号，按照页面设置即可。\n\n这样，下面就可以开始使用jenkins了。\n\n\n## 3. maven，svn,springboot下持续构建java应用\n- 安装maven环境。[下载maven](http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz)\n\n### 3.1 配置jenkins\n\n{% asset_img b.png %}\n\n点击`系统管理`。\n\n{% asset_img c.png %}\n\n配置各种环境：\n\n- maven setting.xml\n\n{% asset_img e.png %}\n\n- jdk,取消自动安装\n\n{% asset_img f.png %}\n\n- maven,取消自动安装\n\n{% asset_img g.png %}\n\n### 3.2 安装maven插件\n\n{% asset_img h.png %}\n\n-------\n\n{% asset_img i.png %}\n\n点击直接安装即可。\n\n### 3.3 创建新项目\n\n{% asset_img 1.png %}\n\n选定。\n\n{% asset_img 2.png %}\n\n点击ok。\n\n### 3.4 配置项目各种信息\n{% asset_img 3.png %}\n\n------------\n{% asset_img 4.png %}\n\n### 3.5 开始构建项目\n\n{% asset_img 5.png %}\n\n查看构建结果\n\n{% asset_img 6.png %}\n\n然后再服务器相关目录下就能看到构建后的jar包:\n{% asset_img 7.png %}\n\n### 3.6 构建后配置\n构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。\n\n#### 3.6.1 直接执行jar\n修改项目配置：\n{% asset_img 8.png %}\n\n添加成功构建后要执行的脚本：\n{% asset_img 8_1.png %}\n\n> 注意脚本写法，如果是后台执行：\n    `BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`\n\n#### 3.6.2 发布jar到远程服务器，并执行\n - 下载相关插件：\n {% asset_img 10.png %}\n \n- 在系统设置中添加远程服务器：\n {% asset_img 11.png %}\n\n- 在项目中设置，选定远程服务器：\n{% asset_img 12.png %}\n\n*注意：*\n{% asset_img 13.png %}\n\n- 备份，执行远程服务器上的jar包\n\n1. 在远程服务器上设置脚本，放在目录：`server/bin`：\n\n>停止应用脚本`stop.sh`：\n    # 将应用停止\n    #stop.sh\n    #!/bin/bash\n    echo \"Stopping SpringBoot Application\"\n    pid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk '{print $2}'`\n    if [ -n \"$pid\" ]\n    then\n       kill -9 $pid\n    fi\n---    \n> 备份应用脚本`replace.sh`:\n    #replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n    #!/bin/bash\n    # 先判断文件是否存在，如果存在，则备份\n    file=\"/server/java/apps/jenkins-demo.jar\"\n    if [ -f \"$file\" ]\n    then\n       mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\n    fi\n    mv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n---\n> 启动应用包脚本`start.sh`:\n    # startup.sh 启动项目\n    #!/bin/bash\n    echo \"授予当前用户权限\"\n    chmod 777 /server/java/apps/jenkins-demo.jar\n    echo \"执行.....\"\n    java -jar /server/java/apps/jenkins-demo.jar\n   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行`nohub java -jar /server/java/apps/jenkins-demo.jar &`不起作用，所在要在jenkins上这样配置`BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`  \n   如果是远程服务器，就可以改成：\n       # startup.sh 启动项目\n       #!/bin/bash\n       echo \"授予当前用户权限\"\n       chmod 777 /server/java/apps/jenkins-demo.jar\n       echo \"执行.....\"\n       nohup java -jar /server/java/apps/jenkins-demo.jar > jenkins-demo.out 2>& 1 &\n    \n---\n2. 设置远程服务器执行脚本： \n\n{% asset_img 14.png %}   \n\n如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。\n\n{% asset_img 15.png %}   \n\n## 备注：\n\n1.替换jar包中的文件\n\n`jar -uvf rpds.jar BOOT-INF/classes/db.properties `\n\n2.启动jar应用程序shell脚本\n\n    #!/bin/sh\n    # chkconfig: 2345 64 36\n    ## java env \n    #################### zhengjianyan #######################\n    export JAVA_HOME=/server/java/jdk\n    export JRE_HOME=$JAVA_HOME/jre\n    \n    BASE_PATH=/server/java/service/com.xcsqjr.scf.service\n    VERSION=1.0.0\n    ## service name\n    APP_NAME=all\n    \n    SERVICE_DIR=$BASE_PATH/com.xcsqjr.scf.service.$APP_NAME\n    SERVICE_NAME=com.xcsqjr.scf.service.$APP_NAME-$VERSION\n    #JAR_NAME=$SERVICE_DIR/$SERVICE_NAME/target\\.jar\n    JAR_NAME=$SERVICE_DIR/target/$SERVICE_NAME.jar\n    PID=$SERVICE_NAME\\.pid\n    \n    rm -rf $SERVICE_DIR/target/*.tmp\n    cd $BASE_PATH\n    cd ..\n    \n    $JAVA_HOME/bin/jar uvf $SERVICE_DIR/target/$SERVICE_NAME.jar application.properties\n    \n    cd $SERVICE_DIR\n    case \"$1\" in\n    \n        start)\n            nohup $JRE_HOME/bin/java -Xms128m -Xmx256m -jar $JAR_NAME >/dev/null 2>&1 &\n            echo $! > $SERVICE_DIR/target/$PID\n            echo \"=== start $SERVICE_NAME\"\n            ;;\n    \n        stop)\n            kill `cat $SERVICE_DIR/target/$PID`\n            rm -rf $SERVICE_DIR/target/$PID\n            echo \"=== stop $SERVICE_NAME\"\n    \n            sleep 5\n            P_ID=`ps -ef | grep -w \"$SERVICE_NAME\" | grep -v \"grep\" | awk '{print $2}'`\n            if [ \"$P_ID\" == \"\" ]; then\n                echo \"=== $SERVICE_NAME process not exists or stop success\"\n            else\n                echo \"=== $SERVICE_NAME process pid is:$P_ID\"\n                echo \"=== begin kill $SERVICE_NAME process, pid is:$P_ID\"\n                kill -9 $P_ID\n            fi\n            ;;\n    \n        restart)\n            $0 stop\n            sleep 2\n            $0 start\n            echo \"=== restart $SERVICE_NAME\"\n            ;;\n    \n        *)\n    \t\techo \"==== restart =====\"\n            ## restart\n            $0 stop\n            sleep 5\n            $0 start\n            ;;\n    esac\n    exit 0\n\n\n\n","source":"_posts/jenkins-java-maven.md","raw":"---\ntitle: jenkins-java-maven持续集成（CentOs7）\ndate: 2017-11-28 09:15:26\ncategories: 持续集成\ntags: jenkins-java-maven\n---\n\n传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。\n\n参考：  \nhttp://www.jianshu.com/p/a7d7df97fe4b\n\n## 1. 安装并运行jenkins-war\n- [下载](https://jenkins.io/download/)\n- 运行 `java -jar jenkins.war --httpPort=8080.`\n- 在浏览器访问 http://localhost:8080. 记得开防火墙。\n\n图一：\n{% asset_img a.png %}\n\n## 2. 初次访问配置\n- 按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。\n- 按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。\n- 创建管理员账号，按照页面设置即可。\n\n这样，下面就可以开始使用jenkins了。\n\n\n## 3. maven，svn,springboot下持续构建java应用\n- 安装maven环境。[下载maven](http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz)\n\n### 3.1 配置jenkins\n\n{% asset_img b.png %}\n\n点击`系统管理`。\n\n{% asset_img c.png %}\n\n配置各种环境：\n\n- maven setting.xml\n\n{% asset_img e.png %}\n\n- jdk,取消自动安装\n\n{% asset_img f.png %}\n\n- maven,取消自动安装\n\n{% asset_img g.png %}\n\n### 3.2 安装maven插件\n\n{% asset_img h.png %}\n\n-------\n\n{% asset_img i.png %}\n\n点击直接安装即可。\n\n### 3.3 创建新项目\n\n{% asset_img 1.png %}\n\n选定。\n\n{% asset_img 2.png %}\n\n点击ok。\n\n### 3.4 配置项目各种信息\n{% asset_img 3.png %}\n\n------------\n{% asset_img 4.png %}\n\n### 3.5 开始构建项目\n\n{% asset_img 5.png %}\n\n查看构建结果\n\n{% asset_img 6.png %}\n\n然后再服务器相关目录下就能看到构建后的jar包:\n{% asset_img 7.png %}\n\n### 3.6 构建后配置\n构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。\n\n#### 3.6.1 直接执行jar\n修改项目配置：\n{% asset_img 8.png %}\n\n添加成功构建后要执行的脚本：\n{% asset_img 8_1.png %}\n\n> 注意脚本写法，如果是后台执行：\n    `BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`\n\n#### 3.6.2 发布jar到远程服务器，并执行\n - 下载相关插件：\n {% asset_img 10.png %}\n \n- 在系统设置中添加远程服务器：\n {% asset_img 11.png %}\n\n- 在项目中设置，选定远程服务器：\n{% asset_img 12.png %}\n\n*注意：*\n{% asset_img 13.png %}\n\n- 备份，执行远程服务器上的jar包\n\n1. 在远程服务器上设置脚本，放在目录：`server/bin`：\n\n>停止应用脚本`stop.sh`：\n    # 将应用停止\n    #stop.sh\n    #!/bin/bash\n    echo \"Stopping SpringBoot Application\"\n    pid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk '{print $2}'`\n    if [ -n \"$pid\" ]\n    then\n       kill -9 $pid\n    fi\n---    \n> 备份应用脚本`replace.sh`:\n    #replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n    #!/bin/bash\n    # 先判断文件是否存在，如果存在，则备份\n    file=\"/server/java/apps/jenkins-demo.jar\"\n    if [ -f \"$file\" ]\n    then\n       mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\n    fi\n    mv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n---\n> 启动应用包脚本`start.sh`:\n    # startup.sh 启动项目\n    #!/bin/bash\n    echo \"授予当前用户权限\"\n    chmod 777 /server/java/apps/jenkins-demo.jar\n    echo \"执行.....\"\n    java -jar /server/java/apps/jenkins-demo.jar\n   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行`nohub java -jar /server/java/apps/jenkins-demo.jar &`不起作用，所在要在jenkins上这样配置`BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`  \n   如果是远程服务器，就可以改成：\n       # startup.sh 启动项目\n       #!/bin/bash\n       echo \"授予当前用户权限\"\n       chmod 777 /server/java/apps/jenkins-demo.jar\n       echo \"执行.....\"\n       nohup java -jar /server/java/apps/jenkins-demo.jar > jenkins-demo.out 2>& 1 &\n    \n---\n2. 设置远程服务器执行脚本： \n\n{% asset_img 14.png %}   \n\n如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。\n\n{% asset_img 15.png %}   \n\n## 备注：\n\n1.替换jar包中的文件\n\n`jar -uvf rpds.jar BOOT-INF/classes/db.properties `\n\n2.启动jar应用程序shell脚本\n\n    #!/bin/sh\n    # chkconfig: 2345 64 36\n    ## java env \n    #################### zhengjianyan #######################\n    export JAVA_HOME=/server/java/jdk\n    export JRE_HOME=$JAVA_HOME/jre\n    \n    BASE_PATH=/server/java/service/com.xcsqjr.scf.service\n    VERSION=1.0.0\n    ## service name\n    APP_NAME=all\n    \n    SERVICE_DIR=$BASE_PATH/com.xcsqjr.scf.service.$APP_NAME\n    SERVICE_NAME=com.xcsqjr.scf.service.$APP_NAME-$VERSION\n    #JAR_NAME=$SERVICE_DIR/$SERVICE_NAME/target\\.jar\n    JAR_NAME=$SERVICE_DIR/target/$SERVICE_NAME.jar\n    PID=$SERVICE_NAME\\.pid\n    \n    rm -rf $SERVICE_DIR/target/*.tmp\n    cd $BASE_PATH\n    cd ..\n    \n    $JAVA_HOME/bin/jar uvf $SERVICE_DIR/target/$SERVICE_NAME.jar application.properties\n    \n    cd $SERVICE_DIR\n    case \"$1\" in\n    \n        start)\n            nohup $JRE_HOME/bin/java -Xms128m -Xmx256m -jar $JAR_NAME >/dev/null 2>&1 &\n            echo $! > $SERVICE_DIR/target/$PID\n            echo \"=== start $SERVICE_NAME\"\n            ;;\n    \n        stop)\n            kill `cat $SERVICE_DIR/target/$PID`\n            rm -rf $SERVICE_DIR/target/$PID\n            echo \"=== stop $SERVICE_NAME\"\n    \n            sleep 5\n            P_ID=`ps -ef | grep -w \"$SERVICE_NAME\" | grep -v \"grep\" | awk '{print $2}'`\n            if [ \"$P_ID\" == \"\" ]; then\n                echo \"=== $SERVICE_NAME process not exists or stop success\"\n            else\n                echo \"=== $SERVICE_NAME process pid is:$P_ID\"\n                echo \"=== begin kill $SERVICE_NAME process, pid is:$P_ID\"\n                kill -9 $P_ID\n            fi\n            ;;\n    \n        restart)\n            $0 stop\n            sleep 2\n            $0 start\n            echo \"=== restart $SERVICE_NAME\"\n            ;;\n    \n        *)\n    \t\techo \"==== restart =====\"\n            ## restart\n            $0 stop\n            sleep 5\n            $0 start\n            ;;\n    esac\n    exit 0\n\n\n\n","slug":"jenkins-java-maven","published":1,"updated":"2018-11-09T01:20:30.171Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38lc0050qcrgflokitr0","content":"<p>传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。</p>\n<p>参考：<br><a href=\"http://www.jianshu.com/p/a7d7df97fe4b\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/a7d7df97fe4b</a></p>\n<h2 id=\"1-安装并运行jenkins-war\"><a href=\"#1-安装并运行jenkins-war\" class=\"headerlink\" title=\"1. 安装并运行jenkins-war\"></a>1. 安装并运行jenkins-war</h2><ul>\n<li><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li>运行 <code>java -jar jenkins.war --httpPort=8080.</code></li>\n<li>在浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>. 记得开防火墙。</li>\n</ul>\n<p>图一：<br><img src=\"/2017/11/28/jenkins-java-maven/a.png\"></p>\n<h2 id=\"2-初次访问配置\"><a href=\"#2-初次访问配置\" class=\"headerlink\" title=\"2. 初次访问配置\"></a>2. 初次访问配置</h2><ul>\n<li>按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。</li>\n<li>按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。</li>\n<li>创建管理员账号，按照页面设置即可。</li>\n</ul>\n<p>这样，下面就可以开始使用jenkins了。</p>\n<h2 id=\"3-maven，svn-springboot下持续构建java应用\"><a href=\"#3-maven，svn-springboot下持续构建java应用\" class=\"headerlink\" title=\"3. maven，svn,springboot下持续构建java应用\"></a>3. maven，svn,springboot下持续构建java应用</h2><ul>\n<li>安装maven环境。<a href=\"http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">下载maven</a></li>\n</ul>\n<h3 id=\"3-1-配置jenkins\"><a href=\"#3-1-配置jenkins\" class=\"headerlink\" title=\"3.1 配置jenkins\"></a>3.1 配置jenkins</h3><img src=\"/2017/11/28/jenkins-java-maven/b.png\">\n<p>点击<code>系统管理</code>。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/c.png\">\n<p>配置各种环境：</p>\n<ul>\n<li>maven setting.xml</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/e.png\">\n<ul>\n<li>jdk,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/f.png\">\n<ul>\n<li>maven,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/g.png\">\n<h3 id=\"3-2-安装maven插件\"><a href=\"#3-2-安装maven插件\" class=\"headerlink\" title=\"3.2 安装maven插件\"></a>3.2 安装maven插件</h3><img src=\"/2017/11/28/jenkins-java-maven/h.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/i.png\">\n<p>点击直接安装即可。</p>\n<h3 id=\"3-3-创建新项目\"><a href=\"#3-3-创建新项目\" class=\"headerlink\" title=\"3.3 创建新项目\"></a>3.3 创建新项目</h3><img src=\"/2017/11/28/jenkins-java-maven/1.png\">\n<p>选定。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/2.png\">\n<p>点击ok。</p>\n<h3 id=\"3-4-配置项目各种信息\"><a href=\"#3-4-配置项目各种信息\" class=\"headerlink\" title=\"3.4 配置项目各种信息\"></a>3.4 配置项目各种信息</h3><img src=\"/2017/11/28/jenkins-java-maven/3.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/4.png\">\n<h3 id=\"3-5-开始构建项目\"><a href=\"#3-5-开始构建项目\" class=\"headerlink\" title=\"3.5 开始构建项目\"></a>3.5 开始构建项目</h3><img src=\"/2017/11/28/jenkins-java-maven/5.png\">\n<p>查看构建结果</p>\n<img src=\"/2017/11/28/jenkins-java-maven/6.png\">\n<p>然后再服务器相关目录下就能看到构建后的jar包:<br><img src=\"/2017/11/28/jenkins-java-maven/7.png\"></p>\n<h3 id=\"3-6-构建后配置\"><a href=\"#3-6-构建后配置\" class=\"headerlink\" title=\"3.6 构建后配置\"></a>3.6 构建后配置</h3><p>构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。</p>\n<h4 id=\"3-6-1-直接执行jar\"><a href=\"#3-6-1-直接执行jar\" class=\"headerlink\" title=\"3.6.1 直接执行jar\"></a>3.6.1 直接执行jar</h4><p>修改项目配置：<br><img src=\"/2017/11/28/jenkins-java-maven/8.png\"></p>\n<p>添加成功构建后要执行的脚本：<br><img src=\"/2017/11/28/jenkins-java-maven/8_1.png\"></p>\n<blockquote>\n<p>注意脚本写法，如果是后台执行：<br>    <code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code></p>\n</blockquote>\n<h4 id=\"3-6-2-发布jar到远程服务器，并执行\"><a href=\"#3-6-2-发布jar到远程服务器，并执行\" class=\"headerlink\" title=\"3.6.2 发布jar到远程服务器，并执行\"></a>3.6.2 发布jar到远程服务器，并执行</h4><ul>\n<li>下载相关插件：<img src=\"/2017/11/28/jenkins-java-maven/10.png\">\n</li>\n</ul>\n<ul>\n<li><p>在系统设置中添加远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/11.png\">\n</li>\n<li><p>在项目中设置，选定远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/12.png\">\n</li>\n</ul>\n<p><em>注意：</em><br><img src=\"/2017/11/28/jenkins-java-maven/13.png\"></p>\n<ul>\n<li>备份，执行远程服务器上的jar包</li>\n</ul>\n<ol>\n<li>在远程服务器上设置脚本，放在目录：<code>server/bin</code>：</li>\n</ol>\n<blockquote>\n<p>停止应用脚本<code>stop.sh</code>：</p>\n</blockquote>\n<pre><code># 将应用停止\n#stop.sh\n#!/bin/bash\necho &quot;Stopping SpringBoot Application&quot;\npid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk &apos;{print $2}&apos;`\nif [ -n &quot;$pid&quot; ]\nthen\n   kill -9 $pid\nfi\n</code></pre><hr>\n<blockquote>\n<p>备份应用脚本<code>replace.sh</code>:</p>\n</blockquote>\n<pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n#!/bin/bash\n# 先判断文件是否存在，如果存在，则备份\nfile=&quot;/server/java/apps/jenkins-demo.jar&quot;\nif [ -f &quot;$file&quot; ]\nthen\n   mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\nfi\nmv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n</code></pre><hr>\n<blockquote>\n<p>启动应用包脚本<code>start.sh</code>:</p>\n</blockquote>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\njava -jar /server/java/apps/jenkins-demo.jar\n</code></pre><p>   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行<code>nohub java -jar /server/java/apps/jenkins-demo.jar &amp;</code>不起作用，所在要在jenkins上这样配置<code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code><br>   如果是远程服务器，就可以改成：</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\nnohup java -jar /server/java/apps/jenkins-demo.jar &gt; jenkins-demo.out 2&gt;&amp; 1 &amp;\n</code></pre><hr>\n<ol start=\"2\">\n<li>设置远程服务器执行脚本： </li>\n</ol>\n<img src=\"/2017/11/28/jenkins-java-maven/14.png\">   \n<p>如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/15.png\">   \n<h2 id=\"备注：\"><a href=\"#备注：\" class=\"headerlink\" title=\"备注：\"></a>备注：</h2><p>1.替换jar包中的文件</p>\n<p><code>jar -uvf rpds.jar BOOT-INF/classes/db.properties</code></p>\n<p>2.启动jar应用程序shell脚本</p>\n<pre><code>#!/bin/sh\n# chkconfig: 2345 64 36\n## java env \n#################### zhengjianyan #######################\nexport JAVA_HOME=/server/java/jdk\nexport JRE_HOME=$JAVA_HOME/jre\n\nBASE_PATH=/server/java/service/com.xcsqjr.scf.service\nVERSION=1.0.0\n## service name\nAPP_NAME=all\n\nSERVICE_DIR=$BASE_PATH/com.xcsqjr.scf.service.$APP_NAME\nSERVICE_NAME=com.xcsqjr.scf.service.$APP_NAME-$VERSION\n#JAR_NAME=$SERVICE_DIR/$SERVICE_NAME/target\\.jar\nJAR_NAME=$SERVICE_DIR/target/$SERVICE_NAME.jar\nPID=$SERVICE_NAME\\.pid\n\nrm -rf $SERVICE_DIR/target/*.tmp\ncd $BASE_PATH\ncd ..\n\n$JAVA_HOME/bin/jar uvf $SERVICE_DIR/target/$SERVICE_NAME.jar application.properties\n\ncd $SERVICE_DIR\ncase &quot;$1&quot; in\n\n    start)\n        nohup $JRE_HOME/bin/java -Xms128m -Xmx256m -jar $JAR_NAME &gt;/dev/null 2&gt;&amp;1 &amp;\n        echo $! &gt; $SERVICE_DIR/target/$PID\n        echo &quot;=== start $SERVICE_NAME&quot;\n        ;;\n\n    stop)\n        kill `cat $SERVICE_DIR/target/$PID`\n        rm -rf $SERVICE_DIR/target/$PID\n        echo &quot;=== stop $SERVICE_NAME&quot;\n\n        sleep 5\n        P_ID=`ps -ef | grep -w &quot;$SERVICE_NAME&quot; | grep -v &quot;grep&quot; | awk &apos;{print $2}&apos;`\n        if [ &quot;$P_ID&quot; == &quot;&quot; ]; then\n            echo &quot;=== $SERVICE_NAME process not exists or stop success&quot;\n        else\n            echo &quot;=== $SERVICE_NAME process pid is:$P_ID&quot;\n            echo &quot;=== begin kill $SERVICE_NAME process, pid is:$P_ID&quot;\n            kill -9 $P_ID\n        fi\n        ;;\n\n    restart)\n        $0 stop\n        sleep 2\n        $0 start\n        echo &quot;=== restart $SERVICE_NAME&quot;\n        ;;\n\n    *)\n        echo &quot;==== restart =====&quot;\n        ## restart\n        $0 stop\n        sleep 5\n        $0 start\n        ;;\nesac\nexit 0\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。</p>\n<p>参考：<br><a href=\"http://www.jianshu.com/p/a7d7df97fe4b\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/a7d7df97fe4b</a></p>\n<h2 id=\"1-安装并运行jenkins-war\"><a href=\"#1-安装并运行jenkins-war\" class=\"headerlink\" title=\"1. 安装并运行jenkins-war\"></a>1. 安装并运行jenkins-war</h2><ul>\n<li><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li>运行 <code>java -jar jenkins.war --httpPort=8080.</code></li>\n<li>在浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>. 记得开防火墙。</li>\n</ul>\n<p>图一：<br><img src=\"/2017/11/28/jenkins-java-maven/a.png\"></p>\n<h2 id=\"2-初次访问配置\"><a href=\"#2-初次访问配置\" class=\"headerlink\" title=\"2. 初次访问配置\"></a>2. 初次访问配置</h2><ul>\n<li>按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。</li>\n<li>按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。</li>\n<li>创建管理员账号，按照页面设置即可。</li>\n</ul>\n<p>这样，下面就可以开始使用jenkins了。</p>\n<h2 id=\"3-maven，svn-springboot下持续构建java应用\"><a href=\"#3-maven，svn-springboot下持续构建java应用\" class=\"headerlink\" title=\"3. maven，svn,springboot下持续构建java应用\"></a>3. maven，svn,springboot下持续构建java应用</h2><ul>\n<li>安装maven环境。<a href=\"http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">下载maven</a></li>\n</ul>\n<h3 id=\"3-1-配置jenkins\"><a href=\"#3-1-配置jenkins\" class=\"headerlink\" title=\"3.1 配置jenkins\"></a>3.1 配置jenkins</h3><img src=\"/2017/11/28/jenkins-java-maven/b.png\">\n<p>点击<code>系统管理</code>。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/c.png\">\n<p>配置各种环境：</p>\n<ul>\n<li>maven setting.xml</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/e.png\">\n<ul>\n<li>jdk,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/f.png\">\n<ul>\n<li>maven,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/g.png\">\n<h3 id=\"3-2-安装maven插件\"><a href=\"#3-2-安装maven插件\" class=\"headerlink\" title=\"3.2 安装maven插件\"></a>3.2 安装maven插件</h3><img src=\"/2017/11/28/jenkins-java-maven/h.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/i.png\">\n<p>点击直接安装即可。</p>\n<h3 id=\"3-3-创建新项目\"><a href=\"#3-3-创建新项目\" class=\"headerlink\" title=\"3.3 创建新项目\"></a>3.3 创建新项目</h3><img src=\"/2017/11/28/jenkins-java-maven/1.png\">\n<p>选定。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/2.png\">\n<p>点击ok。</p>\n<h3 id=\"3-4-配置项目各种信息\"><a href=\"#3-4-配置项目各种信息\" class=\"headerlink\" title=\"3.4 配置项目各种信息\"></a>3.4 配置项目各种信息</h3><img src=\"/2017/11/28/jenkins-java-maven/3.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/4.png\">\n<h3 id=\"3-5-开始构建项目\"><a href=\"#3-5-开始构建项目\" class=\"headerlink\" title=\"3.5 开始构建项目\"></a>3.5 开始构建项目</h3><img src=\"/2017/11/28/jenkins-java-maven/5.png\">\n<p>查看构建结果</p>\n<img src=\"/2017/11/28/jenkins-java-maven/6.png\">\n<p>然后再服务器相关目录下就能看到构建后的jar包:<br><img src=\"/2017/11/28/jenkins-java-maven/7.png\"></p>\n<h3 id=\"3-6-构建后配置\"><a href=\"#3-6-构建后配置\" class=\"headerlink\" title=\"3.6 构建后配置\"></a>3.6 构建后配置</h3><p>构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。</p>\n<h4 id=\"3-6-1-直接执行jar\"><a href=\"#3-6-1-直接执行jar\" class=\"headerlink\" title=\"3.6.1 直接执行jar\"></a>3.6.1 直接执行jar</h4><p>修改项目配置：<br><img src=\"/2017/11/28/jenkins-java-maven/8.png\"></p>\n<p>添加成功构建后要执行的脚本：<br><img src=\"/2017/11/28/jenkins-java-maven/8_1.png\"></p>\n<blockquote>\n<p>注意脚本写法，如果是后台执行：<br>    <code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code></p>\n</blockquote>\n<h4 id=\"3-6-2-发布jar到远程服务器，并执行\"><a href=\"#3-6-2-发布jar到远程服务器，并执行\" class=\"headerlink\" title=\"3.6.2 发布jar到远程服务器，并执行\"></a>3.6.2 发布jar到远程服务器，并执行</h4><ul>\n<li>下载相关插件：<img src=\"/2017/11/28/jenkins-java-maven/10.png\">\n</li>\n</ul>\n<ul>\n<li><p>在系统设置中添加远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/11.png\">\n</li>\n<li><p>在项目中设置，选定远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/12.png\">\n</li>\n</ul>\n<p><em>注意：</em><br><img src=\"/2017/11/28/jenkins-java-maven/13.png\"></p>\n<ul>\n<li>备份，执行远程服务器上的jar包</li>\n</ul>\n<ol>\n<li>在远程服务器上设置脚本，放在目录：<code>server/bin</code>：</li>\n</ol>\n<blockquote>\n<p>停止应用脚本<code>stop.sh</code>：</p>\n</blockquote>\n<pre><code># 将应用停止\n#stop.sh\n#!/bin/bash\necho &quot;Stopping SpringBoot Application&quot;\npid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk &apos;{print $2}&apos;`\nif [ -n &quot;$pid&quot; ]\nthen\n   kill -9 $pid\nfi\n</code></pre><hr>\n<blockquote>\n<p>备份应用脚本<code>replace.sh</code>:</p>\n</blockquote>\n<pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n#!/bin/bash\n# 先判断文件是否存在，如果存在，则备份\nfile=&quot;/server/java/apps/jenkins-demo.jar&quot;\nif [ -f &quot;$file&quot; ]\nthen\n   mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\nfi\nmv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n</code></pre><hr>\n<blockquote>\n<p>启动应用包脚本<code>start.sh</code>:</p>\n</blockquote>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\njava -jar /server/java/apps/jenkins-demo.jar\n</code></pre><p>   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行<code>nohub java -jar /server/java/apps/jenkins-demo.jar &amp;</code>不起作用，所在要在jenkins上这样配置<code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code><br>   如果是远程服务器，就可以改成：</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\nnohup java -jar /server/java/apps/jenkins-demo.jar &gt; jenkins-demo.out 2&gt;&amp; 1 &amp;\n</code></pre><hr>\n<ol start=\"2\">\n<li>设置远程服务器执行脚本： </li>\n</ol>\n<img src=\"/2017/11/28/jenkins-java-maven/14.png\">   \n<p>如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/15.png\">   \n<h2 id=\"备注：\"><a href=\"#备注：\" class=\"headerlink\" title=\"备注：\"></a>备注：</h2><p>1.替换jar包中的文件</p>\n<p><code>jar -uvf rpds.jar BOOT-INF/classes/db.properties</code></p>\n<p>2.启动jar应用程序shell脚本</p>\n<pre><code>#!/bin/sh\n# chkconfig: 2345 64 36\n## java env \n#################### zhengjianyan #######################\nexport JAVA_HOME=/server/java/jdk\nexport JRE_HOME=$JAVA_HOME/jre\n\nBASE_PATH=/server/java/service/com.xcsqjr.scf.service\nVERSION=1.0.0\n## service name\nAPP_NAME=all\n\nSERVICE_DIR=$BASE_PATH/com.xcsqjr.scf.service.$APP_NAME\nSERVICE_NAME=com.xcsqjr.scf.service.$APP_NAME-$VERSION\n#JAR_NAME=$SERVICE_DIR/$SERVICE_NAME/target\\.jar\nJAR_NAME=$SERVICE_DIR/target/$SERVICE_NAME.jar\nPID=$SERVICE_NAME\\.pid\n\nrm -rf $SERVICE_DIR/target/*.tmp\ncd $BASE_PATH\ncd ..\n\n$JAVA_HOME/bin/jar uvf $SERVICE_DIR/target/$SERVICE_NAME.jar application.properties\n\ncd $SERVICE_DIR\ncase &quot;$1&quot; in\n\n    start)\n        nohup $JRE_HOME/bin/java -Xms128m -Xmx256m -jar $JAR_NAME &gt;/dev/null 2&gt;&amp;1 &amp;\n        echo $! &gt; $SERVICE_DIR/target/$PID\n        echo &quot;=== start $SERVICE_NAME&quot;\n        ;;\n\n    stop)\n        kill `cat $SERVICE_DIR/target/$PID`\n        rm -rf $SERVICE_DIR/target/$PID\n        echo &quot;=== stop $SERVICE_NAME&quot;\n\n        sleep 5\n        P_ID=`ps -ef | grep -w &quot;$SERVICE_NAME&quot; | grep -v &quot;grep&quot; | awk &apos;{print $2}&apos;`\n        if [ &quot;$P_ID&quot; == &quot;&quot; ]; then\n            echo &quot;=== $SERVICE_NAME process not exists or stop success&quot;\n        else\n            echo &quot;=== $SERVICE_NAME process pid is:$P_ID&quot;\n            echo &quot;=== begin kill $SERVICE_NAME process, pid is:$P_ID&quot;\n            kill -9 $P_ID\n        fi\n        ;;\n\n    restart)\n        $0 stop\n        sleep 2\n        $0 start\n        echo &quot;=== restart $SERVICE_NAME&quot;\n        ;;\n\n    *)\n        echo &quot;==== restart =====&quot;\n        ## restart\n        $0 stop\n        sleep 5\n        $0 start\n        ;;\nesac\nexit 0\n</code></pre>"},{"title":"jvm优化-监控工具","date":"2017-10-20T04:52:40.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1552290","source":"_posts/jvm-look-tools.md","raw":"---\ntitle: jvm优化-监控工具\ndate: 2017-10-20 12:52:40\ncategories: jvm\ntags: jvm监控工具\n---\n\nhttps://my.oschina.net/u/1859679/blog/1552290","slug":"jvm-look-tools","published":1,"updated":"2018-11-09T01:20:30.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38ll0055qcrgdzb0pbn2","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n"},{"title":"jvm优化-垃圾回收机制","date":"2017-10-20T04:51:08.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1548866","source":"_posts/jvm-gc.md","raw":"---\ntitle: jvm优化-垃圾回收机制\ndate: 2017-10-20 12:51:08\ncategories: jvm\ntags: gc垃圾回收\n---\n\nhttps://my.oschina.net/u/1859679/blog/1548866","slug":"jvm-gc","published":1,"updated":"2018-11-09T01:20:30.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38lt0057qcrg1p8guvdg","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n"},{"title":"jwt-study","date":"2018-03-08T08:47:23.000Z","_content":"\n","source":"_posts/jwt-study.md","raw":"---\ntitle: jwt-study\ndate: 2018-03-08 16:47:23\ncategories:\ntags:\n---\n\n","slug":"jwt-study","published":1,"updated":"2018-11-09T01:20:30.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38lu0059qcrg2rsus628","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"k8s入门","date":"2018-03-13T00:56:45.000Z","_content":"","source":"_posts/k8s-start.md","raw":"---\ntitle: k8s入门\ndate: 2018-03-13 08:56:45\ncategories: Kubernetes\ntags: k8s\n---\n","slug":"k8s-start","published":1,"updated":"2018-11-09T01:20:30.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38lw005dqcrgmy21segc","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"linux常用命令使用收藏","date":"2017-10-14T03:26:18.000Z","_content":"收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n## 4. 开机启动命令-chkconfig\n\n## 5. 文档操作\n### 5.1 复制文件-cp命令使用\n1. 文件到文件复制\n> 将文档a复制成b（相当于备份并改名）。\ncp -i a b\n或，\ncp a b\n\n2. 文件到目录复制\n>将文档 file1复制到dir1目录下，复制后名称仍未file1\ncp -i file1 dir1\n或，\ncp file1 dir1\n\n3. 目录到目录复制\n>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2\ncp -r dir1 dir2\n将目录dir1下所有文件包括文件夹，都复制到dir2目录下\ncp -r dir1/*.* dir2\n常见错误：\n1、提示cp: omitting directory错误\n复制目录时，使用-r选项即可递归拷贝，如下：\ncp -r dir1 dir2\n\n## 6. 解压/压缩\n### 6.1 压缩\n> 压缩\n  tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n  \n### 6.2 解压\n> 解压\n  tar –xvf file.tar //解压 tar包\n  tar -xzvf file.tar.gz //解压tar.gz\n  tar -xjvf file.tar.bz2   //解压 tar.bz2\n  tar –xZvf file.tar.Z   //解压tar.Z\n  unrar e file.rar //解压rar\n  unzip file.zip //解压zip\n  \n### 6.3 ubuntu 下rar解压工具安装方法：\n \n> 1、压缩功能\n 安装 sudo apt-get install rar\n 卸载 sudo apt-get remove rar\n 2、解压功能\n 安装 sudo apt-get install unrar\n 卸载 sudo apt-get remove unrar\n 压缩解压缩.rar\n 解压：rar x FileName.rar\n 压缩：rar a FileName.rar DirName  \n  \n### 6.4 总结\n> 1、`*.tar` 用 tar –xvf 解压\n  2、`*.gz` 用 gzip -d或者gunzip 解压\n  3、`*.tar.gz`和`*.tgz` 用 tar –xzf 解压\n  4、`*.bz2` 用 bzip2 -d或者用bunzip2 解压\n  5、`*.tar.bz2`用tar –xjf 解压\n  6、`*.Z` 用 uncompress 解压\n  7、`*.tar.Z` 用tar –xZf 解压\n  8、`*.rar` 用 unrar e解压\n  9、`*.zip` 用 unzip 解压    \n\n","source":"_posts/linux-command-use.md","raw":"---\ntitle: linux常用命令使用收藏\ndate: 2017-10-14 11:26:18\ncategories: linux\ntags: linux-command\n---\n收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n## 4. 开机启动命令-chkconfig\n\n## 5. 文档操作\n### 5.1 复制文件-cp命令使用\n1. 文件到文件复制\n> 将文档a复制成b（相当于备份并改名）。\ncp -i a b\n或，\ncp a b\n\n2. 文件到目录复制\n>将文档 file1复制到dir1目录下，复制后名称仍未file1\ncp -i file1 dir1\n或，\ncp file1 dir1\n\n3. 目录到目录复制\n>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2\ncp -r dir1 dir2\n将目录dir1下所有文件包括文件夹，都复制到dir2目录下\ncp -r dir1/*.* dir2\n常见错误：\n1、提示cp: omitting directory错误\n复制目录时，使用-r选项即可递归拷贝，如下：\ncp -r dir1 dir2\n\n## 6. 解压/压缩\n### 6.1 压缩\n> 压缩\n  tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n  \n### 6.2 解压\n> 解压\n  tar –xvf file.tar //解压 tar包\n  tar -xzvf file.tar.gz //解压tar.gz\n  tar -xjvf file.tar.bz2   //解压 tar.bz2\n  tar –xZvf file.tar.Z   //解压tar.Z\n  unrar e file.rar //解压rar\n  unzip file.zip //解压zip\n  \n### 6.3 ubuntu 下rar解压工具安装方法：\n \n> 1、压缩功能\n 安装 sudo apt-get install rar\n 卸载 sudo apt-get remove rar\n 2、解压功能\n 安装 sudo apt-get install unrar\n 卸载 sudo apt-get remove unrar\n 压缩解压缩.rar\n 解压：rar x FileName.rar\n 压缩：rar a FileName.rar DirName  \n  \n### 6.4 总结\n> 1、`*.tar` 用 tar –xvf 解压\n  2、`*.gz` 用 gzip -d或者gunzip 解压\n  3、`*.tar.gz`和`*.tgz` 用 tar –xzf 解压\n  4、`*.bz2` 用 bzip2 -d或者用bunzip2 解压\n  5、`*.tar.bz2`用tar –xjf 解压\n  6、`*.Z` 用 uncompress 解压\n  7、`*.tar.Z` 用tar –xZf 解压\n  8、`*.rar` 用 unrar e解压\n  9、`*.zip` 用 unzip 解压    \n\n","slug":"linux-command-use","published":1,"updated":"2018-11-09T01:20:30.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38lx005fqcrg08rwslp6","content":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p>_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p>_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2><h2 id=\"4-开机启动命令-chkconfig\"><a href=\"#4-开机启动命令-chkconfig\" class=\"headerlink\" title=\"4. 开机启动命令-chkconfig\"></a>4. 开机启动命令-chkconfig</h2><h2 id=\"5-文档操作\"><a href=\"#5-文档操作\" class=\"headerlink\" title=\"5. 文档操作\"></a>5. 文档操作</h2><h3 id=\"5-1-复制文件-cp命令使用\"><a href=\"#5-1-复制文件-cp命令使用\" class=\"headerlink\" title=\"5.1 复制文件-cp命令使用\"></a>5.1 复制文件-cp命令使用</h3><ol>\n<li><p>文件到文件复制</p>\n<blockquote>\n<p>将文档a复制成b（相当于备份并改名）。<br>cp -i a b<br>或，<br>cp a b</p>\n</blockquote>\n</li>\n<li><p>文件到目录复制</p>\n<blockquote>\n<p>将文档 file1复制到dir1目录下，复制后名称仍未file1<br>cp -i file1 dir1<br>或，<br>cp file1 dir1</p>\n</blockquote>\n</li>\n<li><p>目录到目录复制</p>\n<blockquote>\n<p>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2<br>cp -r dir1 dir2<br>将目录dir1下所有文件包括文件夹，都复制到dir2目录下<br>cp -r dir1/<em>.</em> dir2<br>常见错误：<br>1、提示cp: omitting directory错误<br>复制目录时，使用-r选项即可递归拷贝，如下：<br>cp -r dir1 dir2</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"6-解压-压缩\"><a href=\"#6-解压-压缩\" class=\"headerlink\" title=\"6. 解压/压缩\"></a>6. 解压/压缩</h2><h3 id=\"6-1-压缩\"><a href=\"#6-1-压缩\" class=\"headerlink\" title=\"6.1 压缩\"></a>6.1 压缩</h3><blockquote>\n<p>压缩<br>  tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>  tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>  tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>  tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>  rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for linux<br>  zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>\n</blockquote>\n<h3 id=\"6-2-解压\"><a href=\"#6-2-解压\" class=\"headerlink\" title=\"6.2 解压\"></a>6.2 解压</h3><blockquote>\n<p>解压<br>  tar –xvf file.tar //解压 tar包<br>  tar -xzvf file.tar.gz //解压tar.gz<br>  tar -xjvf file.tar.bz2   //解压 tar.bz2<br>  tar –xZvf file.tar.Z   //解压tar.Z<br>  unrar e file.rar //解压rar<br>  unzip file.zip //解压zip</p>\n</blockquote>\n<h3 id=\"6-3-ubuntu-下rar解压工具安装方法：\"><a href=\"#6-3-ubuntu-下rar解压工具安装方法：\" class=\"headerlink\" title=\"6.3 ubuntu 下rar解压工具安装方法：\"></a>6.3 ubuntu 下rar解压工具安装方法：</h3><blockquote>\n<p>1、压缩功能<br> 安装 sudo apt-get install rar<br> 卸载 sudo apt-get remove rar<br> 2、解压功能<br> 安装 sudo apt-get install unrar<br> 卸载 sudo apt-get remove unrar<br> 压缩解压缩.rar<br> 解压：rar x FileName.rar<br> 压缩：rar a FileName.rar DirName  </p>\n</blockquote>\n<h3 id=\"6-4-总结\"><a href=\"#6-4-总结\" class=\"headerlink\" title=\"6.4 总结\"></a>6.4 总结</h3><blockquote>\n<p>1、<code>*.tar</code> 用 tar –xvf 解压<br>  2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>  3、<code>*.tar.gz</code>和<code>*.tgz</code> 用 tar –xzf 解压<br>  4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>  5、<code>*.tar.bz2</code>用tar –xjf 解压<br>  6、<code>*.Z</code> 用 uncompress 解压<br>  7、<code>*.tar.Z</code> 用tar –xZf 解压<br>  8、<code>*.rar</code> 用 unrar e解压<br>  9、<code>*.zip</code> 用 unzip 解压    </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p>_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p>_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2><h2 id=\"4-开机启动命令-chkconfig\"><a href=\"#4-开机启动命令-chkconfig\" class=\"headerlink\" title=\"4. 开机启动命令-chkconfig\"></a>4. 开机启动命令-chkconfig</h2><h2 id=\"5-文档操作\"><a href=\"#5-文档操作\" class=\"headerlink\" title=\"5. 文档操作\"></a>5. 文档操作</h2><h3 id=\"5-1-复制文件-cp命令使用\"><a href=\"#5-1-复制文件-cp命令使用\" class=\"headerlink\" title=\"5.1 复制文件-cp命令使用\"></a>5.1 复制文件-cp命令使用</h3><ol>\n<li><p>文件到文件复制</p>\n<blockquote>\n<p>将文档a复制成b（相当于备份并改名）。<br>cp -i a b<br>或，<br>cp a b</p>\n</blockquote>\n</li>\n<li><p>文件到目录复制</p>\n<blockquote>\n<p>将文档 file1复制到dir1目录下，复制后名称仍未file1<br>cp -i file1 dir1<br>或，<br>cp file1 dir1</p>\n</blockquote>\n</li>\n<li><p>目录到目录复制</p>\n<blockquote>\n<p>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2<br>cp -r dir1 dir2<br>将目录dir1下所有文件包括文件夹，都复制到dir2目录下<br>cp -r dir1/<em>.</em> dir2<br>常见错误：<br>1、提示cp: omitting directory错误<br>复制目录时，使用-r选项即可递归拷贝，如下：<br>cp -r dir1 dir2</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"6-解压-压缩\"><a href=\"#6-解压-压缩\" class=\"headerlink\" title=\"6. 解压/压缩\"></a>6. 解压/压缩</h2><h3 id=\"6-1-压缩\"><a href=\"#6-1-压缩\" class=\"headerlink\" title=\"6.1 压缩\"></a>6.1 压缩</h3><blockquote>\n<p>压缩<br>  tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>  tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>  tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>  tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>  rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for linux<br>  zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>\n</blockquote>\n<h3 id=\"6-2-解压\"><a href=\"#6-2-解压\" class=\"headerlink\" title=\"6.2 解压\"></a>6.2 解压</h3><blockquote>\n<p>解压<br>  tar –xvf file.tar //解压 tar包<br>  tar -xzvf file.tar.gz //解压tar.gz<br>  tar -xjvf file.tar.bz2   //解压 tar.bz2<br>  tar –xZvf file.tar.Z   //解压tar.Z<br>  unrar e file.rar //解压rar<br>  unzip file.zip //解压zip</p>\n</blockquote>\n<h3 id=\"6-3-ubuntu-下rar解压工具安装方法：\"><a href=\"#6-3-ubuntu-下rar解压工具安装方法：\" class=\"headerlink\" title=\"6.3 ubuntu 下rar解压工具安装方法：\"></a>6.3 ubuntu 下rar解压工具安装方法：</h3><blockquote>\n<p>1、压缩功能<br> 安装 sudo apt-get install rar<br> 卸载 sudo apt-get remove rar<br> 2、解压功能<br> 安装 sudo apt-get install unrar<br> 卸载 sudo apt-get remove unrar<br> 压缩解压缩.rar<br> 解压：rar x FileName.rar<br> 压缩：rar a FileName.rar DirName  </p>\n</blockquote>\n<h3 id=\"6-4-总结\"><a href=\"#6-4-总结\" class=\"headerlink\" title=\"6.4 总结\"></a>6.4 总结</h3><blockquote>\n<p>1、<code>*.tar</code> 用 tar –xvf 解压<br>  2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>  3、<code>*.tar.gz</code>和<code>*.tgz</code> 用 tar –xzf 解压<br>  4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>  5、<code>*.tar.bz2</code>用tar –xjf 解压<br>  6、<code>*.Z</code> 用 uncompress 解压<br>  7、<code>*.tar.Z</code> 用tar –xZf 解压<br>  8、<code>*.rar</code> 用 unrar e解压<br>  9、<code>*.zip</code> 用 unzip 解压    </p>\n</blockquote>\n"},{"title":"ubuntu使用常用命令收集","date":"2018-03-01T08:02:21.000Z","_content":"\n记录在使用ubuntu系统过程中常见命令……\n\n## 查看占用端口\n\n`netstat -ln|grep 8388`或者`lsof -i:8388`\n\n## 关闭端口下应用\n\n`kill -9 PID号`\n\n\n## 防火墙\n\n1.安装\n\n`sudo apt-get install ufw` \n\n2.启用\n\n    sudo ufw enable\n    sudo ufw default deny\n    运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n\n3.开启/禁用\n\n    sudo ufw allow|deny [service]\n    打开或关闭某个端口，例如：\n    sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\n    sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\n    sudo ufw allow 53 允许外部访问53端口(tcp/udp)\n    sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\n    sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\n    sudo ufw deny smtp 禁止外部访问smtp服务\n    sudo ufw delete allow smtp 删除上面建立的某条规则\n    \n4.查看防火墙状态\n\n`sudo ufw status`    \n\n开启/关闭防火墙 (默认设置是’disable’)\n\n`# ufw enable|disable`\n\n5.UFW 使用范例：\n\n    允许 53 端口\n    \n    $ sudo ufw allow 53\n    \n    禁用 53 端口\n    \n    $ sudo ufw delete allow 53\n    \n    允许 80 端口\n    \n    $ sudo ufw allow 80/tcp\n    \n    禁用 80 端口\n    \n    $ sudo ufw delete allow 80/tcp\n    \n    允许 smtp 端口\n    \n    $ sudo ufw allow smtp\n    \n    删除 smtp 端口的许可\n    \n    $ sudo ufw delete allow smtp\n    \n    允许某特定 IP\n    \n    $ sudo ufw allow from 192.168.254.254\n    \n    删除上面的规则\n    \n    $ sudo ufw delete allow from 192.168.254.254","source":"_posts/linux-ubuntu-commom.md","raw":"---\ntitle: ubuntu使用常用命令收集\ndate: 2018-03-01 16:02:21\ncategories: ubuntu\ntags:\n---\n\n记录在使用ubuntu系统过程中常见命令……\n\n## 查看占用端口\n\n`netstat -ln|grep 8388`或者`lsof -i:8388`\n\n## 关闭端口下应用\n\n`kill -9 PID号`\n\n\n## 防火墙\n\n1.安装\n\n`sudo apt-get install ufw` \n\n2.启用\n\n    sudo ufw enable\n    sudo ufw default deny\n    运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n\n3.开启/禁用\n\n    sudo ufw allow|deny [service]\n    打开或关闭某个端口，例如：\n    sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\n    sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\n    sudo ufw allow 53 允许外部访问53端口(tcp/udp)\n    sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\n    sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\n    sudo ufw deny smtp 禁止外部访问smtp服务\n    sudo ufw delete allow smtp 删除上面建立的某条规则\n    \n4.查看防火墙状态\n\n`sudo ufw status`    \n\n开启/关闭防火墙 (默认设置是’disable’)\n\n`# ufw enable|disable`\n\n5.UFW 使用范例：\n\n    允许 53 端口\n    \n    $ sudo ufw allow 53\n    \n    禁用 53 端口\n    \n    $ sudo ufw delete allow 53\n    \n    允许 80 端口\n    \n    $ sudo ufw allow 80/tcp\n    \n    禁用 80 端口\n    \n    $ sudo ufw delete allow 80/tcp\n    \n    允许 smtp 端口\n    \n    $ sudo ufw allow smtp\n    \n    删除 smtp 端口的许可\n    \n    $ sudo ufw delete allow smtp\n    \n    允许某特定 IP\n    \n    $ sudo ufw allow from 192.168.254.254\n    \n    删除上面的规则\n    \n    $ sudo ufw delete allow from 192.168.254.254","slug":"linux-ubuntu-commom","published":1,"updated":"2018-11-09T01:20:30.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38lz005jqcrgnlr89z4c","content":"<p>记录在使用ubuntu系统过程中常见命令……</p>\n<h2 id=\"查看占用端口\"><a href=\"#查看占用端口\" class=\"headerlink\" title=\"查看占用端口\"></a>查看占用端口</h2><p><code>netstat -ln|grep 8388</code>或者<code>lsof -i:8388</code></p>\n<h2 id=\"关闭端口下应用\"><a href=\"#关闭端口下应用\" class=\"headerlink\" title=\"关闭端口下应用\"></a>关闭端口下应用</h2><p><code>kill -9 PID号</code></p>\n<h2 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h2><p>1.安装</p>\n<p><code>sudo apt-get install ufw</code> </p>\n<p>2.启用</p>\n<pre><code>sudo ufw enable\nsudo ufw default deny\n运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n</code></pre><p>3.开启/禁用</p>\n<pre><code>sudo ufw allow|deny [service]\n打开或关闭某个端口，例如：\nsudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\nsudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\nsudo ufw allow 53 允许外部访问53端口(tcp/udp)\nsudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\nsudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\nsudo ufw deny smtp 禁止外部访问smtp服务\nsudo ufw delete allow smtp 删除上面建立的某条规则\n</code></pre><p>4.查看防火墙状态</p>\n<p><code>sudo ufw status</code>    </p>\n<p>开启/关闭防火墙 (默认设置是’disable’)</p>\n<p><code># ufw enable|disable</code></p>\n<p>5.UFW 使用范例：</p>\n<pre><code>允许 53 端口\n\n$ sudo ufw allow 53\n\n禁用 53 端口\n\n$ sudo ufw delete allow 53\n\n允许 80 端口\n\n$ sudo ufw allow 80/tcp\n\n禁用 80 端口\n\n$ sudo ufw delete allow 80/tcp\n\n允许 smtp 端口\n\n$ sudo ufw allow smtp\n\n删除 smtp 端口的许可\n\n$ sudo ufw delete allow smtp\n\n允许某特定 IP\n\n$ sudo ufw allow from 192.168.254.254\n\n删除上面的规则\n\n$ sudo ufw delete allow from 192.168.254.254\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>记录在使用ubuntu系统过程中常见命令……</p>\n<h2 id=\"查看占用端口\"><a href=\"#查看占用端口\" class=\"headerlink\" title=\"查看占用端口\"></a>查看占用端口</h2><p><code>netstat -ln|grep 8388</code>或者<code>lsof -i:8388</code></p>\n<h2 id=\"关闭端口下应用\"><a href=\"#关闭端口下应用\" class=\"headerlink\" title=\"关闭端口下应用\"></a>关闭端口下应用</h2><p><code>kill -9 PID号</code></p>\n<h2 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h2><p>1.安装</p>\n<p><code>sudo apt-get install ufw</code> </p>\n<p>2.启用</p>\n<pre><code>sudo ufw enable\nsudo ufw default deny\n运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n</code></pre><p>3.开启/禁用</p>\n<pre><code>sudo ufw allow|deny [service]\n打开或关闭某个端口，例如：\nsudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\nsudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\nsudo ufw allow 53 允许外部访问53端口(tcp/udp)\nsudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\nsudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\nsudo ufw deny smtp 禁止外部访问smtp服务\nsudo ufw delete allow smtp 删除上面建立的某条规则\n</code></pre><p>4.查看防火墙状态</p>\n<p><code>sudo ufw status</code>    </p>\n<p>开启/关闭防火墙 (默认设置是’disable’)</p>\n<p><code># ufw enable|disable</code></p>\n<p>5.UFW 使用范例：</p>\n<pre><code>允许 53 端口\n\n$ sudo ufw allow 53\n\n禁用 53 端口\n\n$ sudo ufw delete allow 53\n\n允许 80 端口\n\n$ sudo ufw allow 80/tcp\n\n禁用 80 端口\n\n$ sudo ufw delete allow 80/tcp\n\n允许 smtp 端口\n\n$ sudo ufw allow smtp\n\n删除 smtp 端口的许可\n\n$ sudo ufw delete allow smtp\n\n允许某特定 IP\n\n$ sudo ufw allow from 192.168.254.254\n\n删除上面的规则\n\n$ sudo ufw delete allow from 192.168.254.254\n</code></pre>"},{"title":"ubuntu下使用数据库客户端软件navicat","date":"2018-08-10T02:02:17.000Z","_content":"\n本文记录在ubuntu系统下使用navicat的各种问题……\n\n网址：http://navicat.com.cn/\n\n## 安装\n\n直接打开官网下载即可。\n\n1.下载好，解压，并进入文件根目录。会看到`start_navicat`文件。   \n\n2.启动\n\n把`export LANG=\"en_US.UTF-8\"`这句改为`export LANG=\"zh_CH.UTF-8\"`。    \n\n执行：`./start_navicat`。即可启动。会下载`wine`。   \n\n3.解决乱码\n\n- 给系统安装字体`sudo apt install fonts-wqy-zenhei`。   \n- 启动navicat，点解倒数第三个菜单，选择最后一个选项(options),在第一个tab下，下拉，选择最后一种字体`WenQuanYi Zen Hei Sharp`。  \n- 退出应用，然后重新启动，应该可以看到正确的显示了。\n\n## 破解\n\n进入目录`cd ~/.navicat64`,删除目录下的system.reg文件即可。如果还是不行，可以把整个.navicat64目录删除。然后重启。","source":"_posts/linux-ubuntu-navicat.md","raw":"---\ntitle: ubuntu下使用数据库客户端软件navicat\ndate: 2018-08-10 10:02:17\ncategories: ubuntu\ntags: ubuntu-navicat\n---\n\n本文记录在ubuntu系统下使用navicat的各种问题……\n\n网址：http://navicat.com.cn/\n\n## 安装\n\n直接打开官网下载即可。\n\n1.下载好，解压，并进入文件根目录。会看到`start_navicat`文件。   \n\n2.启动\n\n把`export LANG=\"en_US.UTF-8\"`这句改为`export LANG=\"zh_CH.UTF-8\"`。    \n\n执行：`./start_navicat`。即可启动。会下载`wine`。   \n\n3.解决乱码\n\n- 给系统安装字体`sudo apt install fonts-wqy-zenhei`。   \n- 启动navicat，点解倒数第三个菜单，选择最后一个选项(options),在第一个tab下，下拉，选择最后一种字体`WenQuanYi Zen Hei Sharp`。  \n- 退出应用，然后重新启动，应该可以看到正确的显示了。\n\n## 破解\n\n进入目录`cd ~/.navicat64`,删除目录下的system.reg文件即可。如果还是不行，可以把整个.navicat64目录删除。然后重启。","slug":"linux-ubuntu-navicat","published":1,"updated":"2018-11-09T01:20:30.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38m0005lqcrgeq70kd1x","content":"<p>本文记录在ubuntu系统下使用navicat的各种问题……</p>\n<p>网址：<a href=\"http://navicat.com.cn/\" target=\"_blank\" rel=\"noopener\">http://navicat.com.cn/</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>直接打开官网下载即可。</p>\n<p>1.下载好，解压，并进入文件根目录。会看到<code>start_navicat</code>文件。   </p>\n<p>2.启动</p>\n<p>把<code>export LANG=&quot;en_US.UTF-8&quot;</code>这句改为<code>export LANG=&quot;zh_CH.UTF-8&quot;</code>。    </p>\n<p>执行：<code>./start_navicat</code>。即可启动。会下载<code>wine</code>。   </p>\n<p>3.解决乱码</p>\n<ul>\n<li>给系统安装字体<code>sudo apt install fonts-wqy-zenhei</code>。   </li>\n<li>启动navicat，点解倒数第三个菜单，选择最后一个选项(options),在第一个tab下，下拉，选择最后一种字体<code>WenQuanYi Zen Hei Sharp</code>。  </li>\n<li>退出应用，然后重新启动，应该可以看到正确的显示了。</li>\n</ul>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><p>进入目录<code>cd ~/.navicat64</code>,删除目录下的system.reg文件即可。如果还是不行，可以把整个.navicat64目录删除。然后重启。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录在ubuntu系统下使用navicat的各种问题……</p>\n<p>网址：<a href=\"http://navicat.com.cn/\" target=\"_blank\" rel=\"noopener\">http://navicat.com.cn/</a></p>\n<h2 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h2><p>直接打开官网下载即可。</p>\n<p>1.下载好，解压，并进入文件根目录。会看到<code>start_navicat</code>文件。   </p>\n<p>2.启动</p>\n<p>把<code>export LANG=&quot;en_US.UTF-8&quot;</code>这句改为<code>export LANG=&quot;zh_CH.UTF-8&quot;</code>。    </p>\n<p>执行：<code>./start_navicat</code>。即可启动。会下载<code>wine</code>。   </p>\n<p>3.解决乱码</p>\n<ul>\n<li>给系统安装字体<code>sudo apt install fonts-wqy-zenhei</code>。   </li>\n<li>启动navicat，点解倒数第三个菜单，选择最后一个选项(options),在第一个tab下，下拉，选择最后一种字体<code>WenQuanYi Zen Hei Sharp</code>。  </li>\n<li>退出应用，然后重新启动，应该可以看到正确的显示了。</li>\n</ul>\n<h2 id=\"破解\"><a href=\"#破解\" class=\"headerlink\" title=\"破解\"></a>破解</h2><p>进入目录<code>cd ~/.navicat64</code>,删除目录下的system.reg文件即可。如果还是不行，可以把整个.navicat64目录删除。然后重启。</p>\n"},{"title":"maven使用经验记录","date":"2018-02-03T02:00:23.000Z","_content":"\n本文记录在开发过程中经常性使用到的maven特性……\n\n### 导出maven依赖的jar包到目录\n\n方法一：在pom目录下执行命令\t\n`mvn dependency:copy-dependencies`\n\n方法二：eclipse项目下：\n选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行\nmaven项目所依赖的jar包会导出到targed/dependency目录中。\n\n{% asset_img a.jpg %} \n\n{% asset_img b.jpg %} \n\n### maven打包时候跳过test检查\n\n方法一： 在pom目录下执行命令\n`mvn clean install -Dmaven.test.skip=true`\n\n方法二： 在pom中添加插件\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-surefire-plugin</artifactId>\n        <configuration>\n            <skipTests>true</skipTests>\n        </configuration>\n    </plugin>\n\n\n### 打包jar\n\n#### 普通打包\n会把maven依赖包一起打包。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n            <source>1.8</source>\n            <target>1.8</target>\n        </configuration>\n    </plugin>\n\n#### 不打包lib\n在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。 \n让后启动指定main类，并指定依赖包目录lib。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-jar-plugin</artifactId>\n        <configuration>\n            <archive>\n                <manifest>\n                    <mainClass>com.xcsqjr.StartAbsServiceAllApplication</mainClass>\n                    <addClasspath>true</addClasspath>\n                    <classpathPrefix>lib/</classpathPrefix>\n                </manifest>\n                <manifestEntries>\n                    <Class-Path>./</Class-Path>\n                </manifestEntries>\n            </archive>\n        </configuration>\n    </plugin>\n","source":"_posts/maven-ofen.md","raw":"---\ntitle: maven使用经验记录\ndate: 2018-02-03 10:00:23\ncategories: maven\ntags: maven常用功能\n---\n\n本文记录在开发过程中经常性使用到的maven特性……\n\n### 导出maven依赖的jar包到目录\n\n方法一：在pom目录下执行命令\t\n`mvn dependency:copy-dependencies`\n\n方法二：eclipse项目下：\n选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行\nmaven项目所依赖的jar包会导出到targed/dependency目录中。\n\n{% asset_img a.jpg %} \n\n{% asset_img b.jpg %} \n\n### maven打包时候跳过test检查\n\n方法一： 在pom目录下执行命令\n`mvn clean install -Dmaven.test.skip=true`\n\n方法二： 在pom中添加插件\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-surefire-plugin</artifactId>\n        <configuration>\n            <skipTests>true</skipTests>\n        </configuration>\n    </plugin>\n\n\n### 打包jar\n\n#### 普通打包\n会把maven依赖包一起打包。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n            <source>1.8</source>\n            <target>1.8</target>\n        </configuration>\n    </plugin>\n\n#### 不打包lib\n在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。 \n让后启动指定main类，并指定依赖包目录lib。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-jar-plugin</artifactId>\n        <configuration>\n            <archive>\n                <manifest>\n                    <mainClass>com.xcsqjr.StartAbsServiceAllApplication</mainClass>\n                    <addClasspath>true</addClasspath>\n                    <classpathPrefix>lib/</classpathPrefix>\n                </manifest>\n                <manifestEntries>\n                    <Class-Path>./</Class-Path>\n                </manifestEntries>\n            </archive>\n        </configuration>\n    </plugin>\n","slug":"maven-ofen","published":1,"updated":"2018-11-09T01:20:30.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38m2005pqcrgrhizk6dn","content":"<p>本文记录在开发过程中经常性使用到的maven特性……</p>\n<h3 id=\"导出maven依赖的jar包到目录\"><a href=\"#导出maven依赖的jar包到目录\" class=\"headerlink\" title=\"导出maven依赖的jar包到目录\"></a>导出maven依赖的jar包到目录</h3><p>方法一：在pom目录下执行命令<br><code>mvn dependency:copy-dependencies</code></p>\n<p>方法二：eclipse项目下：<br>选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行<br>maven项目所依赖的jar包会导出到targed/dependency目录中。</p>\n<img src=\"/2018/02/03/maven-ofen/a.jpg\"> \n<img src=\"/2018/02/03/maven-ofen/b.jpg\"> \n<h3 id=\"maven打包时候跳过test检查\"><a href=\"#maven打包时候跳过test检查\" class=\"headerlink\" title=\"maven打包时候跳过test检查\"></a>maven打包时候跳过test检查</h3><p>方法一： 在pom目录下执行命令<br><code>mvn clean install -Dmaven.test.skip=true</code></p>\n<p>方法二： 在pom中添加插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;skipTests&gt;true&lt;/skipTests&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h3 id=\"打包jar\"><a href=\"#打包jar\" class=\"headerlink\" title=\"打包jar\"></a>打包jar</h3><h4 id=\"普通打包\"><a href=\"#普通打包\" class=\"headerlink\" title=\"普通打包\"></a>普通打包</h4><p>会把maven依赖包一起打包。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;/source&gt;\n        &lt;target&gt;1.8&lt;/target&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h4 id=\"不打包lib\"><a href=\"#不打包lib\" class=\"headerlink\" title=\"不打包lib\"></a>不打包lib</h4><p>在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。<br>让后启动指定main类，并指定依赖包目录lib。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;archive&gt;\n            &lt;manifest&gt;\n                &lt;mainClass&gt;com.xcsqjr.StartAbsServiceAllApplication&lt;/mainClass&gt;\n                &lt;addClasspath&gt;true&lt;/addClasspath&gt;\n                &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;\n            &lt;/manifest&gt;\n            &lt;manifestEntries&gt;\n                &lt;Class-Path&gt;./&lt;/Class-Path&gt;\n            &lt;/manifestEntries&gt;\n        &lt;/archive&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文记录在开发过程中经常性使用到的maven特性……</p>\n<h3 id=\"导出maven依赖的jar包到目录\"><a href=\"#导出maven依赖的jar包到目录\" class=\"headerlink\" title=\"导出maven依赖的jar包到目录\"></a>导出maven依赖的jar包到目录</h3><p>方法一：在pom目录下执行命令<br><code>mvn dependency:copy-dependencies</code></p>\n<p>方法二：eclipse项目下：<br>选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行<br>maven项目所依赖的jar包会导出到targed/dependency目录中。</p>\n<img src=\"/2018/02/03/maven-ofen/a.jpg\"> \n<img src=\"/2018/02/03/maven-ofen/b.jpg\"> \n<h3 id=\"maven打包时候跳过test检查\"><a href=\"#maven打包时候跳过test检查\" class=\"headerlink\" title=\"maven打包时候跳过test检查\"></a>maven打包时候跳过test检查</h3><p>方法一： 在pom目录下执行命令<br><code>mvn clean install -Dmaven.test.skip=true</code></p>\n<p>方法二： 在pom中添加插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;skipTests&gt;true&lt;/skipTests&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h3 id=\"打包jar\"><a href=\"#打包jar\" class=\"headerlink\" title=\"打包jar\"></a>打包jar</h3><h4 id=\"普通打包\"><a href=\"#普通打包\" class=\"headerlink\" title=\"普通打包\"></a>普通打包</h4><p>会把maven依赖包一起打包。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;/source&gt;\n        &lt;target&gt;1.8&lt;/target&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h4 id=\"不打包lib\"><a href=\"#不打包lib\" class=\"headerlink\" title=\"不打包lib\"></a>不打包lib</h4><p>在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。<br>让后启动指定main类，并指定依赖包目录lib。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;archive&gt;\n            &lt;manifest&gt;\n                &lt;mainClass&gt;com.xcsqjr.StartAbsServiceAllApplication&lt;/mainClass&gt;\n                &lt;addClasspath&gt;true&lt;/addClasspath&gt;\n                &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;\n            &lt;/manifest&gt;\n            &lt;manifestEntries&gt;\n                &lt;Class-Path&gt;./&lt;/Class-Path&gt;\n            &lt;/manifestEntries&gt;\n        &lt;/archive&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"title":"微服务实践思考","date":"2017-09-26T02:14:45.000Z","_content":"","source":"_posts/microservice-think.md","raw":"---\ntitle: 微服务实践思考\ndate: 2017-09-26 10:14:45\ncategories: micro-service\ntags: 微服务实践总结\n---\n","slug":"microservice-think","published":1,"updated":"2018-11-09T01:20:30.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38m3005qqcrgj8n2yu7t","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"mysql复制","date":"2018-10-24T14:00:17.000Z","_content":"","source":"_posts/mysql-copy.md","raw":"---\ntitle: mysql复制\ndate: 2018-10-24 22:00:17\ncategories: mysql\ntags: mysql复制\n---\n","slug":"mysql-copy","published":1,"updated":"2018-11-09T01:20:30.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38m4005vqcrgzwtt16q7","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"maven使用常见错误收集","date":"2017-10-25T06:41:24.000Z","_content":"\n本文收集使用maven过程中的常见错误。\n\n> - 问题：\nmaven继承，使用 *`<relativePath></relativePath>`*，出现找不到指向pom，但是实际上已经正确指向了。 \n- 解决：\n    The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, `the group ID, artifact ID and version are still required,` and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.\n  Default value is: ../pom.xml.\n  *所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。*\n    \n    \n","source":"_posts/maven-use-error-collect.md","raw":"---\ntitle: maven使用常见错误收集\ndate: 2017-10-25 14:41:24\ncategories: maven\ntags: maven-error\n---\n\n本文收集使用maven过程中的常见错误。\n\n> - 问题：\nmaven继承，使用 *`<relativePath></relativePath>`*，出现找不到指向pom，但是实际上已经正确指向了。 \n- 解决：\n    The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, `the group ID, artifact ID and version are still required,` and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.\n  Default value is: ../pom.xml.\n  *所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。*\n    \n    \n","slug":"maven-use-error-collect","published":1,"updated":"2018-11-09T01:20:30.264Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38m5005wqcrgi7dqd9b3","content":"<p>本文收集使用maven过程中的常见错误。</p>\n<blockquote>\n<ul>\n<li>问题：<br>maven继承，使用 <em><code>&lt;relativePath&gt;&lt;/relativePath&gt;</code></em>，出现找不到指向pom，但是实际上已经正确指向了。 </li>\n<li>解决：<br>  The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, <code>the group ID, artifact ID and version are still required,</code> and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.<br>Default value is: ../pom.xml.<br><em>所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。</em></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>本文收集使用maven过程中的常见错误。</p>\n<blockquote>\n<ul>\n<li>问题：<br>maven继承，使用 <em><code>&lt;relativePath&gt;&lt;/relativePath&gt;</code></em>，出现找不到指向pom，但是实际上已经正确指向了。 </li>\n<li>解决：<br>  The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, <code>the group ID, artifact ID and version are still required,</code> and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.<br>Default value is: ../pom.xml.<br><em>所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。</em></li>\n</ul>\n</blockquote>\n"},{"title":"mysql建表规范","date":"2017-11-20T05:51:19.000Z","_content":"\n在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：\n\n## 1. 选择优化的数据类型\n\n原则：\n1. 更小的通常更好\n更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。\n\n2. 简单就好\n简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。\n\n3. 尽量避免NULL\n通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。   \n通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。\n\n### 1.1 整数类型\n整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。  \n整数计算通常使用64位的BIGINT。\n\n### 1.2 实数类型\n实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。  \nDOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。  \n在做高精度计算时，使用DECIMAL，比如财务计算。  \n\n### 1.3 字符串类型\nVARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。\nCHAR 不可变长。少用。\nBINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。\nBLOB 存储很大的数据量的字符串类型，二进制存储。\nTEXT 大文本。字符存储。\n- 使用枚举代替字符串\n可以存储枚举对应整型或者字符串……\n\n## 1.4 日期和时间类型\n\n\n","source":"_posts/mysql-create.md","raw":"---\ntitle: mysql建表规范\ndate: 2017-11-20 13:51:19\ncategories: mysql\ntags: mysql建表规范\n---\n\n在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：\n\n## 1. 选择优化的数据类型\n\n原则：\n1. 更小的通常更好\n更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。\n\n2. 简单就好\n简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。\n\n3. 尽量避免NULL\n通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。   \n通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。\n\n### 1.1 整数类型\n整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。  \n整数计算通常使用64位的BIGINT。\n\n### 1.2 实数类型\n实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。  \nDOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。  \n在做高精度计算时，使用DECIMAL，比如财务计算。  \n\n### 1.3 字符串类型\nVARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。\nCHAR 不可变长。少用。\nBINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。\nBLOB 存储很大的数据量的字符串类型，二进制存储。\nTEXT 大文本。字符存储。\n- 使用枚举代替字符串\n可以存储枚举对应整型或者字符串……\n\n## 1.4 日期和时间类型\n\n\n","slug":"mysql-create","published":1,"updated":"2018-11-09T01:20:30.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38m60060qcrgz7pnyowt","content":"<p>在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：</p>\n<h2 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1. 选择优化的数据类型\"></a>1. 选择优化的数据类型</h2><p>原则：</p>\n<ol>\n<li><p>更小的通常更好<br>更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。</p>\n</li>\n<li><p>简单就好<br>简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。</p>\n</li>\n<li><p>尽量避免NULL<br>通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。<br>通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。</p>\n</li>\n</ol>\n<h3 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h3><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。<br>整数计算通常使用64位的BIGINT。</p>\n<h3 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h3><p>实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。<br>DOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。<br>在做高精度计算时，使用DECIMAL，比如财务计算。  </p>\n<h3 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h3><p>VARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。<br>CHAR 不可变长。少用。<br>BINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。<br>BLOB 存储很大的数据量的字符串类型，二进制存储。<br>TEXT 大文本。字符存储。</p>\n<ul>\n<li>使用枚举代替字符串<br>可以存储枚举对应整型或者字符串……</li>\n</ul>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2>","site":{"data":{}},"excerpt":"","more":"<p>在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：</p>\n<h2 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1. 选择优化的数据类型\"></a>1. 选择优化的数据类型</h2><p>原则：</p>\n<ol>\n<li><p>更小的通常更好<br>更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。</p>\n</li>\n<li><p>简单就好<br>简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。</p>\n</li>\n<li><p>尽量避免NULL<br>通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。<br>通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。</p>\n</li>\n</ol>\n<h3 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h3><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。<br>整数计算通常使用64位的BIGINT。</p>\n<h3 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h3><p>实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。<br>DOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。<br>在做高精度计算时，使用DECIMAL，比如财务计算。  </p>\n<h3 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h3><p>VARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。<br>CHAR 不可变长。少用。<br>BINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。<br>BLOB 存储很大的数据量的字符串类型，二进制存储。<br>TEXT 大文本。字符存储。</p>\n<ul>\n<li>使用枚举代替字符串<br>可以存储枚举对应整型或者字符串……</li>\n</ul>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2>"},{"title":"mysql使用问题记录","date":"2018-06-01T14:46:53.000Z","_content":"\n本文记录在实际使用mysql过程遇到的问题……\n\n## mysql5.7更改数据库密码强度和长度\n\n    set global validate_password_policy=0;  \n    set global validate_password_length=4;  \n\n## mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库\n\n    CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';\n    flush privileges;\n    \n 创建用户redmine,密码为：redmine，只对数据库redmine拥有读写权限。   ","source":"_posts/mysql-practice.md","raw":"---\ntitle: mysql使用问题记录\ndate: 2018-06-01 22:46:53\ncategories: mysql\ntags: mysql使用问题收藏\n---\n\n本文记录在实际使用mysql过程遇到的问题……\n\n## mysql5.7更改数据库密码强度和长度\n\n    set global validate_password_policy=0;  \n    set global validate_password_length=4;  \n\n## mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库\n\n    CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';\n    flush privileges;\n    \n 创建用户redmine,密码为：redmine，只对数据库redmine拥有读写权限。   ","slug":"mysql-practice","published":1,"updated":"2018-11-09T01:20:30.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38m70062qcrgdk5zche4","content":"<p>本文记录在实际使用mysql过程遇到的问题……</p>\n<h2 id=\"mysql5-7更改数据库密码强度和长度\"><a href=\"#mysql5-7更改数据库密码强度和长度\" class=\"headerlink\" title=\"mysql5.7更改数据库密码强度和长度\"></a>mysql5.7更改数据库密码强度和长度</h2><pre><code>set global validate_password_policy=0;  \nset global validate_password_length=4;  \n</code></pre><h2 id=\"mysql5-7，创建登录用户，并对用户赋权只能查看某个数据库\"><a href=\"#mysql5-7，创建登录用户，并对用户赋权只能查看某个数据库\" class=\"headerlink\" title=\"mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库\"></a>mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库</h2><pre><code>CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;\nflush privileges;\n</code></pre><p> 创建用户redmine,密码为：redmine，只对数据库redmine拥有读写权限。   </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录在实际使用mysql过程遇到的问题……</p>\n<h2 id=\"mysql5-7更改数据库密码强度和长度\"><a href=\"#mysql5-7更改数据库密码强度和长度\" class=\"headerlink\" title=\"mysql5.7更改数据库密码强度和长度\"></a>mysql5.7更改数据库密码强度和长度</h2><pre><code>set global validate_password_policy=0;  \nset global validate_password_length=4;  \n</code></pre><h2 id=\"mysql5-7，创建登录用户，并对用户赋权只能查看某个数据库\"><a href=\"#mysql5-7，创建登录用户，并对用户赋权只能查看某个数据库\" class=\"headerlink\" title=\"mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库\"></a>mysql5.7，创建登录用户，并对用户赋权只能查看某个数据库</h2><pre><code>CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;\nflush privileges;\n</code></pre><p> 创建用户redmine,密码为：redmine，只对数据库redmine拥有读写权限。   </p>\n"},{"title":"ngrok使用","date":"2018-08-13T07:36:39.000Z","_content":"\n官网：https://ngrok.com","source":"_posts/ngrok-start.md","raw":"---\ntitle: ngrok使用\ndate: 2018-08-13 15:36:39\ncategories: ngrok\ntags: ngrok使用\n---\n\n官网：https://ngrok.com","slug":"ngrok-start","published":1,"updated":"2018-11-09T01:20:30.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38m80065qcrg88ccgdnd","content":"<p>官网：<a href=\"https://ngrok.com\" target=\"_blank\" rel=\"noopener\">https://ngrok.com</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"https://ngrok.com\" target=\"_blank\" rel=\"noopener\">https://ngrok.com</a></p>\n"},{"title":"npm使用问题收集","date":"2018-09-13T03:36:53.000Z","_content":"\n收集在使用过程中遇到的问题……\n\n1.错误一：install错误，强制清空缓存\n\n` npm cache clean --force`","source":"_posts/npm-use.md","raw":"---\ntitle: npm使用问题收集\ndate: 2018-09-13 11:36:53\ncategories: npm\ntags: npm使用问题\n---\n\n收集在使用过程中遇到的问题……\n\n1.错误一：install错误，强制清空缓存\n\n` npm cache clean --force`","slug":"npm-use","published":1,"updated":"2018-11-09T01:20:30.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38ma0068qcrg7yet4adx","content":"<p>收集在使用过程中遇到的问题……</p>\n<p>1.错误一：install错误，强制清空缓存</p>\n<p><code>npm cache clean --force</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>收集在使用过程中遇到的问题……</p>\n<p>1.错误一：install错误，强制清空缓存</p>\n<p><code>npm cache clean --force</code></p>\n"},{"title":"在Pivotal Web Service上发布Spring Boot应用","date":"2017-10-12T07:08:33.000Z","_content":"\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","source":"_posts/pivotal-web-service-start.md","raw":"---\ntitle: 在Pivotal Web Service上发布Spring Boot应用\ndate: 2017-10-12 15:08:33\ncategories: Pivotal Web Service\ntags: pws-push\n---\n\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","slug":"pivotal-web-service-start","published":1,"updated":"2018-11-09T01:20:30.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mb006aqcrglmj4pijl","content":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"noopener\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"noopener\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"noopener\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"noopener\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"noopener\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"noopener\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\"></li>\n</ol>\n"},{"title":"rabbitMq实战记录","date":"2018-01-19T04:12:57.000Z","_content":"\nrabbitMq使用记录，好记性不如烂……","source":"_posts/rabbitmq-action.md","raw":"---\ntitle: rabbitMq实战记录\ndate: 2018-01-19 12:12:57\ncategories: rabbitmq\ntags: \n---\n\nrabbitMq使用记录，好记性不如烂……","slug":"rabbitmq-action","published":1,"updated":"2018-11-09T01:20:30.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mc006eqcrg9z537ytr","content":"<p>rabbitMq使用记录，好记性不如烂……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>rabbitMq使用记录，好记性不如烂……</p>\n"},{"title":"rabbitmq快速安装","date":"2018-01-02T08:02:01.000Z","_content":"\n本文介绍rabbitmq在各系统平台下的安装……\n\n## 在Centos下的快速安装\n\n一、安装erlang\nsudo yum install erlang\n\n检查是否安装好：\n\n    [root@localhost /]# erl\n    Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n\n二、安装rabbitmq\n\n（1）下载安装包\nwget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\n\n（2）安装\n\n    > rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n    > yum install rabbitmq-server-3.6.0-1.noarch.rpm\n\n（3）启用web管理插件\nrabbitmq-plugins enable rabbitmq_management\n\n三、启动RabbitMQ\nchkconfig rabbitmq-server on  //开机启动设置\nservice rabbitmq-server start\n\n 四、打开对应端口\n        # firewall-cmd --permanent --zone=public --add-port=5672/tcp\n        # firewall-cmd --permanent --zone=public --add-port=15672/tcp\n        # firewall-cmd --reload\n\n五、打开网页\nhttp://119.23.78.160:15672/\n\n## 在Ubuntu下的快速安装\n\n安装最新版，参考网址： \nhttp://www.rabbitmq.com/install-debian.html\n\n注：下面安装的不是最新版本。\n一. 安装对应erlang版本：\nerlang-nox (>= 1:19.3-1) | esl-erlang (>= 1:19.3-1).\n`sudo apt-get install erlang-nox`\n\n二. 安装rabbitMq:\n\n    $ sudo apt-get update\n    $ sudo apt-get install rabbitmq-server\n    \n三. 启用web管理插件：\n\n`sudo rabbitmq-plugins enable rabbitmq_management`  \n\n四. 访问\n打开：http://localhost:15672  \n\n五. 登录（本机）：\n用户：guest\n密码：guest\n\n注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。\n","source":"_posts/rabbitmq-install.md","raw":"---\ntitle: rabbitmq快速安装\ndate: 2018-01-02 16:02:01\ncategories: rabbitmq\ntags: rabbitmq-install\n---\n\n本文介绍rabbitmq在各系统平台下的安装……\n\n## 在Centos下的快速安装\n\n一、安装erlang\nsudo yum install erlang\n\n检查是否安装好：\n\n    [root@localhost /]# erl\n    Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n\n二、安装rabbitmq\n\n（1）下载安装包\nwget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\n\n（2）安装\n\n    > rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n    > yum install rabbitmq-server-3.6.0-1.noarch.rpm\n\n（3）启用web管理插件\nrabbitmq-plugins enable rabbitmq_management\n\n三、启动RabbitMQ\nchkconfig rabbitmq-server on  //开机启动设置\nservice rabbitmq-server start\n\n 四、打开对应端口\n        # firewall-cmd --permanent --zone=public --add-port=5672/tcp\n        # firewall-cmd --permanent --zone=public --add-port=15672/tcp\n        # firewall-cmd --reload\n\n五、打开网页\nhttp://119.23.78.160:15672/\n\n## 在Ubuntu下的快速安装\n\n安装最新版，参考网址： \nhttp://www.rabbitmq.com/install-debian.html\n\n注：下面安装的不是最新版本。\n一. 安装对应erlang版本：\nerlang-nox (>= 1:19.3-1) | esl-erlang (>= 1:19.3-1).\n`sudo apt-get install erlang-nox`\n\n二. 安装rabbitMq:\n\n    $ sudo apt-get update\n    $ sudo apt-get install rabbitmq-server\n    \n三. 启用web管理插件：\n\n`sudo rabbitmq-plugins enable rabbitmq_management`  \n\n四. 访问\n打开：http://localhost:15672  \n\n五. 登录（本机）：\n用户：guest\n密码：guest\n\n注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。\n","slug":"rabbitmq-install","published":1,"updated":"2018-11-09T01:20:30.296Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38md006fqcrgp2ffuvl2","content":"<p>本文介绍rabbitmq在各系统平台下的安装……</p>\n<h2 id=\"在Centos下的快速安装\"><a href=\"#在Centos下的快速安装\" class=\"headerlink\" title=\"在Centos下的快速安装\"></a>在Centos下的快速安装</h2><p>一、安装erlang<br>sudo yum install erlang</p>\n<p>检查是否安装好：</p>\n<pre><code>[root@localhost /]# erl\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n</code></pre><p>二、安装rabbitmq</p>\n<p>（1）下载安装包<br>wget <a href=\"http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm</a></p>\n<p>（2）安装</p>\n<pre><code>&gt; rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n&gt; yum install rabbitmq-server-3.6.0-1.noarch.rpm\n</code></pre><p>（3）启用web管理插件<br>rabbitmq-plugins enable rabbitmq_management</p>\n<p>三、启动RabbitMQ<br>chkconfig rabbitmq-server on  //开机启动设置<br>service rabbitmq-server start</p>\n<p> 四、打开对应端口</p>\n<pre><code># firewall-cmd --permanent --zone=public --add-port=5672/tcp\n# firewall-cmd --permanent --zone=public --add-port=15672/tcp\n# firewall-cmd --reload\n</code></pre><p>五、打开网页<br><a href=\"http://119.23.78.160:15672/\" target=\"_blank\" rel=\"noopener\">http://119.23.78.160:15672/</a></p>\n<h2 id=\"在Ubuntu下的快速安装\"><a href=\"#在Ubuntu下的快速安装\" class=\"headerlink\" title=\"在Ubuntu下的快速安装\"></a>在Ubuntu下的快速安装</h2><p>安装最新版，参考网址：<br><a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a></p>\n<p>注：下面安装的不是最新版本。<br>一. 安装对应erlang版本：<br>erlang-nox (&gt;= 1:19.3-1) | esl-erlang (&gt;= 1:19.3-1).<br><code>sudo apt-get install erlang-nox</code></p>\n<p>二. 安装rabbitMq:</p>\n<pre><code>$ sudo apt-get update\n$ sudo apt-get install rabbitmq-server\n</code></pre><p>三. 启用web管理插件：</p>\n<p><code>sudo rabbitmq-plugins enable rabbitmq_management</code>  </p>\n<p>四. 访问<br>打开：<a href=\"http://localhost:15672\" target=\"_blank\" rel=\"noopener\">http://localhost:15672</a>  </p>\n<p>五. 登录（本机）：<br>用户：guest<br>密码：guest</p>\n<p>注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍rabbitmq在各系统平台下的安装……</p>\n<h2 id=\"在Centos下的快速安装\"><a href=\"#在Centos下的快速安装\" class=\"headerlink\" title=\"在Centos下的快速安装\"></a>在Centos下的快速安装</h2><p>一、安装erlang<br>sudo yum install erlang</p>\n<p>检查是否安装好：</p>\n<pre><code>[root@localhost /]# erl\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n</code></pre><p>二、安装rabbitmq</p>\n<p>（1）下载安装包<br>wget <a href=\"http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm</a></p>\n<p>（2）安装</p>\n<pre><code>&gt; rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n&gt; yum install rabbitmq-server-3.6.0-1.noarch.rpm\n</code></pre><p>（3）启用web管理插件<br>rabbitmq-plugins enable rabbitmq_management</p>\n<p>三、启动RabbitMQ<br>chkconfig rabbitmq-server on  //开机启动设置<br>service rabbitmq-server start</p>\n<p> 四、打开对应端口</p>\n<pre><code># firewall-cmd --permanent --zone=public --add-port=5672/tcp\n# firewall-cmd --permanent --zone=public --add-port=15672/tcp\n# firewall-cmd --reload\n</code></pre><p>五、打开网页<br><a href=\"http://119.23.78.160:15672/\" target=\"_blank\" rel=\"noopener\">http://119.23.78.160:15672/</a></p>\n<h2 id=\"在Ubuntu下的快速安装\"><a href=\"#在Ubuntu下的快速安装\" class=\"headerlink\" title=\"在Ubuntu下的快速安装\"></a>在Ubuntu下的快速安装</h2><p>安装最新版，参考网址：<br><a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a></p>\n<p>注：下面安装的不是最新版本。<br>一. 安装对应erlang版本：<br>erlang-nox (&gt;= 1:19.3-1) | esl-erlang (&gt;= 1:19.3-1).<br><code>sudo apt-get install erlang-nox</code></p>\n<p>二. 安装rabbitMq:</p>\n<pre><code>$ sudo apt-get update\n$ sudo apt-get install rabbitmq-server\n</code></pre><p>三. 启用web管理插件：</p>\n<p><code>sudo rabbitmq-plugins enable rabbitmq_management</code>  </p>\n<p>四. 访问<br>打开：<a href=\"http://localhost:15672\" target=\"_blank\" rel=\"noopener\">http://localhost:15672</a>  </p>\n<p>五. 登录（本机）：<br>用户：guest<br>密码：guest</p>\n<p>注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。</p>\n"},{"title":"redis一主多从集群配置","date":"2017-09-21T05:46:08.000Z","_content":"","source":"_posts/redis-cluster-centos.md","raw":"---\ntitle: redis一主多从集群配置\ndate: 2017-09-21 13:46:08\ncategories: redis\ntags:   redis,主从,集群\n---\n","slug":"redis-cluster-centos","published":1,"updated":"2018-11-09T01:20:30.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mf006kqcrgq1zqbv40","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis配置","date":"2017-12-06T06:13:01.000Z","_content":"","source":"_posts/redis-conf.md","raw":"---\ntitle: redis配置\ndate: 2017-12-06 14:13:01\ncategories: redis\ntags: redis,密码,安全\n---\n","slug":"redis-conf","published":1,"updated":"2018-11-09T01:20:30.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mg006lqcrgod6govbd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis命令搜集","date":"2018-03-23T09:36:34.000Z","_content":"\n1.查看所有的key\n\n`> KEYS *`\n\n2.清空所有key和数据\n\n`> flushall`","source":"_posts/redis-common.md","raw":"---\ntitle: redis命令搜集\ndate: 2018-03-23 17:36:34\ncategories: redis\ntags: redis命令\n---\n\n1.查看所有的key\n\n`> KEYS *`\n\n2.清空所有key和数据\n\n`> flushall`","slug":"redis-common","published":1,"updated":"2018-11-09T01:20:30.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mh006pqcrgfah2vffr","content":"<p>1.查看所有的key</p>\n<p><code>&gt; KEYS *</code></p>\n<p>2.清空所有key和数据</p>\n<p><code>&gt; flushall</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.查看所有的key</p>\n<p><code>&gt; KEYS *</code></p>\n<p>2.清空所有key和数据</p>\n<p><code>&gt; flushall</code></p>\n"},{"title":"redis安装","date":"2018-01-18T12:55:18.000Z","_content":"\n本文介绍在linux系统下redis的安装使用……\n\n## redis在ubuntu系统下的安装\n\n### 一、下载，安装，测试\n\nDownload, extract and compile Redis with:\n\n    $ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n    $ tar xzf redis-3.2.0.tar.gz\n    $ cd redis-3.2.0\n    $ make\n\nThe binaries that are now compiled are available in the src directory. Run Redis with:\n\n    $ src/redis-server\n\nYou can interact with Redis using the built-in client:\n\n    $ src/redis-cli redis> set foo bar OK redis> get foo \"bar\"\n\n### 二、设置直接使用redis的启动，客户端命令\nmake编译redis后，执行命令\n\n       $ cd redis-3.2.0\n       $ sudo make install\n       \nsrc中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：\n\n    xiaocao@xiaocao-pc:~$ redis-cli\n     127.0.0.1:6379> get foo\n     \"123456\"\n     127.0.0.1:6379>\n启动服务：`xiaocao@xiaocao-pc:~$ redis-server`\n\n### 三、src目录下执行文件说明：\n\nredis-check-aof //AOF文件修复工具\nredis-cli //Redis命令行客户端，最常用\nredis-server //Redis服务器，最常用\nredis-benchmark //Redis性能测试工具\nredis-check-rdb //\nredis-sentinel     //Sentinel服务器，2.8版本后\n\n### 四、启动，停止redis服务\n\n1、直接启动：make install后\n执行命令：`$ redis-server`     //默认端口是6379\n自定义端口启动：\n执行命令：`$ redis-server --port 6380`\n2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）\n(1)配置初始化脚本。\n>a. `$ cd ~/java/redis-3.2.0/utils`\n将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，\n客户端连接的端口号。\n\n>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。\n\n（2）建立需要的文件夹：\n>/etc/redis      //存放Redis的配置文件\n/var/redis/端口号     //存放Redis的持久化文件\n\n(3)修改配置文件：\n\n    a、$ cd  ~/java/redis-3.2.0\n    b、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\n    c、修改参数( 6380.conf )：\n    参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n         pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n         port                  端口号                                    设置redis监听的端口号\n         dir                    /var/redis/端口号                设置持久化文件存放位置\n    d、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\n    e、执行下面命令使得redis随系统自动启动：\n    $ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n\n### 3、正确停止redis服务命令：\n$ redis-cli SHUTDOWN /默认的  或者\n$ redis-cli -p 6380 SHUTDOWN\n当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。\n\n### 4、关闭后再启动：\n\nservice redis_6380 -p 6380 start  #启动6380端口实例的redis\n\n$ cd /etc/init.d && ./redis_6380 start  #默认启动6379端口实例的redis\n\n## centos7下安装redis\n\n1. 下载源码。\n\n2. 编译安装：\n\n\n    编译前需要安装依赖 yum install -y gcc tcl\n    然后再编译 make -j 4 MALLOC=libc\n    \n    如果要自动启动：`make install -j 4 MALLOC=libc`","source":"_posts/redis-install.md","raw":"---\ntitle: redis安装\ndate: 2018-01-18 20:55:18\ncategories: redis\ntags: redis-install\n---\n\n本文介绍在linux系统下redis的安装使用……\n\n## redis在ubuntu系统下的安装\n\n### 一、下载，安装，测试\n\nDownload, extract and compile Redis with:\n\n    $ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n    $ tar xzf redis-3.2.0.tar.gz\n    $ cd redis-3.2.0\n    $ make\n\nThe binaries that are now compiled are available in the src directory. Run Redis with:\n\n    $ src/redis-server\n\nYou can interact with Redis using the built-in client:\n\n    $ src/redis-cli redis> set foo bar OK redis> get foo \"bar\"\n\n### 二、设置直接使用redis的启动，客户端命令\nmake编译redis后，执行命令\n\n       $ cd redis-3.2.0\n       $ sudo make install\n       \nsrc中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：\n\n    xiaocao@xiaocao-pc:~$ redis-cli\n     127.0.0.1:6379> get foo\n     \"123456\"\n     127.0.0.1:6379>\n启动服务：`xiaocao@xiaocao-pc:~$ redis-server`\n\n### 三、src目录下执行文件说明：\n\nredis-check-aof //AOF文件修复工具\nredis-cli //Redis命令行客户端，最常用\nredis-server //Redis服务器，最常用\nredis-benchmark //Redis性能测试工具\nredis-check-rdb //\nredis-sentinel     //Sentinel服务器，2.8版本后\n\n### 四、启动，停止redis服务\n\n1、直接启动：make install后\n执行命令：`$ redis-server`     //默认端口是6379\n自定义端口启动：\n执行命令：`$ redis-server --port 6380`\n2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）\n(1)配置初始化脚本。\n>a. `$ cd ~/java/redis-3.2.0/utils`\n将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，\n客户端连接的端口号。\n\n>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。\n\n（2）建立需要的文件夹：\n>/etc/redis      //存放Redis的配置文件\n/var/redis/端口号     //存放Redis的持久化文件\n\n(3)修改配置文件：\n\n    a、$ cd  ~/java/redis-3.2.0\n    b、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\n    c、修改参数( 6380.conf )：\n    参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n         pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n         port                  端口号                                    设置redis监听的端口号\n         dir                    /var/redis/端口号                设置持久化文件存放位置\n    d、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\n    e、执行下面命令使得redis随系统自动启动：\n    $ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n\n### 3、正确停止redis服务命令：\n$ redis-cli SHUTDOWN /默认的  或者\n$ redis-cli -p 6380 SHUTDOWN\n当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。\n\n### 4、关闭后再启动：\n\nservice redis_6380 -p 6380 start  #启动6380端口实例的redis\n\n$ cd /etc/init.d && ./redis_6380 start  #默认启动6379端口实例的redis\n\n## centos7下安装redis\n\n1. 下载源码。\n\n2. 编译安装：\n\n\n    编译前需要安装依赖 yum install -y gcc tcl\n    然后再编译 make -j 4 MALLOC=libc\n    \n    如果要自动启动：`make install -j 4 MALLOC=libc`","slug":"redis-install","published":1,"updated":"2018-11-09T01:20:30.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mi006rqcrgjt7vdp3b","content":"<p>本文介绍在linux系统下redis的安装使用……</p>\n<h2 id=\"redis在ubuntu系统下的安装\"><a href=\"#redis在ubuntu系统下的安装\" class=\"headerlink\" title=\"redis在ubuntu系统下的安装\"></a>redis在ubuntu系统下的安装</h2><h3 id=\"一、下载，安装，测试\"><a href=\"#一、下载，安装，测试\" class=\"headerlink\" title=\"一、下载，安装，测试\"></a>一、下载，安装，测试</h3><p>Download, extract and compile Redis with:</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n$ tar xzf redis-3.2.0.tar.gz\n$ cd redis-3.2.0\n$ make\n</code></pre><p>The binaries that are now compiled are available in the src directory. Run Redis with:</p>\n<pre><code>$ src/redis-server\n</code></pre><p>You can interact with Redis using the built-in client:</p>\n<pre><code>$ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot;\n</code></pre><h3 id=\"二、设置直接使用redis的启动，客户端命令\"><a href=\"#二、设置直接使用redis的启动，客户端命令\" class=\"headerlink\" title=\"二、设置直接使用redis的启动，客户端命令\"></a>二、设置直接使用redis的启动，客户端命令</h3><p>make编译redis后，执行命令</p>\n<pre><code>$ cd redis-3.2.0\n$ sudo make install\n</code></pre><p>src中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：</p>\n<pre><code>xiaocao@xiaocao-pc:~$ redis-cli\n 127.0.0.1:6379&gt; get foo\n &quot;123456&quot;\n 127.0.0.1:6379&gt;\n</code></pre><p>启动服务：<code>xiaocao@xiaocao-pc:~$ redis-server</code></p>\n<h3 id=\"三、src目录下执行文件说明：\"><a href=\"#三、src目录下执行文件说明：\" class=\"headerlink\" title=\"三、src目录下执行文件说明：\"></a>三、src目录下执行文件说明：</h3><p>redis-check-aof //AOF文件修复工具<br>redis-cli //Redis命令行客户端，最常用<br>redis-server //Redis服务器，最常用<br>redis-benchmark //Redis性能测试工具<br>redis-check-rdb //<br>redis-sentinel     //Sentinel服务器，2.8版本后</p>\n<h3 id=\"四、启动，停止redis服务\"><a href=\"#四、启动，停止redis服务\" class=\"headerlink\" title=\"四、启动，停止redis服务\"></a>四、启动，停止redis服务</h3><p>1、直接启动：make install后<br>执行命令：<code>$ redis-server</code>     //默认端口是6379<br>自定义端口启动：<br>执行命令：<code>$ redis-server --port 6380</code><br>2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）<br>(1)配置初始化脚本。</p>\n<blockquote>\n<p>a. <code>$ cd ~/java/redis-3.2.0/utils</code><br>将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，<br>客户端连接的端口号。</p>\n</blockquote>\n<blockquote>\n<p>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。</p>\n</blockquote>\n<p>（2）建立需要的文件夹：</p>\n<blockquote>\n<p>/etc/redis      //存放Redis的配置文件<br>/var/redis/端口号     //存放Redis的持久化文件</p>\n</blockquote>\n<p>(3)修改配置文件：</p>\n<pre><code>a、$ cd  ~/java/redis-3.2.0\nb、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\nc、修改参数( 6380.conf )：\n参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n     pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n     port                  端口号                                    设置redis监听的端口号\n     dir                    /var/redis/端口号                设置持久化文件存放位置\nd、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\ne、执行下面命令使得redis随系统自动启动：\n$ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n</code></pre><h3 id=\"3、正确停止redis服务命令：\"><a href=\"#3、正确停止redis服务命令：\" class=\"headerlink\" title=\"3、正确停止redis服务命令：\"></a>3、正确停止redis服务命令：</h3><p>$ redis-cli SHUTDOWN /默认的  或者<br>$ redis-cli -p 6380 SHUTDOWN<br>当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。</p>\n<h3 id=\"4、关闭后再启动：\"><a href=\"#4、关闭后再启动：\" class=\"headerlink\" title=\"4、关闭后再启动：\"></a>4、关闭后再启动：</h3><p>service redis_6380 -p 6380 start  #启动6380端口实例的redis</p>\n<p>$ cd /etc/init.d &amp;&amp; ./redis_6380 start  #默认启动6379端口实例的redis</p>\n<h2 id=\"centos7下安装redis\"><a href=\"#centos7下安装redis\" class=\"headerlink\" title=\"centos7下安装redis\"></a>centos7下安装redis</h2><ol>\n<li><p>下载源码。</p>\n</li>\n<li><p>编译安装：</p>\n</li>\n</ol>\n<pre><code>编译前需要安装依赖 yum install -y gcc tcl\n然后再编译 make -j 4 MALLOC=libc\n\n如果要自动启动：`make install -j 4 MALLOC=libc`\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在linux系统下redis的安装使用……</p>\n<h2 id=\"redis在ubuntu系统下的安装\"><a href=\"#redis在ubuntu系统下的安装\" class=\"headerlink\" title=\"redis在ubuntu系统下的安装\"></a>redis在ubuntu系统下的安装</h2><h3 id=\"一、下载，安装，测试\"><a href=\"#一、下载，安装，测试\" class=\"headerlink\" title=\"一、下载，安装，测试\"></a>一、下载，安装，测试</h3><p>Download, extract and compile Redis with:</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n$ tar xzf redis-3.2.0.tar.gz\n$ cd redis-3.2.0\n$ make\n</code></pre><p>The binaries that are now compiled are available in the src directory. Run Redis with:</p>\n<pre><code>$ src/redis-server\n</code></pre><p>You can interact with Redis using the built-in client:</p>\n<pre><code>$ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot;\n</code></pre><h3 id=\"二、设置直接使用redis的启动，客户端命令\"><a href=\"#二、设置直接使用redis的启动，客户端命令\" class=\"headerlink\" title=\"二、设置直接使用redis的启动，客户端命令\"></a>二、设置直接使用redis的启动，客户端命令</h3><p>make编译redis后，执行命令</p>\n<pre><code>$ cd redis-3.2.0\n$ sudo make install\n</code></pre><p>src中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：</p>\n<pre><code>xiaocao@xiaocao-pc:~$ redis-cli\n 127.0.0.1:6379&gt; get foo\n &quot;123456&quot;\n 127.0.0.1:6379&gt;\n</code></pre><p>启动服务：<code>xiaocao@xiaocao-pc:~$ redis-server</code></p>\n<h3 id=\"三、src目录下执行文件说明：\"><a href=\"#三、src目录下执行文件说明：\" class=\"headerlink\" title=\"三、src目录下执行文件说明：\"></a>三、src目录下执行文件说明：</h3><p>redis-check-aof //AOF文件修复工具<br>redis-cli //Redis命令行客户端，最常用<br>redis-server //Redis服务器，最常用<br>redis-benchmark //Redis性能测试工具<br>redis-check-rdb //<br>redis-sentinel     //Sentinel服务器，2.8版本后</p>\n<h3 id=\"四、启动，停止redis服务\"><a href=\"#四、启动，停止redis服务\" class=\"headerlink\" title=\"四、启动，停止redis服务\"></a>四、启动，停止redis服务</h3><p>1、直接启动：make install后<br>执行命令：<code>$ redis-server</code>     //默认端口是6379<br>自定义端口启动：<br>执行命令：<code>$ redis-server --port 6380</code><br>2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）<br>(1)配置初始化脚本。</p>\n<blockquote>\n<p>a. <code>$ cd ~/java/redis-3.2.0/utils</code><br>将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，<br>客户端连接的端口号。</p>\n</blockquote>\n<blockquote>\n<p>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。</p>\n</blockquote>\n<p>（2）建立需要的文件夹：</p>\n<blockquote>\n<p>/etc/redis      //存放Redis的配置文件<br>/var/redis/端口号     //存放Redis的持久化文件</p>\n</blockquote>\n<p>(3)修改配置文件：</p>\n<pre><code>a、$ cd  ~/java/redis-3.2.0\nb、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\nc、修改参数( 6380.conf )：\n参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n     pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n     port                  端口号                                    设置redis监听的端口号\n     dir                    /var/redis/端口号                设置持久化文件存放位置\nd、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\ne、执行下面命令使得redis随系统自动启动：\n$ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n</code></pre><h3 id=\"3、正确停止redis服务命令：\"><a href=\"#3、正确停止redis服务命令：\" class=\"headerlink\" title=\"3、正确停止redis服务命令：\"></a>3、正确停止redis服务命令：</h3><p>$ redis-cli SHUTDOWN /默认的  或者<br>$ redis-cli -p 6380 SHUTDOWN<br>当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。</p>\n<h3 id=\"4、关闭后再启动：\"><a href=\"#4、关闭后再启动：\" class=\"headerlink\" title=\"4、关闭后再启动：\"></a>4、关闭后再启动：</h3><p>service redis_6380 -p 6380 start  #启动6380端口实例的redis</p>\n<p>$ cd /etc/init.d &amp;&amp; ./redis_6380 start  #默认启动6379端口实例的redis</p>\n<h2 id=\"centos7下安装redis\"><a href=\"#centos7下安装redis\" class=\"headerlink\" title=\"centos7下安装redis\"></a>centos7下安装redis</h2><ol>\n<li><p>下载源码。</p>\n</li>\n<li><p>编译安装：</p>\n</li>\n</ol>\n<pre><code>编译前需要安装依赖 yum install -y gcc tcl\n然后再编译 make -j 4 MALLOC=libc\n\n如果要自动启动：`make install -j 4 MALLOC=libc`\n</code></pre>"},{"title":"redis实现分布式锁","date":"2018-06-11T09:22:58.000Z","_content":"","source":"_posts/redis-distributed-lock.md","raw":"---\ntitle: redis实现分布式锁\ndate: 2018-06-11 17:22:58\ncategories: redis\ntags: redis分布式锁\n---\n","slug":"redis-distributed-lock","published":1,"updated":"2018-11-09T01:20:30.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mk006vqcrg7qsyzyrb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis哨兵模式","date":"2018-06-11T09:27:25.000Z","_content":"","source":"_posts/redis-sentinel.md","raw":"---\ntitle: redis哨兵模式\ndate: 2018-06-11 17:27:25\ncategories: redis\ntags: redis哨兵模式\n---\n","slug":"redis-sentinel","published":1,"updated":"2018-11-09T01:20:30.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38ml006xqcrgad9wjnge","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redmine常见插件安装使用","date":"2018-08-24T08:04:35.000Z","_content":"\nredmine项目管理系统之所以强大并让大家喜欢，正是其插件化的管理模式。各种插件为其增添了不少上天入地的能力！     \n因此，我们在这里就来介绍redmine的插件功能的使用，以及收集一些在开发管理中常用的插件功能。\n\n## redmine插件的安装\n\n1.查找插件并下载(官方仓库)：\n\n官网地址：http://www.redmine.org/plugins?page=1\n\n为了避免下载的插件版本和redmine（3.4.*）的版本冲突，必须选定对应版本下的插件下载。       \n{%asset_img a.png%}         \n\n2.其它途径下载，比如github上。\n\n \n- 安装： \n\n下载插件到plugins目录下，然后执行`bundle exec rake redmine:plugins:migrate RAILS_ENV=production`，再然后重启即可。\n    \n- 卸载： \n\n先执行`bundle exec rake redmine:plugins:migrate NAME=plugin_name VERSION=0 RAILS_ENV=production`，然后删除plugins目录下相应的插件目录，重启就可以了。 \n\n\n## 切图粘贴插件`redmine_image_clipboard_paste`(推荐)\n\n下载网址：https://github.com/thorin/redmine_image_clipboard_paste    \n\n这个是人家改过的新版本，兼容redmine`3.3.*`版本，旧的版本`redmine_image_clipboard_paste`不可用\n1.安装：\n\n    cd /path/to/redmine/\n    git clone git://github.com/thorin/redmine_image_clipboard_paste.git plugins/redmine_image_clipboard_paste\n    bundle exec rake redmine:plugins:migrate RAILS_ENV=production\n    \n2.卸载：\n    \n    cd /path/to/redmine/\n    bundle exec rake redmine:plugins:migrate NAME=redmine_image_clipboard_paste VERSION=0 RAILS_ENV=production\n    rm -rf plugins/redmine_image_clipboard_paste\n    \n## 方便查看问题中的图片`Lightbox Plugin 2`\n\n在Lightbox更加方便的查看问题中的图片，那些小的图片，就不用再点击进去了，直接鼠标放上去就能看。 \n    \n    \n## 代码审查插件`Code Review`\n\n参考网址：http://www.redmine.org/plugins/redmine_code_review\n\n代码审查插件允许对代码仓库中的代码进行审查批阅，做注释。有效地对项目成员写的代码质量做出把控。 \n\n具体使用：\n\n## 工时单插件\n\n可以方便查看各个人的各个项目的工时情况\n\n地址：http://www.redmine.org/plugins/timesheet\n\n## 添加表情插件`Emoji Button`\n\n添加几个表情，使枯燥的编程工作变得更加有趣！  \n\n地址：http://www.redmine.org/plugins/redmine_emojibutton\n\n## office文档查看插件\n\n地址：https://www.redmine.org/plugins/redmine_preview_office\n\n### 安装\n\n实验环境：\n系统：centos7 64位  \nredmine：3.4.6   \nruby：2.3.6  \nrails：4.2.8\n\n#### 一.安装[libreoffice](https://www.libreoffice.org)\n\nlibreoffice提供命令把word文档，excel文档转成pdf格式等。这里同时提供了一个思路，开发应用时候，文档格式转换可以采用它。\n\n下载下面安装包到服务器：    \n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ LibreOffice]# ls\n    LibreOffice_6.1.3.2_Linux_x86-64_rpm                 LibreOffice_6.1.3.2_Linux_x86-64_rpm_sdk                  LibreOffice_6.1.3_Linux_x86-64_rpm_sdk.tar.gz\n    LibreOffice_6.1.3.2_Linux_x86-64_rpm_langpack_zh-CN  LibreOffice_6.1.3_Linux_x86-64_rpm_langpack_zh-CN.tar.gz  LibreOffice_6.1.3_Linux_x86-64_rpm.tar.gz\n\n解压上面安装包，解压后，里面都有目录`RPMS`,安装里面的rpm包即可：   \n\n    yum install *.rpm\n    \n很顺利的安装成功。    \n    \n下面检查libreoffice是否可用：    \n\n重启redmine，查看如下图：    \n\n{%asset_img a-1.png%}\n    \n        ","source":"_posts/redmine-plugins.md","raw":"---\ntitle: redmine常见插件安装使用\ndate: 2018-08-24 16:04:35\ncategories: redmine\ntags: redmine插件\n---\n\nredmine项目管理系统之所以强大并让大家喜欢，正是其插件化的管理模式。各种插件为其增添了不少上天入地的能力！     \n因此，我们在这里就来介绍redmine的插件功能的使用，以及收集一些在开发管理中常用的插件功能。\n\n## redmine插件的安装\n\n1.查找插件并下载(官方仓库)：\n\n官网地址：http://www.redmine.org/plugins?page=1\n\n为了避免下载的插件版本和redmine（3.4.*）的版本冲突，必须选定对应版本下的插件下载。       \n{%asset_img a.png%}         \n\n2.其它途径下载，比如github上。\n\n \n- 安装： \n\n下载插件到plugins目录下，然后执行`bundle exec rake redmine:plugins:migrate RAILS_ENV=production`，再然后重启即可。\n    \n- 卸载： \n\n先执行`bundle exec rake redmine:plugins:migrate NAME=plugin_name VERSION=0 RAILS_ENV=production`，然后删除plugins目录下相应的插件目录，重启就可以了。 \n\n\n## 切图粘贴插件`redmine_image_clipboard_paste`(推荐)\n\n下载网址：https://github.com/thorin/redmine_image_clipboard_paste    \n\n这个是人家改过的新版本，兼容redmine`3.3.*`版本，旧的版本`redmine_image_clipboard_paste`不可用\n1.安装：\n\n    cd /path/to/redmine/\n    git clone git://github.com/thorin/redmine_image_clipboard_paste.git plugins/redmine_image_clipboard_paste\n    bundle exec rake redmine:plugins:migrate RAILS_ENV=production\n    \n2.卸载：\n    \n    cd /path/to/redmine/\n    bundle exec rake redmine:plugins:migrate NAME=redmine_image_clipboard_paste VERSION=0 RAILS_ENV=production\n    rm -rf plugins/redmine_image_clipboard_paste\n    \n## 方便查看问题中的图片`Lightbox Plugin 2`\n\n在Lightbox更加方便的查看问题中的图片，那些小的图片，就不用再点击进去了，直接鼠标放上去就能看。 \n    \n    \n## 代码审查插件`Code Review`\n\n参考网址：http://www.redmine.org/plugins/redmine_code_review\n\n代码审查插件允许对代码仓库中的代码进行审查批阅，做注释。有效地对项目成员写的代码质量做出把控。 \n\n具体使用：\n\n## 工时单插件\n\n可以方便查看各个人的各个项目的工时情况\n\n地址：http://www.redmine.org/plugins/timesheet\n\n## 添加表情插件`Emoji Button`\n\n添加几个表情，使枯燥的编程工作变得更加有趣！  \n\n地址：http://www.redmine.org/plugins/redmine_emojibutton\n\n## office文档查看插件\n\n地址：https://www.redmine.org/plugins/redmine_preview_office\n\n### 安装\n\n实验环境：\n系统：centos7 64位  \nredmine：3.4.6   \nruby：2.3.6  \nrails：4.2.8\n\n#### 一.安装[libreoffice](https://www.libreoffice.org)\n\nlibreoffice提供命令把word文档，excel文档转成pdf格式等。这里同时提供了一个思路，开发应用时候，文档格式转换可以采用它。\n\n下载下面安装包到服务器：    \n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ LibreOffice]# ls\n    LibreOffice_6.1.3.2_Linux_x86-64_rpm                 LibreOffice_6.1.3.2_Linux_x86-64_rpm_sdk                  LibreOffice_6.1.3_Linux_x86-64_rpm_sdk.tar.gz\n    LibreOffice_6.1.3.2_Linux_x86-64_rpm_langpack_zh-CN  LibreOffice_6.1.3_Linux_x86-64_rpm_langpack_zh-CN.tar.gz  LibreOffice_6.1.3_Linux_x86-64_rpm.tar.gz\n\n解压上面安装包，解压后，里面都有目录`RPMS`,安装里面的rpm包即可：   \n\n    yum install *.rpm\n    \n很顺利的安装成功。    \n    \n下面检查libreoffice是否可用：    \n\n重启redmine，查看如下图：    \n\n{%asset_img a-1.png%}\n    \n        ","slug":"redmine-plugins","published":1,"updated":"2018-11-28T03:42:00.899Z","_id":"cjp0m38mn0071qcrg7dxwz5wv","comments":1,"layout":"post","photos":[],"link":"","content":"<p>redmine项目管理系统之所以强大并让大家喜欢，正是其插件化的管理模式。各种插件为其增添了不少上天入地的能力！<br>因此，我们在这里就来介绍redmine的插件功能的使用，以及收集一些在开发管理中常用的插件功能。</p>\n<h2 id=\"redmine插件的安装\"><a href=\"#redmine插件的安装\" class=\"headerlink\" title=\"redmine插件的安装\"></a>redmine插件的安装</h2><p>1.查找插件并下载(官方仓库)：</p>\n<p>官网地址：<a href=\"http://www.redmine.org/plugins?page=1\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins?page=1</a></p>\n<p>为了避免下载的插件版本和redmine（3.4.*）的版本冲突，必须选定对应版本下的插件下载。<br><img src=\"/2018/08/24/redmine-plugins/a.png\">         </p>\n<p>2.其它途径下载，比如github上。</p>\n<ul>\n<li>安装： </li>\n</ul>\n<p>下载插件到plugins目录下，然后执行<code>bundle exec rake redmine:plugins:migrate RAILS_ENV=production</code>，再然后重启即可。</p>\n<ul>\n<li>卸载： </li>\n</ul>\n<p>先执行<code>bundle exec rake redmine:plugins:migrate NAME=plugin_name VERSION=0 RAILS_ENV=production</code>，然后删除plugins目录下相应的插件目录，重启就可以了。 </p>\n<h2 id=\"切图粘贴插件redmine-image-clipboard-paste-推荐\"><a href=\"#切图粘贴插件redmine-image-clipboard-paste-推荐\" class=\"headerlink\" title=\"切图粘贴插件redmine_image_clipboard_paste(推荐)\"></a>切图粘贴插件<code>redmine_image_clipboard_paste</code>(推荐)</h2><p>下载网址：<a href=\"https://github.com/thorin/redmine_image_clipboard_paste\" target=\"_blank\" rel=\"noopener\">https://github.com/thorin/redmine_image_clipboard_paste</a>    </p>\n<p>这个是人家改过的新版本，兼容redmine<code>3.3.*</code>版本，旧的版本<code>redmine_image_clipboard_paste</code>不可用<br>1.安装：</p>\n<pre><code>cd /path/to/redmine/\ngit clone git://github.com/thorin/redmine_image_clipboard_paste.git plugins/redmine_image_clipboard_paste\nbundle exec rake redmine:plugins:migrate RAILS_ENV=production\n</code></pre><p>2.卸载：</p>\n<pre><code>cd /path/to/redmine/\nbundle exec rake redmine:plugins:migrate NAME=redmine_image_clipboard_paste VERSION=0 RAILS_ENV=production\nrm -rf plugins/redmine_image_clipboard_paste\n</code></pre><h2 id=\"方便查看问题中的图片Lightbox-Plugin-2\"><a href=\"#方便查看问题中的图片Lightbox-Plugin-2\" class=\"headerlink\" title=\"方便查看问题中的图片Lightbox Plugin 2\"></a>方便查看问题中的图片<code>Lightbox Plugin 2</code></h2><p>在Lightbox更加方便的查看问题中的图片，那些小的图片，就不用再点击进去了，直接鼠标放上去就能看。 </p>\n<h2 id=\"代码审查插件Code-Review\"><a href=\"#代码审查插件Code-Review\" class=\"headerlink\" title=\"代码审查插件Code Review\"></a>代码审查插件<code>Code Review</code></h2><p>参考网址：<a href=\"http://www.redmine.org/plugins/redmine_code_review\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/redmine_code_review</a></p>\n<p>代码审查插件允许对代码仓库中的代码进行审查批阅，做注释。有效地对项目成员写的代码质量做出把控。 </p>\n<p>具体使用：</p>\n<h2 id=\"工时单插件\"><a href=\"#工时单插件\" class=\"headerlink\" title=\"工时单插件\"></a>工时单插件</h2><p>可以方便查看各个人的各个项目的工时情况</p>\n<p>地址：<a href=\"http://www.redmine.org/plugins/timesheet\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/timesheet</a></p>\n<h2 id=\"添加表情插件Emoji-Button\"><a href=\"#添加表情插件Emoji-Button\" class=\"headerlink\" title=\"添加表情插件Emoji Button\"></a>添加表情插件<code>Emoji Button</code></h2><p>添加几个表情，使枯燥的编程工作变得更加有趣！  </p>\n<p>地址：<a href=\"http://www.redmine.org/plugins/redmine_emojibutton\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/redmine_emojibutton</a></p>\n<h2 id=\"office文档查看插件\"><a href=\"#office文档查看插件\" class=\"headerlink\" title=\"office文档查看插件\"></a>office文档查看插件</h2><p>地址：<a href=\"https://www.redmine.org/plugins/redmine_preview_office\" target=\"_blank\" rel=\"noopener\">https://www.redmine.org/plugins/redmine_preview_office</a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>实验环境：<br>系统：centos7 64位<br>redmine：3.4.6<br>ruby：2.3.6<br>rails：4.2.8</p>\n<h4 id=\"一-安装libreoffice\"><a href=\"#一-安装libreoffice\" class=\"headerlink\" title=\"一.安装libreoffice\"></a>一.安装<a href=\"https://www.libreoffice.org\" target=\"_blank\" rel=\"noopener\">libreoffice</a></h4><p>libreoffice提供命令把word文档，excel文档转成pdf格式等。这里同时提供了一个思路，开发应用时候，文档格式转换可以采用它。</p>\n<p>下载下面安装包到服务器：    </p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ LibreOffice]# ls\nLibreOffice_6.1.3.2_Linux_x86-64_rpm                 LibreOffice_6.1.3.2_Linux_x86-64_rpm_sdk                  LibreOffice_6.1.3_Linux_x86-64_rpm_sdk.tar.gz\nLibreOffice_6.1.3.2_Linux_x86-64_rpm_langpack_zh-CN  LibreOffice_6.1.3_Linux_x86-64_rpm_langpack_zh-CN.tar.gz  LibreOffice_6.1.3_Linux_x86-64_rpm.tar.gz\n</code></pre><p>解压上面安装包，解压后，里面都有目录<code>RPMS</code>,安装里面的rpm包即可：   </p>\n<pre><code>yum install *.rpm\n</code></pre><p>很顺利的安装成功。    </p>\n<p>下面检查libreoffice是否可用：    </p>\n<p>重启redmine，查看如下图：    </p>\n<img src=\"/2018/08/24/redmine-plugins/a-1.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>redmine项目管理系统之所以强大并让大家喜欢，正是其插件化的管理模式。各种插件为其增添了不少上天入地的能力！<br>因此，我们在这里就来介绍redmine的插件功能的使用，以及收集一些在开发管理中常用的插件功能。</p>\n<h2 id=\"redmine插件的安装\"><a href=\"#redmine插件的安装\" class=\"headerlink\" title=\"redmine插件的安装\"></a>redmine插件的安装</h2><p>1.查找插件并下载(官方仓库)：</p>\n<p>官网地址：<a href=\"http://www.redmine.org/plugins?page=1\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins?page=1</a></p>\n<p>为了避免下载的插件版本和redmine（3.4.*）的版本冲突，必须选定对应版本下的插件下载。<br><img src=\"/2018/08/24/redmine-plugins/a.png\">         </p>\n<p>2.其它途径下载，比如github上。</p>\n<ul>\n<li>安装： </li>\n</ul>\n<p>下载插件到plugins目录下，然后执行<code>bundle exec rake redmine:plugins:migrate RAILS_ENV=production</code>，再然后重启即可。</p>\n<ul>\n<li>卸载： </li>\n</ul>\n<p>先执行<code>bundle exec rake redmine:plugins:migrate NAME=plugin_name VERSION=0 RAILS_ENV=production</code>，然后删除plugins目录下相应的插件目录，重启就可以了。 </p>\n<h2 id=\"切图粘贴插件redmine-image-clipboard-paste-推荐\"><a href=\"#切图粘贴插件redmine-image-clipboard-paste-推荐\" class=\"headerlink\" title=\"切图粘贴插件redmine_image_clipboard_paste(推荐)\"></a>切图粘贴插件<code>redmine_image_clipboard_paste</code>(推荐)</h2><p>下载网址：<a href=\"https://github.com/thorin/redmine_image_clipboard_paste\" target=\"_blank\" rel=\"noopener\">https://github.com/thorin/redmine_image_clipboard_paste</a>    </p>\n<p>这个是人家改过的新版本，兼容redmine<code>3.3.*</code>版本，旧的版本<code>redmine_image_clipboard_paste</code>不可用<br>1.安装：</p>\n<pre><code>cd /path/to/redmine/\ngit clone git://github.com/thorin/redmine_image_clipboard_paste.git plugins/redmine_image_clipboard_paste\nbundle exec rake redmine:plugins:migrate RAILS_ENV=production\n</code></pre><p>2.卸载：</p>\n<pre><code>cd /path/to/redmine/\nbundle exec rake redmine:plugins:migrate NAME=redmine_image_clipboard_paste VERSION=0 RAILS_ENV=production\nrm -rf plugins/redmine_image_clipboard_paste\n</code></pre><h2 id=\"方便查看问题中的图片Lightbox-Plugin-2\"><a href=\"#方便查看问题中的图片Lightbox-Plugin-2\" class=\"headerlink\" title=\"方便查看问题中的图片Lightbox Plugin 2\"></a>方便查看问题中的图片<code>Lightbox Plugin 2</code></h2><p>在Lightbox更加方便的查看问题中的图片，那些小的图片，就不用再点击进去了，直接鼠标放上去就能看。 </p>\n<h2 id=\"代码审查插件Code-Review\"><a href=\"#代码审查插件Code-Review\" class=\"headerlink\" title=\"代码审查插件Code Review\"></a>代码审查插件<code>Code Review</code></h2><p>参考网址：<a href=\"http://www.redmine.org/plugins/redmine_code_review\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/redmine_code_review</a></p>\n<p>代码审查插件允许对代码仓库中的代码进行审查批阅，做注释。有效地对项目成员写的代码质量做出把控。 </p>\n<p>具体使用：</p>\n<h2 id=\"工时单插件\"><a href=\"#工时单插件\" class=\"headerlink\" title=\"工时单插件\"></a>工时单插件</h2><p>可以方便查看各个人的各个项目的工时情况</p>\n<p>地址：<a href=\"http://www.redmine.org/plugins/timesheet\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/timesheet</a></p>\n<h2 id=\"添加表情插件Emoji-Button\"><a href=\"#添加表情插件Emoji-Button\" class=\"headerlink\" title=\"添加表情插件Emoji Button\"></a>添加表情插件<code>Emoji Button</code></h2><p>添加几个表情，使枯燥的编程工作变得更加有趣！  </p>\n<p>地址：<a href=\"http://www.redmine.org/plugins/redmine_emojibutton\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/plugins/redmine_emojibutton</a></p>\n<h2 id=\"office文档查看插件\"><a href=\"#office文档查看插件\" class=\"headerlink\" title=\"office文档查看插件\"></a>office文档查看插件</h2><p>地址：<a href=\"https://www.redmine.org/plugins/redmine_preview_office\" target=\"_blank\" rel=\"noopener\">https://www.redmine.org/plugins/redmine_preview_office</a></p>\n<h3 id=\"安装\"><a href=\"#安装\" class=\"headerlink\" title=\"安装\"></a>安装</h3><p>实验环境：<br>系统：centos7 64位<br>redmine：3.4.6<br>ruby：2.3.6<br>rails：4.2.8</p>\n<h4 id=\"一-安装libreoffice\"><a href=\"#一-安装libreoffice\" class=\"headerlink\" title=\"一.安装libreoffice\"></a>一.安装<a href=\"https://www.libreoffice.org\" target=\"_blank\" rel=\"noopener\">libreoffice</a></h4><p>libreoffice提供命令把word文档，excel文档转成pdf格式等。这里同时提供了一个思路，开发应用时候，文档格式转换可以采用它。</p>\n<p>下载下面安装包到服务器：    </p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ LibreOffice]# ls\nLibreOffice_6.1.3.2_Linux_x86-64_rpm                 LibreOffice_6.1.3.2_Linux_x86-64_rpm_sdk                  LibreOffice_6.1.3_Linux_x86-64_rpm_sdk.tar.gz\nLibreOffice_6.1.3.2_Linux_x86-64_rpm_langpack_zh-CN  LibreOffice_6.1.3_Linux_x86-64_rpm_langpack_zh-CN.tar.gz  LibreOffice_6.1.3_Linux_x86-64_rpm.tar.gz\n</code></pre><p>解压上面安装包，解压后，里面都有目录<code>RPMS</code>,安装里面的rpm包即可：   </p>\n<pre><code>yum install *.rpm\n</code></pre><p>很顺利的安装成功。    </p>\n<p>下面检查libreoffice是否可用：    </p>\n<p>重启redmine，查看如下图：    </p>\n<img src=\"/2018/08/24/redmine-plugins/a-1.png\">\n"},{"title":"Redmine通过域名访问慢的问题解决","date":"2018-11-16T09:14:25.000Z","_content":"\n按照之前章节在服务器安装好Redmine后，通过ngxin代理访问，发现巨慢，心塞！  \n于是开始了各种搜，搜，搜……  \n下面，把整个踩坑的过程记录下来！    \n\n## Mongrel服务器启动Redmine\n由于Redmine自带的Webrick Web服务器，听说是要进行域名代理解析，所以会特别慢。于是想确认下，通过翻墙访问，真他妹的变得快一些。唉，毕竟老外开发的东西呀，再加上咱国度的网络问题，呵呵了……   \n还有，万能的网络告知还有个Mongrel的东东。    \nMongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat.  \n\n于是，开始各种google，百度，按照Mongrel\n\n1.替换其自带的服务器webrick为mongrel，方法：  \n`gem install mongrel`\nrails 3.1以上执行:\n`gem install mongrel --pre`\n\n查看rails版本：\n    \n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# rails -v\n    Rails 4.2.8\n\n2.编辑`Gemfile.local`\n\n进入Redmine安装目录下，新建文件`Gemfile.local`并编辑：\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# cat Gemfile.local \n    # Gemfile.local \n    #gem 'thin'\n    gem 'mongrel','~> 1.2.0.pre2'\n    \n3.删除gemfile.lock文件，重新执行:    \n`bundle install`\n\n4.重新启动Redmine：  \n`ruby bin/rails server mongrel -e production -p 8889 -d`\n\n## 配置Nginx代理\n\n    upstream pm.xcsqjr.com{\n        server localhost:8889;\n        #server 10.162.71.10:5050;\n        fair;\n    }  \n    server{\n            listen 80;\n            server_name pm.xcsqjr.com;\n    \taccess_log  /server/java/nginx/logs/pm.xcsqjr.com.access.log;\n            location ~ ${\n                  server_name_in_redirect off;\n    \t      proxy_redirect off;\n                  proxy_set_header Host $host;\n                  proxy_set_header X-Real-IP $remote_addr;\n                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                  proxy_pass http://pm.xcsqjr.com;\n                  client_max_body_size    100m;\n                  index index.html index.htm;\n            }\n            error_page  404              /404.html;\n            error_page  500 502 503 504  /50x.html;\n            location = /50x.html {\n                    root   html;\n            }\n    }\n    \n重启nginx，使配置生效。\n\n激动人心的时刻即将到来，在浏览器输入：http://pm.xcsqjr.com/    \n哎呀，他妹的，还是慢，慢，慢……    \n\n于是，各种继续搜，搜，搜……，各种尝试，还是不行呀！！\n \n哎呦，好像有点新发现了，在这里：    \nhttps://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine    \n\n好吧，就这样，把ngxin代理的配置改下，只能碰碰运气了：   \n\n     upstream redmine {\n             server 127.0.0.1:8889;\n             #server 127.0.0.1:8001;\n             #server 127.0.0.1:8002;\n     }\n     \n     server {\n             server_name pm.xcsqjr.com;\n             root /server/java/redmine/redmine-3.4.6/public;\n     \n             location / {\n                     try_files $uri @redmine;\n             }\n     \n             location @redmine {\n                     proxy_set_header  X-Forwarded-For $remote_addr;\n                     proxy_pass http://redmine;\n             }\n     }\n\n没抱大希望咯，还是打开浏览器大神访问看看吧：http://pm.xcsqjr.com/     \n\n啊，大爷的，飞速的快呀！那一刻，激动的泪水……\n\n可以下班回家煮饭了，感谢上帝！！！","source":"_posts/redmine-mongrel-nginx.md","raw":"---\ntitle: Redmine通过域名访问慢的问题解决\ndate: 2018-11-16 17:14:25\ncategories: redmine\ntags: redmine-mongrel-nginx\n---\n\n按照之前章节在服务器安装好Redmine后，通过ngxin代理访问，发现巨慢，心塞！  \n于是开始了各种搜，搜，搜……  \n下面，把整个踩坑的过程记录下来！    \n\n## Mongrel服务器启动Redmine\n由于Redmine自带的Webrick Web服务器，听说是要进行域名代理解析，所以会特别慢。于是想确认下，通过翻墙访问，真他妹的变得快一些。唉，毕竟老外开发的东西呀，再加上咱国度的网络问题，呵呵了……   \n还有，万能的网络告知还有个Mongrel的东东。    \nMongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat.  \n\n于是，开始各种google，百度，按照Mongrel\n\n1.替换其自带的服务器webrick为mongrel，方法：  \n`gem install mongrel`\nrails 3.1以上执行:\n`gem install mongrel --pre`\n\n查看rails版本：\n    \n    [root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# rails -v\n    Rails 4.2.8\n\n2.编辑`Gemfile.local`\n\n进入Redmine安装目录下，新建文件`Gemfile.local`并编辑：\n\n    [root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# cat Gemfile.local \n    # Gemfile.local \n    #gem 'thin'\n    gem 'mongrel','~> 1.2.0.pre2'\n    \n3.删除gemfile.lock文件，重新执行:    \n`bundle install`\n\n4.重新启动Redmine：  \n`ruby bin/rails server mongrel -e production -p 8889 -d`\n\n## 配置Nginx代理\n\n    upstream pm.xcsqjr.com{\n        server localhost:8889;\n        #server 10.162.71.10:5050;\n        fair;\n    }  \n    server{\n            listen 80;\n            server_name pm.xcsqjr.com;\n    \taccess_log  /server/java/nginx/logs/pm.xcsqjr.com.access.log;\n            location ~ ${\n                  server_name_in_redirect off;\n    \t      proxy_redirect off;\n                  proxy_set_header Host $host;\n                  proxy_set_header X-Real-IP $remote_addr;\n                  proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n                  proxy_pass http://pm.xcsqjr.com;\n                  client_max_body_size    100m;\n                  index index.html index.htm;\n            }\n            error_page  404              /404.html;\n            error_page  500 502 503 504  /50x.html;\n            location = /50x.html {\n                    root   html;\n            }\n    }\n    \n重启nginx，使配置生效。\n\n激动人心的时刻即将到来，在浏览器输入：http://pm.xcsqjr.com/    \n哎呀，他妹的，还是慢，慢，慢……    \n\n于是，各种继续搜，搜，搜……，各种尝试，还是不行呀！！\n \n哎呦，好像有点新发现了，在这里：    \nhttps://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine    \n\n好吧，就这样，把ngxin代理的配置改下，只能碰碰运气了：   \n\n     upstream redmine {\n             server 127.0.0.1:8889;\n             #server 127.0.0.1:8001;\n             #server 127.0.0.1:8002;\n     }\n     \n     server {\n             server_name pm.xcsqjr.com;\n             root /server/java/redmine/redmine-3.4.6/public;\n     \n             location / {\n                     try_files $uri @redmine;\n             }\n     \n             location @redmine {\n                     proxy_set_header  X-Forwarded-For $remote_addr;\n                     proxy_pass http://redmine;\n             }\n     }\n\n没抱大希望咯，还是打开浏览器大神访问看看吧：http://pm.xcsqjr.com/     \n\n啊，大爷的，飞速的快呀！那一刻，激动的泪水……\n\n可以下班回家煮饭了，感谢上帝！！！","slug":"redmine-mongrel-nginx","published":1,"updated":"2018-11-16T10:15:57.323Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mo0073qcrgp5bkok92","content":"<p>按照之前章节在服务器安装好Redmine后，通过ngxin代理访问，发现巨慢，心塞！<br>于是开始了各种搜，搜，搜……<br>下面，把整个踩坑的过程记录下来！    </p>\n<h2 id=\"Mongrel服务器启动Redmine\"><a href=\"#Mongrel服务器启动Redmine\" class=\"headerlink\" title=\"Mongrel服务器启动Redmine\"></a>Mongrel服务器启动Redmine</h2><p>由于Redmine自带的Webrick Web服务器，听说是要进行域名代理解析，所以会特别慢。于是想确认下，通过翻墙访问，真他妹的变得快一些。唉，毕竟老外开发的东西呀，再加上咱国度的网络问题，呵呵了……<br>还有，万能的网络告知还有个Mongrel的东东。<br>Mongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat.  </p>\n<p>于是，开始各种google，百度，按照Mongrel</p>\n<p>1.替换其自带的服务器webrick为mongrel，方法：<br><code>gem install mongrel</code><br>rails 3.1以上执行:<br><code>gem install mongrel --pre</code></p>\n<p>查看rails版本：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# rails -v\nRails 4.2.8\n</code></pre><p>2.编辑<code>Gemfile.local</code></p>\n<p>进入Redmine安装目录下，新建文件<code>Gemfile.local</code>并编辑：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# cat Gemfile.local \n# Gemfile.local \n#gem &apos;thin&apos;\ngem &apos;mongrel&apos;,&apos;~&gt; 1.2.0.pre2&apos;\n</code></pre><p>3.删除gemfile.lock文件，重新执行:<br><code>bundle install</code></p>\n<p>4.重新启动Redmine：<br><code>ruby bin/rails server mongrel -e production -p 8889 -d</code></p>\n<h2 id=\"配置Nginx代理\"><a href=\"#配置Nginx代理\" class=\"headerlink\" title=\"配置Nginx代理\"></a>配置Nginx代理</h2><pre><code>upstream pm.xcsqjr.com{\n    server localhost:8889;\n    #server 10.162.71.10:5050;\n    fair;\n}  \nserver{\n        listen 80;\n        server_name pm.xcsqjr.com;\n    access_log  /server/java/nginx/logs/pm.xcsqjr.com.access.log;\n        location ~ ${\n              server_name_in_redirect off;\n          proxy_redirect off;\n              proxy_set_header Host $host;\n              proxy_set_header X-Real-IP $remote_addr;\n              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n              proxy_pass http://pm.xcsqjr.com;\n              client_max_body_size    100m;\n              index index.html index.htm;\n        }\n        error_page  404              /404.html;\n        error_page  500 502 503 504  /50x.html;\n        location = /50x.html {\n                root   html;\n        }\n}\n</code></pre><p>重启nginx，使配置生效。</p>\n<p>激动人心的时刻即将到来，在浏览器输入：<a href=\"http://pm.xcsqjr.com/\" target=\"_blank\" rel=\"noopener\">http://pm.xcsqjr.com/</a><br>哎呀，他妹的，还是慢，慢，慢……    </p>\n<p>于是，各种继续搜，搜，搜……，各种尝试，还是不行呀！！</p>\n<p>哎呦，好像有点新发现了，在这里：<br><a href=\"https://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine\" target=\"_blank\" rel=\"noopener\">https://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine</a>    </p>\n<p>好吧，就这样，把ngxin代理的配置改下，只能碰碰运气了：   </p>\n<pre><code>upstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n\nserver {\n        server_name pm.xcsqjr.com;\n        root /server/java/redmine/redmine-3.4.6/public;\n\n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n}\n</code></pre><p>没抱大希望咯，还是打开浏览器大神访问看看吧：<a href=\"http://pm.xcsqjr.com/\" target=\"_blank\" rel=\"noopener\">http://pm.xcsqjr.com/</a>     </p>\n<p>啊，大爷的，飞速的快呀！那一刻，激动的泪水……</p>\n<p>可以下班回家煮饭了，感谢上帝！！！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>按照之前章节在服务器安装好Redmine后，通过ngxin代理访问，发现巨慢，心塞！<br>于是开始了各种搜，搜，搜……<br>下面，把整个踩坑的过程记录下来！    </p>\n<h2 id=\"Mongrel服务器启动Redmine\"><a href=\"#Mongrel服务器启动Redmine\" class=\"headerlink\" title=\"Mongrel服务器启动Redmine\"></a>Mongrel服务器启动Redmine</h2><p>由于Redmine自带的Webrick Web服务器，听说是要进行域名代理解析，所以会特别慢。于是想确认下，通过翻墙访问，真他妹的变得快一些。唉，毕竟老外开发的东西呀，再加上咱国度的网络问题，呵呵了……<br>还有，万能的网络告知还有个Mongrel的东东。<br>Mongrel是一种快速的针对Ruby的Http服务器，专门为部署发布ROR应用而产生的。Mongrel相比Rails自带的纯Ruby服务器Webrick速度快很多并支持并发访问，有望成为Ruby的Tomcat.  </p>\n<p>于是，开始各种google，百度，按照Mongrel</p>\n<p>1.替换其自带的服务器webrick为mongrel，方法：<br><code>gem install mongrel</code><br>rails 3.1以上执行:<br><code>gem install mongrel --pre</code></p>\n<p>查看rails版本：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ ~]# rails -v\nRails 4.2.8\n</code></pre><p>2.编辑<code>Gemfile.local</code></p>\n<p>进入Redmine安装目录下，新建文件<code>Gemfile.local</code>并编辑：</p>\n<pre><code>[root@iZwz9b0bqrkbhqd5lu2pwhZ redmine-3.4.6]# cat Gemfile.local \n# Gemfile.local \n#gem &apos;thin&apos;\ngem &apos;mongrel&apos;,&apos;~&gt; 1.2.0.pre2&apos;\n</code></pre><p>3.删除gemfile.lock文件，重新执行:<br><code>bundle install</code></p>\n<p>4.重新启动Redmine：<br><code>ruby bin/rails server mongrel -e production -p 8889 -d</code></p>\n<h2 id=\"配置Nginx代理\"><a href=\"#配置Nginx代理\" class=\"headerlink\" title=\"配置Nginx代理\"></a>配置Nginx代理</h2><pre><code>upstream pm.xcsqjr.com{\n    server localhost:8889;\n    #server 10.162.71.10:5050;\n    fair;\n}  \nserver{\n        listen 80;\n        server_name pm.xcsqjr.com;\n    access_log  /server/java/nginx/logs/pm.xcsqjr.com.access.log;\n        location ~ ${\n              server_name_in_redirect off;\n          proxy_redirect off;\n              proxy_set_header Host $host;\n              proxy_set_header X-Real-IP $remote_addr;\n              proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n              proxy_pass http://pm.xcsqjr.com;\n              client_max_body_size    100m;\n              index index.html index.htm;\n        }\n        error_page  404              /404.html;\n        error_page  500 502 503 504  /50x.html;\n        location = /50x.html {\n                root   html;\n        }\n}\n</code></pre><p>重启nginx，使配置生效。</p>\n<p>激动人心的时刻即将到来，在浏览器输入：<a href=\"http://pm.xcsqjr.com/\" target=\"_blank\" rel=\"noopener\">http://pm.xcsqjr.com/</a><br>哎呀，他妹的，还是慢，慢，慢……    </p>\n<p>于是，各种继续搜，搜，搜……，各种尝试，还是不行呀！！</p>\n<p>哎呦，好像有点新发现了，在这里：<br><a href=\"https://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine\" target=\"_blank\" rel=\"noopener\">https://www.nginx.com/resources/wiki/start/topics/recipes/redmine/?highlight=redmine</a>    </p>\n<p>好吧，就这样，把ngxin代理的配置改下，只能碰碰运气了：   </p>\n<pre><code>upstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n\nserver {\n        server_name pm.xcsqjr.com;\n        root /server/java/redmine/redmine-3.4.6/public;\n\n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n}\n</code></pre><p>没抱大希望咯，还是打开浏览器大神访问看看吧：<a href=\"http://pm.xcsqjr.com/\" target=\"_blank\" rel=\"noopener\">http://pm.xcsqjr.com/</a>     </p>\n<p>啊，大爷的，飞速的快呀！那一刻，激动的泪水……</p>\n<p>可以下班回家煮饭了，感谢上帝！！！</p>\n"},{"title":"redmine使用踩坑记","date":"2018-11-23T01:14:54.000Z","_content":"\n### 附件图片加载不全，中文附件下载空白\n\n问题描述：   \n在浏览器，域名访问redmine系统，图片显示不全，中文附件下载后空白。琢磨老半天，上服务器查看了下，附件都已经上传到服务器，从服务器把对应的图片拉取下来后，用工具打开，正常。我去，那是啥子问题咧，开始以为是Redmine系统编码问题，各种百度，么用。后来在本地环境装个Redmine环境，直接访问，不经过Nginx，不存在显示不了图片的问题，尴尬咯。那就只有一种可能了，Nginx配置的问题了，似乎看到了光明……\n\n折腾了老半天，真他妈的是nginx的配置造成的。我去……     \n\n原来配置：\n\n    upstream redmine {\n            server 127.0.0.1:8889;\n            #server 127.0.0.1:8001;\n            #server 127.0.0.1:8002;\n    }\n    \n    server {\n    \tlisten 80;\n        server_name pm.xcsqjr.com;\n        root /server/java/redmine/redmine-3.4.6/public;\n    \n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n    }\n    \n改为：\n\n在conf中新增文件夹`sites`并添加文件`proxy.include`\n\n    proxy_set_header   Host $http_host;                                                                                                                     \n    proxy_set_header   X-Real-IP $remote_addr;                                                                                                                   \n    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header   X-Forwarded-Proto $scheme;\n    \n    client_max_body_size       10m;\n    client_body_buffer_size    128k;\n    \n    proxy_connect_timeout      90;\n    proxy_send_timeout         90;\n    proxy_read_timeout         90;\n    \n    proxy_buffer_size          4k;\n    proxy_buffers              4 32k;\n    proxy_busy_buffers_size    64k;\n    proxy_temp_file_write_size 64k;\n\n\n    upstream redmine {\n            server 127.0.0.1:8889;\n            #server 127.0.0.1:8001;\n            #server 127.0.0.1:8002;\n    }\n\n编辑配置：\n   \n    server {\n    \tlisten 80;\n        server_name pm.xcsqjr.com;\n    \tcharset utf-8;\n    \tinclude sites/proxy.include;\n         root /server/java/redmine/redmine-3.4.6/public;\n    \t#proxy_redirect off; #加上这行跳转会有问题\n    \n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n    } \n          ","source":"_posts/redmine-use-record.md","raw":"---\ntitle: redmine使用踩坑记\ndate: 2018-11-23 09:14:54\ncategories: redmine\ntags:\n---\n\n### 附件图片加载不全，中文附件下载空白\n\n问题描述：   \n在浏览器，域名访问redmine系统，图片显示不全，中文附件下载后空白。琢磨老半天，上服务器查看了下，附件都已经上传到服务器，从服务器把对应的图片拉取下来后，用工具打开，正常。我去，那是啥子问题咧，开始以为是Redmine系统编码问题，各种百度，么用。后来在本地环境装个Redmine环境，直接访问，不经过Nginx，不存在显示不了图片的问题，尴尬咯。那就只有一种可能了，Nginx配置的问题了，似乎看到了光明……\n\n折腾了老半天，真他妈的是nginx的配置造成的。我去……     \n\n原来配置：\n\n    upstream redmine {\n            server 127.0.0.1:8889;\n            #server 127.0.0.1:8001;\n            #server 127.0.0.1:8002;\n    }\n    \n    server {\n    \tlisten 80;\n        server_name pm.xcsqjr.com;\n        root /server/java/redmine/redmine-3.4.6/public;\n    \n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n    }\n    \n改为：\n\n在conf中新增文件夹`sites`并添加文件`proxy.include`\n\n    proxy_set_header   Host $http_host;                                                                                                                     \n    proxy_set_header   X-Real-IP $remote_addr;                                                                                                                   \n    proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\n    proxy_set_header   X-Forwarded-Proto $scheme;\n    \n    client_max_body_size       10m;\n    client_body_buffer_size    128k;\n    \n    proxy_connect_timeout      90;\n    proxy_send_timeout         90;\n    proxy_read_timeout         90;\n    \n    proxy_buffer_size          4k;\n    proxy_buffers              4 32k;\n    proxy_busy_buffers_size    64k;\n    proxy_temp_file_write_size 64k;\n\n\n    upstream redmine {\n            server 127.0.0.1:8889;\n            #server 127.0.0.1:8001;\n            #server 127.0.0.1:8002;\n    }\n\n编辑配置：\n   \n    server {\n    \tlisten 80;\n        server_name pm.xcsqjr.com;\n    \tcharset utf-8;\n    \tinclude sites/proxy.include;\n         root /server/java/redmine/redmine-3.4.6/public;\n    \t#proxy_redirect off; #加上这行跳转会有问题\n    \n        location / {\n                try_files $uri @redmine;\n        }\n\n        location @redmine {\n                proxy_set_header  X-Forwarded-For $remote_addr;\n                proxy_pass http://redmine;\n        }\n    } \n          ","slug":"redmine-use-record","published":1,"updated":"2018-11-27T11:12:12.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mp0076qcrgsc565s4s","content":"<h3 id=\"附件图片加载不全，中文附件下载空白\"><a href=\"#附件图片加载不全，中文附件下载空白\" class=\"headerlink\" title=\"附件图片加载不全，中文附件下载空白\"></a>附件图片加载不全，中文附件下载空白</h3><p>问题描述：<br>在浏览器，域名访问redmine系统，图片显示不全，中文附件下载后空白。琢磨老半天，上服务器查看了下，附件都已经上传到服务器，从服务器把对应的图片拉取下来后，用工具打开，正常。我去，那是啥子问题咧，开始以为是Redmine系统编码问题，各种百度，么用。后来在本地环境装个Redmine环境，直接访问，不经过Nginx，不存在显示不了图片的问题，尴尬咯。那就只有一种可能了，Nginx配置的问题了，似乎看到了光明……</p>\n<p>折腾了老半天，真他妈的是nginx的配置造成的。我去……     </p>\n<p>原来配置：</p>\n<pre><code>upstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n\nserver {\n    listen 80;\n    server_name pm.xcsqjr.com;\n    root /server/java/redmine/redmine-3.4.6/public;\n\n    location / {\n            try_files $uri @redmine;\n    }\n\n    location @redmine {\n            proxy_set_header  X-Forwarded-For $remote_addr;\n            proxy_pass http://redmine;\n    }\n}\n</code></pre><p>改为：</p>\n<p>在conf中新增文件夹<code>sites</code>并添加文件<code>proxy.include</code></p>\n<pre><code>proxy_set_header   Host $http_host;                                                                                                                     \nproxy_set_header   X-Real-IP $remote_addr;                                                                                                                   \nproxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header   X-Forwarded-Proto $scheme;\n\nclient_max_body_size       10m;\nclient_body_buffer_size    128k;\n\nproxy_connect_timeout      90;\nproxy_send_timeout         90;\nproxy_read_timeout         90;\n\nproxy_buffer_size          4k;\nproxy_buffers              4 32k;\nproxy_busy_buffers_size    64k;\nproxy_temp_file_write_size 64k;\n\n\nupstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n</code></pre><p>编辑配置：</p>\n<pre><code>server {\n    listen 80;\n    server_name pm.xcsqjr.com;\n    charset utf-8;\n    include sites/proxy.include;\n     root /server/java/redmine/redmine-3.4.6/public;\n    #proxy_redirect off; #加上这行跳转会有问题\n\n    location / {\n            try_files $uri @redmine;\n    }\n\n    location @redmine {\n            proxy_set_header  X-Forwarded-For $remote_addr;\n            proxy_pass http://redmine;\n    }\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"附件图片加载不全，中文附件下载空白\"><a href=\"#附件图片加载不全，中文附件下载空白\" class=\"headerlink\" title=\"附件图片加载不全，中文附件下载空白\"></a>附件图片加载不全，中文附件下载空白</h3><p>问题描述：<br>在浏览器，域名访问redmine系统，图片显示不全，中文附件下载后空白。琢磨老半天，上服务器查看了下，附件都已经上传到服务器，从服务器把对应的图片拉取下来后，用工具打开，正常。我去，那是啥子问题咧，开始以为是Redmine系统编码问题，各种百度，么用。后来在本地环境装个Redmine环境，直接访问，不经过Nginx，不存在显示不了图片的问题，尴尬咯。那就只有一种可能了，Nginx配置的问题了，似乎看到了光明……</p>\n<p>折腾了老半天，真他妈的是nginx的配置造成的。我去……     </p>\n<p>原来配置：</p>\n<pre><code>upstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n\nserver {\n    listen 80;\n    server_name pm.xcsqjr.com;\n    root /server/java/redmine/redmine-3.4.6/public;\n\n    location / {\n            try_files $uri @redmine;\n    }\n\n    location @redmine {\n            proxy_set_header  X-Forwarded-For $remote_addr;\n            proxy_pass http://redmine;\n    }\n}\n</code></pre><p>改为：</p>\n<p>在conf中新增文件夹<code>sites</code>并添加文件<code>proxy.include</code></p>\n<pre><code>proxy_set_header   Host $http_host;                                                                                                                     \nproxy_set_header   X-Real-IP $remote_addr;                                                                                                                   \nproxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;\nproxy_set_header   X-Forwarded-Proto $scheme;\n\nclient_max_body_size       10m;\nclient_body_buffer_size    128k;\n\nproxy_connect_timeout      90;\nproxy_send_timeout         90;\nproxy_read_timeout         90;\n\nproxy_buffer_size          4k;\nproxy_buffers              4 32k;\nproxy_busy_buffers_size    64k;\nproxy_temp_file_write_size 64k;\n\n\nupstream redmine {\n        server 127.0.0.1:8889;\n        #server 127.0.0.1:8001;\n        #server 127.0.0.1:8002;\n}\n</code></pre><p>编辑配置：</p>\n<pre><code>server {\n    listen 80;\n    server_name pm.xcsqjr.com;\n    charset utf-8;\n    include sites/proxy.include;\n     root /server/java/redmine/redmine-3.4.6/public;\n    #proxy_redirect off; #加上这行跳转会有问题\n\n    location / {\n            try_files $uri @redmine;\n    }\n\n    location @redmine {\n            proxy_set_header  X-Forwarded-For $remote_addr;\n            proxy_pass http://redmine;\n    }\n} \n</code></pre>"},{"title":"restful-api设计摘要","date":"2017-09-29T14:07:54.000Z","_content":"本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","source":"_posts/restful-api-dev.md","raw":"---\ntitle: restful-api设计摘要\ndate: 2017-09-29 22:07:54\ncategories: api-manage\ntags: restful-api\n---\n本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","slug":"restful-api-dev","published":1,"updated":"2018-11-09T01:20:30.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mr0079qcrgpasphrab","content":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"noopener\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"noopener\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"noopener\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"noopener\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"noopener\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"noopener\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n"},{"title":"rocketmq入门","date":"2018-08-13T07:34:20.000Z","_content":"\n官网：rocketmq.apache.org\n","source":"_posts/rocketmq-start.md","raw":"---\ntitle: rocketmq入门\ndate: 2018-08-13 15:34:20\ncategories: rocketmq\ntags: rocketmq入门\n---\n\n官网：rocketmq.apache.org\n","slug":"rocketmq-start","published":1,"updated":"2018-11-09T01:20:30.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38ms007cqcrg1mdsx40o","content":"<p>官网：rocketmq.apache.org</p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：rocketmq.apache.org</p>\n"},{"title":"spring-boot更改ContextPath方法","date":"2017-09-28T06:03:23.000Z","_content":"在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","source":"_posts/sboot-change-contextpath.md","raw":"---\ntitle: spring-boot更改ContextPath方法\ndate: 2017-09-28 14:03:23\ncategories: spring-boot\ntags: change-contextpath-way\n---\n在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","slug":"sboot-change-contextpath","published":1,"updated":"2018-11-09T01:20:30.342Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mt007eqcrgalr5s2an","content":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n"},{"title":"spring-cloud-feign在使用中遇到的一些问题","date":"2017-09-24T13:53:46.000Z","_content":"\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","source":"_posts/scloud-feign-anyquestion.md","raw":"---\ntitle: spring-cloud-feign在使用中遇到的一些问题\ndate: 2017-09-24 21:53:46\ncategories: spring-cloud\ntags: feign使用常见问题\n---\n\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","slug":"scloud-feign-anyquestion","published":1,"updated":"2018-11-09T01:20:30.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mu007hqcrgfozkgje0","content":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n"},{"title":"Spring cloud微服务：分布式配置中心-加密解密","date":"2018-04-21T14:22:30.000Z","_content":"\n在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。\n但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。\n\n\n## 安装JCE\n\n在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：\n\n    README.txt\n    local_policy.jar\n    US_export_policy.jar\n\n我们需要将local_policy.jar和US_export_policy.jar两个文件复制到`$JAVA_HOME/jre/lib/security`目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。\n\nJCE下载地址：[Java 8 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)\n\n## 查看相关端点\n\n安装后，重启config-server。可以通过浏览器查看一些相关信息：\n\n- /encrypt/status：查看加密功能状态的端点\n- /key：查看密钥的端点\n- /encrypt：对请求的body内容进行加密的端点\n- /decrypt：对请求的body内容进行解密的端点\n\n## 配置密钥\n\n### 对称加解密\n\n暂时不做介绍。推荐直接用下面非对称方式！\n\n### 非对称加解密\n\n使用非对称加解密具有更高安全性……\n\n- 使用JDK工具keytool生成密钥对。\n\n它的位置在： %JAVA_HOME%\\bin\\keytool.exe。\n\n使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：\n\n    keytool -genkeypair -alias config-server -keyalg RSA \\ \n      -dname \"CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china\" \\\n      -keypass 222222 \\\n      -keystore config-server.jks \\\n      -storepass 111111 \\\n      -validity 365 \\\n\n参考：\nhttp://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\n\n## 配置bootstrap.yml\n\n把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：\n\n    encrypt:\n      keyStore:\n        location: classpath:/config-server.jks\n        password: 11111\n        alias: config-server\n        secret: 222222\n\n*注*：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：\n\n    ENCRYPT_KEY_STORE_LOCATION\n    ENCRYPT_KEY_STORE_ALIAS\n    ENCRYPT_KEY_STORE_PASSWORD\n    ENCRYPT_KEY_STORE_SECRET\n    \n重新启动项目，浏览：http://192.168.1.104:3331/encrypt/status  \n\n    {\n        \"status\": \"OK\"\n    }\n    \n说明配置成功了。\n\n## 对配置加密\n\n先在命令窗口对具体配置明文进行加密,如：\n\n对明文zmt加密（认证用户名为admin、密码为123456）\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:ncrypt -d zmt\n    AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n    \n对密文解密：\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\n    zmt   \n    \n在配置文件中配置密文：\n\n通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。`{cipher}`代表是密文，需要解密。\n\n    api:\n      password: '{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io='\n\n调用显示：\n\n    @Value(\"${api.password}\")\n    private String apiPwd;\n\n    @Override\n    public VTestResp test3(@SensitiveFormat String name) {\n        VTestResp testResp = new VTestResp();\n        testResp.setName(name + \">>>>\" + apiPwd);\n        return testResp;\n    }\n    \n    结果：\n    {\n        \"name\": \"abc>>>>ymu123456\",\n        \"sex\": 0\n    }\n    \n## 对特殊字符加密问题\n\n参考：http://blog.didispace.com/spring-cloud-config-sp-char-encryp         ","source":"_posts/scloud-config-server-encrypt-decrypt.md","raw":"---\ntitle: Spring cloud微服务：分布式配置中心-加密解密\ndate: 2018-04-21 22:22:30\ncategories: spring-cloud\ntags: spring-cloud(配置中心加解密)\n---\n\n在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。\n但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。\n\n\n## 安装JCE\n\n在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：\n\n    README.txt\n    local_policy.jar\n    US_export_policy.jar\n\n我们需要将local_policy.jar和US_export_policy.jar两个文件复制到`$JAVA_HOME/jre/lib/security`目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。\n\nJCE下载地址：[Java 8 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)\n\n## 查看相关端点\n\n安装后，重启config-server。可以通过浏览器查看一些相关信息：\n\n- /encrypt/status：查看加密功能状态的端点\n- /key：查看密钥的端点\n- /encrypt：对请求的body内容进行加密的端点\n- /decrypt：对请求的body内容进行解密的端点\n\n## 配置密钥\n\n### 对称加解密\n\n暂时不做介绍。推荐直接用下面非对称方式！\n\n### 非对称加解密\n\n使用非对称加解密具有更高安全性……\n\n- 使用JDK工具keytool生成密钥对。\n\n它的位置在： %JAVA_HOME%\\bin\\keytool.exe。\n\n使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：\n\n    keytool -genkeypair -alias config-server -keyalg RSA \\ \n      -dname \"CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china\" \\\n      -keypass 222222 \\\n      -keystore config-server.jks \\\n      -storepass 111111 \\\n      -validity 365 \\\n\n参考：\nhttp://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\n\n## 配置bootstrap.yml\n\n把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：\n\n    encrypt:\n      keyStore:\n        location: classpath:/config-server.jks\n        password: 11111\n        alias: config-server\n        secret: 222222\n\n*注*：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：\n\n    ENCRYPT_KEY_STORE_LOCATION\n    ENCRYPT_KEY_STORE_ALIAS\n    ENCRYPT_KEY_STORE_PASSWORD\n    ENCRYPT_KEY_STORE_SECRET\n    \n重新启动项目，浏览：http://192.168.1.104:3331/encrypt/status  \n\n    {\n        \"status\": \"OK\"\n    }\n    \n说明配置成功了。\n\n## 对配置加密\n\n先在命令窗口对具体配置明文进行加密,如：\n\n对明文zmt加密（认证用户名为admin、密码为123456）\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:ncrypt -d zmt\n    AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n    \n对密文解密：\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\n    zmt   \n    \n在配置文件中配置密文：\n\n通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。`{cipher}`代表是密文，需要解密。\n\n    api:\n      password: '{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io='\n\n调用显示：\n\n    @Value(\"${api.password}\")\n    private String apiPwd;\n\n    @Override\n    public VTestResp test3(@SensitiveFormat String name) {\n        VTestResp testResp = new VTestResp();\n        testResp.setName(name + \">>>>\" + apiPwd);\n        return testResp;\n    }\n    \n    结果：\n    {\n        \"name\": \"abc>>>>ymu123456\",\n        \"sex\": 0\n    }\n    \n## 对特殊字符加密问题\n\n参考：http://blog.didispace.com/spring-cloud-config-sp-char-encryp         ","slug":"scloud-config-server-encrypt-decrypt","published":1,"updated":"2018-11-09T01:20:30.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mv007lqcrgszga76y1","content":"<p>在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。<br>但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。</p>\n<h2 id=\"安装JCE\"><a href=\"#安装JCE\" class=\"headerlink\" title=\"安装JCE\"></a>安装JCE</h2><p>在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：</p>\n<pre><code>README.txt\nlocal_policy.jar\nUS_export_policy.jar\n</code></pre><p>我们需要将local_policy.jar和US_export_policy.jar两个文件复制到<code>$JAVA_HOME/jre/lib/security</code>目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。</p>\n<p>JCE下载地址：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html\" target=\"_blank\" rel=\"noopener\">Java 8 JCE</a></p>\n<h2 id=\"查看相关端点\"><a href=\"#查看相关端点\" class=\"headerlink\" title=\"查看相关端点\"></a>查看相关端点</h2><p>安装后，重启config-server。可以通过浏览器查看一些相关信息：</p>\n<ul>\n<li>/encrypt/status：查看加密功能状态的端点</li>\n<li>/key：查看密钥的端点</li>\n<li>/encrypt：对请求的body内容进行加密的端点</li>\n<li>/decrypt：对请求的body内容进行解密的端点</li>\n</ul>\n<h2 id=\"配置密钥\"><a href=\"#配置密钥\" class=\"headerlink\" title=\"配置密钥\"></a>配置密钥</h2><h3 id=\"对称加解密\"><a href=\"#对称加解密\" class=\"headerlink\" title=\"对称加解密\"></a>对称加解密</h3><p>暂时不做介绍。推荐直接用下面非对称方式！</p>\n<h3 id=\"非对称加解密\"><a href=\"#非对称加解密\" class=\"headerlink\" title=\"非对称加解密\"></a>非对称加解密</h3><p>使用非对称加解密具有更高安全性……</p>\n<ul>\n<li>使用JDK工具keytool生成密钥对。</li>\n</ul>\n<p>它的位置在： %JAVA_HOME%\\bin\\keytool.exe。</p>\n<p>使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：</p>\n<pre><code>keytool -genkeypair -alias config-server -keyalg RSA \\ \n  -dname &quot;CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china&quot; \\\n  -keypass 222222 \\\n  -keystore config-server.jks \\\n  -storepass 111111 \\\n  -validity 365 \\\n</code></pre><p>参考：<br><a href=\"http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\" target=\"_blank\" rel=\"noopener\">http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing</a></p>\n<h2 id=\"配置bootstrap-yml\"><a href=\"#配置bootstrap-yml\" class=\"headerlink\" title=\"配置bootstrap.yml\"></a>配置bootstrap.yml</h2><p>把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：</p>\n<pre><code>encrypt:\n  keyStore:\n    location: classpath:/config-server.jks\n    password: 11111\n    alias: config-server\n    secret: 222222\n</code></pre><p><em>注</em>：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：</p>\n<pre><code>ENCRYPT_KEY_STORE_LOCATION\nENCRYPT_KEY_STORE_ALIAS\nENCRYPT_KEY_STORE_PASSWORD\nENCRYPT_KEY_STORE_SECRET\n</code></pre><p>重新启动项目，浏览：<a href=\"http://192.168.1.104:3331/encrypt/status\" target=\"_blank\" rel=\"noopener\">http://192.168.1.104:3331/encrypt/status</a>  </p>\n<pre><code>{\n    &quot;status&quot;: &quot;OK&quot;\n}\n</code></pre><p>说明配置成功了。</p>\n<h2 id=\"对配置加密\"><a href=\"#对配置加密\" class=\"headerlink\" title=\"对配置加密\"></a>对配置加密</h2><p>先在命令窗口对具体配置明文进行加密,如：</p>\n<p>对明文zmt加密（认证用户名为admin、密码为123456）</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:ncrypt -d zmt\nAQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n</code></pre><p>对密文解密：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\nzmt   \n</code></pre><p>在配置文件中配置密文：</p>\n<p>通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。<code>{cipher}</code>代表是密文，需要解密。</p>\n<pre><code>api:\n  password: &apos;{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io=&apos;\n</code></pre><p>调用显示：</p>\n<pre><code>@Value(&quot;${api.password}&quot;)\nprivate String apiPwd;\n\n@Override\npublic VTestResp test3(@SensitiveFormat String name) {\n    VTestResp testResp = new VTestResp();\n    testResp.setName(name + &quot;&gt;&gt;&gt;&gt;&quot; + apiPwd);\n    return testResp;\n}\n\n结果：\n{\n    &quot;name&quot;: &quot;abc&gt;&gt;&gt;&gt;ymu123456&quot;,\n    &quot;sex&quot;: 0\n}\n</code></pre><h2 id=\"对特殊字符加密问题\"><a href=\"#对特殊字符加密问题\" class=\"headerlink\" title=\"对特殊字符加密问题\"></a>对特殊字符加密问题</h2><p>参考：<a href=\"http://blog.didispace.com/spring-cloud-config-sp-char-encryp\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/spring-cloud-config-sp-char-encryp</a>         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。<br>但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。</p>\n<h2 id=\"安装JCE\"><a href=\"#安装JCE\" class=\"headerlink\" title=\"安装JCE\"></a>安装JCE</h2><p>在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：</p>\n<pre><code>README.txt\nlocal_policy.jar\nUS_export_policy.jar\n</code></pre><p>我们需要将local_policy.jar和US_export_policy.jar两个文件复制到<code>$JAVA_HOME/jre/lib/security</code>目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。</p>\n<p>JCE下载地址：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html\" target=\"_blank\" rel=\"noopener\">Java 8 JCE</a></p>\n<h2 id=\"查看相关端点\"><a href=\"#查看相关端点\" class=\"headerlink\" title=\"查看相关端点\"></a>查看相关端点</h2><p>安装后，重启config-server。可以通过浏览器查看一些相关信息：</p>\n<ul>\n<li>/encrypt/status：查看加密功能状态的端点</li>\n<li>/key：查看密钥的端点</li>\n<li>/encrypt：对请求的body内容进行加密的端点</li>\n<li>/decrypt：对请求的body内容进行解密的端点</li>\n</ul>\n<h2 id=\"配置密钥\"><a href=\"#配置密钥\" class=\"headerlink\" title=\"配置密钥\"></a>配置密钥</h2><h3 id=\"对称加解密\"><a href=\"#对称加解密\" class=\"headerlink\" title=\"对称加解密\"></a>对称加解密</h3><p>暂时不做介绍。推荐直接用下面非对称方式！</p>\n<h3 id=\"非对称加解密\"><a href=\"#非对称加解密\" class=\"headerlink\" title=\"非对称加解密\"></a>非对称加解密</h3><p>使用非对称加解密具有更高安全性……</p>\n<ul>\n<li>使用JDK工具keytool生成密钥对。</li>\n</ul>\n<p>它的位置在： %JAVA_HOME%\\bin\\keytool.exe。</p>\n<p>使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：</p>\n<pre><code>keytool -genkeypair -alias config-server -keyalg RSA \\ \n  -dname &quot;CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china&quot; \\\n  -keypass 222222 \\\n  -keystore config-server.jks \\\n  -storepass 111111 \\\n  -validity 365 \\\n</code></pre><p>参考：<br><a href=\"http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\" target=\"_blank\" rel=\"noopener\">http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing</a></p>\n<h2 id=\"配置bootstrap-yml\"><a href=\"#配置bootstrap-yml\" class=\"headerlink\" title=\"配置bootstrap.yml\"></a>配置bootstrap.yml</h2><p>把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：</p>\n<pre><code>encrypt:\n  keyStore:\n    location: classpath:/config-server.jks\n    password: 11111\n    alias: config-server\n    secret: 222222\n</code></pre><p><em>注</em>：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：</p>\n<pre><code>ENCRYPT_KEY_STORE_LOCATION\nENCRYPT_KEY_STORE_ALIAS\nENCRYPT_KEY_STORE_PASSWORD\nENCRYPT_KEY_STORE_SECRET\n</code></pre><p>重新启动项目，浏览：<a href=\"http://192.168.1.104:3331/encrypt/status\" target=\"_blank\" rel=\"noopener\">http://192.168.1.104:3331/encrypt/status</a>  </p>\n<pre><code>{\n    &quot;status&quot;: &quot;OK&quot;\n}\n</code></pre><p>说明配置成功了。</p>\n<h2 id=\"对配置加密\"><a href=\"#对配置加密\" class=\"headerlink\" title=\"对配置加密\"></a>对配置加密</h2><p>先在命令窗口对具体配置明文进行加密,如：</p>\n<p>对明文zmt加密（认证用户名为admin、密码为123456）</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:ncrypt -d zmt\nAQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n</code></pre><p>对密文解密：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\nzmt   \n</code></pre><p>在配置文件中配置密文：</p>\n<p>通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。<code>{cipher}</code>代表是密文，需要解密。</p>\n<pre><code>api:\n  password: &apos;{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io=&apos;\n</code></pre><p>调用显示：</p>\n<pre><code>@Value(&quot;${api.password}&quot;)\nprivate String apiPwd;\n\n@Override\npublic VTestResp test3(@SensitiveFormat String name) {\n    VTestResp testResp = new VTestResp();\n    testResp.setName(name + &quot;&gt;&gt;&gt;&gt;&quot; + apiPwd);\n    return testResp;\n}\n\n结果：\n{\n    &quot;name&quot;: &quot;abc&gt;&gt;&gt;&gt;ymu123456&quot;,\n    &quot;sex&quot;: 0\n}\n</code></pre><h2 id=\"对特殊字符加密问题\"><a href=\"#对特殊字符加密问题\" class=\"headerlink\" title=\"对特殊字符加密问题\"></a>对特殊字符加密问题</h2><p>参考：<a href=\"http://blog.didispace.com/spring-cloud-config-sp-char-encryp\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/spring-cloud-config-sp-char-encryp</a>         </p>\n"},{"title":"spring cloud feign自定义","date":"2018-05-08T12:36:02.000Z","_content":"\n参考：https://www.jianshu.com/p/755b15ff0249","source":"_posts/scloud-feign-config.md","raw":"---\ntitle: spring cloud feign自定义\ndate: 2018-05-08 20:36:02\ncategories: spring-cloud\ntags: feign\n---\n\n参考：https://www.jianshu.com/p/755b15ff0249","slug":"scloud-feign-config","published":1,"updated":"2018-11-09T01:20:30.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mw007nqcrgreu51mhn","content":"<p>参考：<a href=\"https://www.jianshu.com/p/755b15ff0249\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/755b15ff0249</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://www.jianshu.com/p/755b15ff0249\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/755b15ff0249</a></p>\n"},{"title":"spring cloud Hystrix监控","date":"2018-05-08T07:30:31.000Z","_content":"\n参考：https://www.jianshu.com/p/b7b20fc09ca9\n\nhttps://blog.csdn.net/liaokailin/article/details/51344281\n\n\n## 单个节点监控\n\n\n## 聚合监控","source":"_posts/scloud-hystrix-dashboard.md","raw":"---\ntitle: spring cloud Hystrix监控\ndate: 2018-05-08 15:30:31\ncategories: spring-cloud\ntags: hystrix,dashboard\n---\n\n参考：https://www.jianshu.com/p/b7b20fc09ca9\n\nhttps://blog.csdn.net/liaokailin/article/details/51344281\n\n\n## 单个节点监控\n\n\n## 聚合监控","slug":"scloud-hystrix-dashboard","published":1,"updated":"2018-11-09T01:20:30.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38my007rqcrg5iunx1ho","content":"<p>参考：<a href=\"https://www.jianshu.com/p/b7b20fc09ca9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b7b20fc09ca9</a></p>\n<p><a href=\"https://blog.csdn.net/liaokailin/article/details/51344281\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liaokailin/article/details/51344281</a></p>\n<h2 id=\"单个节点监控\"><a href=\"#单个节点监控\" class=\"headerlink\" title=\"单个节点监控\"></a>单个节点监控</h2><h2 id=\"聚合监控\"><a href=\"#聚合监控\" class=\"headerlink\" title=\"聚合监控\"></a>聚合监控</h2>","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://www.jianshu.com/p/b7b20fc09ca9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b7b20fc09ca9</a></p>\n<p><a href=\"https://blog.csdn.net/liaokailin/article/details/51344281\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liaokailin/article/details/51344281</a></p>\n<h2 id=\"单个节点监控\"><a href=\"#单个节点监控\" class=\"headerlink\" title=\"单个节点监控\"></a>单个节点监控</h2><h2 id=\"聚合监控\"><a href=\"#聚合监控\" class=\"headerlink\" title=\"聚合监控\"></a>聚合监控</h2>"},{"title":"spring cloud 熔断器,服务降级","date":"2018-05-08T03:21:35.000Z","_content":"\n## ","source":"_posts/scloud-hystrix.md","raw":"---\ntitle: spring cloud 熔断器,服务降级\ndate: 2018-05-08 11:21:35\ncategories: spring-cloud\ntags: hystrix\n---\n\n## ","slug":"scloud-hystrix","published":1,"updated":"2018-11-09T01:20:30.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38mz007tqcrgkns8r0qm","content":"<p>## </p>\n","site":{"data":{}},"excerpt":"","more":"<p>## </p>\n"},{"title":"spring-cloud-zuul网关统一异常处理","date":"2017-09-23T09:48:05.000Z","_content":"","source":"_posts/scloud-zuul-exception.md","raw":"---\ntitle: spring-cloud-zuul网关统一异常处理\ndate: 2017-09-23 17:48:05\ncategories: spring-cloud\ntags: zuul-exception\n---\n","slug":"scloud-zuul-exception","published":1,"updated":"2018-11-09T01:20:30.358Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38n1007wqcrgzpgb7xzd","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"scloud-zuul-filters网关过滤","date":"2017-10-11T08:56:22.000Z","_content":"在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","source":"_posts/scloud-zuul-filters.md","raw":"---\ntitle: scloud-zuul-filters网关过滤\ndate: 2017-10-11 16:56:22\ncategories: spring-cloud\ntags: zuul-filters\n---\n在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","slug":"scloud-zuul-filters","published":1,"updated":"2018-11-09T01:20:30.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38n2007zqcrgycz5goml","content":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n"},{"title":"spring-cloud-zuul网关入门","date":"2017-10-11T07:42:53.000Z","_content":"## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","source":"_posts/scloud-zuul-start.md","raw":"---\ntitle: spring-cloud-zuul网关入门\ndate: 2017-10-11 15:42:53\ncategories: spring-cloud\ntags: zuul-start\n---\n## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","slug":"scloud-zuul-start","published":1,"updated":"2018-11-09T01:20:30.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38n30082qcrgpaaq6si0","content":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>"},{"title":"shadowsocks-go代理服务器搭建","date":"2017-11-11T09:05:31.000Z","_content":"\n这是用来干嘛的，你懂的。\n\n网址：\n\n[shadowsocks](https://github.com/shadowsocks)\n\n[sadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)\n\n## 服务端\n\n编译好执行文件：{% asset_link server.tar.gz Shadowsocks-server %}  \n放到服务器，更改.json文件配置，解压直接执行.sh文件即可。\n\n1. 首先，买个国外的服务器再说吧……\n   \n2. 在服务器安装golang环境。\n    安装包：{% asset_link go1.9.2.linux-amd64.tar.gz go1.9.2 %}\n    \n    这里不做介绍……\n    \n3. 在服务器安装git环境。\n\n    这里不做介绍……\n    \n4. 下载服务端代码shadowsocks-go.\n\n        # on server\n        go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n    \n    golang环境会自动编译可执行代码到${GOPATH}/bin  \n      \n5.  执行启动\n\n- *创建配置文件*：\n`touch /server/shadowsocks/shadowsocks.json`\n- *编辑shadowsocks.json*：\n    \n        {\t \n            \"server\":\"30.12.6.2\",\n            \"server_port\":8388,\n            \"local_port\":1080,\n            \"password\":\"123456\",\n            \"method\": \"aes-256-cfb\",\n            \"timeout\":600\n        }\n\n> 说明：       \n`server`:服务器ip地址；\n`server_port`:服务器端口；\n`local_port:`客户端代理端口；\n`method`:加密方式； \n\n- *启动*:\n\n\n    shadowsocks-server -c /server/shadowsocks/shadowsocks.json > /server/shadowsocks/log &.   \n    \n> 说明：\n`-c` 指定配置文件。 \n`log`记录日志。\n`&.` 后台执行    \n\n- *查看是否启动*：\n\n        [root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\n        tcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n\n\n---\n\n## 客户端\n\n### linux系统\n编译好执行文件：{% asset_link client.tar.gz Shadowsocks-client %} \n在linux客户端解压，修改.json配置文件中相关参数，启动即可。\n\n### windows系统\n直接下载客户端。[网址](https://github.com/shadowsocks/shadowsocks-windows)\n安装包：{% asset_link Shadowsocks-4.0.6.zip Shadowsocks-win %}\n双击打开：\n{% asset_img a.png %}\n\n把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。\n\n### ubuntu系统    \n\n- go客户端：\n`go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local`\n由于被墙，客户端下载不了。\n所以要在服务端执行，然后再把可执行二进制文件下拉到本地。\n\n*配置客户端文件*\n创建文件：shadowsocks-local.json\n编辑：\n    \n    {\n    \t\"local_port\": 1081,\n    \t\"server_password\": [\n    \t\t[\"127.0.0.1:8387\", \"foobar\"],\n    \t\t[\"127.0.0.1:8388\", \"barfoo\", \"aes-128-cfb\"]\n    \t]\n    }\n\n可以配置多个服务器，单个服务器，则去掉一个。\n\n启动：类似服务端，用`-c`指定配置文件。    \n\n- qt5客户端：\n\n1. 二进制包安装。[安装网址](https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)  \n\n2. 推荐，命令安装：\n    \n        #Ubuntu 14.04及更高版本\n        #添加ppa源\n        sudo add-apt-repository ppa:hzwhuang/ss-qt5\n        sudo apt-get update\n        sudo apt-get install shadowsocks-qt5\n         \n        #启动shadowsocks-qt5\n        \n        可以通过which shadowsocks-qt5找到可执行文件的位置。\n        \n        执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n\n### 移动\n\n- 安卓客户端：\n\n下载：{%asset_link Shadowsocks_v4.2.5_apkpure.com.apk Shadowsocks_v4.2.5_apkpure.com.apk%}\n\n- 苹果客户端：\n\n安装app：FirstWingy\n\n### 修改浏览器代理\n> SOCKS5 127.0.0.1:local_port\n\n如果可以，在chrome中可以安装代理设置插件       \n{% asset_img b.png %}\n\n然后启动，试下访问：[google](https://www.google.com)\n\n\n\n### linux下全局代理\n\n实验环境：Ubuntu系统\n\n1.安装应用`privoxy`\n\n一款工具，将socks代理转换成http。\n\n`sudo apt-get install privoxy`\n\n2.更改配置\n\n    sudo gedit /etc/privoxy/config\n    \n    ----------------------------------------------------------------\n\n    # 在 froward-socks4下面添加一条socks5的，因为shadowsocks为socks5，\n    # 地址是127.0.0.1:1080。注意他们最后有一个“.”\n    #        forward-socks4   /               socks-gw.example.com:1080  .\n    forward-socks5   /               127.0.0.1:1080 .\n    \n    # 下面还存在以下一条配置，表示privoxy监听本机8118端口，\n    # 把它作为http代理，代理地址为 http://localhost.8118/ 。\n    # 可以把地址改为 0.0.0.0:8118，表示外网也可以通过本机IP作http代理。\n    # 这样，你的外网IP为1.2.3.4，别人就可以设置 http://1.2.3.4:8118/ 为http代理。\n    　listen-address localhost:8118  #端口可以随意设定\n    \n    上面配置可能导致无法启动privoxy,新版本安全问题导致。改为：   \n    listen-address 192.168.1.115:8118  #端口可以随意设定  \n\n3.重启privoxy\n\n    sudo systemctl restart privoxy.serivce\n    \n4.添加环境变量\n\n    vim ~/.bashrc\n    \n    ----\n    添加两行：\n    export http_proxy=http://127.0.0.1:8118/\n    export https_proxy=http://127.0.0.1:8118/  \n    \n5.使环境变量立即生效\n\n    source ~/.bashrc\n    \n说明：如果只是想临时的让当前命令窗口代理，那么只需要添加临时变量，不需要编辑~/.bashrc。  \n只需要在当前命令窗口执行`export http_proxy=http://127.0.0.1:8118/` ` export https_proxy=http://127.0.0.1:8118/ `         ","source":"_posts/shadowsocks-go.md","raw":"---\ntitle: shadowsocks-go代理服务器搭建\ndate: 2017-11-11 17:05:31\ncategories: shadowsocks\ntags: shadowsocks-go\n---\n\n这是用来干嘛的，你懂的。\n\n网址：\n\n[shadowsocks](https://github.com/shadowsocks)\n\n[sadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)\n\n## 服务端\n\n编译好执行文件：{% asset_link server.tar.gz Shadowsocks-server %}  \n放到服务器，更改.json文件配置，解压直接执行.sh文件即可。\n\n1. 首先，买个国外的服务器再说吧……\n   \n2. 在服务器安装golang环境。\n    安装包：{% asset_link go1.9.2.linux-amd64.tar.gz go1.9.2 %}\n    \n    这里不做介绍……\n    \n3. 在服务器安装git环境。\n\n    这里不做介绍……\n    \n4. 下载服务端代码shadowsocks-go.\n\n        # on server\n        go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n    \n    golang环境会自动编译可执行代码到${GOPATH}/bin  \n      \n5.  执行启动\n\n- *创建配置文件*：\n`touch /server/shadowsocks/shadowsocks.json`\n- *编辑shadowsocks.json*：\n    \n        {\t \n            \"server\":\"30.12.6.2\",\n            \"server_port\":8388,\n            \"local_port\":1080,\n            \"password\":\"123456\",\n            \"method\": \"aes-256-cfb\",\n            \"timeout\":600\n        }\n\n> 说明：       \n`server`:服务器ip地址；\n`server_port`:服务器端口；\n`local_port:`客户端代理端口；\n`method`:加密方式； \n\n- *启动*:\n\n\n    shadowsocks-server -c /server/shadowsocks/shadowsocks.json > /server/shadowsocks/log &.   \n    \n> 说明：\n`-c` 指定配置文件。 \n`log`记录日志。\n`&.` 后台执行    \n\n- *查看是否启动*：\n\n        [root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\n        tcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n\n\n---\n\n## 客户端\n\n### linux系统\n编译好执行文件：{% asset_link client.tar.gz Shadowsocks-client %} \n在linux客户端解压，修改.json配置文件中相关参数，启动即可。\n\n### windows系统\n直接下载客户端。[网址](https://github.com/shadowsocks/shadowsocks-windows)\n安装包：{% asset_link Shadowsocks-4.0.6.zip Shadowsocks-win %}\n双击打开：\n{% asset_img a.png %}\n\n把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。\n\n### ubuntu系统    \n\n- go客户端：\n`go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local`\n由于被墙，客户端下载不了。\n所以要在服务端执行，然后再把可执行二进制文件下拉到本地。\n\n*配置客户端文件*\n创建文件：shadowsocks-local.json\n编辑：\n    \n    {\n    \t\"local_port\": 1081,\n    \t\"server_password\": [\n    \t\t[\"127.0.0.1:8387\", \"foobar\"],\n    \t\t[\"127.0.0.1:8388\", \"barfoo\", \"aes-128-cfb\"]\n    \t]\n    }\n\n可以配置多个服务器，单个服务器，则去掉一个。\n\n启动：类似服务端，用`-c`指定配置文件。    \n\n- qt5客户端：\n\n1. 二进制包安装。[安装网址](https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)  \n\n2. 推荐，命令安装：\n    \n        #Ubuntu 14.04及更高版本\n        #添加ppa源\n        sudo add-apt-repository ppa:hzwhuang/ss-qt5\n        sudo apt-get update\n        sudo apt-get install shadowsocks-qt5\n         \n        #启动shadowsocks-qt5\n        \n        可以通过which shadowsocks-qt5找到可执行文件的位置。\n        \n        执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n\n### 移动\n\n- 安卓客户端：\n\n下载：{%asset_link Shadowsocks_v4.2.5_apkpure.com.apk Shadowsocks_v4.2.5_apkpure.com.apk%}\n\n- 苹果客户端：\n\n安装app：FirstWingy\n\n### 修改浏览器代理\n> SOCKS5 127.0.0.1:local_port\n\n如果可以，在chrome中可以安装代理设置插件       \n{% asset_img b.png %}\n\n然后启动，试下访问：[google](https://www.google.com)\n\n\n\n### linux下全局代理\n\n实验环境：Ubuntu系统\n\n1.安装应用`privoxy`\n\n一款工具，将socks代理转换成http。\n\n`sudo apt-get install privoxy`\n\n2.更改配置\n\n    sudo gedit /etc/privoxy/config\n    \n    ----------------------------------------------------------------\n\n    # 在 froward-socks4下面添加一条socks5的，因为shadowsocks为socks5，\n    # 地址是127.0.0.1:1080。注意他们最后有一个“.”\n    #        forward-socks4   /               socks-gw.example.com:1080  .\n    forward-socks5   /               127.0.0.1:1080 .\n    \n    # 下面还存在以下一条配置，表示privoxy监听本机8118端口，\n    # 把它作为http代理，代理地址为 http://localhost.8118/ 。\n    # 可以把地址改为 0.0.0.0:8118，表示外网也可以通过本机IP作http代理。\n    # 这样，你的外网IP为1.2.3.4，别人就可以设置 http://1.2.3.4:8118/ 为http代理。\n    　listen-address localhost:8118  #端口可以随意设定\n    \n    上面配置可能导致无法启动privoxy,新版本安全问题导致。改为：   \n    listen-address 192.168.1.115:8118  #端口可以随意设定  \n\n3.重启privoxy\n\n    sudo systemctl restart privoxy.serivce\n    \n4.添加环境变量\n\n    vim ~/.bashrc\n    \n    ----\n    添加两行：\n    export http_proxy=http://127.0.0.1:8118/\n    export https_proxy=http://127.0.0.1:8118/  \n    \n5.使环境变量立即生效\n\n    source ~/.bashrc\n    \n说明：如果只是想临时的让当前命令窗口代理，那么只需要添加临时变量，不需要编辑~/.bashrc。  \n只需要在当前命令窗口执行`export http_proxy=http://127.0.0.1:8118/` ` export https_proxy=http://127.0.0.1:8118/ `         ","slug":"shadowsocks-go","published":1,"updated":"2018-11-09T01:20:30.374Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38n40084qcrgg8j0l8qt","content":"<p>这是用来干嘛的，你懂的。</p>\n<p>网址：</p>\n<p><a href=\"https://github.com/shadowsocks\" target=\"_blank\" rel=\"noopener\">shadowsocks</a></p>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">sadowsocks-go</a></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/server.tar.gz\" title=\"Shadowsocks-server\">Shadowsocks-server</a><br>放到服务器，更改.json文件配置，解压直接执行.sh文件即可。</p>\n<ol>\n<li><p>首先，买个国外的服务器再说吧……</p>\n</li>\n<li><p>在服务器安装golang环境。<br> 安装包：<a href=\"/2017/11/11/shadowsocks-go/go1.9.2.linux-amd64.tar.gz\" title=\"go1.9.2\">go1.9.2</a></p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>在服务器安装git环境。</p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>下载服务端代码shadowsocks-go.</p>\n<pre><code># on server\ngo get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n</code></pre><p> golang环境会自动编译可执行代码到${GOPATH}/bin  </p>\n</li>\n<li><p>执行启动</p>\n</li>\n</ol>\n<ul>\n<li><em>创建配置文件</em>：<br><code>touch /server/shadowsocks/shadowsocks.json</code></li>\n<li><p><em>编辑shadowsocks.json</em>：</p>\n<pre><code>{     \n    &quot;server&quot;:&quot;30.12.6.2&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;method&quot;: &quot;aes-256-cfb&quot;,\n    &quot;timeout&quot;:600\n}\n</code></pre></li>\n</ul>\n<blockquote>\n<p>说明：<br><code>server</code>:服务器ip地址；<br><code>server_port</code>:服务器端口；<br><code>local_port:</code>客户端代理端口；<br><code>method</code>:加密方式； </p>\n</blockquote>\n<ul>\n<li><em>启动</em>:</li>\n</ul>\n<pre><code>shadowsocks-server -c /server/shadowsocks/shadowsocks.json &gt; /server/shadowsocks/log &amp;.   \n</code></pre><blockquote>\n<p>说明：<br><code>-c</code> 指定配置文件。<br><code>log</code>记录日志。<br><code>&amp;.</code> 后台执行    </p>\n</blockquote>\n<ul>\n<li><p><em>查看是否启动</em>：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\ntcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h3><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/client.tar.gz\" title=\"Shadowsocks-client\">Shadowsocks-client</a><br>在linux客户端解压，修改.json配置文件中相关参数，启动即可。</p>\n<h3 id=\"windows系统\"><a href=\"#windows系统\" class=\"headerlink\" title=\"windows系统\"></a>windows系统</h3><p>直接下载客户端。<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">网址</a><br>安装包：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks-4.0.6.zip\" title=\"Shadowsocks-win\">Shadowsocks-win</a><br>双击打开：<br><img src=\"/2017/11/11/shadowsocks-go/a.png\"></p>\n<p>把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。</p>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><ul>\n<li>go客户端：<br><code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</code><br>由于被墙，客户端下载不了。<br>所以要在服务端执行，然后再把可执行二进制文件下拉到本地。</li>\n</ul>\n<p><em>配置客户端文件</em><br>创建文件：shadowsocks-local.json<br>编辑：</p>\n<pre><code>{\n    &quot;local_port&quot;: 1081,\n    &quot;server_password&quot;: [\n        [&quot;127.0.0.1:8387&quot;, &quot;foobar&quot;],\n        [&quot;127.0.0.1:8388&quot;, &quot;barfoo&quot;, &quot;aes-128-cfb&quot;]\n    ]\n}\n</code></pre><p>可以配置多个服务器，单个服务器，则去掉一个。</p>\n<p>启动：类似服务端，用<code>-c</code>指定配置文件。    </p>\n<ul>\n<li>qt5客户端：</li>\n</ul>\n<ol>\n<li><p>二进制包安装。<a href=\"https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"noopener\">安装网址</a>  </p>\n</li>\n<li><p>推荐，命令安装：</p>\n<pre><code>#Ubuntu 14.04及更高版本\n#添加ppa源\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n\n#启动shadowsocks-qt5\n\n可以通过which shadowsocks-qt5找到可执行文件的位置。\n\n执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n</code></pre></li>\n</ol>\n<h3 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h3><ul>\n<li>安卓客户端：</li>\n</ul>\n<p>下载：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk\" title=\"Shadowsocks_v4.2.5_apkpure.com.apk\">Shadowsocks_v4.2.5_apkpure.com.apk</a></p>\n<ul>\n<li>苹果客户端：</li>\n</ul>\n<p>安装app：FirstWingy</p>\n<h3 id=\"修改浏览器代理\"><a href=\"#修改浏览器代理\" class=\"headerlink\" title=\"修改浏览器代理\"></a>修改浏览器代理</h3><blockquote>\n<p>SOCKS5 127.0.0.1:local_port</p>\n</blockquote>\n<p>如果可以，在chrome中可以安装代理设置插件<br><img src=\"/2017/11/11/shadowsocks-go/b.png\"></p>\n<p>然后启动，试下访问：<a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">google</a></p>\n<h3 id=\"linux下全局代理\"><a href=\"#linux下全局代理\" class=\"headerlink\" title=\"linux下全局代理\"></a>linux下全局代理</h3><p>实验环境：Ubuntu系统</p>\n<p>1.安装应用<code>privoxy</code></p>\n<p>一款工具，将socks代理转换成http。</p>\n<p><code>sudo apt-get install privoxy</code></p>\n<p>2.更改配置</p>\n<pre><code>sudo gedit /etc/privoxy/config\n\n----------------------------------------------------------------\n\n# 在 froward-socks4下面添加一条socks5的，因为shadowsocks为socks5，\n# 地址是127.0.0.1:1080。注意他们最后有一个“.”\n#        forward-socks4   /               socks-gw.example.com:1080  .\nforward-socks5   /               127.0.0.1:1080 .\n\n# 下面还存在以下一条配置，表示privoxy监听本机8118端口，\n# 把它作为http代理，代理地址为 http://localhost.8118/ 。\n# 可以把地址改为 0.0.0.0:8118，表示外网也可以通过本机IP作http代理。\n# 这样，你的外网IP为1.2.3.4，别人就可以设置 http://1.2.3.4:8118/ 为http代理。\n　listen-address localhost:8118  #端口可以随意设定\n\n上面配置可能导致无法启动privoxy,新版本安全问题导致。改为：   \nlisten-address 192.168.1.115:8118  #端口可以随意设定  \n</code></pre><p>3.重启privoxy</p>\n<pre><code>sudo systemctl restart privoxy.serivce\n</code></pre><p>4.添加环境变量</p>\n<pre><code>vim ~/.bashrc\n\n----\n添加两行：\nexport http_proxy=http://127.0.0.1:8118/\nexport https_proxy=http://127.0.0.1:8118/  \n</code></pre><p>5.使环境变量立即生效</p>\n<pre><code>source ~/.bashrc\n</code></pre><p>说明：如果只是想临时的让当前命令窗口代理，那么只需要添加临时变量，不需要编辑~/.bashrc。<br>只需要在当前命令窗口执行<code>export http_proxy=http://127.0.0.1:8118/</code> <code>export https_proxy=http://127.0.0.1:8118/</code>         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是用来干嘛的，你懂的。</p>\n<p>网址：</p>\n<p><a href=\"https://github.com/shadowsocks\" target=\"_blank\" rel=\"noopener\">shadowsocks</a></p>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">sadowsocks-go</a></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/server.tar.gz\" title=\"Shadowsocks-server\">Shadowsocks-server</a><br>放到服务器，更改.json文件配置，解压直接执行.sh文件即可。</p>\n<ol>\n<li><p>首先，买个国外的服务器再说吧……</p>\n</li>\n<li><p>在服务器安装golang环境。<br> 安装包：<a href=\"/2017/11/11/shadowsocks-go/go1.9.2.linux-amd64.tar.gz\" title=\"go1.9.2\">go1.9.2</a></p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>在服务器安装git环境。</p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>下载服务端代码shadowsocks-go.</p>\n<pre><code># on server\ngo get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n</code></pre><p> golang环境会自动编译可执行代码到${GOPATH}/bin  </p>\n</li>\n<li><p>执行启动</p>\n</li>\n</ol>\n<ul>\n<li><em>创建配置文件</em>：<br><code>touch /server/shadowsocks/shadowsocks.json</code></li>\n<li><p><em>编辑shadowsocks.json</em>：</p>\n<pre><code>{     \n    &quot;server&quot;:&quot;30.12.6.2&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;method&quot;: &quot;aes-256-cfb&quot;,\n    &quot;timeout&quot;:600\n}\n</code></pre></li>\n</ul>\n<blockquote>\n<p>说明：<br><code>server</code>:服务器ip地址；<br><code>server_port</code>:服务器端口；<br><code>local_port:</code>客户端代理端口；<br><code>method</code>:加密方式； </p>\n</blockquote>\n<ul>\n<li><em>启动</em>:</li>\n</ul>\n<pre><code>shadowsocks-server -c /server/shadowsocks/shadowsocks.json &gt; /server/shadowsocks/log &amp;.   \n</code></pre><blockquote>\n<p>说明：<br><code>-c</code> 指定配置文件。<br><code>log</code>记录日志。<br><code>&amp;.</code> 后台执行    </p>\n</blockquote>\n<ul>\n<li><p><em>查看是否启动</em>：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\ntcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h3><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/client.tar.gz\" title=\"Shadowsocks-client\">Shadowsocks-client</a><br>在linux客户端解压，修改.json配置文件中相关参数，启动即可。</p>\n<h3 id=\"windows系统\"><a href=\"#windows系统\" class=\"headerlink\" title=\"windows系统\"></a>windows系统</h3><p>直接下载客户端。<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">网址</a><br>安装包：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks-4.0.6.zip\" title=\"Shadowsocks-win\">Shadowsocks-win</a><br>双击打开：<br><img src=\"/2017/11/11/shadowsocks-go/a.png\"></p>\n<p>把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。</p>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><ul>\n<li>go客户端：<br><code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</code><br>由于被墙，客户端下载不了。<br>所以要在服务端执行，然后再把可执行二进制文件下拉到本地。</li>\n</ul>\n<p><em>配置客户端文件</em><br>创建文件：shadowsocks-local.json<br>编辑：</p>\n<pre><code>{\n    &quot;local_port&quot;: 1081,\n    &quot;server_password&quot;: [\n        [&quot;127.0.0.1:8387&quot;, &quot;foobar&quot;],\n        [&quot;127.0.0.1:8388&quot;, &quot;barfoo&quot;, &quot;aes-128-cfb&quot;]\n    ]\n}\n</code></pre><p>可以配置多个服务器，单个服务器，则去掉一个。</p>\n<p>启动：类似服务端，用<code>-c</code>指定配置文件。    </p>\n<ul>\n<li>qt5客户端：</li>\n</ul>\n<ol>\n<li><p>二进制包安装。<a href=\"https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"noopener\">安装网址</a>  </p>\n</li>\n<li><p>推荐，命令安装：</p>\n<pre><code>#Ubuntu 14.04及更高版本\n#添加ppa源\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n\n#启动shadowsocks-qt5\n\n可以通过which shadowsocks-qt5找到可执行文件的位置。\n\n执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n</code></pre></li>\n</ol>\n<h3 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h3><ul>\n<li>安卓客户端：</li>\n</ul>\n<p>下载：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk\" title=\"Shadowsocks_v4.2.5_apkpure.com.apk\">Shadowsocks_v4.2.5_apkpure.com.apk</a></p>\n<ul>\n<li>苹果客户端：</li>\n</ul>\n<p>安装app：FirstWingy</p>\n<h3 id=\"修改浏览器代理\"><a href=\"#修改浏览器代理\" class=\"headerlink\" title=\"修改浏览器代理\"></a>修改浏览器代理</h3><blockquote>\n<p>SOCKS5 127.0.0.1:local_port</p>\n</blockquote>\n<p>如果可以，在chrome中可以安装代理设置插件<br><img src=\"/2017/11/11/shadowsocks-go/b.png\"></p>\n<p>然后启动，试下访问：<a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">google</a></p>\n<h3 id=\"linux下全局代理\"><a href=\"#linux下全局代理\" class=\"headerlink\" title=\"linux下全局代理\"></a>linux下全局代理</h3><p>实验环境：Ubuntu系统</p>\n<p>1.安装应用<code>privoxy</code></p>\n<p>一款工具，将socks代理转换成http。</p>\n<p><code>sudo apt-get install privoxy</code></p>\n<p>2.更改配置</p>\n<pre><code>sudo gedit /etc/privoxy/config\n\n----------------------------------------------------------------\n\n# 在 froward-socks4下面添加一条socks5的，因为shadowsocks为socks5，\n# 地址是127.0.0.1:1080。注意他们最后有一个“.”\n#        forward-socks4   /               socks-gw.example.com:1080  .\nforward-socks5   /               127.0.0.1:1080 .\n\n# 下面还存在以下一条配置，表示privoxy监听本机8118端口，\n# 把它作为http代理，代理地址为 http://localhost.8118/ 。\n# 可以把地址改为 0.0.0.0:8118，表示外网也可以通过本机IP作http代理。\n# 这样，你的外网IP为1.2.3.4，别人就可以设置 http://1.2.3.4:8118/ 为http代理。\n　listen-address localhost:8118  #端口可以随意设定\n\n上面配置可能导致无法启动privoxy,新版本安全问题导致。改为：   \nlisten-address 192.168.1.115:8118  #端口可以随意设定  \n</code></pre><p>3.重启privoxy</p>\n<pre><code>sudo systemctl restart privoxy.serivce\n</code></pre><p>4.添加环境变量</p>\n<pre><code>vim ~/.bashrc\n\n----\n添加两行：\nexport http_proxy=http://127.0.0.1:8118/\nexport https_proxy=http://127.0.0.1:8118/  \n</code></pre><p>5.使环境变量立即生效</p>\n<pre><code>source ~/.bashrc\n</code></pre><p>说明：如果只是想临时的让当前命令窗口代理，那么只需要添加临时变量，不需要编辑~/.bashrc。<br>只需要在当前命令窗口执行<code>export http_proxy=http://127.0.0.1:8118/</code> <code>export https_proxy=http://127.0.0.1:8118/</code>         </p>\n"},{"title":"Spinnaker持续集成初试","date":"2018-08-13T06:56:33.000Z","_content":"\n[官网](https://www.spinnaker.io/)","source":"_posts/spinnaker-start.md","raw":"---\ntitle: Spinnaker持续集成初试\ndate: 2018-08-13 14:56:33\ncategories: 持续集成\ntags: spinnaker-start\n---\n\n[官网](https://www.spinnaker.io/)","slug":"spinnaker-start","published":1,"updated":"2018-11-09T01:20:30.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38n60088qcrgsn07ocox","content":"<p><a href=\"https://www.spinnaker.io/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.spinnaker.io/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n"},{"title":"spring-boot异步调用","date":"2017-11-10T08:22:18.000Z","_content":"\n在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。\n在spring-boot中，通过简单的注解 `@Async` 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：\n\n参考：\n- http://blog.csdn.net/blueheart20/article/details/44648667\n- http://blog.csdn.net/liuchuanhong1/article/details/64132520\n\n## 1. 启用异步操作功能\n很简单，只需要在主类中添加注解`@EnableAsync` 即可。\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.scheduling.annotation.EnableAsync;\n    \n    @EnableAsync\n    @SpringBootApplication\n    public class SpringBootAsyncApplication {\n    \n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(SpringBootAsyncApplication.class, args);\n    \t}\n    }\n\n## 2. 定义处理类，并添加方法\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.scheduling.annotation.Async;\n    import org.springframework.scheduling.annotation.AsyncResult;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Random;\n    import java.util.concurrent.Future;\n    \n    @Component\n    public class Task {\n    \n        public static Random random =new Random();\n    \n        @Async\n        public void webTest() throws Exception {\n            System.out.println(\"开始测试异步\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成测试异步，耗时：\" + (end - start) + \"毫秒\");\n        }\n    \n        @Async\n        public Future<String> doTaskOne() throws Exception {\n            System.out.println(\"开始做任务一\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务一，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务一完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskTwo() throws Exception {\n            System.out.println(\"开始做任务二\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务二，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务二完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskThree() throws Exception {\n            System.out.println(\"开始做任务三\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务三，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务三完成\");\n        }\n    }\n\n只需要在方法上添加注解`@Async`。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。\n\n## 3. 测试\n\n    package com.ymu.demo.async;\n    \n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import java.util.concurrent.Future;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class SpringBootAsyncApplicationTests {\n    \n        @Autowired\n        private Task task;\n    \n        @Test\n        public void contextLoads() {\n    \n            System.out.println(\"===============load context\");\n        }\n    \n        @Test\n        public void test() throws Exception {\n    \n            long start = System.currentTimeMillis();\n    \n            Future<String> task1 = task.doTaskOne();\n            Future<String> task2 = task.doTaskTwo();\n            Future<String> task3 = task.doTaskThree();\n    \n            while(true) {\n                if(task1.isDone() && task2.isDone() && task3.isDone()) {\n                    // 三个任务都调用完成，退出循环等待\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n    \n            long end = System.currentTimeMillis();\n    \n            System.out.println(\"任务全部完成，总耗时：\" + (end - start) + \"毫秒\");\n    \n        }\n    \n    }\n\n---\n    package com.ymu.demo.async;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    public class IndexController {\n    \n        @Autowired\n        Task task;\n    \n        @GetMapping(\"/index\")\n        public String index() throws Exception {\n            task.webTest();\n            return \"index\";\n        }\n    }\n    \n## 4. 基于@Async调用中的异常处理机制\n   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：\n   \n1. 自定义实现AsyncTaskExecutor的任务执行器。\n2. 配置由自定义的TaskExecutor替代内置的任务执行器。      \n\n自定义的TaskExecutor\n\n    \n","source":"_posts/spring-boot-async.md","raw":"---\ntitle: spring-boot异步调用\ndate: 2017-11-10 16:22:18\ncategories: spring-boot\ntags: spring-boot-async\n---\n\n在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。\n在spring-boot中，通过简单的注解 `@Async` 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：\n\n参考：\n- http://blog.csdn.net/blueheart20/article/details/44648667\n- http://blog.csdn.net/liuchuanhong1/article/details/64132520\n\n## 1. 启用异步操作功能\n很简单，只需要在主类中添加注解`@EnableAsync` 即可。\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.scheduling.annotation.EnableAsync;\n    \n    @EnableAsync\n    @SpringBootApplication\n    public class SpringBootAsyncApplication {\n    \n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(SpringBootAsyncApplication.class, args);\n    \t}\n    }\n\n## 2. 定义处理类，并添加方法\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.scheduling.annotation.Async;\n    import org.springframework.scheduling.annotation.AsyncResult;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Random;\n    import java.util.concurrent.Future;\n    \n    @Component\n    public class Task {\n    \n        public static Random random =new Random();\n    \n        @Async\n        public void webTest() throws Exception {\n            System.out.println(\"开始测试异步\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成测试异步，耗时：\" + (end - start) + \"毫秒\");\n        }\n    \n        @Async\n        public Future<String> doTaskOne() throws Exception {\n            System.out.println(\"开始做任务一\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务一，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务一完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskTwo() throws Exception {\n            System.out.println(\"开始做任务二\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务二，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务二完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskThree() throws Exception {\n            System.out.println(\"开始做任务三\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务三，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务三完成\");\n        }\n    }\n\n只需要在方法上添加注解`@Async`。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。\n\n## 3. 测试\n\n    package com.ymu.demo.async;\n    \n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import java.util.concurrent.Future;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class SpringBootAsyncApplicationTests {\n    \n        @Autowired\n        private Task task;\n    \n        @Test\n        public void contextLoads() {\n    \n            System.out.println(\"===============load context\");\n        }\n    \n        @Test\n        public void test() throws Exception {\n    \n            long start = System.currentTimeMillis();\n    \n            Future<String> task1 = task.doTaskOne();\n            Future<String> task2 = task.doTaskTwo();\n            Future<String> task3 = task.doTaskThree();\n    \n            while(true) {\n                if(task1.isDone() && task2.isDone() && task3.isDone()) {\n                    // 三个任务都调用完成，退出循环等待\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n    \n            long end = System.currentTimeMillis();\n    \n            System.out.println(\"任务全部完成，总耗时：\" + (end - start) + \"毫秒\");\n    \n        }\n    \n    }\n\n---\n    package com.ymu.demo.async;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    public class IndexController {\n    \n        @Autowired\n        Task task;\n    \n        @GetMapping(\"/index\")\n        public String index() throws Exception {\n            task.webTest();\n            return \"index\";\n        }\n    }\n    \n## 4. 基于@Async调用中的异常处理机制\n   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：\n   \n1. 自定义实现AsyncTaskExecutor的任务执行器。\n2. 配置由自定义的TaskExecutor替代内置的任务执行器。      \n\n自定义的TaskExecutor\n\n    \n","slug":"spring-boot-async","published":1,"updated":"2018-11-09T01:20:30.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38n7008aqcrgjocqdqng","content":"<p>在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。<br>在spring-boot中，通过简单的注解 <code>@Async</code> 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/blueheart20/article/details/44648667\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/blueheart20/article/details/44648667</a></li>\n<li><a href=\"http://blog.csdn.net/liuchuanhong1/article/details/64132520\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/liuchuanhong1/article/details/64132520</a></li>\n</ul>\n<h2 id=\"1-启用异步操作功能\"><a href=\"#1-启用异步操作功能\" class=\"headerlink\" title=\"1. 启用异步操作功能\"></a>1. 启用异步操作功能</h2><p>很简单，只需要在主类中添加注解<code>@EnableAsync</code> 即可。</p>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootAsyncApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAsyncApplication.class, args);\n    }\n}\n</code></pre><h2 id=\"2-定义处理类，并添加方法\"><a href=\"#2-定义处理类，并添加方法\" class=\"headerlink\" title=\"2. 定义处理类，并添加方法\"></a>2. 定义处理类，并添加方法</h2><pre><code>package com.ymu.demo.async;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.AsyncResult;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Random;\nimport java.util.concurrent.Future;\n\n@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    @Async\n    public void webTest() throws Exception {\n        System.out.println(&quot;开始测试异步&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成测试异步，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskOne() throws Exception {\n        System.out.println(&quot;开始做任务一&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskTwo() throws Exception {\n        System.out.println(&quot;开始做任务二&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务二完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskThree() throws Exception {\n        System.out.println(&quot;开始做任务三&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务三完成&quot;);\n    }\n}\n</code></pre><p>只需要在方法上添加注解<code>@Async</code>。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。</p>\n<h2 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h2><pre><code>package com.ymu.demo.async;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.concurrent.Future;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootAsyncApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void contextLoads() {\n\n        System.out.println(&quot;===============load context&quot;);\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        Future&lt;String&gt; task1 = task.doTaskOne();\n        Future&lt;String&gt; task2 = task.doTaskTwo();\n        Future&lt;String&gt; task3 = task.doTaskThree();\n\n        while(true) {\n            if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {\n                // 三个任务都调用完成，退出循环等待\n                break;\n            }\n            Thread.sleep(1000);\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n\n    }\n\n}\n</code></pre><hr>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class IndexController {\n\n    @Autowired\n    Task task;\n\n    @GetMapping(&quot;/index&quot;)\n    public String index() throws Exception {\n        task.webTest();\n        return &quot;index&quot;;\n    }\n}\n</code></pre><h2 id=\"4-基于-Async调用中的异常处理机制\"><a href=\"#4-基于-Async调用中的异常处理机制\" class=\"headerlink\" title=\"4. 基于@Async调用中的异常处理机制\"></a>4. 基于@Async调用中的异常处理机制</h2><p>   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：</p>\n<ol>\n<li>自定义实现AsyncTaskExecutor的任务执行器。</li>\n<li>配置由自定义的TaskExecutor替代内置的任务执行器。      </li>\n</ol>\n<p>自定义的TaskExecutor</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。<br>在spring-boot中，通过简单的注解 <code>@Async</code> 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/blueheart20/article/details/44648667\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/blueheart20/article/details/44648667</a></li>\n<li><a href=\"http://blog.csdn.net/liuchuanhong1/article/details/64132520\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/liuchuanhong1/article/details/64132520</a></li>\n</ul>\n<h2 id=\"1-启用异步操作功能\"><a href=\"#1-启用异步操作功能\" class=\"headerlink\" title=\"1. 启用异步操作功能\"></a>1. 启用异步操作功能</h2><p>很简单，只需要在主类中添加注解<code>@EnableAsync</code> 即可。</p>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootAsyncApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAsyncApplication.class, args);\n    }\n}\n</code></pre><h2 id=\"2-定义处理类，并添加方法\"><a href=\"#2-定义处理类，并添加方法\" class=\"headerlink\" title=\"2. 定义处理类，并添加方法\"></a>2. 定义处理类，并添加方法</h2><pre><code>package com.ymu.demo.async;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.AsyncResult;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Random;\nimport java.util.concurrent.Future;\n\n@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    @Async\n    public void webTest() throws Exception {\n        System.out.println(&quot;开始测试异步&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成测试异步，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskOne() throws Exception {\n        System.out.println(&quot;开始做任务一&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskTwo() throws Exception {\n        System.out.println(&quot;开始做任务二&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务二完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskThree() throws Exception {\n        System.out.println(&quot;开始做任务三&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务三完成&quot;);\n    }\n}\n</code></pre><p>只需要在方法上添加注解<code>@Async</code>。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。</p>\n<h2 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h2><pre><code>package com.ymu.demo.async;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.concurrent.Future;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootAsyncApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void contextLoads() {\n\n        System.out.println(&quot;===============load context&quot;);\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        Future&lt;String&gt; task1 = task.doTaskOne();\n        Future&lt;String&gt; task2 = task.doTaskTwo();\n        Future&lt;String&gt; task3 = task.doTaskThree();\n\n        while(true) {\n            if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {\n                // 三个任务都调用完成，退出循环等待\n                break;\n            }\n            Thread.sleep(1000);\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n\n    }\n\n}\n</code></pre><hr>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class IndexController {\n\n    @Autowired\n    Task task;\n\n    @GetMapping(&quot;/index&quot;)\n    public String index() throws Exception {\n        task.webTest();\n        return &quot;index&quot;;\n    }\n}\n</code></pre><h2 id=\"4-基于-Async调用中的异常处理机制\"><a href=\"#4-基于-Async调用中的异常处理机制\" class=\"headerlink\" title=\"4. 基于@Async调用中的异常处理机制\"></a>4. 基于@Async调用中的异常处理机制</h2><p>   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：</p>\n<ol>\n<li>自定义实现AsyncTaskExecutor的任务执行器。</li>\n<li>配置由自定义的TaskExecutor替代内置的任务执行器。      </li>\n</ol>\n<p>自定义的TaskExecutor</p>\n"},{"title":"Spring-Cache使用","date":"2018-03-23T09:29:57.000Z","_content":"","source":"_posts/spring-boot-cache.md","raw":"---\ntitle: Spring-Cache使用\ndate: 2018-03-23 17:29:57\ncategories: spring-boot\ntags: spring cache\n---\n","slug":"spring-boot-cache","published":1,"updated":"2018-11-09T01:20:30.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38n8008dqcrgbrglkh56","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"springboot跨域请求解决","date":"2017-11-15T01:43:12.000Z","_content":"先推荐三篇文章\n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[同源策略和跨域访问](http://blog.csdn.net/shimiso/article/details/21830313)\n[详解js跨域问题](https://segmentfault.com/a/1190000000718840)\n[springboot前后端分离跨域](https://my.oschina.net/u/3677020/blog/1573162)\n\n## 什么是跨域\n\n要想了解跨域，就先要知道什么是同源策略。\n\n同源策略，它是由Netscape提出的一个著名的安全策略。\n\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\n\n域：协议+地址(域名或IP)+端口\n\n## 为什么要有同源策略\n\n可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。\n\n## 为什么要有跨域\n\n最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。\n\n## 如何解决跨域\n\n*JSONP*\n\n只能实现GET请求，但是被一些老浏览器支持。\n\n*代理*\n\n在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。\n\n*CORS*\n\n2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。\n\n出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 http://example.com 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 http://hello-world.example，就需要使用该标准。http://hello-world.example 在HTTP的响应头部中定义 Access-Control-Allow-Origin: http://example.org，通知浏览器允许 http://example.org 跨源从 http://hello-world.example上获取资源。\n\n## springboot跨域\n\n### 设置全局跨域\n- 方法一：\n    \n        @Configuration\n        public class WebConfig extends WebMvcConfigurationSupport {\n            /**\n             * 全局跨域设置\n             *\n             * @param registry\n             */\n            @Override\n            protected void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\");\n        //                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n        //                .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        \n        }\n\n### 局部跨域\n","source":"_posts/spring-boot-cors.md","raw":"---\ntitle: springboot跨域请求解决\ndate: 2017-11-15 09:43:12\ncategories: spring-boot\ntags: spring-cors\n---\n先推荐三篇文章\n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[同源策略和跨域访问](http://blog.csdn.net/shimiso/article/details/21830313)\n[详解js跨域问题](https://segmentfault.com/a/1190000000718840)\n[springboot前后端分离跨域](https://my.oschina.net/u/3677020/blog/1573162)\n\n## 什么是跨域\n\n要想了解跨域，就先要知道什么是同源策略。\n\n同源策略，它是由Netscape提出的一个著名的安全策略。\n\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\n\n域：协议+地址(域名或IP)+端口\n\n## 为什么要有同源策略\n\n可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。\n\n## 为什么要有跨域\n\n最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。\n\n## 如何解决跨域\n\n*JSONP*\n\n只能实现GET请求，但是被一些老浏览器支持。\n\n*代理*\n\n在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。\n\n*CORS*\n\n2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。\n\n出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 http://example.com 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 http://hello-world.example，就需要使用该标准。http://hello-world.example 在HTTP的响应头部中定义 Access-Control-Allow-Origin: http://example.org，通知浏览器允许 http://example.org 跨源从 http://hello-world.example上获取资源。\n\n## springboot跨域\n\n### 设置全局跨域\n- 方法一：\n    \n        @Configuration\n        public class WebConfig extends WebMvcConfigurationSupport {\n            /**\n             * 全局跨域设置\n             *\n             * @param registry\n             */\n            @Override\n            protected void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\");\n        //                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n        //                .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        \n        }\n\n### 局部跨域\n","slug":"spring-boot-cors","published":1,"updated":"2018-11-09T01:20:30.904Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38na008gqcrg4jyo3nb3","content":"<p>先推荐三篇文章<br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a><br><a href=\"http://blog.csdn.net/shimiso/article/details/21830313\" target=\"_blank\" rel=\"noopener\">同源策略和跨域访问</a><br><a href=\"https://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"noopener\">详解js跨域问题</a><br><a href=\"https://my.oschina.net/u/3677020/blog/1573162\" target=\"_blank\" rel=\"noopener\">springboot前后端分离跨域</a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>要想了解跨域，就先要知道什么是同源策略。</p>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略。</p>\n<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>\n<p>域：协议+地址(域名或IP)+端口</p>\n<h2 id=\"为什么要有同源策略\"><a href=\"#为什么要有同源策略\" class=\"headerlink\" title=\"为什么要有同源策略\"></a>为什么要有同源策略</h2><p>可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。</p>\n<h2 id=\"为什么要有跨域\"><a href=\"#为什么要有跨域\" class=\"headerlink\" title=\"为什么要有跨域\"></a>为什么要有跨域</h2><p>最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。</p>\n<h2 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h2><p><em>JSONP</em></p>\n<p>只能实现GET请求，但是被一些老浏览器支持。</p>\n<p><em>代理</em></p>\n<p>在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。</p>\n<p><em>CORS</em></p>\n<p>2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。</p>\n<p>出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 <a href=\"http://hello-world.example，就需要使用该标准。http://hello-world.example\" target=\"_blank\" rel=\"noopener\">http://hello-world.example，就需要使用该标准。http://hello-world.example</a> 在HTTP的响应头部中定义 Access-Control-Allow-Origin: <a href=\"http://example.org，通知浏览器允许\" target=\"_blank\" rel=\"noopener\">http://example.org，通知浏览器允许</a> <a href=\"http://example.org\" target=\"_blank\" rel=\"noopener\">http://example.org</a> 跨源从 <a href=\"http://hello-world.example上获取资源。\" target=\"_blank\" rel=\"noopener\">http://hello-world.example上获取资源。</a></p>\n<h2 id=\"springboot跨域\"><a href=\"#springboot跨域\" class=\"headerlink\" title=\"springboot跨域\"></a>springboot跨域</h2><h3 id=\"设置全局跨域\"><a href=\"#设置全局跨域\" class=\"headerlink\" title=\"设置全局跨域\"></a>设置全局跨域</h3><ul>\n<li><p>方法一：</p>\n<pre><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n    /**\n     * 全局跨域设置\n     *\n     * @param registry\n     */\n    @Override\n    protected void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;)\n                //放行哪些原始域\n                .allowedOrigins(&quot;*&quot;)\n                //是否发送Cookie信息\n                .allowCredentials(true)\n                //放行哪些原始域(请求方式)\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)\n                //放行哪些原始域(头部信息)\n                .allowedHeaders(&quot;*&quot;);\n//                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n//                .exposedHeaders(&quot;Header1&quot;, &quot;Header2&quot;);\n    }\n\n}\n</code></pre></li>\n</ul>\n<h3 id=\"局部跨域\"><a href=\"#局部跨域\" class=\"headerlink\" title=\"局部跨域\"></a>局部跨域</h3>","site":{"data":{}},"excerpt":"","more":"<p>先推荐三篇文章<br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a><br><a href=\"http://blog.csdn.net/shimiso/article/details/21830313\" target=\"_blank\" rel=\"noopener\">同源策略和跨域访问</a><br><a href=\"https://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"noopener\">详解js跨域问题</a><br><a href=\"https://my.oschina.net/u/3677020/blog/1573162\" target=\"_blank\" rel=\"noopener\">springboot前后端分离跨域</a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>要想了解跨域，就先要知道什么是同源策略。</p>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略。</p>\n<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>\n<p>域：协议+地址(域名或IP)+端口</p>\n<h2 id=\"为什么要有同源策略\"><a href=\"#为什么要有同源策略\" class=\"headerlink\" title=\"为什么要有同源策略\"></a>为什么要有同源策略</h2><p>可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。</p>\n<h2 id=\"为什么要有跨域\"><a href=\"#为什么要有跨域\" class=\"headerlink\" title=\"为什么要有跨域\"></a>为什么要有跨域</h2><p>最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。</p>\n<h2 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h2><p><em>JSONP</em></p>\n<p>只能实现GET请求，但是被一些老浏览器支持。</p>\n<p><em>代理</em></p>\n<p>在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。</p>\n<p><em>CORS</em></p>\n<p>2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。</p>\n<p>出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 <a href=\"http://hello-world.example，就需要使用该标准。http://hello-world.example\" target=\"_blank\" rel=\"noopener\">http://hello-world.example，就需要使用该标准。http://hello-world.example</a> 在HTTP的响应头部中定义 Access-Control-Allow-Origin: <a href=\"http://example.org，通知浏览器允许\" target=\"_blank\" rel=\"noopener\">http://example.org，通知浏览器允许</a> <a href=\"http://example.org\" target=\"_blank\" rel=\"noopener\">http://example.org</a> 跨源从 <a href=\"http://hello-world.example上获取资源。\" target=\"_blank\" rel=\"noopener\">http://hello-world.example上获取资源。</a></p>\n<h2 id=\"springboot跨域\"><a href=\"#springboot跨域\" class=\"headerlink\" title=\"springboot跨域\"></a>springboot跨域</h2><h3 id=\"设置全局跨域\"><a href=\"#设置全局跨域\" class=\"headerlink\" title=\"设置全局跨域\"></a>设置全局跨域</h3><ul>\n<li><p>方法一：</p>\n<pre><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n    /**\n     * 全局跨域设置\n     *\n     * @param registry\n     */\n    @Override\n    protected void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;)\n                //放行哪些原始域\n                .allowedOrigins(&quot;*&quot;)\n                //是否发送Cookie信息\n                .allowCredentials(true)\n                //放行哪些原始域(请求方式)\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)\n                //放行哪些原始域(头部信息)\n                .allowedHeaders(&quot;*&quot;);\n//                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n//                .exposedHeaders(&quot;Header1&quot;, &quot;Header2&quot;);\n    }\n\n}\n</code></pre></li>\n</ul>\n<h3 id=\"局部跨域\"><a href=\"#局部跨域\" class=\"headerlink\" title=\"局部跨域\"></a>局部跨域</h3>"},{"title":"spring-boot开发常见异常收录","date":"2017-09-28T16:31:25.000Z","_content":"\n## jpa篇\n\n### 1 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n#### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n#### 1.2 不传递依赖\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n#### 1.3 在@SpringBootApplication中排除其注入\n\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n### 2 自动创建表指定Mysql搜索引擎类型\n\n解决方法，只需要在配置文件添加如下代码:\n    \n    # 指定生成表名的存储引擎为InneoDB\n    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n\n## 启动类配置\n\n1.让一个类型不被ComponentScan扫描\n\n    @ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n            value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\n    public class ServiceFileclientApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ServiceFileclientApplication.class, args);\n        }\n    }\n    \n    ----\n    \n    package com.ymu.servicefileclient.config;\n    \n    public @interface ExcludeComponent {\n    }\n    \n    -------\n    /**\n     * 该类为Feign的配置类\n     * 注意：该类不应该在主应用程序上下文的@CompantScan中\n     */\n    @ExcludeComponent\n    @Configuration\n    public class FeignConfiguration {\n    \n        /**\n         * 用feign.Contract.Default替换SpringMvcContract契约\n         *\n         * @return\n         */\n        @Bean\n        public Contract feignContract() {\n            return new feign.Contract.Default();\n        }\n    \n    }\n\n## 文件相关\n\n1.在jar包所在目录下创建文件或者文件夹\n\n     //运行jar所在文件目录\n     @Value(\"${user.dir}\")\n     private String userDir;\n     \n     //创建文件夹abc\n      URI uri = URI.create(userDir);\n      File file = new File(uri + \"/abc\");\n      if (!file.exists()) {\n          file.mkdir();\n      }\n\n2.系统用户根目录下创建文件\n\n     // 桌面路径\n    FileSystemView fsv = FileSystemView.getFileSystemView();\n    File com = fsv.getHomeDirectory();\n    // String url = com.getPath().replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\") + \"\\\\\";\n    String filePath = com.getPath();\n    String fileName = \"导出数据.pdf\";\n    String uri = filePath.concat(File.separator).concat(fileName);   \n   \n3.获取类所在资源目录\n\n    this.getClass().getClassLoader().getResource(\"\").getPath(); \n    \n    --------------------------------------x\n    \n    近期在用springboot封装一些对外服务的API接口，在本机测试都很顺利，可是当我打包jar文件放到服务器上测试的时候发现了类似下面的异常信息：\n    \n    java.nio.file.NoSuchFileException: file:/app.jar!/BOOT-INF/classes!/xxx.properties \n     \n    于是网上一番搜索，找到类似的解决方法：\n    Properties prop = new Properties();\n    InputStream is = this.getClass().getResourceAsStream(filePath);     \n    \n## 取消自动配置\n\n### 方式一\n\n去掉pom中相关的依赖包。\n\n### 代码中配置\n\n1.使用了@EnableAutoConfiguration的时候    \n\n    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n    \n2.使用了@SpringBootApplication的时候\n\n    @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n    1\n3.使用了@SpringCloudApplication的时候\n\n    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n    @SpringCloudApplication\n    \n4.通过配置文件来设置\n\n    spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n    1\n    \n    ","source":"_posts/spring-boot-dev-error-show.md","raw":"---\ntitle: spring-boot开发常见异常收录\ndate: 2017-09-29 00:31:25\ncategories: spring-boot\ntags: spring-boot使用经验\n---\n\n## jpa篇\n\n### 1 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n#### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n#### 1.2 不传递依赖\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n#### 1.3 在@SpringBootApplication中排除其注入\n\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n### 2 自动创建表指定Mysql搜索引擎类型\n\n解决方法，只需要在配置文件添加如下代码:\n    \n    # 指定生成表名的存储引擎为InneoDB\n    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n\n## 启动类配置\n\n1.让一个类型不被ComponentScan扫描\n\n    @ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n            value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\n    public class ServiceFileclientApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ServiceFileclientApplication.class, args);\n        }\n    }\n    \n    ----\n    \n    package com.ymu.servicefileclient.config;\n    \n    public @interface ExcludeComponent {\n    }\n    \n    -------\n    /**\n     * 该类为Feign的配置类\n     * 注意：该类不应该在主应用程序上下文的@CompantScan中\n     */\n    @ExcludeComponent\n    @Configuration\n    public class FeignConfiguration {\n    \n        /**\n         * 用feign.Contract.Default替换SpringMvcContract契约\n         *\n         * @return\n         */\n        @Bean\n        public Contract feignContract() {\n            return new feign.Contract.Default();\n        }\n    \n    }\n\n## 文件相关\n\n1.在jar包所在目录下创建文件或者文件夹\n\n     //运行jar所在文件目录\n     @Value(\"${user.dir}\")\n     private String userDir;\n     \n     //创建文件夹abc\n      URI uri = URI.create(userDir);\n      File file = new File(uri + \"/abc\");\n      if (!file.exists()) {\n          file.mkdir();\n      }\n\n2.系统用户根目录下创建文件\n\n     // 桌面路径\n    FileSystemView fsv = FileSystemView.getFileSystemView();\n    File com = fsv.getHomeDirectory();\n    // String url = com.getPath().replaceAll(\"\\\\\\\\\", \"\\\\\\\\\\\\\\\\\") + \"\\\\\";\n    String filePath = com.getPath();\n    String fileName = \"导出数据.pdf\";\n    String uri = filePath.concat(File.separator).concat(fileName);   \n   \n3.获取类所在资源目录\n\n    this.getClass().getClassLoader().getResource(\"\").getPath(); \n    \n    --------------------------------------x\n    \n    近期在用springboot封装一些对外服务的API接口，在本机测试都很顺利，可是当我打包jar文件放到服务器上测试的时候发现了类似下面的异常信息：\n    \n    java.nio.file.NoSuchFileException: file:/app.jar!/BOOT-INF/classes!/xxx.properties \n     \n    于是网上一番搜索，找到类似的解决方法：\n    Properties prop = new Properties();\n    InputStream is = this.getClass().getResourceAsStream(filePath);     \n    \n## 取消自动配置\n\n### 方式一\n\n去掉pom中相关的依赖包。\n\n### 代码中配置\n\n1.使用了@EnableAutoConfiguration的时候    \n\n    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n    \n2.使用了@SpringBootApplication的时候\n\n    @SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n    1\n3.使用了@SpringCloudApplication的时候\n\n    @EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n    @SpringCloudApplication\n    \n4.通过配置文件来设置\n\n    spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n    1\n    \n    ","slug":"spring-boot-dev-error-show","published":1,"updated":"2018-11-09T01:20:30.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38nb008jqcrgvaset9cy","content":"<h2 id=\"jpa篇\"><a href=\"#jpa篇\" class=\"headerlink\" title=\"jpa篇\"></a>jpa篇</h2><h3 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1 异常一：缺少jpa数据源配置\"></a>1 异常一：缺少jpa数据源配置</h3><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h4 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h4><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2 不传递依赖\"></a>1.2 不传递依赖</h4><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h4 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h4><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre><h3 id=\"2-自动创建表指定Mysql搜索引擎类型\"><a href=\"#2-自动创建表指定Mysql搜索引擎类型\" class=\"headerlink\" title=\"2 自动创建表指定Mysql搜索引擎类型\"></a>2 自动创建表指定Mysql搜索引擎类型</h3><p>解决方法，只需要在配置文件添加如下代码:</p>\n<pre><code># 指定生成表名的存储引擎为InneoDB\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n</code></pre><h2 id=\"启动类配置\"><a href=\"#启动类配置\" class=\"headerlink\" title=\"启动类配置\"></a>启动类配置</h2><p>1.让一个类型不被ComponentScan扫描</p>\n<pre><code>@ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n        value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\npublic class ServiceFileclientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceFileclientApplication.class, args);\n    }\n}\n\n----\n\npackage com.ymu.servicefileclient.config;\n\npublic @interface ExcludeComponent {\n}\n\n-------\n/**\n * 该类为Feign的配置类\n * 注意：该类不应该在主应用程序上下文的@CompantScan中\n */\n@ExcludeComponent\n@Configuration\npublic class FeignConfiguration {\n\n    /**\n     * 用feign.Contract.Default替换SpringMvcContract契约\n     *\n     * @return\n     */\n    @Bean\n    public Contract feignContract() {\n        return new feign.Contract.Default();\n    }\n\n}\n</code></pre><h2 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h2><p>1.在jar包所在目录下创建文件或者文件夹</p>\n<pre><code>//运行jar所在文件目录\n@Value(&quot;${user.dir}&quot;)\nprivate String userDir;\n\n//创建文件夹abc\n URI uri = URI.create(userDir);\n File file = new File(uri + &quot;/abc&quot;);\n if (!file.exists()) {\n     file.mkdir();\n }\n</code></pre><p>2.系统用户根目录下创建文件</p>\n<pre><code> // 桌面路径\nFileSystemView fsv = FileSystemView.getFileSystemView();\nFile com = fsv.getHomeDirectory();\n// String url = com.getPath().replaceAll(&quot;\\\\\\\\&quot;, &quot;\\\\\\\\\\\\\\\\&quot;) + &quot;\\\\&quot;;\nString filePath = com.getPath();\nString fileName = &quot;导出数据.pdf&quot;;\nString uri = filePath.concat(File.separator).concat(fileName);   \n</code></pre><p>3.获取类所在资源目录</p>\n<pre><code>this.getClass().getClassLoader().getResource(&quot;&quot;).getPath(); \n\n--------------------------------------x\n\n近期在用springboot封装一些对外服务的API接口，在本机测试都很顺利，可是当我打包jar文件放到服务器上测试的时候发现了类似下面的异常信息：\n\njava.nio.file.NoSuchFileException: file:/app.jar!/BOOT-INF/classes!/xxx.properties \n\n于是网上一番搜索，找到类似的解决方法：\nProperties prop = new Properties();\nInputStream is = this.getClass().getResourceAsStream(filePath);     \n</code></pre><h2 id=\"取消自动配置\"><a href=\"#取消自动配置\" class=\"headerlink\" title=\"取消自动配置\"></a>取消自动配置</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>去掉pom中相关的依赖包。</p>\n<h3 id=\"代码中配置\"><a href=\"#代码中配置\" class=\"headerlink\" title=\"代码中配置\"></a>代码中配置</h3><p>1.使用了@EnableAutoConfiguration的时候    </p>\n<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n</code></pre><p>2.使用了@SpringBootApplication的时候</p>\n<pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n1\n</code></pre><p>3.使用了@SpringCloudApplication的时候</p>\n<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n@SpringCloudApplication\n</code></pre><p>4.通过配置文件来设置</p>\n<pre><code>spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n1\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"jpa篇\"><a href=\"#jpa篇\" class=\"headerlink\" title=\"jpa篇\"></a>jpa篇</h2><h3 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1 异常一：缺少jpa数据源配置\"></a>1 异常一：缺少jpa数据源配置</h3><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h4 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h4><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2 不传递依赖\"></a>1.2 不传递依赖</h4><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h4 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h4><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre><h3 id=\"2-自动创建表指定Mysql搜索引擎类型\"><a href=\"#2-自动创建表指定Mysql搜索引擎类型\" class=\"headerlink\" title=\"2 自动创建表指定Mysql搜索引擎类型\"></a>2 自动创建表指定Mysql搜索引擎类型</h3><p>解决方法，只需要在配置文件添加如下代码:</p>\n<pre><code># 指定生成表名的存储引擎为InneoDB\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n</code></pre><h2 id=\"启动类配置\"><a href=\"#启动类配置\" class=\"headerlink\" title=\"启动类配置\"></a>启动类配置</h2><p>1.让一个类型不被ComponentScan扫描</p>\n<pre><code>@ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n        value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\npublic class ServiceFileclientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceFileclientApplication.class, args);\n    }\n}\n\n----\n\npackage com.ymu.servicefileclient.config;\n\npublic @interface ExcludeComponent {\n}\n\n-------\n/**\n * 该类为Feign的配置类\n * 注意：该类不应该在主应用程序上下文的@CompantScan中\n */\n@ExcludeComponent\n@Configuration\npublic class FeignConfiguration {\n\n    /**\n     * 用feign.Contract.Default替换SpringMvcContract契约\n     *\n     * @return\n     */\n    @Bean\n    public Contract feignContract() {\n        return new feign.Contract.Default();\n    }\n\n}\n</code></pre><h2 id=\"文件相关\"><a href=\"#文件相关\" class=\"headerlink\" title=\"文件相关\"></a>文件相关</h2><p>1.在jar包所在目录下创建文件或者文件夹</p>\n<pre><code>//运行jar所在文件目录\n@Value(&quot;${user.dir}&quot;)\nprivate String userDir;\n\n//创建文件夹abc\n URI uri = URI.create(userDir);\n File file = new File(uri + &quot;/abc&quot;);\n if (!file.exists()) {\n     file.mkdir();\n }\n</code></pre><p>2.系统用户根目录下创建文件</p>\n<pre><code> // 桌面路径\nFileSystemView fsv = FileSystemView.getFileSystemView();\nFile com = fsv.getHomeDirectory();\n// String url = com.getPath().replaceAll(&quot;\\\\\\\\&quot;, &quot;\\\\\\\\\\\\\\\\&quot;) + &quot;\\\\&quot;;\nString filePath = com.getPath();\nString fileName = &quot;导出数据.pdf&quot;;\nString uri = filePath.concat(File.separator).concat(fileName);   \n</code></pre><p>3.获取类所在资源目录</p>\n<pre><code>this.getClass().getClassLoader().getResource(&quot;&quot;).getPath(); \n\n--------------------------------------x\n\n近期在用springboot封装一些对外服务的API接口，在本机测试都很顺利，可是当我打包jar文件放到服务器上测试的时候发现了类似下面的异常信息：\n\njava.nio.file.NoSuchFileException: file:/app.jar!/BOOT-INF/classes!/xxx.properties \n\n于是网上一番搜索，找到类似的解决方法：\nProperties prop = new Properties();\nInputStream is = this.getClass().getResourceAsStream(filePath);     \n</code></pre><h2 id=\"取消自动配置\"><a href=\"#取消自动配置\" class=\"headerlink\" title=\"取消自动配置\"></a>取消自动配置</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>去掉pom中相关的依赖包。</p>\n<h3 id=\"代码中配置\"><a href=\"#代码中配置\" class=\"headerlink\" title=\"代码中配置\"></a>代码中配置</h3><p>1.使用了@EnableAutoConfiguration的时候    </p>\n<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n</code></pre><p>2.使用了@SpringBootApplication的时候</p>\n<pre><code>@SpringBootApplication(exclude = {DataSourceAutoConfiguration.class})\n1\n</code></pre><p>3.使用了@SpringCloudApplication的时候</p>\n<pre><code>@EnableAutoConfiguration(exclude={DataSourceAutoConfiguration.class})\n@SpringCloudApplication\n</code></pre><p>4.通过配置文件来设置</p>\n<pre><code>spring.autoconfigure.exclude=org.springframework.boot.autoconfigure.jdbc.DataSourceAutoConfiguration\n1\n</code></pre>"},{"title":"spring-boot消息国际化","date":"2018-05-18T01:58:40.000Z","_content":"","source":"_posts/spring-boot-messages.md","raw":"---\ntitle: spring-boot消息国际化\ndate: 2018-05-18 09:58:40\ncategories: spring-boot\ntags: spring mvc国际化\n---\n","slug":"spring-boot-messages","published":1,"updated":"2018-11-09T01:20:30.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38ng008mqcrgzejkvg7d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"spring-boot发布包jar的秘密","date":"2018-10-19T09:27:44.000Z","_content":"\n### 修改spring-boot可执行jar包\n\n本主题介绍的实际是对java可执行jar包的修改问题。 \n\n在生产环境中，有时候我们发现了个小bug，开发迅速修改代码后，很多时候我们不得不重新发布一个新的可执行jar包上去替换掉。   \n但是这样就有个问题了，如果开发人员改动了很多的源码，这样我们就不得不重新测试检查各个功能了。而在生产环境，我们只是想仅仅替换改动的一点点东西。 \n\n在war包运行的情况下，我们可以直接在tomcat对应应用解压文件夹下替换某个文件即可。但是打成jar包就没那么方便了。\n\n所以，这里介绍两种方式达成目的：只换jar包中的某个文件资源：\n\n#### 方法一：用解压工具\n\n1.下载服务器中的jar包。  \n2.用360等相关解压工具直接双击`jar`包，打开。  \n3.拖动改动后的文件进去覆盖`jar`中的。  \n4.关闭解压工具软件。 \n5.重新上传改动后的`jar`包到服务器。   \n6.执行查看改动后效果。\n\n_注意：_ 整个过程不能解压下载下来的`jar`包。\n\n#### 方法二：java命令\n\n1.下载服务器jar包。    \n2.解压jar包\n\n    shell>jar xvf micro-service-core-0608-5-SC-SNAPSHOT.jar\n\n解压后三个目录：\nBOOT-INF、META-INF、org\n\n3.把修改过的文件在BOOT-INF下对应的文件夹中覆盖\n\n4.重新打回jar包\n     \n注意：不能覆盖META-INF下面的MANIFEST.MF文件，不能压缩打包。所以直接用下面命令行打包即可。\n     \n    shell>jar cvf0M core.jar BOOT-INF META-INF org\n\n执行完在当前目录下应该出现core.jar的新jar包。\n\n5.验证新jar包是否可执行（正确打包）\n\n    shell>jar cvf0M core.jar BOOT-INF META-INF org\n\n如果能正常启动，则重新打包成功\n\n","source":"_posts/spring-boot-jar.md","raw":"---\ntitle: spring-boot发布包jar的秘密\ndate: 2018-10-19 17:27:44\ncategories: spring-boot\ntags: spring-boot-jar\n---\n\n### 修改spring-boot可执行jar包\n\n本主题介绍的实际是对java可执行jar包的修改问题。 \n\n在生产环境中，有时候我们发现了个小bug，开发迅速修改代码后，很多时候我们不得不重新发布一个新的可执行jar包上去替换掉。   \n但是这样就有个问题了，如果开发人员改动了很多的源码，这样我们就不得不重新测试检查各个功能了。而在生产环境，我们只是想仅仅替换改动的一点点东西。 \n\n在war包运行的情况下，我们可以直接在tomcat对应应用解压文件夹下替换某个文件即可。但是打成jar包就没那么方便了。\n\n所以，这里介绍两种方式达成目的：只换jar包中的某个文件资源：\n\n#### 方法一：用解压工具\n\n1.下载服务器中的jar包。  \n2.用360等相关解压工具直接双击`jar`包，打开。  \n3.拖动改动后的文件进去覆盖`jar`中的。  \n4.关闭解压工具软件。 \n5.重新上传改动后的`jar`包到服务器。   \n6.执行查看改动后效果。\n\n_注意：_ 整个过程不能解压下载下来的`jar`包。\n\n#### 方法二：java命令\n\n1.下载服务器jar包。    \n2.解压jar包\n\n    shell>jar xvf micro-service-core-0608-5-SC-SNAPSHOT.jar\n\n解压后三个目录：\nBOOT-INF、META-INF、org\n\n3.把修改过的文件在BOOT-INF下对应的文件夹中覆盖\n\n4.重新打回jar包\n     \n注意：不能覆盖META-INF下面的MANIFEST.MF文件，不能压缩打包。所以直接用下面命令行打包即可。\n     \n    shell>jar cvf0M core.jar BOOT-INF META-INF org\n\n执行完在当前目录下应该出现core.jar的新jar包。\n\n5.验证新jar包是否可执行（正确打包）\n\n    shell>jar cvf0M core.jar BOOT-INF META-INF org\n\n如果能正常启动，则重新打包成功\n\n","slug":"spring-boot-jar","published":1,"updated":"2018-11-09T01:20:30.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38ni008pqcrgys165lmp","content":"<h3 id=\"修改spring-boot可执行jar包\"><a href=\"#修改spring-boot可执行jar包\" class=\"headerlink\" title=\"修改spring-boot可执行jar包\"></a>修改spring-boot可执行jar包</h3><p>本主题介绍的实际是对java可执行jar包的修改问题。 </p>\n<p>在生产环境中，有时候我们发现了个小bug，开发迅速修改代码后，很多时候我们不得不重新发布一个新的可执行jar包上去替换掉。<br>但是这样就有个问题了，如果开发人员改动了很多的源码，这样我们就不得不重新测试检查各个功能了。而在生产环境，我们只是想仅仅替换改动的一点点东西。 </p>\n<p>在war包运行的情况下，我们可以直接在tomcat对应应用解压文件夹下替换某个文件即可。但是打成jar包就没那么方便了。</p>\n<p>所以，这里介绍两种方式达成目的：只换jar包中的某个文件资源：</p>\n<h4 id=\"方法一：用解压工具\"><a href=\"#方法一：用解压工具\" class=\"headerlink\" title=\"方法一：用解压工具\"></a>方法一：用解压工具</h4><p>1.下载服务器中的jar包。<br>2.用360等相关解压工具直接双击<code>jar</code>包，打开。<br>3.拖动改动后的文件进去覆盖<code>jar</code>中的。<br>4.关闭解压工具软件。<br>5.重新上传改动后的<code>jar</code>包到服务器。<br>6.执行查看改动后效果。</p>\n<p><em>注意：</em> 整个过程不能解压下载下来的<code>jar</code>包。</p>\n<h4 id=\"方法二：java命令\"><a href=\"#方法二：java命令\" class=\"headerlink\" title=\"方法二：java命令\"></a>方法二：java命令</h4><p>1.下载服务器jar包。<br>2.解压jar包</p>\n<pre><code>shell&gt;jar xvf micro-service-core-0608-5-SC-SNAPSHOT.jar\n</code></pre><p>解压后三个目录：<br>BOOT-INF、META-INF、org</p>\n<p>3.把修改过的文件在BOOT-INF下对应的文件夹中覆盖</p>\n<p>4.重新打回jar包</p>\n<p>注意：不能覆盖META-INF下面的MANIFEST.MF文件，不能压缩打包。所以直接用下面命令行打包即可。</p>\n<pre><code>shell&gt;jar cvf0M core.jar BOOT-INF META-INF org\n</code></pre><p>执行完在当前目录下应该出现core.jar的新jar包。</p>\n<p>5.验证新jar包是否可执行（正确打包）</p>\n<pre><code>shell&gt;jar cvf0M core.jar BOOT-INF META-INF org\n</code></pre><p>如果能正常启动，则重新打包成功</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"修改spring-boot可执行jar包\"><a href=\"#修改spring-boot可执行jar包\" class=\"headerlink\" title=\"修改spring-boot可执行jar包\"></a>修改spring-boot可执行jar包</h3><p>本主题介绍的实际是对java可执行jar包的修改问题。 </p>\n<p>在生产环境中，有时候我们发现了个小bug，开发迅速修改代码后，很多时候我们不得不重新发布一个新的可执行jar包上去替换掉。<br>但是这样就有个问题了，如果开发人员改动了很多的源码，这样我们就不得不重新测试检查各个功能了。而在生产环境，我们只是想仅仅替换改动的一点点东西。 </p>\n<p>在war包运行的情况下，我们可以直接在tomcat对应应用解压文件夹下替换某个文件即可。但是打成jar包就没那么方便了。</p>\n<p>所以，这里介绍两种方式达成目的：只换jar包中的某个文件资源：</p>\n<h4 id=\"方法一：用解压工具\"><a href=\"#方法一：用解压工具\" class=\"headerlink\" title=\"方法一：用解压工具\"></a>方法一：用解压工具</h4><p>1.下载服务器中的jar包。<br>2.用360等相关解压工具直接双击<code>jar</code>包，打开。<br>3.拖动改动后的文件进去覆盖<code>jar</code>中的。<br>4.关闭解压工具软件。<br>5.重新上传改动后的<code>jar</code>包到服务器。<br>6.执行查看改动后效果。</p>\n<p><em>注意：</em> 整个过程不能解压下载下来的<code>jar</code>包。</p>\n<h4 id=\"方法二：java命令\"><a href=\"#方法二：java命令\" class=\"headerlink\" title=\"方法二：java命令\"></a>方法二：java命令</h4><p>1.下载服务器jar包。<br>2.解压jar包</p>\n<pre><code>shell&gt;jar xvf micro-service-core-0608-5-SC-SNAPSHOT.jar\n</code></pre><p>解压后三个目录：<br>BOOT-INF、META-INF、org</p>\n<p>3.把修改过的文件在BOOT-INF下对应的文件夹中覆盖</p>\n<p>4.重新打回jar包</p>\n<p>注意：不能覆盖META-INF下面的MANIFEST.MF文件，不能压缩打包。所以直接用下面命令行打包即可。</p>\n<pre><code>shell&gt;jar cvf0M core.jar BOOT-INF META-INF org\n</code></pre><p>执行完在当前目录下应该出现core.jar的新jar包。</p>\n<p>5.验证新jar包是否可执行（正确打包）</p>\n<pre><code>shell&gt;jar cvf0M core.jar BOOT-INF META-INF org\n</code></pre><p>如果能正常启动，则重新打包成功</p>\n"},{"title":"teamcity持续集成使用","date":"2017-10-30T01:18:57.000Z","_content":"","source":"_posts/teamcity-use-start.md","raw":"---\ntitle: teamcity持续集成使用\ndate: 2017-10-30 09:18:57\ncategories: teamcity\ntags: teamcity-start\n---\n","slug":"teamcity-use-start","published":1,"updated":"2018-11-09T01:20:30.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38nk008sqcrgws52kj3d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"TypeScript学习(一)","date":"2017-10-13T15:33:23.000Z","_content":"","source":"_posts/tslang-study-one.md","raw":"---\ntitle: TypeScript学习(一)\ndate: 2017-10-13 23:33:23\ncategories: TypeScript\ntags: \n---\n","slug":"tslang-study-one","published":1,"updated":"2018-11-09T01:20:30.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38nm008uqcrgkz37oqse","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"通过Xshell登录vagrant虚拟机","date":"2018-11-15T07:00:40.000Z","_content":"\n在windows系统环境中，可以在命令行窗口中通过`vagrant ssh`登录`vagrant`虚拟机，但是操作有诸多不便，比如复制粘贴…… \n于是，我们想到了`Xshell`。下面介绍通过`Xshell`来登录`vagrant`虚拟机。 \n\n## 使用`vagrant`账号登录\n\nVagrant虚拟机默认登录账号为`vagrant`,且通过私钥登录。 \n\n在虚拟机 vagrantfile 的目录位置下进行。\n\n1.启动虚拟机\n\n    Xshell 6 (Build 0101)\n    Copyright (c) 2002 NetSarang Computer, Inc. All rights reserved.\n    \n    Type `help' to learn how to use Xshell prompt.\n    [d:\\~]$ cd G:\\xr-server\\xr-server\n    [G:\\xr-server\\xr-server]$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Machine already provisioned. Run `vagrant provision` or use the `--provision`\n    ==> default: flag to force provisioning. Provisioners marked to run always will still run.\n    \n    [G:\\xr-server\\xr-server]$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Importing base box 'centos/7'...\n    ==> default: Matching MAC address for NAT networking...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Setting the name of the VM: centos7_xr-server\n    ==> default: Clearing any previously set network interfaces...\n    ==> default: Preparing network interfaces based on configuration...\n        default: Adapter 1: nat\n    ==> default: Forwarding ports...\n        default: 22 (guest) => 2222 (host) (adapter 1)\n    ==> default: Running 'pre-boot' VM customizations...\n    ==> default: Booting VM...\n    ==> default: Waiting for machine to boot. This may take a few minutes...\n        default: SSH address: 127.0.0.1:2222\n        default: SSH username: vagrant\n        default: SSH auth method: private key\n        default: \n        default: Vagrant insecure key detected. Vagrant will automatically replace\n        default: this with a newly generated keypair for better security.\n        default: \n        default: Inserting generated public key within guest...\n        default: Removing insecure key from the guest if it's present...\n        default: Key inserted! Disconnecting and reconnecting using new SSH key...\n    ==> default: Machine booted and ready!\n    ==> default: Checking for guest additions in VM...\n        default: No guest additions were detected on the base box for this VM! Guest\n        default: additions are required for forwarded ports, shared folders, host only\n        default: networking, and more. If SSH fails on this machine, please install\n        default: the guest additions and repackage the box to continue.\n        default: \n        default: This is not an error message; everything may continue to work properly,\n        default: in which case you may ignore this message.\n    ==> default: Setting hostname...\n    ==> default: Rsyncing folder: /cygdrive/g/xr-server/xr-server/ => /vagrant\n\n2.查看虚拟机ssh信息\n\n    [G:\\xr-server\\xr-server]$ vagrant ssh-config\n    Host default\n      HostName 127.0.0.1\n      User vagrant\n      Port 2222\n      UserKnownHostsFile /dev/null\n      StrictHostKeyChecking no\n      PasswordAuthentication no\n      IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key\n      IdentitiesOnly yes\n      LogLevel FATAL\n\n查看 hostname ，port，IdentityFile 这三个位置。知道登录主机，端口，登录私钥。\n\n3.在Xshell下新建会话，登录\n\n{%asset_img a-1.png%}\n\n点击连接，如下图：\n\n{%asset_img a-2.png%}\n\n点击确定，如下图：\n\n{%asset_img a-3.png%}\n\n选定私钥。位置在`IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key`\n\n登录成功：\n\n    Connecting to 127.0.0.1:2222...\n    Connection established.\n    To escape to local shell, press 'Ctrl+Alt+]'.\n    \n    WARNING! The remote SSH server rejected X11 forwarding request.\n    Last login: Thu Nov 15 07:31:28 2018 from 10.0.2.2\n    [vagrant@xr-server ~]$ ll\n    total 0\n    [vagrant@xr-server ~]$ cd /\n    [vagrant@xr-server /]$ \n\n\n## root账号登录\n\n1.vagrant登陆后，切换到root账号，vagrant虚拟机的root账号密码默认为`vagrant`  \n如果root没有初始化，则可以设置root的密码：   \n\n    [vagrant@xr-server ~]$ su root\n    Password: \n    [root@xr-server vagrant]# \n\n2.修改 /etc/ssh/sshd_config 文件，（注意，vagrant用户下这个文件是只读的，可能什么也看不见）   \n\n- 修改 ssd_config 里 PermitRootLogin属性 改为yes ，并把前面的# 去掉\n\n`[root@xr-server vagrant]# vim /etc/ssh/sshd_config`\n\n{%asset_img b-1.png%}\n\n保存退出。\n\n- PasswordAuthentication 改为yes 并且去掉 #\n\n{%asset_img b-2.png%}\n\n保存退出。\n\n3.保存退出，重启sshd服务     \n`$ systemctl restart sshd`\n或者\n`systemctl restart sshd.service`\n\n_问题_：虽然xshell里都是用127.0.0.1:2222或者2200 这种登录的，但是也可以使用自己设置的ip 例如192.16.25.11:22 去登录，这里用自己设置的ip时端口则是22。\n设置完成以后就和自己开的虚拟机没什么两样了。\n\n\n","source":"_posts/vagrant-Xshell.md","raw":"---\ntitle: 通过Xshell登录vagrant虚拟机\ndate: 2018-11-15 15:00:40\ncategories: vagrant\ntags:\n---\n\n在windows系统环境中，可以在命令行窗口中通过`vagrant ssh`登录`vagrant`虚拟机，但是操作有诸多不便，比如复制粘贴…… \n于是，我们想到了`Xshell`。下面介绍通过`Xshell`来登录`vagrant`虚拟机。 \n\n## 使用`vagrant`账号登录\n\nVagrant虚拟机默认登录账号为`vagrant`,且通过私钥登录。 \n\n在虚拟机 vagrantfile 的目录位置下进行。\n\n1.启动虚拟机\n\n    Xshell 6 (Build 0101)\n    Copyright (c) 2002 NetSarang Computer, Inc. All rights reserved.\n    \n    Type `help' to learn how to use Xshell prompt.\n    [d:\\~]$ cd G:\\xr-server\\xr-server\n    [G:\\xr-server\\xr-server]$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Machine already provisioned. Run `vagrant provision` or use the `--provision`\n    ==> default: flag to force provisioning. Provisioners marked to run always will still run.\n    \n    [G:\\xr-server\\xr-server]$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Importing base box 'centos/7'...\n    ==> default: Matching MAC address for NAT networking...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Setting the name of the VM: centos7_xr-server\n    ==> default: Clearing any previously set network interfaces...\n    ==> default: Preparing network interfaces based on configuration...\n        default: Adapter 1: nat\n    ==> default: Forwarding ports...\n        default: 22 (guest) => 2222 (host) (adapter 1)\n    ==> default: Running 'pre-boot' VM customizations...\n    ==> default: Booting VM...\n    ==> default: Waiting for machine to boot. This may take a few minutes...\n        default: SSH address: 127.0.0.1:2222\n        default: SSH username: vagrant\n        default: SSH auth method: private key\n        default: \n        default: Vagrant insecure key detected. Vagrant will automatically replace\n        default: this with a newly generated keypair for better security.\n        default: \n        default: Inserting generated public key within guest...\n        default: Removing insecure key from the guest if it's present...\n        default: Key inserted! Disconnecting and reconnecting using new SSH key...\n    ==> default: Machine booted and ready!\n    ==> default: Checking for guest additions in VM...\n        default: No guest additions were detected on the base box for this VM! Guest\n        default: additions are required for forwarded ports, shared folders, host only\n        default: networking, and more. If SSH fails on this machine, please install\n        default: the guest additions and repackage the box to continue.\n        default: \n        default: This is not an error message; everything may continue to work properly,\n        default: in which case you may ignore this message.\n    ==> default: Setting hostname...\n    ==> default: Rsyncing folder: /cygdrive/g/xr-server/xr-server/ => /vagrant\n\n2.查看虚拟机ssh信息\n\n    [G:\\xr-server\\xr-server]$ vagrant ssh-config\n    Host default\n      HostName 127.0.0.1\n      User vagrant\n      Port 2222\n      UserKnownHostsFile /dev/null\n      StrictHostKeyChecking no\n      PasswordAuthentication no\n      IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key\n      IdentitiesOnly yes\n      LogLevel FATAL\n\n查看 hostname ，port，IdentityFile 这三个位置。知道登录主机，端口，登录私钥。\n\n3.在Xshell下新建会话，登录\n\n{%asset_img a-1.png%}\n\n点击连接，如下图：\n\n{%asset_img a-2.png%}\n\n点击确定，如下图：\n\n{%asset_img a-3.png%}\n\n选定私钥。位置在`IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key`\n\n登录成功：\n\n    Connecting to 127.0.0.1:2222...\n    Connection established.\n    To escape to local shell, press 'Ctrl+Alt+]'.\n    \n    WARNING! The remote SSH server rejected X11 forwarding request.\n    Last login: Thu Nov 15 07:31:28 2018 from 10.0.2.2\n    [vagrant@xr-server ~]$ ll\n    total 0\n    [vagrant@xr-server ~]$ cd /\n    [vagrant@xr-server /]$ \n\n\n## root账号登录\n\n1.vagrant登陆后，切换到root账号，vagrant虚拟机的root账号密码默认为`vagrant`  \n如果root没有初始化，则可以设置root的密码：   \n\n    [vagrant@xr-server ~]$ su root\n    Password: \n    [root@xr-server vagrant]# \n\n2.修改 /etc/ssh/sshd_config 文件，（注意，vagrant用户下这个文件是只读的，可能什么也看不见）   \n\n- 修改 ssd_config 里 PermitRootLogin属性 改为yes ，并把前面的# 去掉\n\n`[root@xr-server vagrant]# vim /etc/ssh/sshd_config`\n\n{%asset_img b-1.png%}\n\n保存退出。\n\n- PasswordAuthentication 改为yes 并且去掉 #\n\n{%asset_img b-2.png%}\n\n保存退出。\n\n3.保存退出，重启sshd服务     \n`$ systemctl restart sshd`\n或者\n`systemctl restart sshd.service`\n\n_问题_：虽然xshell里都是用127.0.0.1:2222或者2200 这种登录的，但是也可以使用自己设置的ip 例如192.16.25.11:22 去登录，这里用自己设置的ip时端口则是22。\n设置完成以后就和自己开的虚拟机没什么两样了。\n\n\n","slug":"vagrant-Xshell","published":1,"updated":"2018-11-15T07:53:32.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38no008yqcrgiqvh5vjg","content":"<p>在windows系统环境中，可以在命令行窗口中通过<code>vagrant ssh</code>登录<code>vagrant</code>虚拟机，但是操作有诸多不便，比如复制粘贴……<br>于是，我们想到了<code>Xshell</code>。下面介绍通过<code>Xshell</code>来登录<code>vagrant</code>虚拟机。 </p>\n<h2 id=\"使用vagrant账号登录\"><a href=\"#使用vagrant账号登录\" class=\"headerlink\" title=\"使用vagrant账号登录\"></a>使用<code>vagrant</code>账号登录</h2><p>Vagrant虚拟机默认登录账号为<code>vagrant</code>,且通过私钥登录。 </p>\n<p>在虚拟机 vagrantfile 的目录位置下进行。</p>\n<p>1.启动虚拟机</p>\n<pre><code>Xshell 6 (Build 0101)\nCopyright (c) 2002 NetSarang Computer, Inc. All rights reserved.\n\nType `help&apos; to learn how to use Xshell prompt.\n[d:\\~]$ cd G:\\xr-server\\xr-server\n[G:\\xr-server\\xr-server]$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Machine already provisioned. Run `vagrant provision` or use the `--provision`\n==&gt; default: flag to force provisioning. Provisioners marked to run always will still run.\n\n[G:\\xr-server\\xr-server]$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Importing base box &apos;centos/7&apos;...\n==&gt; default: Matching MAC address for NAT networking...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Setting the name of the VM: centos7_xr-server\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Running &apos;pre-boot&apos; VM customizations...\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n    default: \n    default: Vagrant insecure key detected. Vagrant will automatically replace\n    default: this with a newly generated keypair for better security.\n    default: \n    default: Inserting generated public key within guest...\n    default: Removing insecure key from the guest if it&apos;s present...\n    default: Key inserted! Disconnecting and reconnecting using new SSH key...\n==&gt; default: Machine booted and ready!\n==&gt; default: Checking for guest additions in VM...\n    default: No guest additions were detected on the base box for this VM! Guest\n    default: additions are required for forwarded ports, shared folders, host only\n    default: networking, and more. If SSH fails on this machine, please install\n    default: the guest additions and repackage the box to continue.\n    default: \n    default: This is not an error message; everything may continue to work properly,\n    default: in which case you may ignore this message.\n==&gt; default: Setting hostname...\n==&gt; default: Rsyncing folder: /cygdrive/g/xr-server/xr-server/ =&gt; /vagrant\n</code></pre><p>2.查看虚拟机ssh信息</p>\n<pre><code>[G:\\xr-server\\xr-server]$ vagrant ssh-config\nHost default\n  HostName 127.0.0.1\n  User vagrant\n  Port 2222\n  UserKnownHostsFile /dev/null\n  StrictHostKeyChecking no\n  PasswordAuthentication no\n  IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key\n  IdentitiesOnly yes\n  LogLevel FATAL\n</code></pre><p>查看 hostname ，port，IdentityFile 这三个位置。知道登录主机，端口，登录私钥。</p>\n<p>3.在Xshell下新建会话，登录</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-1.png\">\n<p>点击连接，如下图：</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-2.png\">\n<p>点击确定，如下图：</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-3.png\">\n<p>选定私钥。位置在<code>IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key</code></p>\n<p>登录成功：</p>\n<pre><code>Connecting to 127.0.0.1:2222...\nConnection established.\nTo escape to local shell, press &apos;Ctrl+Alt+]&apos;.\n\nWARNING! The remote SSH server rejected X11 forwarding request.\nLast login: Thu Nov 15 07:31:28 2018 from 10.0.2.2\n[vagrant@xr-server ~]$ ll\ntotal 0\n[vagrant@xr-server ~]$ cd /\n[vagrant@xr-server /]$ \n</code></pre><h2 id=\"root账号登录\"><a href=\"#root账号登录\" class=\"headerlink\" title=\"root账号登录\"></a>root账号登录</h2><p>1.vagrant登陆后，切换到root账号，vagrant虚拟机的root账号密码默认为<code>vagrant</code><br>如果root没有初始化，则可以设置root的密码：   </p>\n<pre><code>[vagrant@xr-server ~]$ su root\nPassword: \n[root@xr-server vagrant]# \n</code></pre><p>2.修改 /etc/ssh/sshd_config 文件，（注意，vagrant用户下这个文件是只读的，可能什么也看不见）   </p>\n<ul>\n<li>修改 ssd_config 里 PermitRootLogin属性 改为yes ，并把前面的# 去掉</li>\n</ul>\n<p><code>[root@xr-server vagrant]# vim /etc/ssh/sshd_config</code></p>\n<img src=\"/2018/11/15/vagrant-Xshell/b-1.png\">\n<p>保存退出。</p>\n<ul>\n<li>PasswordAuthentication 改为yes 并且去掉 #</li>\n</ul>\n<img src=\"/2018/11/15/vagrant-Xshell/b-2.png\">\n<p>保存退出。</p>\n<p>3.保存退出，重启sshd服务<br><code>$ systemctl restart sshd</code><br>或者<br><code>systemctl restart sshd.service</code></p>\n<p>_问题_：虽然xshell里都是用127.0.0.1:2222或者2200 这种登录的，但是也可以使用自己设置的ip 例如192.16.25.11:22 去登录，这里用自己设置的ip时端口则是22。<br>设置完成以后就和自己开的虚拟机没什么两样了。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在windows系统环境中，可以在命令行窗口中通过<code>vagrant ssh</code>登录<code>vagrant</code>虚拟机，但是操作有诸多不便，比如复制粘贴……<br>于是，我们想到了<code>Xshell</code>。下面介绍通过<code>Xshell</code>来登录<code>vagrant</code>虚拟机。 </p>\n<h2 id=\"使用vagrant账号登录\"><a href=\"#使用vagrant账号登录\" class=\"headerlink\" title=\"使用vagrant账号登录\"></a>使用<code>vagrant</code>账号登录</h2><p>Vagrant虚拟机默认登录账号为<code>vagrant</code>,且通过私钥登录。 </p>\n<p>在虚拟机 vagrantfile 的目录位置下进行。</p>\n<p>1.启动虚拟机</p>\n<pre><code>Xshell 6 (Build 0101)\nCopyright (c) 2002 NetSarang Computer, Inc. All rights reserved.\n\nType `help&apos; to learn how to use Xshell prompt.\n[d:\\~]$ cd G:\\xr-server\\xr-server\n[G:\\xr-server\\xr-server]$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Machine already provisioned. Run `vagrant provision` or use the `--provision`\n==&gt; default: flag to force provisioning. Provisioners marked to run always will still run.\n\n[G:\\xr-server\\xr-server]$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Importing base box &apos;centos/7&apos;...\n==&gt; default: Matching MAC address for NAT networking...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Setting the name of the VM: centos7_xr-server\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Running &apos;pre-boot&apos; VM customizations...\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n    default: \n    default: Vagrant insecure key detected. Vagrant will automatically replace\n    default: this with a newly generated keypair for better security.\n    default: \n    default: Inserting generated public key within guest...\n    default: Removing insecure key from the guest if it&apos;s present...\n    default: Key inserted! Disconnecting and reconnecting using new SSH key...\n==&gt; default: Machine booted and ready!\n==&gt; default: Checking for guest additions in VM...\n    default: No guest additions were detected on the base box for this VM! Guest\n    default: additions are required for forwarded ports, shared folders, host only\n    default: networking, and more. If SSH fails on this machine, please install\n    default: the guest additions and repackage the box to continue.\n    default: \n    default: This is not an error message; everything may continue to work properly,\n    default: in which case you may ignore this message.\n==&gt; default: Setting hostname...\n==&gt; default: Rsyncing folder: /cygdrive/g/xr-server/xr-server/ =&gt; /vagrant\n</code></pre><p>2.查看虚拟机ssh信息</p>\n<pre><code>[G:\\xr-server\\xr-server]$ vagrant ssh-config\nHost default\n  HostName 127.0.0.1\n  User vagrant\n  Port 2222\n  UserKnownHostsFile /dev/null\n  StrictHostKeyChecking no\n  PasswordAuthentication no\n  IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key\n  IdentitiesOnly yes\n  LogLevel FATAL\n</code></pre><p>查看 hostname ，port，IdentityFile 这三个位置。知道登录主机，端口，登录私钥。</p>\n<p>3.在Xshell下新建会话，登录</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-1.png\">\n<p>点击连接，如下图：</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-2.png\">\n<p>点击确定，如下图：</p>\n<img src=\"/2018/11/15/vagrant-Xshell/a-3.png\">\n<p>选定私钥。位置在<code>IdentityFile G:/xr-server/xr-server/.vagrant/machines/default/virtualbox/private_key</code></p>\n<p>登录成功：</p>\n<pre><code>Connecting to 127.0.0.1:2222...\nConnection established.\nTo escape to local shell, press &apos;Ctrl+Alt+]&apos;.\n\nWARNING! The remote SSH server rejected X11 forwarding request.\nLast login: Thu Nov 15 07:31:28 2018 from 10.0.2.2\n[vagrant@xr-server ~]$ ll\ntotal 0\n[vagrant@xr-server ~]$ cd /\n[vagrant@xr-server /]$ \n</code></pre><h2 id=\"root账号登录\"><a href=\"#root账号登录\" class=\"headerlink\" title=\"root账号登录\"></a>root账号登录</h2><p>1.vagrant登陆后，切换到root账号，vagrant虚拟机的root账号密码默认为<code>vagrant</code><br>如果root没有初始化，则可以设置root的密码：   </p>\n<pre><code>[vagrant@xr-server ~]$ su root\nPassword: \n[root@xr-server vagrant]# \n</code></pre><p>2.修改 /etc/ssh/sshd_config 文件，（注意，vagrant用户下这个文件是只读的，可能什么也看不见）   </p>\n<ul>\n<li>修改 ssd_config 里 PermitRootLogin属性 改为yes ，并把前面的# 去掉</li>\n</ul>\n<p><code>[root@xr-server vagrant]# vim /etc/ssh/sshd_config</code></p>\n<img src=\"/2018/11/15/vagrant-Xshell/b-1.png\">\n<p>保存退出。</p>\n<ul>\n<li>PasswordAuthentication 改为yes 并且去掉 #</li>\n</ul>\n<img src=\"/2018/11/15/vagrant-Xshell/b-2.png\">\n<p>保存退出。</p>\n<p>3.保存退出，重启sshd服务<br><code>$ systemctl restart sshd</code><br>或者<br><code>systemctl restart sshd.service</code></p>\n<p>_问题_：虽然xshell里都是用127.0.0.1:2222或者2200 这种登录的，但是也可以使用自己设置的ip 例如192.16.25.11:22 去登录，这里用自己设置的ip时端口则是22。<br>设置完成以后就和自己开的虚拟机没什么两样了。</p>\n"},{"title":"vagrant常用命令","date":"2018-11-15T09:52:14.000Z","_content":"\nhttps://www.vagrantup.com/docs/cli/","source":"_posts/vagrant-cli.md","raw":"---\ntitle: vagrant常用命令\ndate: 2018-11-15 17:52:14\ncategories: vagrant\ntags:\n---\n\nhttps://www.vagrantup.com/docs/cli/","slug":"vagrant-cli","published":1,"updated":"2018-11-15T09:53:40.673Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38np0090qcrgc88npqk9","content":"<p><a href=\"https://www.vagrantup.com/docs/cli/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/cli/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.vagrantup.com/docs/cli/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/cli/</a></p>\n"},{"title":"vagrant各种配置介绍","date":"2018-11-15T09:55:52.000Z","_content":"\nhttps://www.vagrantup.com/docs/vagrantfile/","source":"_posts/vagrant-vagrantfile.md","raw":"---\ntitle: vagrant各种配置介绍\ndate: 2018-11-15 17:55:52\ncategories: vagrant\ntags:\n---\n\nhttps://www.vagrantup.com/docs/vagrantfile/","slug":"vagrant-vagrantfile","published":1,"updated":"2018-11-15T09:56:35.622Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38nr0094qcrgr6axj54j","content":"<p><a href=\"https://www.vagrantup.com/docs/vagrantfile/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/vagrantfile/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://www.vagrantup.com/docs/vagrantfile/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/docs/vagrantfile/</a></p>\n"},{"title":"网站的高性能","date":"2017-10-13T02:33:45.000Z","_content":"_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","source":"_posts/website-high-performance.md","raw":"---\ntitle: 网站的高性能\ndate: 2017-10-13 10:33:45\ncategories: 架构\ntags: website-high-performance\n---\n_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","slug":"website-high-performance","published":1,"updated":"2018-11-09T01:20:30.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38ns0096qcrgoniwylgc","content":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n</blockquote>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol start=\"2\">\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol start=\"3\">\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol start=\"4\">\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol start=\"5\">\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>","site":{"data":{}},"excerpt":"","more":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n</blockquote>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol start=\"2\">\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol start=\"3\">\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol start=\"4\">\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol start=\"5\">\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>"},{"title":"redis发布订阅特性介绍","date":"2018-06-11T09:24:37.000Z","_content":"","source":"_posts/redis-pub-sub.md","raw":"---\ntitle: redis发布订阅特性介绍\ndate: 2018-06-11 17:24:37\ncategories: redis\ntags: redis发布订阅\n---\n","slug":"redis-pub-sub","published":1,"updated":"2018-11-09T01:20:30.311Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38nu009aqcrg96dxxtog","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"zookeeper-curator","date":"2018-06-28T02:01:04.000Z","_content":"","source":"_posts/zookeeper-curator.md","raw":"---\ntitle: zookeeper-curator\ndate: 2018-06-28 10:01:04\ncategories: zookeeper\ntags: apache curator\n---\n","slug":"zookeeper-curator","published":1,"updated":"2018-11-09T01:20:31.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38nv009bqcrgyxqyge7h","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"zookeeper-start","date":"2018-06-28T02:00:46.000Z","_content":"","source":"_posts/zookeeper-start.md","raw":"---\ntitle: zookeeper-start\ndate: 2018-06-28 10:00:46\ncategories: zookeeper\ntags: zookeeper安装使用\n---\n","slug":"zookeeper-start","published":1,"updated":"2018-11-09T01:20:31.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38nx009gqcrgqcetecug","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"wkhtmltopdf使用记录","date":"2018-06-19T10:32:21.000Z","_content":"\nhtml转pdf工具wkhtmltopdf的使用记录……\n\n官网：https://wkhtmltopdf.org/\n\n## centos下安装环境\n\n1.依赖包安装： `yum install zlib fontconfig freetype libX11 libXext libXrender` \n\n\n## 使用问题收集\n\n1.中文字体乱码的问题。\n\nlinux：把字体{%asset_link simsun.ttc simsun.ttc%}添加到系统`usr/share/fonts`下。\n\n2.设定纸张大小，内容随纸张大小。\n\n3.Arial字体\n\n直接把{%asset_link Arial.zip Arial%}中相关字体文件添加到系统`usr/share/fonts`。\n\n参考：https://blog.csdn.net/churujianghu/article/details/75076255\n\n示例：     \n./wkhtmltopdf --page-height 5cm --page-width 7cm --margin-bottom 0cm --margin-top 0.1cm --margin-left 0.1cm --margin-right 0cm --disable-smart-shrinking   label.html label.html label.html label.pdf\n","source":"_posts/wkhtmltopdf.md","raw":"---\ntitle: wkhtmltopdf使用记录\ndate: 2018-06-19 18:32:21\ncategories: pdf\ntags: wkhtmltopdf\n---\n\nhtml转pdf工具wkhtmltopdf的使用记录……\n\n官网：https://wkhtmltopdf.org/\n\n## centos下安装环境\n\n1.依赖包安装： `yum install zlib fontconfig freetype libX11 libXext libXrender` \n\n\n## 使用问题收集\n\n1.中文字体乱码的问题。\n\nlinux：把字体{%asset_link simsun.ttc simsun.ttc%}添加到系统`usr/share/fonts`下。\n\n2.设定纸张大小，内容随纸张大小。\n\n3.Arial字体\n\n直接把{%asset_link Arial.zip Arial%}中相关字体文件添加到系统`usr/share/fonts`。\n\n参考：https://blog.csdn.net/churujianghu/article/details/75076255\n\n示例：     \n./wkhtmltopdf --page-height 5cm --page-width 7cm --margin-bottom 0cm --margin-top 0.1cm --margin-left 0.1cm --margin-right 0cm --disable-smart-shrinking   label.html label.html label.html label.pdf\n","slug":"wkhtmltopdf","published":1,"updated":"2018-11-09T01:20:30.966Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38ny009hqcrgsnl5yzsk","content":"<p>html转pdf工具wkhtmltopdf的使用记录……</p>\n<p>官网：<a href=\"https://wkhtmltopdf.org/\" target=\"_blank\" rel=\"noopener\">https://wkhtmltopdf.org/</a></p>\n<h2 id=\"centos下安装环境\"><a href=\"#centos下安装环境\" class=\"headerlink\" title=\"centos下安装环境\"></a>centos下安装环境</h2><p>1.依赖包安装： <code>yum install zlib fontconfig freetype libX11 libXext libXrender</code> </p>\n<h2 id=\"使用问题收集\"><a href=\"#使用问题收集\" class=\"headerlink\" title=\"使用问题收集\"></a>使用问题收集</h2><p>1.中文字体乱码的问题。</p>\n<p>linux：把字体<a href=\"/2018/06/19/wkhtmltopdf/simsun.ttc\" title=\"simsun.ttc\">simsun.ttc</a>添加到系统<code>usr/share/fonts</code>下。</p>\n<p>2.设定纸张大小，内容随纸张大小。</p>\n<p>3.Arial字体</p>\n<p>直接把<a href=\"/2018/06/19/wkhtmltopdf/Arial.zip\" title=\"Arial\">Arial</a>中相关字体文件添加到系统<code>usr/share/fonts</code>。</p>\n<p>参考：<a href=\"https://blog.csdn.net/churujianghu/article/details/75076255\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/churujianghu/article/details/75076255</a></p>\n<p>示例：<br>./wkhtmltopdf –page-height 5cm –page-width 7cm –margin-bottom 0cm –margin-top 0.1cm –margin-left 0.1cm –margin-right 0cm –disable-smart-shrinking   label.html label.html label.html label.pdf</p>\n","site":{"data":{}},"excerpt":"","more":"<p>html转pdf工具wkhtmltopdf的使用记录……</p>\n<p>官网：<a href=\"https://wkhtmltopdf.org/\" target=\"_blank\" rel=\"noopener\">https://wkhtmltopdf.org/</a></p>\n<h2 id=\"centos下安装环境\"><a href=\"#centos下安装环境\" class=\"headerlink\" title=\"centos下安装环境\"></a>centos下安装环境</h2><p>1.依赖包安装： <code>yum install zlib fontconfig freetype libX11 libXext libXrender</code> </p>\n<h2 id=\"使用问题收集\"><a href=\"#使用问题收集\" class=\"headerlink\" title=\"使用问题收集\"></a>使用问题收集</h2><p>1.中文字体乱码的问题。</p>\n<p>linux：把字体<a href=\"/2018/06/19/wkhtmltopdf/simsun.ttc\" title=\"simsun.ttc\">simsun.ttc</a>添加到系统<code>usr/share/fonts</code>下。</p>\n<p>2.设定纸张大小，内容随纸张大小。</p>\n<p>3.Arial字体</p>\n<p>直接把<a href=\"/2018/06/19/wkhtmltopdf/Arial.zip\" title=\"Arial\">Arial</a>中相关字体文件添加到系统<code>usr/share/fonts</code>。</p>\n<p>参考：<a href=\"https://blog.csdn.net/churujianghu/article/details/75076255\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/churujianghu/article/details/75076255</a></p>\n<p>示例：<br>./wkhtmltopdf –page-height 5cm –page-width 7cm –margin-bottom 0cm –margin-top 0.1cm –margin-left 0.1cm –margin-right 0cm –disable-smart-shrinking   label.html label.html label.html label.pdf</p>\n"},{"title":"rest-api版本迭代管理实践","date":"2017-09-26T06:23:44.000Z","_content":"\n在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。  \n因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  \n\n通常，restful-api的版本迭代实现方式主要又两种：\n\n- 在url中显示设置，如：`https://api.example.com/v1/`。\n- 在http请求头中添加，如：\n        \n        设置请求头：\n        Content-Version: 1\n        \n        请求:\n        https://api.example.com\n \n-------------------------------------------------------------\n \n首先，建立spring-boot-web项目：\n\n{% asset_img a.png %}\n \n        \n## 在请求头中设置\n\n1.创建注解类ApiVersion\n在controller中添加注解标志api版本\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.bind.annotation.Mapping;\n    \n    import java.lang.annotation.*;\n    \n    /**\n     * \n     * 接口版本标识注解\n     *\n     */\n    @Target({ElementType.METHOD, ElementType.TYPE})\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Mapping\n    public @interface ApiVersion {\n        int value();\n    }\n\n2.创建处理类ApiVersionCondition\n继承RequestCondition，每次url请求都会首先进入该方法。\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import java.util.regex.Pattern;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        private int apiVersion;\n    \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n    \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        \tString path = request.getServletPath();\n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n    \t\tString contentVersion = request.getHeader(\"Content-Version\"); //在http请求头中定义api版本，而不是在url中\n            if (null == contentVersion || \"\".equals(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version非null非空\");\n            }\n            if (!isInteger(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version必须为整数\");\n            }\n    \n            int version = Integer.valueOf(contentVersion).intValue();\n            if(version >= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n        /**\n         * 判断字符串是否为整数。\n         * @param str\n         * @return\n         */\n        private boolean isInteger(String str) {\n            Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\");\n            return pattern.matcher(str).matches();\n        }\n    \n    }\n    \n3.自定义url注册回调类CustomRequestMappingHandlerMapping\nurl注解回调句柄类。继承RequestMappingHandlerMapping。\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 类。\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        /**\n         * 方法\n         * @param method\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n    \n\n4.创建web配置类并编辑内容：WebConfig\n配置自定义类RequestMappingHandlerMapping。\n    \n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    @Configuration\n    public class WebConfig extends WebMvcConfigurationSupport{\n    \n        @Override\n        @Bean\n        public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n            RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n            handlerMapping.setOrder(0);\n            handlerMapping.setInterceptors(getInterceptors()); \n            return handlerMapping;\n        }\n        \n    }\n\n5.创建演示类HelloController\n\n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.ApiVersion;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.RequestMethod;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    @RestController\n    @RequestMapping\n    public class HelloController {\n    \t\n    \t//---------------- api版本管理 demo start ------------------//\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        public String hello0(HttpServletRequest request){\n            print(request);\n            return \"hello\";\n        }\n    \n    \t@RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(1)\n        public String hello1(HttpServletRequest request){\n            print(request);\n            return \"hello:v1\";\n        }\n    \n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(5)\n        public String hello5(HttpServletRequest request){\n            print(request);\n            return \"hello:v5\";\n        }\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(2)\n        public String hello2(HttpServletRequest request){\n            print(request);\n            return \"hello:v2\";\n        }\n    \n        private void print(HttpServletRequest request) {\n            System.out.println(\"version:\" + request.getHeader(\"Content-Version\"));\n        }\n        \n    }    \n\n6.演示：\n\n{% asset_img b.png %}\n\n------------------------------\n\n{% asset_img c.png %}\n    \n\n## 在url中显示设置\n\n在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 \n\n1.修改CustomRequestMappingHandlerMapping类。\n只需要重写方法：\n\n    /**\n     * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set<String> s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(\"\");\n            if (s != null && !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!\"/error\".equals(str)) {\n                        pathNew.append(\"/{version}\");\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n        \n    -----------------------------------------------------\n        \n    完整代码如下：    \n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.RequestMappingInfo;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    import java.util.Set;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n         * 不用在每个类或方法的@RequestMapping中加。\n         * @param method\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n            RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n            if (requestMappingInfo != null) {\n                PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n                Set<String> s = pcOri.getPatterns();\n                StringBuilder pathNew = new StringBuilder(\"\");\n                if (s != null && !s.isEmpty()) {\n                    for (String str: s ) {\n                        if (!\"/error\".equals(str)) {\n                            pathNew.append(\"/{version}\");\n                            pathNew.append(str);\n                        } else {\n                            pathNew.append(str);\n                        }\n                    }\n                }\n    \n                PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n    \n                RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n    \n                return requestMappingInfoNew;\n    \n            }\n            return requestMappingInfo;\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n\n2.修改类ApiVersionCondition。\n主要修改方法：getMatchingCondition\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n    \n    -----------------------------------------------------------\n    \n    完整代码如下：\n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import java.util.regex.Matcher;\n    import java.util.regex.Pattern;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n        private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(\"v(\\\\d+)/\");\n        \n        private int apiVersion;\n        \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n        \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        \tString path = request.getServletPath(); \n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n            Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n            if(m.find()){\n                Integer version = Integer.valueOf(m.group(1));\n                if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                    return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n    }\n\n3.演示：\n\n{%asset_img d.png%}\n\n--------------------------------------\n\n{%asset_img e.png%}\n\n   ","source":"_posts/api-version.md","raw":"---\ntitle: rest-api版本迭代管理实践\ndate: 2017-09-26 14:23:44\ncategories: api-manage\ntags: api-version-manage,spring-boot中API版本迭代管理\n---\n\n在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。  \n因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  \n\n通常，restful-api的版本迭代实现方式主要又两种：\n\n- 在url中显示设置，如：`https://api.example.com/v1/`。\n- 在http请求头中添加，如：\n        \n        设置请求头：\n        Content-Version: 1\n        \n        请求:\n        https://api.example.com\n \n-------------------------------------------------------------\n \n首先，建立spring-boot-web项目：\n\n{% asset_img a.png %}\n \n        \n## 在请求头中设置\n\n1.创建注解类ApiVersion\n在controller中添加注解标志api版本\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.bind.annotation.Mapping;\n    \n    import java.lang.annotation.*;\n    \n    /**\n     * \n     * 接口版本标识注解\n     *\n     */\n    @Target({ElementType.METHOD, ElementType.TYPE})\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Mapping\n    public @interface ApiVersion {\n        int value();\n    }\n\n2.创建处理类ApiVersionCondition\n继承RequestCondition，每次url请求都会首先进入该方法。\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import java.util.regex.Pattern;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        private int apiVersion;\n    \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n    \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        \tString path = request.getServletPath();\n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n    \t\tString contentVersion = request.getHeader(\"Content-Version\"); //在http请求头中定义api版本，而不是在url中\n            if (null == contentVersion || \"\".equals(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version非null非空\");\n            }\n            if (!isInteger(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version必须为整数\");\n            }\n    \n            int version = Integer.valueOf(contentVersion).intValue();\n            if(version >= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n        /**\n         * 判断字符串是否为整数。\n         * @param str\n         * @return\n         */\n        private boolean isInteger(String str) {\n            Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\");\n            return pattern.matcher(str).matches();\n        }\n    \n    }\n    \n3.自定义url注册回调类CustomRequestMappingHandlerMapping\nurl注解回调句柄类。继承RequestMappingHandlerMapping。\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 类。\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        /**\n         * 方法\n         * @param method\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n    \n\n4.创建web配置类并编辑内容：WebConfig\n配置自定义类RequestMappingHandlerMapping。\n    \n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    @Configuration\n    public class WebConfig extends WebMvcConfigurationSupport{\n    \n        @Override\n        @Bean\n        public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n            RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n            handlerMapping.setOrder(0);\n            handlerMapping.setInterceptors(getInterceptors()); \n            return handlerMapping;\n        }\n        \n    }\n\n5.创建演示类HelloController\n\n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.ApiVersion;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.RequestMethod;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    @RestController\n    @RequestMapping\n    public class HelloController {\n    \t\n    \t//---------------- api版本管理 demo start ------------------//\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        public String hello0(HttpServletRequest request){\n            print(request);\n            return \"hello\";\n        }\n    \n    \t@RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(1)\n        public String hello1(HttpServletRequest request){\n            print(request);\n            return \"hello:v1\";\n        }\n    \n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(5)\n        public String hello5(HttpServletRequest request){\n            print(request);\n            return \"hello:v5\";\n        }\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(2)\n        public String hello2(HttpServletRequest request){\n            print(request);\n            return \"hello:v2\";\n        }\n    \n        private void print(HttpServletRequest request) {\n            System.out.println(\"version:\" + request.getHeader(\"Content-Version\"));\n        }\n        \n    }    \n\n6.演示：\n\n{% asset_img b.png %}\n\n------------------------------\n\n{% asset_img c.png %}\n    \n\n## 在url中显示设置\n\n在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 \n\n1.修改CustomRequestMappingHandlerMapping类。\n只需要重写方法：\n\n    /**\n     * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set<String> s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(\"\");\n            if (s != null && !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!\"/error\".equals(str)) {\n                        pathNew.append(\"/{version}\");\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n        \n    -----------------------------------------------------\n        \n    完整代码如下：    \n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.RequestMappingInfo;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    import java.util.Set;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n         * 不用在每个类或方法的@RequestMapping中加。\n         * @param method\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n            RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n            if (requestMappingInfo != null) {\n                PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n                Set<String> s = pcOri.getPatterns();\n                StringBuilder pathNew = new StringBuilder(\"\");\n                if (s != null && !s.isEmpty()) {\n                    for (String str: s ) {\n                        if (!\"/error\".equals(str)) {\n                            pathNew.append(\"/{version}\");\n                            pathNew.append(str);\n                        } else {\n                            pathNew.append(str);\n                        }\n                    }\n                }\n    \n                PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n    \n                RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n    \n                return requestMappingInfoNew;\n    \n            }\n            return requestMappingInfo;\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n\n2.修改类ApiVersionCondition。\n主要修改方法：getMatchingCondition\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n    \n    -----------------------------------------------------------\n    \n    完整代码如下：\n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import java.util.regex.Matcher;\n    import java.util.regex.Pattern;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n        private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(\"v(\\\\d+)/\");\n        \n        private int apiVersion;\n        \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n        \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        \tString path = request.getServletPath(); \n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n            Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n            if(m.find()){\n                Integer version = Integer.valueOf(m.group(1));\n                if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                    return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n    }\n\n3.演示：\n\n{%asset_img d.png%}\n\n--------------------------------------\n\n{%asset_img e.png%}\n\n   ","slug":"api-version","published":1,"updated":"2018-11-09T01:20:29.968Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38oz00cmqcrgnoqbte76","content":"<p>在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。<br>因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  </p>\n<p>通常，restful-api的版本迭代实现方式主要又两种：</p>\n<ul>\n<li>在url中显示设置，如：<code>https://api.example.com/v1/</code>。</li>\n<li><p>在http请求头中添加，如：</p>\n<pre><code>设置请求头：\nContent-Version: 1\n\n请求:\nhttps://api.example.com\n</code></pre></li>\n</ul>\n<hr>\n<p>首先，建立spring-boot-web项目：</p>\n<img src=\"/2017/09/26/api-version/a.png\">\n<h2 id=\"在请求头中设置\"><a href=\"#在请求头中设置\" class=\"headerlink\" title=\"在请求头中设置\"></a>在请求头中设置</h2><p>1.创建注解类ApiVersion<br>在controller中添加注解标志api版本</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.bind.annotation.Mapping;\n\nimport java.lang.annotation.*;\n\n/**\n * \n * 接口版本标识注解\n *\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Mapping\npublic @interface ApiVersion {\n    int value();\n}\n</code></pre><p>2.创建处理类ApiVersionCondition<br>继承RequestCondition，每次url请求都会首先进入该方法。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.regex.Pattern;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        String path = request.getServletPath();\n        if (path == null) {\n            return null;\n        }\n        String contentVersion = request.getHeader(&quot;Content-Version&quot;); //在http请求头中定义api版本，而不是在url中\n        if (null == contentVersion || &quot;&quot;.equals(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version非null非空&quot;);\n        }\n        if (!isInteger(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version必须为整数&quot;);\n        }\n\n        int version = Integer.valueOf(contentVersion).intValue();\n        if(version &gt;= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n    /**\n     * 判断字符串是否为整数。\n     * @param str\n     * @return\n     */\n    private boolean isInteger(String str) {\n        Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[\\\\d]*$&quot;);\n        return pattern.matcher(str).matches();\n    }\n\n}\n</code></pre><p>3.自定义url注册回调类CustomRequestMappingHandlerMapping<br>url注解回调句柄类。继承RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 类。\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    /**\n     * 方法\n     * @param method\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>4.创建web配置类并编辑内容：WebConfig<br>配置自定义类RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\n@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport{\n\n    @Override\n    @Bean\n    public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n        RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n        handlerMapping.setOrder(0);\n        handlerMapping.setInterceptors(getInterceptors()); \n        return handlerMapping;\n    }\n\n}\n</code></pre><p>5.创建演示类HelloController</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.ApiVersion;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@RestController\n@RequestMapping\npublic class HelloController {\n\n    //---------------- api版本管理 demo start ------------------//\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    public String hello0(HttpServletRequest request){\n        print(request);\n        return &quot;hello&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(1)\n    public String hello1(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v1&quot;;\n    }\n\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(5)\n    public String hello5(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v5&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(2)\n    public String hello2(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v2&quot;;\n    }\n\n    private void print(HttpServletRequest request) {\n        System.out.println(&quot;version:&quot; + request.getHeader(&quot;Content-Version&quot;));\n    }\n\n}    \n</code></pre><p>6.演示：</p>\n<img src=\"/2017/09/26/api-version/b.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/c.png\">\n<h2 id=\"在url中显示设置\"><a href=\"#在url中显示设置\" class=\"headerlink\" title=\"在url中显示设置\"></a>在url中显示设置</h2><p>在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 </p>\n<p>1.修改CustomRequestMappingHandlerMapping类。<br>只需要重写方法：</p>\n<pre><code>/**\n * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n * 不用在每个类或方法的@RequestMapping中加。\n * @param method\n * @param handlerType\n * @return\n */\n@Override\nprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n    RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n    if (requestMappingInfo != null) {\n        PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n        Set&lt;String&gt; s = pcOri.getPatterns();\n        StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n        if (s != null &amp;&amp; !s.isEmpty()) {\n            for (String str: s ) {\n                if (!&quot;/error&quot;.equals(str)) {\n                    pathNew.append(&quot;/{version}&quot;);\n                    pathNew.append(str);\n                } else {\n                    pathNew.append(str);\n                }\n            }\n        }\n\n        PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n        RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n        return requestMappingInfoNew;\n\n    }\n    return requestMappingInfo;\n}\n\n-----------------------------------------------------\n\n完整代码如下：    \n\npackage com.ymu.framework.spring.mvc.api;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\nimport java.util.Set;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set&lt;String&gt; s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n            if (s != null &amp;&amp; !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!&quot;/error&quot;.equals(str)) {\n                        pathNew.append(&quot;/{version}&quot;);\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>2.修改类ApiVersionCondition。<br>主要修改方法：getMatchingCondition</p>\n<pre><code>public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n    String path = request.getServletPath(); \n    if (path == null) {\n        return null;\n    }\n    Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n    if(m.find()){\n        Integer version = Integer.valueOf(m.group(1));\n        if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n    }\n    return null;\n}\n\n-----------------------------------------------------------\n\n完整代码如下：\n\npackage com.ymu.framework.spring.mvc.api;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n    private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(&quot;v(\\\\d+)/&quot;);\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n}\n</code></pre><p>3.演示：</p>\n<img src=\"/2017/09/26/api-version/d.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/e.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。<br>因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  </p>\n<p>通常，restful-api的版本迭代实现方式主要又两种：</p>\n<ul>\n<li>在url中显示设置，如：<code>https://api.example.com/v1/</code>。</li>\n<li><p>在http请求头中添加，如：</p>\n<pre><code>设置请求头：\nContent-Version: 1\n\n请求:\nhttps://api.example.com\n</code></pre></li>\n</ul>\n<hr>\n<p>首先，建立spring-boot-web项目：</p>\n<img src=\"/2017/09/26/api-version/a.png\">\n<h2 id=\"在请求头中设置\"><a href=\"#在请求头中设置\" class=\"headerlink\" title=\"在请求头中设置\"></a>在请求头中设置</h2><p>1.创建注解类ApiVersion<br>在controller中添加注解标志api版本</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.bind.annotation.Mapping;\n\nimport java.lang.annotation.*;\n\n/**\n * \n * 接口版本标识注解\n *\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Mapping\npublic @interface ApiVersion {\n    int value();\n}\n</code></pre><p>2.创建处理类ApiVersionCondition<br>继承RequestCondition，每次url请求都会首先进入该方法。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.regex.Pattern;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        String path = request.getServletPath();\n        if (path == null) {\n            return null;\n        }\n        String contentVersion = request.getHeader(&quot;Content-Version&quot;); //在http请求头中定义api版本，而不是在url中\n        if (null == contentVersion || &quot;&quot;.equals(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version非null非空&quot;);\n        }\n        if (!isInteger(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version必须为整数&quot;);\n        }\n\n        int version = Integer.valueOf(contentVersion).intValue();\n        if(version &gt;= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n    /**\n     * 判断字符串是否为整数。\n     * @param str\n     * @return\n     */\n    private boolean isInteger(String str) {\n        Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[\\\\d]*$&quot;);\n        return pattern.matcher(str).matches();\n    }\n\n}\n</code></pre><p>3.自定义url注册回调类CustomRequestMappingHandlerMapping<br>url注解回调句柄类。继承RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 类。\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    /**\n     * 方法\n     * @param method\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>4.创建web配置类并编辑内容：WebConfig<br>配置自定义类RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\n@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport{\n\n    @Override\n    @Bean\n    public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n        RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n        handlerMapping.setOrder(0);\n        handlerMapping.setInterceptors(getInterceptors()); \n        return handlerMapping;\n    }\n\n}\n</code></pre><p>5.创建演示类HelloController</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.ApiVersion;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@RestController\n@RequestMapping\npublic class HelloController {\n\n    //---------------- api版本管理 demo start ------------------//\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    public String hello0(HttpServletRequest request){\n        print(request);\n        return &quot;hello&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(1)\n    public String hello1(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v1&quot;;\n    }\n\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(5)\n    public String hello5(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v5&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(2)\n    public String hello2(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v2&quot;;\n    }\n\n    private void print(HttpServletRequest request) {\n        System.out.println(&quot;version:&quot; + request.getHeader(&quot;Content-Version&quot;));\n    }\n\n}    \n</code></pre><p>6.演示：</p>\n<img src=\"/2017/09/26/api-version/b.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/c.png\">\n<h2 id=\"在url中显示设置\"><a href=\"#在url中显示设置\" class=\"headerlink\" title=\"在url中显示设置\"></a>在url中显示设置</h2><p>在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 </p>\n<p>1.修改CustomRequestMappingHandlerMapping类。<br>只需要重写方法：</p>\n<pre><code>/**\n * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n * 不用在每个类或方法的@RequestMapping中加。\n * @param method\n * @param handlerType\n * @return\n */\n@Override\nprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n    RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n    if (requestMappingInfo != null) {\n        PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n        Set&lt;String&gt; s = pcOri.getPatterns();\n        StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n        if (s != null &amp;&amp; !s.isEmpty()) {\n            for (String str: s ) {\n                if (!&quot;/error&quot;.equals(str)) {\n                    pathNew.append(&quot;/{version}&quot;);\n                    pathNew.append(str);\n                } else {\n                    pathNew.append(str);\n                }\n            }\n        }\n\n        PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n        RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n        return requestMappingInfoNew;\n\n    }\n    return requestMappingInfo;\n}\n\n-----------------------------------------------------\n\n完整代码如下：    \n\npackage com.ymu.framework.spring.mvc.api;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\nimport java.util.Set;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set&lt;String&gt; s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n            if (s != null &amp;&amp; !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!&quot;/error&quot;.equals(str)) {\n                        pathNew.append(&quot;/{version}&quot;);\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>2.修改类ApiVersionCondition。<br>主要修改方法：getMatchingCondition</p>\n<pre><code>public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n    String path = request.getServletPath(); \n    if (path == null) {\n        return null;\n    }\n    Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n    if(m.find()){\n        Integer version = Integer.valueOf(m.group(1));\n        if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n    }\n    return null;\n}\n\n-----------------------------------------------------------\n\n完整代码如下：\n\npackage com.ymu.framework.spring.mvc.api;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n    private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(&quot;v(\\\\d+)/&quot;);\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n}\n</code></pre><p>3.演示：</p>\n<img src=\"/2017/09/26/api-version/d.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/e.png\">\n"},{"title":"centos常用命令收藏","date":"2018-06-11T09:37:52.000Z","_content":"\n本文主要记录常用的命令……  \n\n以备查询使用……\n\n\n## 查看系统信息\n\n### 查看端口占用\n\n`netstat -lnp|grep 8000`\n\n## 设置自启动\n\n在生产环境，一些基础应用环境需要系统启动的时候自动启动……\n\n### 服务自启动设置\n\n执行命令`systemctl enable *`即可。\n\n例如设置`docker`服务自启动：  \n`systemctl enable docker.service`\n\n### 脚本自启动\n\n### 参考：\n\n    一、添加开机自启服务\n    \n    在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：\n    systemctl enable jenkins.service #设置jenkins服务为自启动服务\n    sysstemctl start  jenkins.service #启动jenkins服务\n    \n    二、添加开机自启脚本\n    \n    在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：\n    #!/bin/bash\n    #description:开机自启脚本\n    /usr/local/tomcat/bin/startup.sh  #启动tomcat\n    \n    方法一\n    \n    1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）\n    chmod +x /opt/script/autostart.sh\n    \n    2、打开/etc/rc.d/rc/local文件，在末尾增加如下内容\n    /opt/script/autostart.sh\n    \n    3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n    chmod +x /etc/rc.d/rc.local\n    \n    方法二\n    \n    1、将脚本移动到/etc/rc.d/init.d目录下\n    mv  /opt/script/autostart.sh /etc/rc.d/init.d\n    \n    2、增加脚本的可执行权限\n    chmod +x  /etc/rc.d/init.d/autostart.sh\n    \n    3、添加脚本到开机自动启动项目中\n    cd /etc/rc.d/init.d\n    chkconfig --add autostart.sh\n    chkconfig autostart.sh on\n    \n## 系统进程管理\n\n### 查看进程信息\n\n#### 1.根据端口，查看进程信息\n\n    # lsof -i:8011  //查看端口，找到进程pid\n    # cd /proc/pid\n    # ll\n    \n    ---------------------------------------------------------\n    \n    [root@izwz9bwlp4pyxy4mnxaycez 1113]# ll\n    total 0\n    dr-xr-xr-x  2 root root 0 10月 31 17:30 attr\n    -rw-r--r--  1 root root 0 11月  5 10:24 autogroup\n    -r--------  1 root root 0 11月  5 10:24 auxv\n    -r--r--r--  1 root root 0 11月  5 10:24 cgroup\n    --w-------  1 root root 0 11月  5 10:24 clear_refs\n    -r--r--r--  1 root root 0 10月  8 21:02 cmdline\n    -rw-r--r--  1 root root 0 11月  5 10:24 comm\n    -rw-r--r--  1 root root 0 11月  5 10:24 coredump_filter\n    -r--r--r--  1 root root 0 11月  5 10:24 cpuset\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 cwd -> /\n    -r--------  1 root root 0 11月  1 15:13 environ\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 exe -> /server/java/jdk/bin/java\n    dr-x------  2 root root 0 10月 31 17:30 fd\n    dr-x------  2 root root 0 11月  1 11:53 fdinfo\n    -rw-r--r--  1 root root 0 11月  5 10:24 gid_map\n    -r--------  1 root root 0 11月  5 10:24 io\n    -r--r--r--  1 root root 0 11月  5 10:24 limits\n    -rw-r--r--  1 root root 0 11月  5 10:24 loginuid\n    dr-x------  2 root root 0 11月  5 10:24 map_files\n    -r--r--r--  1 root root 0 11月  5 10:24 maps\n    -rw-------  1 root root 0 11月  5 10:24 mem\n    -r--r--r--  1 root root 0 11月  5 10:24 mountinfo\n    -r--r--r--  1 root root 0 11月  5 10:24 mounts\n    -r--------  1 root root 0 11月  5 10:24 mountstats\n    dr-xr-xr-x  5 root root 0 11月  5 10:24 net\n    dr-x--x--x  2 root root 0 11月  5 10:24 ns\n    -r--r--r--  1 root root 0 11月  5 10:24 numa_maps\n    -rw-r--r--  1 root root 0 11月  5 10:24 oom_adj\n    -r--r--r--  1 root root 0 11月  5 10:24 oom_score\n    -rw-r--r--  1 root root 0 11月  5 10:24 oom_score_adj\n    -r--r--r--  1 root root 0 11月  5 10:24 pagemap\n    -r--------  1 root root 0 11月  5 10:24 patch_state\n    -r--r--r--  1 root root 0 11月  5 10:24 personality\n    -rw-r--r--  1 root root 0 11月  5 10:24 projid_map\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 root -> /\n    -rw-r--r--  1 root root 0 11月  5 10:24 sched\n    -r--r--r--  1 root root 0 11月  5 10:24 schedstat\n    -r--r--r--  1 root root 0 11月  5 10:24 sessionid\n    -rw-r--r--  1 root root 0 11月  5 10:24 setgroups\n    -r--r--r--  1 root root 0 11月  5 10:24 smaps\n    -r--r--r--  1 root root 0 11月  5 10:24 stack\n    -r--r--r--  1 root root 0 10月  8 21:02 stat\n    -r--r--r--  1 root root 0 11月  5 10:24 statm\n    -r--r--r--  1 root root 0 10月  8 21:02 status\n    -r--r--r--  1 root root 0 11月  5 10:24 syscall\n    dr-xr-xr-x 30 root root 0 11月  5 10:24 task\n    -r--r--r--  1 root root 0 11月  5 10:24 timers\n    -rw-r--r--  1 root root 0 11月  5 10:24 uid_map\n    -r--r--r--  1 root root 0 11月  5 10:24 wchan\n\n#### 2.查看进程\n\n    # ps aux | less  --查看所有运行中的进程\n    # ps -A --查看系统中的每个进程。\n    # ps -u vivek --查看用户vivek运行的进程\n    \n#### 3.动态显示进程\n\n    # top\n按q退出，按h进入帮助\n\n#### 4.树状显示进程\n\n    [root@izwz9bwlp4pyxy4mnxaycez ~]# pstree\n    systemd─┬─aliyun-service\n            ├─atd\n            ├─auditd───{auditd}\n            ├─crond\n            ├─dbus-daemon\n            ├─dhclient\n            ├─irqbalance\n            ├─26*[java───27*[{java}]]\n            ├─java───26*[{java}]\n            ├─2*[java───32*[{java}]]\n            ├─java───23*[{java}]\n            ├─java───21*[{java}]\n            ├─java───61*[{java}]\n            ├─java───247*[{java}]\n            ├─java───57*[{java}]\n            ├─java───49*[{java}]\n            ├─login───bash\n            ├─mysqld_safe───mysqld───128*[{mysqld}]\n            ├─mysqld_safe───mysqld───194*[{mysqld}]\n            ├─10*[nginx───nginx]\n            ├─ntpd\n            ├─polkitd───5*[{polkitd}]\n            ├─redis-server───2*[{redis-server}]\n            ├─rsyslogd───2*[{rsyslogd}]\n            ├─sshd─┬─3*[sshd───bash]\n            │      ├─2*[sshd───bash───2*[tail]]\n            │      ├─sshd───bash───pstree\n            │      └─sshd───sshd\n            ├─systemd-journal\n            ├─systemd-logind\n            ├─systemd-udevd\n            ├─tuned───4*[{tuned}]\n            └─wrapper─┬─java───53*[{java}]\n                      └─{wrapper}\n\n### 将进程快照储存到文件中\n\n输入下列命令：\n    \t\n    # top -b -n1 > /tmp/process.log\n\n你也可以将结果通过邮件发给自己：\n\n    # top -b -n1 | mail -s 'Process snapshot' you@example.com\n    \n## 查看服务器情况\n\n### 1.查看服务器CPU型号  \n\n    grep \"model name\" /proc/cpuinfo | cut -f2 -d:  \n    \n### 2.查看服务器内存容量\n\n    grep MemTotal /proc/meminfo\n    grep MemTotal /proc/meminfo | cut -f2 -d:\n    free -m |grep \"Mem\" | awk '{print $2}' \n    \n### 3.查看服务器的CPU是32位还是64位\n\n    getconf LONG_BIT\n    \n### 4.查看当前Linux的版本\n\n    more /etc/redhat-release cat /etc/redhat-release\n    \n### 5.查看Linux内核版本\n\n    uname -r\n    uname -a\n    \n### 6.查看服务器当前时间\n\n    date\n    \n### 7.查看服务器硬盘和分区\n\n    df -h\n    fdisk -l\n    \n### 8.查看挂载情况\n\n    mount\n    \n### 9.查看目录大小\n\n    du /etc -sh\n    \n### 10.查看服务器初始安装的软件包\n\n    cat -n /root/install.log\n    more /root/install.log | wc -l\n    \n### 11.查看已经安装的软件包\n\n    rpm -qa\n    rpm -qa | wc -l\n    yum list installed | wc -l\n    \n### 12.查看服务器键盘布局\n\n    cat /etc/sysconfig/keyboard\n    cat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d=\n    \n### 13.查看Selinux状态\n\n    sestatus\n    sestatus | cut -f2 -d:\n    cat /etc/sysconfig/selinux\n    \n### 14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。\n    \n    ifconfig\n    cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR\n    cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d=\n    ifconfig eth0 |grep \"inet addr:\" |awk '{print $2}'|cut -c 6-\n    ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'\n    \n### 15.查看服务器默认网关\n\n    cat /etc/sysconfig/network\n    \n### 16.查看服务器的默认DNS\n\n    cat /etc/resolv.conf\n    \n### 17.查看服务器默认语言\n\n    echo $LANG $LANGUAGE\n    cat /etc/sysconfig/i18n\n    \n### 18.查看服务器所属时区和UTC时间\n\n    cat /etc/sysconfig/clock\n    \n### 19.查看服务器主机名\n\n    hostname\n    cat /etc/sysconfig/network\n    \n## CentOS挂载新硬盘                                        \n参考：http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html \n1.查看当前硬盘使用状况：\n\n    df -h\n2.查看新硬盘\n \n    fdisk -l \n新添加的硬盘的编号为 `/dev/xvdb    /dev/xvde  /dev/vdb`\n\n3.硬盘分区   \n 1)进入fdisk模式     \n    `/sbin/fdisk /dev/vdb`  \n 2)输入n进行分区  \n 3)选择分区类型   \n \n  这里有两个选项：   \n- p: 主分区 linux上主分区最多能有4个    \n- e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。     \n\n这里我选择的p。\n\n 4)选择分区个数  \n 可以选择4个分区，这里我只分成1个分区    \n 5)设置柱面，这里选择默认值就可以  \n 6)输入w，写入分区表，进行分区   \n \n4.格式化分区 \n\n将新分区格式化为ext4文件系统     \n1)如果创建的是主分区 \n`mkfs -t ext4  /dev/vdb1 `\n\n5.挂载硬盘  \n1)创建挂载点     \n在根目录下创建sqjr目录   \n`mkdir /server /sqjr `\n2)将/dev/vdb1挂载到/sqjr下    \n `mount /dev/vdb1 /server  /sqjr`\n \n6.设置开机启动自动挂载    \n新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。    \n设置开机自动挂载需要修改/etc/fstab文件    \n`vi /etc/fstab `    \n在文件的最后增加一行  \n`/dev/vdb1 /server ext4 defaults 1 2 `\n\n7.取消挂载 /dev/xvdb1   \n`umount /dev/vdb1`\n\n8.重启    \n`reboot -n `                        \n\n           \n    \n        ","source":"_posts/linux-centos-command.md","raw":"---\ntitle: centos常用命令收藏\ndate: 2018-06-11 17:37:52\ncategories: CentOs\ntags: centos常用命令\n---\n\n本文主要记录常用的命令……  \n\n以备查询使用……\n\n\n## 查看系统信息\n\n### 查看端口占用\n\n`netstat -lnp|grep 8000`\n\n## 设置自启动\n\n在生产环境，一些基础应用环境需要系统启动的时候自动启动……\n\n### 服务自启动设置\n\n执行命令`systemctl enable *`即可。\n\n例如设置`docker`服务自启动：  \n`systemctl enable docker.service`\n\n### 脚本自启动\n\n### 参考：\n\n    一、添加开机自启服务\n    \n    在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：\n    systemctl enable jenkins.service #设置jenkins服务为自启动服务\n    sysstemctl start  jenkins.service #启动jenkins服务\n    \n    二、添加开机自启脚本\n    \n    在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：\n    #!/bin/bash\n    #description:开机自启脚本\n    /usr/local/tomcat/bin/startup.sh  #启动tomcat\n    \n    方法一\n    \n    1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）\n    chmod +x /opt/script/autostart.sh\n    \n    2、打开/etc/rc.d/rc/local文件，在末尾增加如下内容\n    /opt/script/autostart.sh\n    \n    3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\n    chmod +x /etc/rc.d/rc.local\n    \n    方法二\n    \n    1、将脚本移动到/etc/rc.d/init.d目录下\n    mv  /opt/script/autostart.sh /etc/rc.d/init.d\n    \n    2、增加脚本的可执行权限\n    chmod +x  /etc/rc.d/init.d/autostart.sh\n    \n    3、添加脚本到开机自动启动项目中\n    cd /etc/rc.d/init.d\n    chkconfig --add autostart.sh\n    chkconfig autostart.sh on\n    \n## 系统进程管理\n\n### 查看进程信息\n\n#### 1.根据端口，查看进程信息\n\n    # lsof -i:8011  //查看端口，找到进程pid\n    # cd /proc/pid\n    # ll\n    \n    ---------------------------------------------------------\n    \n    [root@izwz9bwlp4pyxy4mnxaycez 1113]# ll\n    total 0\n    dr-xr-xr-x  2 root root 0 10月 31 17:30 attr\n    -rw-r--r--  1 root root 0 11月  5 10:24 autogroup\n    -r--------  1 root root 0 11月  5 10:24 auxv\n    -r--r--r--  1 root root 0 11月  5 10:24 cgroup\n    --w-------  1 root root 0 11月  5 10:24 clear_refs\n    -r--r--r--  1 root root 0 10月  8 21:02 cmdline\n    -rw-r--r--  1 root root 0 11月  5 10:24 comm\n    -rw-r--r--  1 root root 0 11月  5 10:24 coredump_filter\n    -r--r--r--  1 root root 0 11月  5 10:24 cpuset\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 cwd -> /\n    -r--------  1 root root 0 11月  1 15:13 environ\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 exe -> /server/java/jdk/bin/java\n    dr-x------  2 root root 0 10月 31 17:30 fd\n    dr-x------  2 root root 0 11月  1 11:53 fdinfo\n    -rw-r--r--  1 root root 0 11月  5 10:24 gid_map\n    -r--------  1 root root 0 11月  5 10:24 io\n    -r--r--r--  1 root root 0 11月  5 10:24 limits\n    -rw-r--r--  1 root root 0 11月  5 10:24 loginuid\n    dr-x------  2 root root 0 11月  5 10:24 map_files\n    -r--r--r--  1 root root 0 11月  5 10:24 maps\n    -rw-------  1 root root 0 11月  5 10:24 mem\n    -r--r--r--  1 root root 0 11月  5 10:24 mountinfo\n    -r--r--r--  1 root root 0 11月  5 10:24 mounts\n    -r--------  1 root root 0 11月  5 10:24 mountstats\n    dr-xr-xr-x  5 root root 0 11月  5 10:24 net\n    dr-x--x--x  2 root root 0 11月  5 10:24 ns\n    -r--r--r--  1 root root 0 11月  5 10:24 numa_maps\n    -rw-r--r--  1 root root 0 11月  5 10:24 oom_adj\n    -r--r--r--  1 root root 0 11月  5 10:24 oom_score\n    -rw-r--r--  1 root root 0 11月  5 10:24 oom_score_adj\n    -r--r--r--  1 root root 0 11月  5 10:24 pagemap\n    -r--------  1 root root 0 11月  5 10:24 patch_state\n    -r--r--r--  1 root root 0 11月  5 10:24 personality\n    -rw-r--r--  1 root root 0 11月  5 10:24 projid_map\n    lrwxrwxrwx  1 root root 0 11月  5 10:24 root -> /\n    -rw-r--r--  1 root root 0 11月  5 10:24 sched\n    -r--r--r--  1 root root 0 11月  5 10:24 schedstat\n    -r--r--r--  1 root root 0 11月  5 10:24 sessionid\n    -rw-r--r--  1 root root 0 11月  5 10:24 setgroups\n    -r--r--r--  1 root root 0 11月  5 10:24 smaps\n    -r--r--r--  1 root root 0 11月  5 10:24 stack\n    -r--r--r--  1 root root 0 10月  8 21:02 stat\n    -r--r--r--  1 root root 0 11月  5 10:24 statm\n    -r--r--r--  1 root root 0 10月  8 21:02 status\n    -r--r--r--  1 root root 0 11月  5 10:24 syscall\n    dr-xr-xr-x 30 root root 0 11月  5 10:24 task\n    -r--r--r--  1 root root 0 11月  5 10:24 timers\n    -rw-r--r--  1 root root 0 11月  5 10:24 uid_map\n    -r--r--r--  1 root root 0 11月  5 10:24 wchan\n\n#### 2.查看进程\n\n    # ps aux | less  --查看所有运行中的进程\n    # ps -A --查看系统中的每个进程。\n    # ps -u vivek --查看用户vivek运行的进程\n    \n#### 3.动态显示进程\n\n    # top\n按q退出，按h进入帮助\n\n#### 4.树状显示进程\n\n    [root@izwz9bwlp4pyxy4mnxaycez ~]# pstree\n    systemd─┬─aliyun-service\n            ├─atd\n            ├─auditd───{auditd}\n            ├─crond\n            ├─dbus-daemon\n            ├─dhclient\n            ├─irqbalance\n            ├─26*[java───27*[{java}]]\n            ├─java───26*[{java}]\n            ├─2*[java───32*[{java}]]\n            ├─java───23*[{java}]\n            ├─java───21*[{java}]\n            ├─java───61*[{java}]\n            ├─java───247*[{java}]\n            ├─java───57*[{java}]\n            ├─java───49*[{java}]\n            ├─login───bash\n            ├─mysqld_safe───mysqld───128*[{mysqld}]\n            ├─mysqld_safe───mysqld───194*[{mysqld}]\n            ├─10*[nginx───nginx]\n            ├─ntpd\n            ├─polkitd───5*[{polkitd}]\n            ├─redis-server───2*[{redis-server}]\n            ├─rsyslogd───2*[{rsyslogd}]\n            ├─sshd─┬─3*[sshd───bash]\n            │      ├─2*[sshd───bash───2*[tail]]\n            │      ├─sshd───bash───pstree\n            │      └─sshd───sshd\n            ├─systemd-journal\n            ├─systemd-logind\n            ├─systemd-udevd\n            ├─tuned───4*[{tuned}]\n            └─wrapper─┬─java───53*[{java}]\n                      └─{wrapper}\n\n### 将进程快照储存到文件中\n\n输入下列命令：\n    \t\n    # top -b -n1 > /tmp/process.log\n\n你也可以将结果通过邮件发给自己：\n\n    # top -b -n1 | mail -s 'Process snapshot' you@example.com\n    \n## 查看服务器情况\n\n### 1.查看服务器CPU型号  \n\n    grep \"model name\" /proc/cpuinfo | cut -f2 -d:  \n    \n### 2.查看服务器内存容量\n\n    grep MemTotal /proc/meminfo\n    grep MemTotal /proc/meminfo | cut -f2 -d:\n    free -m |grep \"Mem\" | awk '{print $2}' \n    \n### 3.查看服务器的CPU是32位还是64位\n\n    getconf LONG_BIT\n    \n### 4.查看当前Linux的版本\n\n    more /etc/redhat-release cat /etc/redhat-release\n    \n### 5.查看Linux内核版本\n\n    uname -r\n    uname -a\n    \n### 6.查看服务器当前时间\n\n    date\n    \n### 7.查看服务器硬盘和分区\n\n    df -h\n    fdisk -l\n    \n### 8.查看挂载情况\n\n    mount\n    \n### 9.查看目录大小\n\n    du /etc -sh\n    \n### 10.查看服务器初始安装的软件包\n\n    cat -n /root/install.log\n    more /root/install.log | wc -l\n    \n### 11.查看已经安装的软件包\n\n    rpm -qa\n    rpm -qa | wc -l\n    yum list installed | wc -l\n    \n### 12.查看服务器键盘布局\n\n    cat /etc/sysconfig/keyboard\n    cat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d=\n    \n### 13.查看Selinux状态\n\n    sestatus\n    sestatus | cut -f2 -d:\n    cat /etc/sysconfig/selinux\n    \n### 14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。\n    \n    ifconfig\n    cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR\n    cat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d=\n    ifconfig eth0 |grep \"inet addr:\" |awk '{print $2}'|cut -c 6-\n    ifconfig | grep 'inet addr:'| grep -v '127.0.0.1' | cut -d: -f2 | awk '{ print $1}'\n    \n### 15.查看服务器默认网关\n\n    cat /etc/sysconfig/network\n    \n### 16.查看服务器的默认DNS\n\n    cat /etc/resolv.conf\n    \n### 17.查看服务器默认语言\n\n    echo $LANG $LANGUAGE\n    cat /etc/sysconfig/i18n\n    \n### 18.查看服务器所属时区和UTC时间\n\n    cat /etc/sysconfig/clock\n    \n### 19.查看服务器主机名\n\n    hostname\n    cat /etc/sysconfig/network\n    \n## CentOS挂载新硬盘                                        \n参考：http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html \n1.查看当前硬盘使用状况：\n\n    df -h\n2.查看新硬盘\n \n    fdisk -l \n新添加的硬盘的编号为 `/dev/xvdb    /dev/xvde  /dev/vdb`\n\n3.硬盘分区   \n 1)进入fdisk模式     \n    `/sbin/fdisk /dev/vdb`  \n 2)输入n进行分区  \n 3)选择分区类型   \n \n  这里有两个选项：   \n- p: 主分区 linux上主分区最多能有4个    \n- e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。     \n\n这里我选择的p。\n\n 4)选择分区个数  \n 可以选择4个分区，这里我只分成1个分区    \n 5)设置柱面，这里选择默认值就可以  \n 6)输入w，写入分区表，进行分区   \n \n4.格式化分区 \n\n将新分区格式化为ext4文件系统     \n1)如果创建的是主分区 \n`mkfs -t ext4  /dev/vdb1 `\n\n5.挂载硬盘  \n1)创建挂载点     \n在根目录下创建sqjr目录   \n`mkdir /server /sqjr `\n2)将/dev/vdb1挂载到/sqjr下    \n `mount /dev/vdb1 /server  /sqjr`\n \n6.设置开机启动自动挂载    \n新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。    \n设置开机自动挂载需要修改/etc/fstab文件    \n`vi /etc/fstab `    \n在文件的最后增加一行  \n`/dev/vdb1 /server ext4 defaults 1 2 `\n\n7.取消挂载 /dev/xvdb1   \n`umount /dev/vdb1`\n\n8.重启    \n`reboot -n `                        \n\n           \n    \n        ","slug":"linux-centos-command","published":1,"updated":"2018-11-15T03:26:58.350Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38p100cnqcrgruo1jxd4","content":"<p>本文主要记录常用的命令……  </p>\n<p>以备查询使用……</p>\n<h2 id=\"查看系统信息\"><a href=\"#查看系统信息\" class=\"headerlink\" title=\"查看系统信息\"></a>查看系统信息</h2><h3 id=\"查看端口占用\"><a href=\"#查看端口占用\" class=\"headerlink\" title=\"查看端口占用\"></a>查看端口占用</h3><p><code>netstat -lnp|grep 8000</code></p>\n<h2 id=\"设置自启动\"><a href=\"#设置自启动\" class=\"headerlink\" title=\"设置自启动\"></a>设置自启动</h2><p>在生产环境，一些基础应用环境需要系统启动的时候自动启动……</p>\n<h3 id=\"服务自启动设置\"><a href=\"#服务自启动设置\" class=\"headerlink\" title=\"服务自启动设置\"></a>服务自启动设置</h3><p>执行命令<code>systemctl enable *</code>即可。</p>\n<p>例如设置<code>docker</code>服务自启动：<br><code>systemctl enable docker.service</code></p>\n<h3 id=\"脚本自启动\"><a href=\"#脚本自启动\" class=\"headerlink\" title=\"脚本自启动\"></a>脚本自启动</h3><h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><pre><code>一、添加开机自启服务\n\n在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：\nsystemctl enable jenkins.service #设置jenkins服务为自启动服务\nsysstemctl start  jenkins.service #启动jenkins服务\n\n二、添加开机自启脚本\n\n在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：\n#!/bin/bash\n#description:开机自启脚本\n/usr/local/tomcat/bin/startup.sh  #启动tomcat\n\n方法一\n\n1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）\nchmod +x /opt/script/autostart.sh\n\n2、打开/etc/rc.d/rc/local文件，在末尾增加如下内容\n/opt/script/autostart.sh\n\n3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\nchmod +x /etc/rc.d/rc.local\n\n方法二\n\n1、将脚本移动到/etc/rc.d/init.d目录下\nmv  /opt/script/autostart.sh /etc/rc.d/init.d\n\n2、增加脚本的可执行权限\nchmod +x  /etc/rc.d/init.d/autostart.sh\n\n3、添加脚本到开机自动启动项目中\ncd /etc/rc.d/init.d\nchkconfig --add autostart.sh\nchkconfig autostart.sh on\n</code></pre><h2 id=\"系统进程管理\"><a href=\"#系统进程管理\" class=\"headerlink\" title=\"系统进程管理\"></a>系统进程管理</h2><h3 id=\"查看进程信息\"><a href=\"#查看进程信息\" class=\"headerlink\" title=\"查看进程信息\"></a>查看进程信息</h3><h4 id=\"1-根据端口，查看进程信息\"><a href=\"#1-根据端口，查看进程信息\" class=\"headerlink\" title=\"1.根据端口，查看进程信息\"></a>1.根据端口，查看进程信息</h4><pre><code># lsof -i:8011  //查看端口，找到进程pid\n# cd /proc/pid\n# ll\n\n---------------------------------------------------------\n\n[root@izwz9bwlp4pyxy4mnxaycez 1113]# ll\ntotal 0\ndr-xr-xr-x  2 root root 0 10月 31 17:30 attr\n-rw-r--r--  1 root root 0 11月  5 10:24 autogroup\n-r--------  1 root root 0 11月  5 10:24 auxv\n-r--r--r--  1 root root 0 11月  5 10:24 cgroup\n--w-------  1 root root 0 11月  5 10:24 clear_refs\n-r--r--r--  1 root root 0 10月  8 21:02 cmdline\n-rw-r--r--  1 root root 0 11月  5 10:24 comm\n-rw-r--r--  1 root root 0 11月  5 10:24 coredump_filter\n-r--r--r--  1 root root 0 11月  5 10:24 cpuset\nlrwxrwxrwx  1 root root 0 11月  5 10:24 cwd -&gt; /\n-r--------  1 root root 0 11月  1 15:13 environ\nlrwxrwxrwx  1 root root 0 11月  5 10:24 exe -&gt; /server/java/jdk/bin/java\ndr-x------  2 root root 0 10月 31 17:30 fd\ndr-x------  2 root root 0 11月  1 11:53 fdinfo\n-rw-r--r--  1 root root 0 11月  5 10:24 gid_map\n-r--------  1 root root 0 11月  5 10:24 io\n-r--r--r--  1 root root 0 11月  5 10:24 limits\n-rw-r--r--  1 root root 0 11月  5 10:24 loginuid\ndr-x------  2 root root 0 11月  5 10:24 map_files\n-r--r--r--  1 root root 0 11月  5 10:24 maps\n-rw-------  1 root root 0 11月  5 10:24 mem\n-r--r--r--  1 root root 0 11月  5 10:24 mountinfo\n-r--r--r--  1 root root 0 11月  5 10:24 mounts\n-r--------  1 root root 0 11月  5 10:24 mountstats\ndr-xr-xr-x  5 root root 0 11月  5 10:24 net\ndr-x--x--x  2 root root 0 11月  5 10:24 ns\n-r--r--r--  1 root root 0 11月  5 10:24 numa_maps\n-rw-r--r--  1 root root 0 11月  5 10:24 oom_adj\n-r--r--r--  1 root root 0 11月  5 10:24 oom_score\n-rw-r--r--  1 root root 0 11月  5 10:24 oom_score_adj\n-r--r--r--  1 root root 0 11月  5 10:24 pagemap\n-r--------  1 root root 0 11月  5 10:24 patch_state\n-r--r--r--  1 root root 0 11月  5 10:24 personality\n-rw-r--r--  1 root root 0 11月  5 10:24 projid_map\nlrwxrwxrwx  1 root root 0 11月  5 10:24 root -&gt; /\n-rw-r--r--  1 root root 0 11月  5 10:24 sched\n-r--r--r--  1 root root 0 11月  5 10:24 schedstat\n-r--r--r--  1 root root 0 11月  5 10:24 sessionid\n-rw-r--r--  1 root root 0 11月  5 10:24 setgroups\n-r--r--r--  1 root root 0 11月  5 10:24 smaps\n-r--r--r--  1 root root 0 11月  5 10:24 stack\n-r--r--r--  1 root root 0 10月  8 21:02 stat\n-r--r--r--  1 root root 0 11月  5 10:24 statm\n-r--r--r--  1 root root 0 10月  8 21:02 status\n-r--r--r--  1 root root 0 11月  5 10:24 syscall\ndr-xr-xr-x 30 root root 0 11月  5 10:24 task\n-r--r--r--  1 root root 0 11月  5 10:24 timers\n-rw-r--r--  1 root root 0 11月  5 10:24 uid_map\n-r--r--r--  1 root root 0 11月  5 10:24 wchan\n</code></pre><h4 id=\"2-查看进程\"><a href=\"#2-查看进程\" class=\"headerlink\" title=\"2.查看进程\"></a>2.查看进程</h4><pre><code># ps aux | less  --查看所有运行中的进程\n# ps -A --查看系统中的每个进程。\n# ps -u vivek --查看用户vivek运行的进程\n</code></pre><h4 id=\"3-动态显示进程\"><a href=\"#3-动态显示进程\" class=\"headerlink\" title=\"3.动态显示进程\"></a>3.动态显示进程</h4><pre><code># top\n</code></pre><p>按q退出，按h进入帮助</p>\n<h4 id=\"4-树状显示进程\"><a href=\"#4-树状显示进程\" class=\"headerlink\" title=\"4.树状显示进程\"></a>4.树状显示进程</h4><pre><code>[root@izwz9bwlp4pyxy4mnxaycez ~]# pstree\nsystemd─┬─aliyun-service\n        ├─atd\n        ├─auditd───{auditd}\n        ├─crond\n        ├─dbus-daemon\n        ├─dhclient\n        ├─irqbalance\n        ├─26*[java───27*[{java}]]\n        ├─java───26*[{java}]\n        ├─2*[java───32*[{java}]]\n        ├─java───23*[{java}]\n        ├─java───21*[{java}]\n        ├─java───61*[{java}]\n        ├─java───247*[{java}]\n        ├─java───57*[{java}]\n        ├─java───49*[{java}]\n        ├─login───bash\n        ├─mysqld_safe───mysqld───128*[{mysqld}]\n        ├─mysqld_safe───mysqld───194*[{mysqld}]\n        ├─10*[nginx───nginx]\n        ├─ntpd\n        ├─polkitd───5*[{polkitd}]\n        ├─redis-server───2*[{redis-server}]\n        ├─rsyslogd───2*[{rsyslogd}]\n        ├─sshd─┬─3*[sshd───bash]\n        │      ├─2*[sshd───bash───2*[tail]]\n        │      ├─sshd───bash───pstree\n        │      └─sshd───sshd\n        ├─systemd-journal\n        ├─systemd-logind\n        ├─systemd-udevd\n        ├─tuned───4*[{tuned}]\n        └─wrapper─┬─java───53*[{java}]\n                  └─{wrapper}\n</code></pre><h3 id=\"将进程快照储存到文件中\"><a href=\"#将进程快照储存到文件中\" class=\"headerlink\" title=\"将进程快照储存到文件中\"></a>将进程快照储存到文件中</h3><p>输入下列命令：</p>\n<pre><code># top -b -n1 &gt; /tmp/process.log\n</code></pre><p>你也可以将结果通过邮件发给自己：</p>\n<pre><code># top -b -n1 | mail -s &apos;Process snapshot&apos; you@example.com\n</code></pre><h2 id=\"查看服务器情况\"><a href=\"#查看服务器情况\" class=\"headerlink\" title=\"查看服务器情况\"></a>查看服务器情况</h2><h3 id=\"1-查看服务器CPU型号\"><a href=\"#1-查看服务器CPU型号\" class=\"headerlink\" title=\"1.查看服务器CPU型号\"></a>1.查看服务器CPU型号</h3><pre><code>grep &quot;model name&quot; /proc/cpuinfo | cut -f2 -d:  \n</code></pre><h3 id=\"2-查看服务器内存容量\"><a href=\"#2-查看服务器内存容量\" class=\"headerlink\" title=\"2.查看服务器内存容量\"></a>2.查看服务器内存容量</h3><pre><code>grep MemTotal /proc/meminfo\ngrep MemTotal /proc/meminfo | cut -f2 -d:\nfree -m |grep &quot;Mem&quot; | awk &apos;{print $2}&apos; \n</code></pre><h3 id=\"3-查看服务器的CPU是32位还是64位\"><a href=\"#3-查看服务器的CPU是32位还是64位\" class=\"headerlink\" title=\"3.查看服务器的CPU是32位还是64位\"></a>3.查看服务器的CPU是32位还是64位</h3><pre><code>getconf LONG_BIT\n</code></pre><h3 id=\"4-查看当前Linux的版本\"><a href=\"#4-查看当前Linux的版本\" class=\"headerlink\" title=\"4.查看当前Linux的版本\"></a>4.查看当前Linux的版本</h3><pre><code>more /etc/redhat-release cat /etc/redhat-release\n</code></pre><h3 id=\"5-查看Linux内核版本\"><a href=\"#5-查看Linux内核版本\" class=\"headerlink\" title=\"5.查看Linux内核版本\"></a>5.查看Linux内核版本</h3><pre><code>uname -r\nuname -a\n</code></pre><h3 id=\"6-查看服务器当前时间\"><a href=\"#6-查看服务器当前时间\" class=\"headerlink\" title=\"6.查看服务器当前时间\"></a>6.查看服务器当前时间</h3><pre><code>date\n</code></pre><h3 id=\"7-查看服务器硬盘和分区\"><a href=\"#7-查看服务器硬盘和分区\" class=\"headerlink\" title=\"7.查看服务器硬盘和分区\"></a>7.查看服务器硬盘和分区</h3><pre><code>df -h\nfdisk -l\n</code></pre><h3 id=\"8-查看挂载情况\"><a href=\"#8-查看挂载情况\" class=\"headerlink\" title=\"8.查看挂载情况\"></a>8.查看挂载情况</h3><pre><code>mount\n</code></pre><h3 id=\"9-查看目录大小\"><a href=\"#9-查看目录大小\" class=\"headerlink\" title=\"9.查看目录大小\"></a>9.查看目录大小</h3><pre><code>du /etc -sh\n</code></pre><h3 id=\"10-查看服务器初始安装的软件包\"><a href=\"#10-查看服务器初始安装的软件包\" class=\"headerlink\" title=\"10.查看服务器初始安装的软件包\"></a>10.查看服务器初始安装的软件包</h3><pre><code>cat -n /root/install.log\nmore /root/install.log | wc -l\n</code></pre><h3 id=\"11-查看已经安装的软件包\"><a href=\"#11-查看已经安装的软件包\" class=\"headerlink\" title=\"11.查看已经安装的软件包\"></a>11.查看已经安装的软件包</h3><pre><code>rpm -qa\nrpm -qa | wc -l\nyum list installed | wc -l\n</code></pre><h3 id=\"12-查看服务器键盘布局\"><a href=\"#12-查看服务器键盘布局\" class=\"headerlink\" title=\"12.查看服务器键盘布局\"></a>12.查看服务器键盘布局</h3><pre><code>cat /etc/sysconfig/keyboard\ncat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d=\n</code></pre><h3 id=\"13-查看Selinux状态\"><a href=\"#13-查看Selinux状态\" class=\"headerlink\" title=\"13.查看Selinux状态\"></a>13.查看Selinux状态</h3><pre><code>sestatus\nsestatus | cut -f2 -d:\ncat /etc/sysconfig/selinux\n</code></pre><h3 id=\"14-查看服务器网卡的ip，Mac地址-在ifcfg-eth0-文件里你可以看到mac，网关等信息。\"><a href=\"#14-查看服务器网卡的ip，Mac地址-在ifcfg-eth0-文件里你可以看到mac，网关等信息。\" class=\"headerlink\" title=\"14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。\"></a>14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。</h3><pre><code>ifconfig\ncat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR\ncat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d=\nifconfig eth0 |grep &quot;inet addr:&quot; |awk &apos;{print $2}&apos;|cut -c 6-\nifconfig | grep &apos;inet addr:&apos;| grep -v &apos;127.0.0.1&apos; | cut -d: -f2 | awk &apos;{ print $1}&apos;\n</code></pre><h3 id=\"15-查看服务器默认网关\"><a href=\"#15-查看服务器默认网关\" class=\"headerlink\" title=\"15.查看服务器默认网关\"></a>15.查看服务器默认网关</h3><pre><code>cat /etc/sysconfig/network\n</code></pre><h3 id=\"16-查看服务器的默认DNS\"><a href=\"#16-查看服务器的默认DNS\" class=\"headerlink\" title=\"16.查看服务器的默认DNS\"></a>16.查看服务器的默认DNS</h3><pre><code>cat /etc/resolv.conf\n</code></pre><h3 id=\"17-查看服务器默认语言\"><a href=\"#17-查看服务器默认语言\" class=\"headerlink\" title=\"17.查看服务器默认语言\"></a>17.查看服务器默认语言</h3><pre><code>echo $LANG $LANGUAGE\ncat /etc/sysconfig/i18n\n</code></pre><h3 id=\"18-查看服务器所属时区和UTC时间\"><a href=\"#18-查看服务器所属时区和UTC时间\" class=\"headerlink\" title=\"18.查看服务器所属时区和UTC时间\"></a>18.查看服务器所属时区和UTC时间</h3><pre><code>cat /etc/sysconfig/clock\n</code></pre><h3 id=\"19-查看服务器主机名\"><a href=\"#19-查看服务器主机名\" class=\"headerlink\" title=\"19.查看服务器主机名\"></a>19.查看服务器主机名</h3><pre><code>hostname\ncat /etc/sysconfig/network\n</code></pre><h2 id=\"CentOS挂载新硬盘\"><a href=\"#CentOS挂载新硬盘\" class=\"headerlink\" title=\"CentOS挂载新硬盘\"></a>CentOS挂载新硬盘</h2><p>参考：<a href=\"http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html</a><br>1.查看当前硬盘使用状况：</p>\n<pre><code>df -h\n</code></pre><p>2.查看新硬盘</p>\n<pre><code>fdisk -l \n</code></pre><p>新添加的硬盘的编号为 <code>/dev/xvdb    /dev/xvde  /dev/vdb</code></p>\n<p>3.硬盘分区<br> 1)进入fdisk模式<br>    <code>/sbin/fdisk /dev/vdb</code><br> 2)输入n进行分区<br> 3)选择分区类型   </p>\n<p>  这里有两个选项：   </p>\n<ul>\n<li>p: 主分区 linux上主分区最多能有4个    </li>\n<li>e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。     </li>\n</ul>\n<p>这里我选择的p。</p>\n<p> 4)选择分区个数<br> 可以选择4个分区，这里我只分成1个分区<br> 5)设置柱面，这里选择默认值就可以<br> 6)输入w，写入分区表，进行分区   </p>\n<p>4.格式化分区 </p>\n<p>将新分区格式化为ext4文件系统<br>1)如果创建的是主分区<br><code>mkfs -t ext4  /dev/vdb1</code></p>\n<p>5.挂载硬盘<br>1)创建挂载点<br>在根目录下创建sqjr目录<br><code>mkdir /server /sqjr</code><br>2)将/dev/vdb1挂载到/sqjr下<br> <code>mount /dev/vdb1 /server  /sqjr</code></p>\n<p>6.设置开机启动自动挂载<br>新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。<br>设置开机自动挂载需要修改/etc/fstab文件<br><code>vi /etc/fstab</code><br>在文件的最后增加一行<br><code>/dev/vdb1 /server ext4 defaults 1 2</code></p>\n<p>7.取消挂载 /dev/xvdb1<br><code>umount /dev/vdb1</code></p>\n<p>8.重启<br><code>reboot -n</code>                        </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文主要记录常用的命令……  </p>\n<p>以备查询使用……</p>\n<h2 id=\"查看系统信息\"><a href=\"#查看系统信息\" class=\"headerlink\" title=\"查看系统信息\"></a>查看系统信息</h2><h3 id=\"查看端口占用\"><a href=\"#查看端口占用\" class=\"headerlink\" title=\"查看端口占用\"></a>查看端口占用</h3><p><code>netstat -lnp|grep 8000</code></p>\n<h2 id=\"设置自启动\"><a href=\"#设置自启动\" class=\"headerlink\" title=\"设置自启动\"></a>设置自启动</h2><p>在生产环境，一些基础应用环境需要系统启动的时候自动启动……</p>\n<h3 id=\"服务自启动设置\"><a href=\"#服务自启动设置\" class=\"headerlink\" title=\"服务自启动设置\"></a>服务自启动设置</h3><p>执行命令<code>systemctl enable *</code>即可。</p>\n<p>例如设置<code>docker</code>服务自启动：<br><code>systemctl enable docker.service</code></p>\n<h3 id=\"脚本自启动\"><a href=\"#脚本自启动\" class=\"headerlink\" title=\"脚本自启动\"></a>脚本自启动</h3><h3 id=\"参考：\"><a href=\"#参考：\" class=\"headerlink\" title=\"参考：\"></a>参考：</h3><pre><code>一、添加开机自启服务\n\n在CentOS 7中添加开机自启服务非常方便，只需要两条命令(以Jenkins为例)：\nsystemctl enable jenkins.service #设置jenkins服务为自启动服务\nsysstemctl start  jenkins.service #启动jenkins服务\n\n二、添加开机自启脚本\n\n在centos7中增加脚本有两种常用的方法，以脚本autostart.sh为例：\n#!/bin/bash\n#description:开机自启脚本\n/usr/local/tomcat/bin/startup.sh  #启动tomcat\n\n方法一\n\n1、赋予脚本可执行权限（/opt/script/autostart.sh是你的脚本路径）\nchmod +x /opt/script/autostart.sh\n\n2、打开/etc/rc.d/rc/local文件，在末尾增加如下内容\n/opt/script/autostart.sh\n\n3、在centos7中，/etc/rc.d/rc.local的权限被降低了，所以需要执行如下命令赋予其可执行权限\nchmod +x /etc/rc.d/rc.local\n\n方法二\n\n1、将脚本移动到/etc/rc.d/init.d目录下\nmv  /opt/script/autostart.sh /etc/rc.d/init.d\n\n2、增加脚本的可执行权限\nchmod +x  /etc/rc.d/init.d/autostart.sh\n\n3、添加脚本到开机自动启动项目中\ncd /etc/rc.d/init.d\nchkconfig --add autostart.sh\nchkconfig autostart.sh on\n</code></pre><h2 id=\"系统进程管理\"><a href=\"#系统进程管理\" class=\"headerlink\" title=\"系统进程管理\"></a>系统进程管理</h2><h3 id=\"查看进程信息\"><a href=\"#查看进程信息\" class=\"headerlink\" title=\"查看进程信息\"></a>查看进程信息</h3><h4 id=\"1-根据端口，查看进程信息\"><a href=\"#1-根据端口，查看进程信息\" class=\"headerlink\" title=\"1.根据端口，查看进程信息\"></a>1.根据端口，查看进程信息</h4><pre><code># lsof -i:8011  //查看端口，找到进程pid\n# cd /proc/pid\n# ll\n\n---------------------------------------------------------\n\n[root@izwz9bwlp4pyxy4mnxaycez 1113]# ll\ntotal 0\ndr-xr-xr-x  2 root root 0 10月 31 17:30 attr\n-rw-r--r--  1 root root 0 11月  5 10:24 autogroup\n-r--------  1 root root 0 11月  5 10:24 auxv\n-r--r--r--  1 root root 0 11月  5 10:24 cgroup\n--w-------  1 root root 0 11月  5 10:24 clear_refs\n-r--r--r--  1 root root 0 10月  8 21:02 cmdline\n-rw-r--r--  1 root root 0 11月  5 10:24 comm\n-rw-r--r--  1 root root 0 11月  5 10:24 coredump_filter\n-r--r--r--  1 root root 0 11月  5 10:24 cpuset\nlrwxrwxrwx  1 root root 0 11月  5 10:24 cwd -&gt; /\n-r--------  1 root root 0 11月  1 15:13 environ\nlrwxrwxrwx  1 root root 0 11月  5 10:24 exe -&gt; /server/java/jdk/bin/java\ndr-x------  2 root root 0 10月 31 17:30 fd\ndr-x------  2 root root 0 11月  1 11:53 fdinfo\n-rw-r--r--  1 root root 0 11月  5 10:24 gid_map\n-r--------  1 root root 0 11月  5 10:24 io\n-r--r--r--  1 root root 0 11月  5 10:24 limits\n-rw-r--r--  1 root root 0 11月  5 10:24 loginuid\ndr-x------  2 root root 0 11月  5 10:24 map_files\n-r--r--r--  1 root root 0 11月  5 10:24 maps\n-rw-------  1 root root 0 11月  5 10:24 mem\n-r--r--r--  1 root root 0 11月  5 10:24 mountinfo\n-r--r--r--  1 root root 0 11月  5 10:24 mounts\n-r--------  1 root root 0 11月  5 10:24 mountstats\ndr-xr-xr-x  5 root root 0 11月  5 10:24 net\ndr-x--x--x  2 root root 0 11月  5 10:24 ns\n-r--r--r--  1 root root 0 11月  5 10:24 numa_maps\n-rw-r--r--  1 root root 0 11月  5 10:24 oom_adj\n-r--r--r--  1 root root 0 11月  5 10:24 oom_score\n-rw-r--r--  1 root root 0 11月  5 10:24 oom_score_adj\n-r--r--r--  1 root root 0 11月  5 10:24 pagemap\n-r--------  1 root root 0 11月  5 10:24 patch_state\n-r--r--r--  1 root root 0 11月  5 10:24 personality\n-rw-r--r--  1 root root 0 11月  5 10:24 projid_map\nlrwxrwxrwx  1 root root 0 11月  5 10:24 root -&gt; /\n-rw-r--r--  1 root root 0 11月  5 10:24 sched\n-r--r--r--  1 root root 0 11月  5 10:24 schedstat\n-r--r--r--  1 root root 0 11月  5 10:24 sessionid\n-rw-r--r--  1 root root 0 11月  5 10:24 setgroups\n-r--r--r--  1 root root 0 11月  5 10:24 smaps\n-r--r--r--  1 root root 0 11月  5 10:24 stack\n-r--r--r--  1 root root 0 10月  8 21:02 stat\n-r--r--r--  1 root root 0 11月  5 10:24 statm\n-r--r--r--  1 root root 0 10月  8 21:02 status\n-r--r--r--  1 root root 0 11月  5 10:24 syscall\ndr-xr-xr-x 30 root root 0 11月  5 10:24 task\n-r--r--r--  1 root root 0 11月  5 10:24 timers\n-rw-r--r--  1 root root 0 11月  5 10:24 uid_map\n-r--r--r--  1 root root 0 11月  5 10:24 wchan\n</code></pre><h4 id=\"2-查看进程\"><a href=\"#2-查看进程\" class=\"headerlink\" title=\"2.查看进程\"></a>2.查看进程</h4><pre><code># ps aux | less  --查看所有运行中的进程\n# ps -A --查看系统中的每个进程。\n# ps -u vivek --查看用户vivek运行的进程\n</code></pre><h4 id=\"3-动态显示进程\"><a href=\"#3-动态显示进程\" class=\"headerlink\" title=\"3.动态显示进程\"></a>3.动态显示进程</h4><pre><code># top\n</code></pre><p>按q退出，按h进入帮助</p>\n<h4 id=\"4-树状显示进程\"><a href=\"#4-树状显示进程\" class=\"headerlink\" title=\"4.树状显示进程\"></a>4.树状显示进程</h4><pre><code>[root@izwz9bwlp4pyxy4mnxaycez ~]# pstree\nsystemd─┬─aliyun-service\n        ├─atd\n        ├─auditd───{auditd}\n        ├─crond\n        ├─dbus-daemon\n        ├─dhclient\n        ├─irqbalance\n        ├─26*[java───27*[{java}]]\n        ├─java───26*[{java}]\n        ├─2*[java───32*[{java}]]\n        ├─java───23*[{java}]\n        ├─java───21*[{java}]\n        ├─java───61*[{java}]\n        ├─java───247*[{java}]\n        ├─java───57*[{java}]\n        ├─java───49*[{java}]\n        ├─login───bash\n        ├─mysqld_safe───mysqld───128*[{mysqld}]\n        ├─mysqld_safe───mysqld───194*[{mysqld}]\n        ├─10*[nginx───nginx]\n        ├─ntpd\n        ├─polkitd───5*[{polkitd}]\n        ├─redis-server───2*[{redis-server}]\n        ├─rsyslogd───2*[{rsyslogd}]\n        ├─sshd─┬─3*[sshd───bash]\n        │      ├─2*[sshd───bash───2*[tail]]\n        │      ├─sshd───bash───pstree\n        │      └─sshd───sshd\n        ├─systemd-journal\n        ├─systemd-logind\n        ├─systemd-udevd\n        ├─tuned───4*[{tuned}]\n        └─wrapper─┬─java───53*[{java}]\n                  └─{wrapper}\n</code></pre><h3 id=\"将进程快照储存到文件中\"><a href=\"#将进程快照储存到文件中\" class=\"headerlink\" title=\"将进程快照储存到文件中\"></a>将进程快照储存到文件中</h3><p>输入下列命令：</p>\n<pre><code># top -b -n1 &gt; /tmp/process.log\n</code></pre><p>你也可以将结果通过邮件发给自己：</p>\n<pre><code># top -b -n1 | mail -s &apos;Process snapshot&apos; you@example.com\n</code></pre><h2 id=\"查看服务器情况\"><a href=\"#查看服务器情况\" class=\"headerlink\" title=\"查看服务器情况\"></a>查看服务器情况</h2><h3 id=\"1-查看服务器CPU型号\"><a href=\"#1-查看服务器CPU型号\" class=\"headerlink\" title=\"1.查看服务器CPU型号\"></a>1.查看服务器CPU型号</h3><pre><code>grep &quot;model name&quot; /proc/cpuinfo | cut -f2 -d:  \n</code></pre><h3 id=\"2-查看服务器内存容量\"><a href=\"#2-查看服务器内存容量\" class=\"headerlink\" title=\"2.查看服务器内存容量\"></a>2.查看服务器内存容量</h3><pre><code>grep MemTotal /proc/meminfo\ngrep MemTotal /proc/meminfo | cut -f2 -d:\nfree -m |grep &quot;Mem&quot; | awk &apos;{print $2}&apos; \n</code></pre><h3 id=\"3-查看服务器的CPU是32位还是64位\"><a href=\"#3-查看服务器的CPU是32位还是64位\" class=\"headerlink\" title=\"3.查看服务器的CPU是32位还是64位\"></a>3.查看服务器的CPU是32位还是64位</h3><pre><code>getconf LONG_BIT\n</code></pre><h3 id=\"4-查看当前Linux的版本\"><a href=\"#4-查看当前Linux的版本\" class=\"headerlink\" title=\"4.查看当前Linux的版本\"></a>4.查看当前Linux的版本</h3><pre><code>more /etc/redhat-release cat /etc/redhat-release\n</code></pre><h3 id=\"5-查看Linux内核版本\"><a href=\"#5-查看Linux内核版本\" class=\"headerlink\" title=\"5.查看Linux内核版本\"></a>5.查看Linux内核版本</h3><pre><code>uname -r\nuname -a\n</code></pre><h3 id=\"6-查看服务器当前时间\"><a href=\"#6-查看服务器当前时间\" class=\"headerlink\" title=\"6.查看服务器当前时间\"></a>6.查看服务器当前时间</h3><pre><code>date\n</code></pre><h3 id=\"7-查看服务器硬盘和分区\"><a href=\"#7-查看服务器硬盘和分区\" class=\"headerlink\" title=\"7.查看服务器硬盘和分区\"></a>7.查看服务器硬盘和分区</h3><pre><code>df -h\nfdisk -l\n</code></pre><h3 id=\"8-查看挂载情况\"><a href=\"#8-查看挂载情况\" class=\"headerlink\" title=\"8.查看挂载情况\"></a>8.查看挂载情况</h3><pre><code>mount\n</code></pre><h3 id=\"9-查看目录大小\"><a href=\"#9-查看目录大小\" class=\"headerlink\" title=\"9.查看目录大小\"></a>9.查看目录大小</h3><pre><code>du /etc -sh\n</code></pre><h3 id=\"10-查看服务器初始安装的软件包\"><a href=\"#10-查看服务器初始安装的软件包\" class=\"headerlink\" title=\"10.查看服务器初始安装的软件包\"></a>10.查看服务器初始安装的软件包</h3><pre><code>cat -n /root/install.log\nmore /root/install.log | wc -l\n</code></pre><h3 id=\"11-查看已经安装的软件包\"><a href=\"#11-查看已经安装的软件包\" class=\"headerlink\" title=\"11.查看已经安装的软件包\"></a>11.查看已经安装的软件包</h3><pre><code>rpm -qa\nrpm -qa | wc -l\nyum list installed | wc -l\n</code></pre><h3 id=\"12-查看服务器键盘布局\"><a href=\"#12-查看服务器键盘布局\" class=\"headerlink\" title=\"12.查看服务器键盘布局\"></a>12.查看服务器键盘布局</h3><pre><code>cat /etc/sysconfig/keyboard\ncat /etc/sysconfig/keyboard | grep KEYTABLE | cut -f2 -d=\n</code></pre><h3 id=\"13-查看Selinux状态\"><a href=\"#13-查看Selinux状态\" class=\"headerlink\" title=\"13.查看Selinux状态\"></a>13.查看Selinux状态</h3><pre><code>sestatus\nsestatus | cut -f2 -d:\ncat /etc/sysconfig/selinux\n</code></pre><h3 id=\"14-查看服务器网卡的ip，Mac地址-在ifcfg-eth0-文件里你可以看到mac，网关等信息。\"><a href=\"#14-查看服务器网卡的ip，Mac地址-在ifcfg-eth0-文件里你可以看到mac，网关等信息。\" class=\"headerlink\" title=\"14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。\"></a>14.查看服务器网卡的ip，Mac地址,在ifcfg-eth0 文件里你可以看到mac，网关等信息。</h3><pre><code>ifconfig\ncat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR\ncat /etc/sysconfig/network-scripts/ifcfg-eth0 | grep IPADDR | cut -f2 -d=\nifconfig eth0 |grep &quot;inet addr:&quot; |awk &apos;{print $2}&apos;|cut -c 6-\nifconfig | grep &apos;inet addr:&apos;| grep -v &apos;127.0.0.1&apos; | cut -d: -f2 | awk &apos;{ print $1}&apos;\n</code></pre><h3 id=\"15-查看服务器默认网关\"><a href=\"#15-查看服务器默认网关\" class=\"headerlink\" title=\"15.查看服务器默认网关\"></a>15.查看服务器默认网关</h3><pre><code>cat /etc/sysconfig/network\n</code></pre><h3 id=\"16-查看服务器的默认DNS\"><a href=\"#16-查看服务器的默认DNS\" class=\"headerlink\" title=\"16.查看服务器的默认DNS\"></a>16.查看服务器的默认DNS</h3><pre><code>cat /etc/resolv.conf\n</code></pre><h3 id=\"17-查看服务器默认语言\"><a href=\"#17-查看服务器默认语言\" class=\"headerlink\" title=\"17.查看服务器默认语言\"></a>17.查看服务器默认语言</h3><pre><code>echo $LANG $LANGUAGE\ncat /etc/sysconfig/i18n\n</code></pre><h3 id=\"18-查看服务器所属时区和UTC时间\"><a href=\"#18-查看服务器所属时区和UTC时间\" class=\"headerlink\" title=\"18.查看服务器所属时区和UTC时间\"></a>18.查看服务器所属时区和UTC时间</h3><pre><code>cat /etc/sysconfig/clock\n</code></pre><h3 id=\"19-查看服务器主机名\"><a href=\"#19-查看服务器主机名\" class=\"headerlink\" title=\"19.查看服务器主机名\"></a>19.查看服务器主机名</h3><pre><code>hostname\ncat /etc/sysconfig/network\n</code></pre><h2 id=\"CentOS挂载新硬盘\"><a href=\"#CentOS挂载新硬盘\" class=\"headerlink\" title=\"CentOS挂载新硬盘\"></a>CentOS挂载新硬盘</h2><p>参考：<a href=\"http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html\" target=\"_blank\" rel=\"noopener\">http://blog.sina.com.cn/s/blog_6177e8400101ntvu.html</a><br>1.查看当前硬盘使用状况：</p>\n<pre><code>df -h\n</code></pre><p>2.查看新硬盘</p>\n<pre><code>fdisk -l \n</code></pre><p>新添加的硬盘的编号为 <code>/dev/xvdb    /dev/xvde  /dev/vdb</code></p>\n<p>3.硬盘分区<br> 1)进入fdisk模式<br>    <code>/sbin/fdisk /dev/vdb</code><br> 2)输入n进行分区<br> 3)选择分区类型   </p>\n<p>  这里有两个选项：   </p>\n<ul>\n<li>p: 主分区 linux上主分区最多能有4个    </li>\n<li>e: 扩展分区 linux上扩展分区只能有1个，扩展分区创建后不能直接使用，还要在扩展分区上创建逻辑分区。     </li>\n</ul>\n<p>这里我选择的p。</p>\n<p> 4)选择分区个数<br> 可以选择4个分区，这里我只分成1个分区<br> 5)设置柱面，这里选择默认值就可以<br> 6)输入w，写入分区表，进行分区   </p>\n<p>4.格式化分区 </p>\n<p>将新分区格式化为ext4文件系统<br>1)如果创建的是主分区<br><code>mkfs -t ext4  /dev/vdb1</code></p>\n<p>5.挂载硬盘<br>1)创建挂载点<br>在根目录下创建sqjr目录<br><code>mkdir /server /sqjr</code><br>2)将/dev/vdb1挂载到/sqjr下<br> <code>mount /dev/vdb1 /server  /sqjr</code></p>\n<p>6.设置开机启动自动挂载<br>新创建的分区不能开机自动挂载，每次重启机器都要手动挂载。<br>设置开机自动挂载需要修改/etc/fstab文件<br><code>vi /etc/fstab</code><br>在文件的最后增加一行<br><code>/dev/vdb1 /server ext4 defaults 1 2</code></p>\n<p>7.取消挂载 /dev/xvdb1<br><code>umount /dev/vdb1</code></p>\n<p>8.重启<br><code>reboot -n</code>                        </p>\n"},{"title":"nginx能做什么","date":"2018-09-12T09:14:54.000Z","_content":"\n## 前言\n本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。\n\n## Nginx能做什么\n反向代理\n负载均衡\nHTTP服务器（包含动静分离）\n正向代理\n以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做\n\n## 反向代理\n反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码\n\n    server {  \n        listen       80;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n        location / {\n            proxy_pass http://localhost:8080;\n            proxy_set_header Host $host:$server_port;\n        }\n    }\n保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了\n\n## 负载均衡\n负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。\n\n### 1.RR（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n简单配置\n\n\n    upstream test {\n        server localhost:8080;\n        server localhost:8081;\n    }\n    server {\n        listen       81;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n        location / {\n            proxy_pass http://test;\n            proxy_set_header Host $host:$server_port;\n        }\n    }\n    \n负载均衡的核心代码为\n\n    upstream test {\n        server localhost:8080;\n        server localhost:8081;\n    }\n这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。\n\n### 2.权重\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如\n\n    upstream test {\n        server localhost:8080 weight=9;\n        server localhost:8081 weight=1;\n    }\n那么10次一般只会有1次会访问到8081，而有9次会访问到8080\n\n### 3.ip_hash\n上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n\n    upstream test {\n        ip_hash;\n        server localhost:8080;\n        server localhost:8081;\n    }\n### 4.fair（第三方）\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\n    upstream backend { \n        fair; \n        server localhost:8080;\n        server localhost:8081;\n    }\n### 5.url_hash（第三方）\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n\n    upstream backend { \n        hash $request_uri; \n        hash_method crc32; \n        server localhost:8080;\n        server localhost:8081;\n    }\n以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍\n\n## HTTP服务器\nNginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器\n\n    server {\n        listen       80;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n\n        location / {\n               root   e:\\wwwroot;\n               index  index.html;\n           }\n    }\n这样如果访问http://localhost 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。\n\n## 动静分离\n动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路\n\n    upstream test{  \n       server localhost:8080;  \n       server localhost:8081;  \n    }   \n\n    server {  \n        listen       80;  \n        server_name  localhost;  \n\n        location / {  \n            root   e:\\wwwroot;  \n            index  index.html;  \n        }  \n\n        # 所有静态请求都由nginx处理，存放目录为html  \n        location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n            root    e:\\wwwroot;  \n        }  \n\n        # 所有动态请求都转发给tomcat处理  \n        location ~ \\.(jsp|do)$ {  \n            proxy_pass  http://test;  \n        }  \n\n        error_page   500 502 503 504  /50x.html;  \n        location = /50x.html {  \n            root   e:\\wwwroot;  \n        }  \n    }\n这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活\n\n## 正向代理\n正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。\n\n    resolver 114.114.114.114 8.8.8.8;\n    server {\n\n        resolver_timeout 5s;\n\n        listen 81;\n\n        access_log  e:\\wwwroot\\proxy.access.log;\n        error_log   e:\\wwwroot\\proxy.error.log;\n\n        location / {\n            proxy_pass http://$host$request_uri;\n        }\n    }\nresolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。\n\n## 最后说两句\n启动停止及配置文件位置的命令:\n\n    /etc/init.d/nginx start/restart # 启动/重启Nginx服务\n    \n    /etc/init.d/nginx stop # 停止Nginx服务\n    \n    /etc/nginx/nginx.conf # Nginx配置文件位置\nNginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是\n\n    nginx -s reload\nwindows下面就是\n\n    nginx.exe -s reload\n\n著作权归作者所有。\n商业转载请联系作者获得授权，非商业转载请注明出处。\n作者：ll\n链接：https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340\n来源：极客教程","source":"_posts/nginx-study.md","raw":"---\ntitle: nginx能做什么\ndate: 2018-09-12 17:14:54\ncategories: Nginx\ntags: nginx能做什么\n---\n\n## 前言\n本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。\n\n## Nginx能做什么\n反向代理\n负载均衡\nHTTP服务器（包含动静分离）\n正向代理\n以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做\n\n## 反向代理\n反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码\n\n    server {  \n        listen       80;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n        location / {\n            proxy_pass http://localhost:8080;\n            proxy_set_header Host $host:$server_port;\n        }\n    }\n保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了\n\n## 负载均衡\n负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。\n\n### 1.RR（默认）\n每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。\n简单配置\n\n\n    upstream test {\n        server localhost:8080;\n        server localhost:8081;\n    }\n    server {\n        listen       81;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n        location / {\n            proxy_pass http://test;\n            proxy_set_header Host $host:$server_port;\n        }\n    }\n    \n负载均衡的核心代码为\n\n    upstream test {\n        server localhost:8080;\n        server localhost:8081;\n    }\n这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问http://localhost 的时候,也不会有问题，会默认跳转到http://localhost:8080 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。\n\n### 2.权重\n指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如\n\n    upstream test {\n        server localhost:8080 weight=9;\n        server localhost:8081 weight=1;\n    }\n那么10次一般只会有1次会访问到8081，而有9次会访问到8080\n\n### 3.ip_hash\n上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。\n\n    upstream test {\n        ip_hash;\n        server localhost:8080;\n        server localhost:8081;\n    }\n### 4.fair（第三方）\n按后端服务器的响应时间来分配请求，响应时间短的优先分配。\n\n    upstream backend { \n        fair; \n        server localhost:8080;\n        server localhost:8081;\n    }\n### 5.url_hash（第三方）\n按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法\n\n    upstream backend { \n        hash $request_uri; \n        hash_method crc32; \n        server localhost:8080;\n        server localhost:8081;\n    }\n以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍\n\n## HTTP服务器\nNginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器\n\n    server {\n        listen       80;                                                         \n        server_name  localhost;                                               \n        client_max_body_size 1024M;\n\n\n        location / {\n               root   e:\\wwwroot;\n               index  index.html;\n           }\n    }\n这样如果访问http://localhost 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。\n\n## 动静分离\n动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路\n\n    upstream test{  \n       server localhost:8080;  \n       server localhost:8081;  \n    }   \n\n    server {  \n        listen       80;  \n        server_name  localhost;  \n\n        location / {  \n            root   e:\\wwwroot;  \n            index  index.html;  \n        }  \n\n        # 所有静态请求都由nginx处理，存放目录为html  \n        location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n            root    e:\\wwwroot;  \n        }  \n\n        # 所有动态请求都转发给tomcat处理  \n        location ~ \\.(jsp|do)$ {  \n            proxy_pass  http://test;  \n        }  \n\n        error_page   500 502 503 504  /50x.html;  \n        location = /50x.html {  \n            root   e:\\wwwroot;  \n        }  \n    }\n这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活\n\n## 正向代理\n正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。\n\n    resolver 114.114.114.114 8.8.8.8;\n    server {\n\n        resolver_timeout 5s;\n\n        listen 81;\n\n        access_log  e:\\wwwroot\\proxy.access.log;\n        error_log   e:\\wwwroot\\proxy.error.log;\n\n        location / {\n            proxy_pass http://$host$request_uri;\n        }\n    }\nresolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。\n\n## 最后说两句\n启动停止及配置文件位置的命令:\n\n    /etc/init.d/nginx start/restart # 启动/重启Nginx服务\n    \n    /etc/init.d/nginx stop # 停止Nginx服务\n    \n    /etc/nginx/nginx.conf # Nginx配置文件位置\nNginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是\n\n    nginx -s reload\nwindows下面就是\n\n    nginx.exe -s reload\n\n著作权归作者所有。\n商业转载请联系作者获得授权，非商业转载请注明出处。\n作者：ll\n链接：https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340\n来源：极客教程","slug":"nginx-study","published":1,"updated":"2018-11-09T01:20:30.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38p200cpqcrgsp04pp69","content":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。</p>\n<h2 id=\"Nginx能做什么\"><a href=\"#Nginx能做什么\" class=\"headerlink\" title=\"Nginx能做什么\"></a>Nginx能做什么</h2><p>反向代理<br>负载均衡<br>HTTP服务器（包含动静分离）<br>正向代理<br>以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码</p>\n<pre><code>server {  \n    listen       80;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_set_header Host $host:$server_port;\n    }\n}\n</code></pre><p>保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。</p>\n<h3 id=\"1-RR（默认）\"><a href=\"#1-RR（默认）\" class=\"headerlink\" title=\"1.RR（默认）\"></a>1.RR（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>简单配置</p>\n<pre><code>upstream test {\n    server localhost:8080;\n    server localhost:8081;\n}\nserver {\n    listen       81;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n    location / {\n        proxy_pass http://test;\n        proxy_set_header Host $host:$server_port;\n    }\n}\n</code></pre><p>负载均衡的核心代码为</p>\n<pre><code>upstream test {\n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><p>这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问<a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">http://localhost</a> 的时候,也不会有问题，会默认跳转到<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。</p>\n<h3 id=\"2-权重\"><a href=\"#2-权重\" class=\"headerlink\" title=\"2.权重\"></a>2.权重</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如</p>\n<pre><code>upstream test {\n    server localhost:8080 weight=9;\n    server localhost:8081 weight=1;\n}\n</code></pre><p>那么10次一般只会有1次会访问到8081，而有9次会访问到8080</p>\n<h3 id=\"3-ip-hash\"><a href=\"#3-ip-hash\" class=\"headerlink\" title=\"3.ip_hash\"></a>3.ip_hash</h3><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>\n<pre><code>upstream test {\n    ip_hash;\n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><h3 id=\"4-fair（第三方）\"><a href=\"#4-fair（第三方）\" class=\"headerlink\" title=\"4.fair（第三方）\"></a>4.fair（第三方）</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<pre><code>upstream backend { \n    fair; \n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><h3 id=\"5-url-hash（第三方）\"><a href=\"#5-url-hash（第三方）\" class=\"headerlink\" title=\"5.url_hash（第三方）\"></a>5.url_hash（第三方）</h3><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</p>\n<pre><code>upstream backend { \n    hash $request_uri; \n    hash_method crc32; \n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><p>以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍</p>\n<h2 id=\"HTTP服务器\"><a href=\"#HTTP服务器\" class=\"headerlink\" title=\"HTTP服务器\"></a>HTTP服务器</h2><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器</p>\n<pre><code>server {\n    listen       80;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n\n    location / {\n           root   e:\\wwwroot;\n           index  index.html;\n       }\n}\n</code></pre><p>这样如果访问<a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">http://localhost</a> 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路</p>\n<pre><code>upstream test{  \n   server localhost:8080;  \n   server localhost:8081;  \n}   \n\nserver {  \n    listen       80;  \n    server_name  localhost;  \n\n    location / {  \n        root   e:\\wwwroot;  \n        index  index.html;  \n    }  \n\n    # 所有静态请求都由nginx处理，存放目录为html  \n    location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n        root    e:\\wwwroot;  \n    }  \n\n    # 所有动态请求都转发给tomcat处理  \n    location ~ \\.(jsp|do)$ {  \n        proxy_pass  http://test;  \n    }  \n\n    error_page   500 502 503 504  /50x.html;  \n    location = /50x.html {  \n        root   e:\\wwwroot;  \n    }  \n}\n</code></pre><p>这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。</p>\n<pre><code>resolver 114.114.114.114 8.8.8.8;\nserver {\n\n    resolver_timeout 5s;\n\n    listen 81;\n\n    access_log  e:\\wwwroot\\proxy.access.log;\n    error_log   e:\\wwwroot\\proxy.error.log;\n\n    location / {\n        proxy_pass http://$host$request_uri;\n    }\n}\n</code></pre><p>resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。</p>\n<h2 id=\"最后说两句\"><a href=\"#最后说两句\" class=\"headerlink\" title=\"最后说两句\"></a>最后说两句</h2><p>启动停止及配置文件位置的命令:</p>\n<pre><code>/etc/init.d/nginx start/restart # 启动/重启Nginx服务\n\n/etc/init.d/nginx stop # 停止Nginx服务\n\n/etc/nginx/nginx.conf # Nginx配置文件位置\n</code></pre><p>Nginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是</p>\n<pre><code>nginx -s reload\n</code></pre><p>windows下面就是</p>\n<pre><code>nginx.exe -s reload\n</code></pre><p>著作权归作者所有。<br>商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：ll<br>链接：<a href=\"https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340\" target=\"_blank\" rel=\"noopener\">https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340</a><br>来源：极客教程</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h2><p>本文只针对Nginx在不加载第三方模块的情况能处理哪些事情，由于第三方模块太多所以也介绍不完，当然本文本身也可能介绍的不完整，毕竟只是我个人使用过和了解到过得。</p>\n<h2 id=\"Nginx能做什么\"><a href=\"#Nginx能做什么\" class=\"headerlink\" title=\"Nginx能做什么\"></a>Nginx能做什么</h2><p>反向代理<br>负载均衡<br>HTTP服务器（包含动静分离）<br>正向代理<br>以上就是我了解到的Nginx在不依赖第三方模块能处理的事情，下面详细说明每种功能怎么做</p>\n<h2 id=\"反向代理\"><a href=\"#反向代理\" class=\"headerlink\" title=\"反向代理\"></a>反向代理</h2><p>反向代理应该是Nginx做的最多的一件事了，什么是反向代理呢，以下是百度百科的说法：反向代理（Reverse Proxy）方式是指以代理服务器来接受internet上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求连接的客户端，此时代理服务器对外就表现为一个反向代理服务器。简单来说就是真实的服务器不能直接被外部网络访问，所以需要一台代理服务器，而代理服务器能被外部网络访问的同时又跟真实服务器在同一个网络环境，当然也可能是同一台服务器，端口不同而已。 下面贴上一段简单的实现反向代理的代码</p>\n<pre><code>server {  \n    listen       80;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n    location / {\n        proxy_pass http://localhost:8080;\n        proxy_set_header Host $host:$server_port;\n    }\n}\n</code></pre><p>保存配置文件后启动Nginx，这样当我们访问localhost的时候，就相当于访问localhost:8080了</p>\n<h2 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h2><p>负载均衡也是Nginx常用的一个功能，负载均衡其意思就是分摊到多个操作单元上进行执行，例如Web服务器、FTP服务器、企业关键应用服务器和其它关键任务服务器等，从而共同完成工作任务。简单而言就是当有2台或以上服务器时，根据规则随机的将请求分发到指定的服务器上处理，负载均衡配置一般都需要同时配置反向代理，通过反向代理跳转到负载均衡。而Nginx目前支持自带3种负载均衡策略，还有2种常用的第三方策略。</p>\n<h3 id=\"1-RR（默认）\"><a href=\"#1-RR（默认）\" class=\"headerlink\" title=\"1.RR（默认）\"></a>1.RR（默认）</h3><p>每个请求按时间顺序逐一分配到不同的后端服务器，如果后端服务器down掉，能自动剔除。<br>简单配置</p>\n<pre><code>upstream test {\n    server localhost:8080;\n    server localhost:8081;\n}\nserver {\n    listen       81;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n    location / {\n        proxy_pass http://test;\n        proxy_set_header Host $host:$server_port;\n    }\n}\n</code></pre><p>负载均衡的核心代码为</p>\n<pre><code>upstream test {\n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><p>这里我配置了2台服务器，当然实际上是一台，只是端口不一样而已，而8081的服务器是不存在的,也就是说访问不到，但是我们访问<a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">http://localhost</a> 的时候,也不会有问题，会默认跳转到<a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a> 具体是因为Nginx会自动判断服务器的状态，如果服务器处于不能访问（服务器挂了），就不会跳转到这台服务器，所以也避免了一台服务器挂了影响使用的情况，由于Nginx默认是RR策略，所以我们不需要其他更多的设置。</p>\n<h3 id=\"2-权重\"><a href=\"#2-权重\" class=\"headerlink\" title=\"2.权重\"></a>2.权重</h3><p>指定轮询几率，weight和访问比率成正比，用于后端服务器性能不均的情况。 例如</p>\n<pre><code>upstream test {\n    server localhost:8080 weight=9;\n    server localhost:8081 weight=1;\n}\n</code></pre><p>那么10次一般只会有1次会访问到8081，而有9次会访问到8080</p>\n<h3 id=\"3-ip-hash\"><a href=\"#3-ip-hash\" class=\"headerlink\" title=\"3.ip_hash\"></a>3.ip_hash</h3><p>上面的2种方式都有一个问题，那就是下一个请求来的时候请求可能分发到另外一个服务器，当我们的程序不是无状态的时候（采用了session保存数据），这时候就有一个很大的很问题了，比如把登录信息保存到了session中，那么跳转到另外一台服务器的时候就需要重新登录了，所以很多时候我们需要一个客户只访问一个服务器，那么就需要用iphash了，iphash的每个请求按访问ip的hash结果分配，这样每个访客固定访问一个后端服务器，可以解决session的问题。</p>\n<pre><code>upstream test {\n    ip_hash;\n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><h3 id=\"4-fair（第三方）\"><a href=\"#4-fair（第三方）\" class=\"headerlink\" title=\"4.fair（第三方）\"></a>4.fair（第三方）</h3><p>按后端服务器的响应时间来分配请求，响应时间短的优先分配。</p>\n<pre><code>upstream backend { \n    fair; \n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><h3 id=\"5-url-hash（第三方）\"><a href=\"#5-url-hash（第三方）\" class=\"headerlink\" title=\"5.url_hash（第三方）\"></a>5.url_hash（第三方）</h3><p>按访问url的hash结果来分配请求，使每个url定向到同一个后端服务器，后端服务器为缓存时比较有效。 在upstream中加入hash语句，server语句中不能写入weight等其他的参数，hash_method是使用的hash算法</p>\n<pre><code>upstream backend { \n    hash $request_uri; \n    hash_method crc32; \n    server localhost:8080;\n    server localhost:8081;\n}\n</code></pre><p>以上5种负载均衡各自适用不同情况下使用，所以可以根据实际情况选择使用哪种策略模式,不过fair和url_hash需要安装第三方模块才能使用，由于本文主要介绍Nginx能做的事情，所以Nginx安装第三方模块不会再本文介绍</p>\n<h2 id=\"HTTP服务器\"><a href=\"#HTTP服务器\" class=\"headerlink\" title=\"HTTP服务器\"></a>HTTP服务器</h2><p>Nginx本身也是一个静态资源的服务器，当只有静态资源的时候，就可以使用Nginx来做服务器，同时现在也很流行动静分离，就可以通过Nginx来实现，首先看看Nginx做静态资源服务器</p>\n<pre><code>server {\n    listen       80;                                                         \n    server_name  localhost;                                               \n    client_max_body_size 1024M;\n\n\n    location / {\n           root   e:\\wwwroot;\n           index  index.html;\n       }\n}\n</code></pre><p>这样如果访问<a href=\"http://localhost\" target=\"_blank\" rel=\"noopener\">http://localhost</a> 就会默认访问到E盘wwwroot目录下面的index.html，如果一个网站只是静态页面的话，那么就可以通过这种方式来实现部署。</p>\n<h2 id=\"动静分离\"><a href=\"#动静分离\" class=\"headerlink\" title=\"动静分离\"></a>动静分离</h2><p>动静分离是让动态网站里的动态网页根据一定规则把不变的资源和经常变的资源区分开来，动静资源做好了拆分以后，我们就可以根据静态资源的特点将其做缓存操作，这就是网站静态化处理的核心思路</p>\n<pre><code>upstream test{  \n   server localhost:8080;  \n   server localhost:8081;  \n}   \n\nserver {  \n    listen       80;  \n    server_name  localhost;  \n\n    location / {  \n        root   e:\\wwwroot;  \n        index  index.html;  \n    }  \n\n    # 所有静态请求都由nginx处理，存放目录为html  \n    location ~ \\.(gif|jpg|jpeg|png|bmp|swf|css|js)$ {  \n        root    e:\\wwwroot;  \n    }  \n\n    # 所有动态请求都转发给tomcat处理  \n    location ~ \\.(jsp|do)$ {  \n        proxy_pass  http://test;  \n    }  \n\n    error_page   500 502 503 504  /50x.html;  \n    location = /50x.html {  \n        root   e:\\wwwroot;  \n    }  \n}\n</code></pre><p>这样我们就可以吧HTML以及图片和css以及js放到wwwroot目录下，而tomcat只负责处理jsp和请求，例如当我们后缀为gif的时候，Nginx默认会从wwwroot获取到当前请求的动态图文件返回，当然这里的静态文件跟Nginx是同一台服务器，我们也可以在另外一台服务器，然后通过反向代理和负载均衡配置过去就好了，只要搞清楚了最基本的流程，很多配置就很简单了，另外localtion后面其实是一个正则表达式，所以非常灵活</p>\n<h2 id=\"正向代理\"><a href=\"#正向代理\" class=\"headerlink\" title=\"正向代理\"></a>正向代理</h2><p>正向代理，意思是一个位于客户端和原始服务器(origin server)之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并指定目标(原始服务器)，然后代理向原始服务器转交请求并将获得的内容返回给客户端。客户端才能使用正向代理。当你需要把你的服务器作为代理服务器的时候，可以用Nginx来实现正向代理，但是目前Nginx有一个问题，那么就是不支持HTTPS，虽然我百度到过配置HTTPS的正向代理，但是到最后发现还是代理不了，当然可能是我配置的不对，所以也希望有知道正确方法的同志们留言说明一下。</p>\n<pre><code>resolver 114.114.114.114 8.8.8.8;\nserver {\n\n    resolver_timeout 5s;\n\n    listen 81;\n\n    access_log  e:\\wwwroot\\proxy.access.log;\n    error_log   e:\\wwwroot\\proxy.error.log;\n\n    location / {\n        proxy_pass http://$host$request_uri;\n    }\n}\n</code></pre><p>resolver是配置正向代理的DNS服务器，listen 是正向代理的端口，配置好了就可以在ie上面或者其他代理插件上面使用服务器ip+端口号进行代理了。</p>\n<h2 id=\"最后说两句\"><a href=\"#最后说两句\" class=\"headerlink\" title=\"最后说两句\"></a>最后说两句</h2><p>启动停止及配置文件位置的命令:</p>\n<pre><code>/etc/init.d/nginx start/restart # 启动/重启Nginx服务\n\n/etc/init.d/nginx stop # 停止Nginx服务\n\n/etc/nginx/nginx.conf # Nginx配置文件位置\n</code></pre><p>Nginx是支持热启动的，也就是说当我们修改配置文件后，不用关闭Nginx，就可以实现让配置生效，当然我并不知道多少人知道这个，反正我一开始并不知道，导致经常杀死了Nginx线程再来启动。。。Nginx从新读取配置的命令是</p>\n<pre><code>nginx -s reload\n</code></pre><p>windows下面就是</p>\n<pre><code>nginx.exe -s reload\n</code></pre><p>著作权归作者所有。<br>商业转载请联系作者获得授权，非商业转载请注明出处。<br>作者：ll<br>链接：<a href=\"https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340\" target=\"_blank\" rel=\"noopener\">https://www.geekjc.com/post/58e70c55e8d0c72d3c4fa340</a><br>来源：极客教程</p>\n"},{"title":"项目管理系统Redmine使用","date":"2018-06-01T13:35:04.000Z","_content":"\n在软件开发过程中，项目管理的有效性直接会影响到项目开发的进度，质量，还有整个团队的协助。总之，没有一个好的项目管理系统，这对项目经理来说就像是上了战场，却没有任何武器一样，必定败仗。  \n\n下面介绍这款比较流行的项目管理工具redmine。有了它，项目经理就可以对整个项目的开发全过程进行管理。任务的分配、bug的跟踪、知识库的建立等等……\n\n[官网](http://www.redmine.org)\n\n## 在ubuntu下安装\n\n参考：http://www.redmine.org/projects/redmine/wiki/Guide\n\n###　下载redmine安装包\n\n网址：http://www.redmine.org/projects/redmine/wiki/Download\n\n    wget http://www.redmine.org/releases/redmine-3.4.5.tar.gz\n    \n\n### 安装Ruby环境\n\n参考官网说明，注意redmine版本对ruby版本的要求。 \n\n1.下载地址：http://ftp.ruby-lang.org/pub/ruby/   \n    \n    //下载\n    zmt@zmt-Lenovo:~/Desktop/work/tools$ wget http://ftp.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz\n    zmt@zmt-Lenovo:~/Desktop/work/tools$ tar -zxvf ruby-2.4.4.tar.gz \n    \n    //查询openssl安装路径\n    zmt@zmt-Lenovo:~$ openssl version -a\n    OpenSSL 1.1.0g  2 Nov 2017\n    built on: reproducible build, date unspecified\n    platform: debian-amd64\n    compiler: gcc -DDSO_DLFCN -DHAVE_DLFCN_H -DNDEBUG -DOPENSSL_THREADS -DOPENSSL_NO_STATIC_ENGINE -DOPENSSL_PIC -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DOPENSSLDIR=\"\\\"/usr/lib/ssl\\\"\" -DENGINESDIR=\"\\\"/usr/lib/x86_64-linux-gnu/engines-1.1\\\"\" \n    OPENSSLDIR: \"/usr/lib/ssl\"\n    ENGINESDIR: \"/usr/lib/x86_64-linux-gnu/engines-1.1\"\n    \n    //看上面结果，确定openssl安装dir为：/usr/lib/ssl\n    \n    //安装：\n    $ cd ruby-2.4.4\n    $ ./configure  --with-openssl-dir=/usr/lib/ssl\n    $ make\n    $ sudo make install\n    \n    \n3.检查是否安装成功：    \n    \n    zmt@zmt-Lenovo:~$ ruby -v\n    ruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-linux]\n\n看到上面显示说明安装成功。\n\n### 创建空的数据库，并初始化用户\n\n一般数据库名为redmine,但是可以自己更改。\n\n1.MySQL\n\n创建数据库登录用户redmine，密码为redmine\n    \n    //mysql要求５.6或以上版本\n    \n    CREATE DATABASE redmine CHARACTER SET utf8mb4;\n    CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';   \n    \n    //刷新权限\n    flush privileges;\n    \n\n### 数据库连接配置设置\n\n解压下载的`redmine-3.4.5.tar.gz`， 并进入解压包内。 在`config`目录下，可以看到文件`database.yml.example`，复制该文件命名为`database.yml`，放在同一个目录`config`下。下面就可以编辑文件`database.yml`了。  \n\n1.mysql的配置\n\n- 默认端口3306\n\n        production:\n          adapter: mysql2\n          database: redmine\n          host: localhost\n          username: redmine\n          password: redmine\n\n- 不是3306端口，如下配置：\n\n        production:\n          adapter: mysql2\n          database: redmine\n          host: localhost\n          port: 3307\n          username: redmine\n          password: redmine\n          \n按照以上配置修改好，保存并退出。\n\n### redmine运行相关依赖包安装\n\nRedmine uses [Bundler](http://gembundler.com/) to manage gems dependencies.   \n\n1.首先按照Bundler\n\n    sudo gem install bundler\n    \n报错误：\n\n    zmt@zmt-Lenovo:~$ gem install bundler\n    ERROR:  While executing gem ... (Gem::Exception)\n        Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources\n\n意思是，要要求系统按照OpenSSL，然后按上面步骤重新编译安装ruby。\n\n按照openssl：\n    \n    sudo apt-get install openssl\n    \n重新编译按照ruby后再执行`gem install bundler`。      \n\n还是不行，可能是因为不是以root用户安装的缘故。 \n\n_注：_  没关系，我们不通过网络安装，而是直接下载gem安装包安装。\n\n\n    安装RubyGems安装\n    \n    如果第一步能执行成功，不需要另外安装rubygems，因为安装ruby的时候已经安装。 \n    \n    网址：https://rubygems.org/\n    \n    下载并安装：\n    \n        # wget https://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.6.tgz\n        # tar zxvf rubygems-2.6.6.tgz\n        # cd rubygems-2.6.6.tgz\n        # ruby setup.rb\n        \n        //显示版本好，说民安装成功\n        zmt@zmt-Lenovo:~/Desktop/work/tools/rubygems-2.6.6$ gem -v\n        2.6.6\n                      \n    安装成功，重新执行步骤1，即安装Bundler，执行：\n    \n        gem install bundler\n\n \n2.然后可以利用bundler安装redmine相关依赖包\n\nThen you can install all the gems required by Redmine using the following command:\n\n    bundle install --without development test\n    \n<<----未完--->>\n\n## Centos7下安装全过程记录\n\n参考网址：http://www.redmine.org/projects/redmine/wiki/RedmineInstall\n\n应用版本信息：\nredmine： redmine-3.4.6.tar.gz   \nruby： ruby-2.3.6.tar.gz\n\n首先安装系统相关包：\n\n    yum -y install patch make gcc gcc-c++ gcc-g77 flex* bison file  \n    yum -y install libtool libtool-libs libtool-ltdl-devel* autoconf kernel-devel automake libmcrypt*  \n    yum -y install libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel  \n    yum -y install freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel  \n    yum -y install glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel  \n    yum -y install ncurses ncurses-devel curl curl-devel e2fsprogs  \n    yum -y install e2fsprogs-devel krb5 krb5-devel libidn libidn-devel  \n    yum -y install openssl openssl-devel vim-minimal nano sendmail  \n    yum -y install fonts-chinese gettext gettext-devel  \n    yum -y install gmp-devel pspell-devel   \n    yum -y install readline* libxslt* pcre* net-snmp* gmp* libtidy*  \n    yum -y install ImageMagick* subversion*  \n\n### 下载redmine安装包\n\n可以在官网下载正式发布的二进制包[下载](http://www.redmine.org/projects/redmine/wiki/Download)。 \n\n### 创建空的数据库以及相关数据库用户\n\n首先要保证已经安装好数据库。下面以mysql为例进行安装。mysql版本>5.5.2。     \n创建脚本：    \n   \n    CREATE DATABASE redmine CHARACTER SET utf8mb4;\n    #CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password'; #这样的，navicat客户端无法登录\n    CREATE USER 'redmine'@'localhost' IDENTIFIED WITH mysql_native_password BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';\n    \n### 为redmine配置数据库\n\n首先，解压redmine包，并进入config目录。  \n\n`[root@ymu config]# cp database.yml.example database.yml`\n\n然后编辑`database.yml`：\n\n    production:\n      adapter: mysql2\n      database: redmine\n      host: localhost\n      port: 3307\n      username: redmine\n      password: redmine\n      \n_注意_: 主机名用`localhost`可能报错，要改成`127.0.0.1`。      \n      \n### 安装依赖包\n\n1.安装ruby环境。\n\n- 安装上面描述方式，ruby源码包安装方式。选择版本安装。\n- 系统源安装。`yum install gem`。会自动安装ruby环境。\n\n下面采用源码编译安装方式。   \n检查是否安装成功：   \n`ruby -v`   `gem -v`\n\n问题解决：安装完ruby却提示`[/usr/bin/ruby: No such file or directory]`\n    \n`ln -s /usr/local/bin/ruby /usr/bin/ruby`   \n`ln -s /usr/local/bin/gem /usr/bin/gem` \n \n\n2.安装`bundler`\n\nredmine的依赖包都通过bundler来安装。   \n\n`gem install bundler`\n\n3.安装所有依赖\n\n执行下面命令前，记得要按照上面方法安装所有系统依赖包。\n\n    [root@ymu ~]# cd /server/tools/redmine-3.4.6/\n    [root@ymu redmine-3.4.6]# bundle install --without development test\n   \n\n### 安全生成存储会话\n\n`bundle exec rake generate_secret_token`\n \n\n### 创建表\n\n    [root@ymu redmine-3.4.6]# bundle exec rake generate_secret_token\n    [root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake db:migrate\n\n查看数据库，可以看到已经创建了很多表。     \n\n### 设置数据库默认数据\n\n    [root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake redmine:load_default_data\n    \n    Select language: ar, az, bg, bs, ca, cs, da, de, el, en, en-GB, es, es-PA, et, eu, fa, fi, fr, gl, he, hr, hu, id, it, ja, ko, lt, lv, mk, mn, nl, no, pl, pt, pt-BR, ro, ru, sk, sl, sq, sr, sr-YU, sv, th, tr, uk, vi, zh, zh-TW [en] zh\n    ====================================\n    Default configuration data loaded.\n\n记得：输入zh，然后按下回车。否则会是英文版本数据。\n\n### 设置文件权限\n\n- 如果上面的所有操作都是root用户，那么就不必要设置文件权限，可以跳过此步骤。 （_上面以root操作，跳过这步骤_）    \n- 如果不是在root超级用户下，则要设置文件权限，否则redmine应用程序无法操作一些文件权限。    \n\n在redmine解压根目录下，这些文件必须赋予权限：  \n\n    files (storage of attachments)\n    log (application log file production.log)\n    tmp and tmp/pdf (create these ones if not present, used to generate PDF documents among other things)\n    public/plugin_assets (assets of plugins)\n    \n如果没有这些文件：     \n    \n    mkdir -p tmp tmp/pdf public/plugin_assets\n    sudo chown -R redmine:redmine files log tmp public/plugin_assets\n    sudo chmod -R 755 files log tmp public/plugin_assets\n    \n如果都有：   \n\n     sudo chown -R redmine:redmine files log tmp public/plugin_assets\n     sudo chmod -R 755 files log tmp public/plugin_assets\n \n_注意_:保证下面目录不包含可执行文件。\n \n    sudo find files log tmp public/plugin_assets -type f -exec chmod -x {} +    \n    \n### 测试是否安装成功\n\n按照下面经验执行操作：\n\n    bundle exec rails server webrick -e production   //在redmine安装目录下执行\n    \n    //注意，服务器端执行上面命令可能报错，可能是端口不可用，可以改变端口：\n    bundle exec rails server webrick -e production -p 8889\n    \n    改变端口执行服务成功，但是在客户机子不能访问，此时要这么执行：\n     bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889\n    \n    ok搞定\n    \n    守护进程模式执行：\n     nohup bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 &\n    或者：\n    bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 -d    \n    \n然后就可以访问：http：//loaclhost:port。  \n\n### 登录redmine\n\n默认账号密码： \nusername=admin  \npwd=admin\n\n打开网址后，用默认账号密码登录后，会要求修改密码。把密码改为： \nusername=admin  \npwd=admin123    \n\n按页面提示，填写修改相关信息即可。   \n\n### 修改配置（不修改则采用默认的配置）\n\nredmine的配置设置文件放在：config/configuration.yml。  \n如果要自己定义配置，则可以`copy config/configuration.yml.example to config/configuration.yml`，然后编辑`configuration.yml`文件即可。 \n\n记得：修改配置文件后重启redmine，否则不生效。  \n\n### 重启redmine\n\n采用直接kill掉：\n\n    lsof -i:3000\n    kill -9 pid\n    \n### 开机自启\n\n编辑启动文件\n\nvi /etc/rc.local\n\n最后一行或者适当的位置，加入一下内容。此处必须用绝对路径。注意根据实际redmine路径来填写。\n\n/usr/local/rvm/rubies/ruby-2.0.0-p598/bin/ruby /root/redmine-2.6.0/script/rails server webrick -e production -d    \n\n### 设置Email/SMTP服务器\n\n项目管理中，分配了任务或者测试提交了bug给某个开发人员，那么可以通过邮件及时的提醒他。    \n\n下面我们就来配置邮件服务器：  \n参考：http://www.redmine.org/projects/redmine/wiki/EmailConfiguration  \n\n1.编辑配置文件：config/configuration.yml\n\n添加邮箱服务器配置，异步发送邮件（qq邮箱为例子）：\n\n    email_delivery:\n        delivery_method: :async_smtp\n        async_smtp_settings:\n          address: \"smtp.qq.com\"\n          port: 25\n          authentication: :login\n          domain: 'qq.com'\n          user_name: '932852117@qq.com'\n          password: '××××××'\n              \n下面是实际操作内容：              \n\n    # default configuration options for all environments\n    default:\n      # Outgoing emails configuration\n      # See the examples below and the Rails guide for more configuration options:\n      # http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration\n      email_delivery:\n        delivery_method: :async_smtp\n        async_smtp_settings:\n          address: \"smtp.qq.com\"\n          port: 25\n          authentication: :login\n          domain: 'qq.com'\n          user_name: '932852117@qq.com'\n          password: '××××××'\n    \n      # ==== Simple SMTP server at localhost\n\n2.开启邮箱服务器\n\n{%asset_img b.png%}\n\n3.重启redmine并测试是否配置成功。 \n        \n登录redmine，在管理->配置中： \n\n{%asset_img c.png%}\n\n输入配置的邮箱地址后，保存。然后点击右下角的`发送测试邮件`：     \n\n{%asset_img d.png%}\n\n看到绿色提示`邮件已发送至 zhangmutian@xcsqjr.com`。证明配置已成功，可以愉快的使用了。\n\n\n### scm配置\n\n主要是svn和git版本库管理工具。  \n\n如：svn的  \n`scm_subversion_command: \"svn_replacement.exe\"`\n\n只需要安装svn或者git服务端，然后在配置文件指向即可。   \n\n### 其它的配置\n\n一般采用默认的就好了。 \n\n1.附件存储路径。`attachments_storage_path: /var/redmine/files`   \n2.日志保存路径。   \n\n等等……\n\n------------------------------------------------------\n\n恭喜恭喜，到此，你已成功安装redmine了，并且它已经具备了该有的基础功能了。赶紧来看下它帅帅的样子吧：\n\n{%asset_img a.png%}\n\n尽情的去探索redmine很多很多，酷酷的特性吧，让它正真成为你在项目管理中的瑞士军刀……\n\n\n\n\n\n          ","source":"_posts/redmine-start.md","raw":"---\ntitle: 项目管理系统Redmine使用\ndate: 2018-06-01 21:35:04\ncategories: redmine\ntags: \n---\n\n在软件开发过程中，项目管理的有效性直接会影响到项目开发的进度，质量，还有整个团队的协助。总之，没有一个好的项目管理系统，这对项目经理来说就像是上了战场，却没有任何武器一样，必定败仗。  \n\n下面介绍这款比较流行的项目管理工具redmine。有了它，项目经理就可以对整个项目的开发全过程进行管理。任务的分配、bug的跟踪、知识库的建立等等……\n\n[官网](http://www.redmine.org)\n\n## 在ubuntu下安装\n\n参考：http://www.redmine.org/projects/redmine/wiki/Guide\n\n###　下载redmine安装包\n\n网址：http://www.redmine.org/projects/redmine/wiki/Download\n\n    wget http://www.redmine.org/releases/redmine-3.4.5.tar.gz\n    \n\n### 安装Ruby环境\n\n参考官网说明，注意redmine版本对ruby版本的要求。 \n\n1.下载地址：http://ftp.ruby-lang.org/pub/ruby/   \n    \n    //下载\n    zmt@zmt-Lenovo:~/Desktop/work/tools$ wget http://ftp.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz\n    zmt@zmt-Lenovo:~/Desktop/work/tools$ tar -zxvf ruby-2.4.4.tar.gz \n    \n    //查询openssl安装路径\n    zmt@zmt-Lenovo:~$ openssl version -a\n    OpenSSL 1.1.0g  2 Nov 2017\n    built on: reproducible build, date unspecified\n    platform: debian-amd64\n    compiler: gcc -DDSO_DLFCN -DHAVE_DLFCN_H -DNDEBUG -DOPENSSL_THREADS -DOPENSSL_NO_STATIC_ENGINE -DOPENSSL_PIC -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DOPENSSLDIR=\"\\\"/usr/lib/ssl\\\"\" -DENGINESDIR=\"\\\"/usr/lib/x86_64-linux-gnu/engines-1.1\\\"\" \n    OPENSSLDIR: \"/usr/lib/ssl\"\n    ENGINESDIR: \"/usr/lib/x86_64-linux-gnu/engines-1.1\"\n    \n    //看上面结果，确定openssl安装dir为：/usr/lib/ssl\n    \n    //安装：\n    $ cd ruby-2.4.4\n    $ ./configure  --with-openssl-dir=/usr/lib/ssl\n    $ make\n    $ sudo make install\n    \n    \n3.检查是否安装成功：    \n    \n    zmt@zmt-Lenovo:~$ ruby -v\n    ruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-linux]\n\n看到上面显示说明安装成功。\n\n### 创建空的数据库，并初始化用户\n\n一般数据库名为redmine,但是可以自己更改。\n\n1.MySQL\n\n创建数据库登录用户redmine，密码为redmine\n    \n    //mysql要求５.6或以上版本\n    \n    CREATE DATABASE redmine CHARACTER SET utf8mb4;\n    CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';   \n    \n    //刷新权限\n    flush privileges;\n    \n\n### 数据库连接配置设置\n\n解压下载的`redmine-3.4.5.tar.gz`， 并进入解压包内。 在`config`目录下，可以看到文件`database.yml.example`，复制该文件命名为`database.yml`，放在同一个目录`config`下。下面就可以编辑文件`database.yml`了。  \n\n1.mysql的配置\n\n- 默认端口3306\n\n        production:\n          adapter: mysql2\n          database: redmine\n          host: localhost\n          username: redmine\n          password: redmine\n\n- 不是3306端口，如下配置：\n\n        production:\n          adapter: mysql2\n          database: redmine\n          host: localhost\n          port: 3307\n          username: redmine\n          password: redmine\n          \n按照以上配置修改好，保存并退出。\n\n### redmine运行相关依赖包安装\n\nRedmine uses [Bundler](http://gembundler.com/) to manage gems dependencies.   \n\n1.首先按照Bundler\n\n    sudo gem install bundler\n    \n报错误：\n\n    zmt@zmt-Lenovo:~$ gem install bundler\n    ERROR:  While executing gem ... (Gem::Exception)\n        Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources\n\n意思是，要要求系统按照OpenSSL，然后按上面步骤重新编译安装ruby。\n\n按照openssl：\n    \n    sudo apt-get install openssl\n    \n重新编译按照ruby后再执行`gem install bundler`。      \n\n还是不行，可能是因为不是以root用户安装的缘故。 \n\n_注：_  没关系，我们不通过网络安装，而是直接下载gem安装包安装。\n\n\n    安装RubyGems安装\n    \n    如果第一步能执行成功，不需要另外安装rubygems，因为安装ruby的时候已经安装。 \n    \n    网址：https://rubygems.org/\n    \n    下载并安装：\n    \n        # wget https://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.6.tgz\n        # tar zxvf rubygems-2.6.6.tgz\n        # cd rubygems-2.6.6.tgz\n        # ruby setup.rb\n        \n        //显示版本好，说民安装成功\n        zmt@zmt-Lenovo:~/Desktop/work/tools/rubygems-2.6.6$ gem -v\n        2.6.6\n                      \n    安装成功，重新执行步骤1，即安装Bundler，执行：\n    \n        gem install bundler\n\n \n2.然后可以利用bundler安装redmine相关依赖包\n\nThen you can install all the gems required by Redmine using the following command:\n\n    bundle install --without development test\n    \n<<----未完--->>\n\n## Centos7下安装全过程记录\n\n参考网址：http://www.redmine.org/projects/redmine/wiki/RedmineInstall\n\n应用版本信息：\nredmine： redmine-3.4.6.tar.gz   \nruby： ruby-2.3.6.tar.gz\n\n首先安装系统相关包：\n\n    yum -y install patch make gcc gcc-c++ gcc-g77 flex* bison file  \n    yum -y install libtool libtool-libs libtool-ltdl-devel* autoconf kernel-devel automake libmcrypt*  \n    yum -y install libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel  \n    yum -y install freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel  \n    yum -y install glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel  \n    yum -y install ncurses ncurses-devel curl curl-devel e2fsprogs  \n    yum -y install e2fsprogs-devel krb5 krb5-devel libidn libidn-devel  \n    yum -y install openssl openssl-devel vim-minimal nano sendmail  \n    yum -y install fonts-chinese gettext gettext-devel  \n    yum -y install gmp-devel pspell-devel   \n    yum -y install readline* libxslt* pcre* net-snmp* gmp* libtidy*  \n    yum -y install ImageMagick* subversion*  \n\n### 下载redmine安装包\n\n可以在官网下载正式发布的二进制包[下载](http://www.redmine.org/projects/redmine/wiki/Download)。 \n\n### 创建空的数据库以及相关数据库用户\n\n首先要保证已经安装好数据库。下面以mysql为例进行安装。mysql版本>5.5.2。     \n创建脚本：    \n   \n    CREATE DATABASE redmine CHARACTER SET utf8mb4;\n    #CREATE USER 'redmine'@'localhost' IDENTIFIED BY 'my_password'; #这样的，navicat客户端无法登录\n    CREATE USER 'redmine'@'localhost' IDENTIFIED WITH mysql_native_password BY 'my_password';\n    GRANT ALL PRIVILEGES ON redmine.* TO 'redmine'@'localhost';\n    \n### 为redmine配置数据库\n\n首先，解压redmine包，并进入config目录。  \n\n`[root@ymu config]# cp database.yml.example database.yml`\n\n然后编辑`database.yml`：\n\n    production:\n      adapter: mysql2\n      database: redmine\n      host: localhost\n      port: 3307\n      username: redmine\n      password: redmine\n      \n_注意_: 主机名用`localhost`可能报错，要改成`127.0.0.1`。      \n      \n### 安装依赖包\n\n1.安装ruby环境。\n\n- 安装上面描述方式，ruby源码包安装方式。选择版本安装。\n- 系统源安装。`yum install gem`。会自动安装ruby环境。\n\n下面采用源码编译安装方式。   \n检查是否安装成功：   \n`ruby -v`   `gem -v`\n\n问题解决：安装完ruby却提示`[/usr/bin/ruby: No such file or directory]`\n    \n`ln -s /usr/local/bin/ruby /usr/bin/ruby`   \n`ln -s /usr/local/bin/gem /usr/bin/gem` \n \n\n2.安装`bundler`\n\nredmine的依赖包都通过bundler来安装。   \n\n`gem install bundler`\n\n3.安装所有依赖\n\n执行下面命令前，记得要按照上面方法安装所有系统依赖包。\n\n    [root@ymu ~]# cd /server/tools/redmine-3.4.6/\n    [root@ymu redmine-3.4.6]# bundle install --without development test\n   \n\n### 安全生成存储会话\n\n`bundle exec rake generate_secret_token`\n \n\n### 创建表\n\n    [root@ymu redmine-3.4.6]# bundle exec rake generate_secret_token\n    [root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake db:migrate\n\n查看数据库，可以看到已经创建了很多表。     \n\n### 设置数据库默认数据\n\n    [root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake redmine:load_default_data\n    \n    Select language: ar, az, bg, bs, ca, cs, da, de, el, en, en-GB, es, es-PA, et, eu, fa, fi, fr, gl, he, hr, hu, id, it, ja, ko, lt, lv, mk, mn, nl, no, pl, pt, pt-BR, ro, ru, sk, sl, sq, sr, sr-YU, sv, th, tr, uk, vi, zh, zh-TW [en] zh\n    ====================================\n    Default configuration data loaded.\n\n记得：输入zh，然后按下回车。否则会是英文版本数据。\n\n### 设置文件权限\n\n- 如果上面的所有操作都是root用户，那么就不必要设置文件权限，可以跳过此步骤。 （_上面以root操作，跳过这步骤_）    \n- 如果不是在root超级用户下，则要设置文件权限，否则redmine应用程序无法操作一些文件权限。    \n\n在redmine解压根目录下，这些文件必须赋予权限：  \n\n    files (storage of attachments)\n    log (application log file production.log)\n    tmp and tmp/pdf (create these ones if not present, used to generate PDF documents among other things)\n    public/plugin_assets (assets of plugins)\n    \n如果没有这些文件：     \n    \n    mkdir -p tmp tmp/pdf public/plugin_assets\n    sudo chown -R redmine:redmine files log tmp public/plugin_assets\n    sudo chmod -R 755 files log tmp public/plugin_assets\n    \n如果都有：   \n\n     sudo chown -R redmine:redmine files log tmp public/plugin_assets\n     sudo chmod -R 755 files log tmp public/plugin_assets\n \n_注意_:保证下面目录不包含可执行文件。\n \n    sudo find files log tmp public/plugin_assets -type f -exec chmod -x {} +    \n    \n### 测试是否安装成功\n\n按照下面经验执行操作：\n\n    bundle exec rails server webrick -e production   //在redmine安装目录下执行\n    \n    //注意，服务器端执行上面命令可能报错，可能是端口不可用，可以改变端口：\n    bundle exec rails server webrick -e production -p 8889\n    \n    改变端口执行服务成功，但是在客户机子不能访问，此时要这么执行：\n     bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889\n    \n    ok搞定\n    \n    守护进程模式执行：\n     nohup bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 &\n    或者：\n    bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 -d    \n    \n然后就可以访问：http：//loaclhost:port。  \n\n### 登录redmine\n\n默认账号密码： \nusername=admin  \npwd=admin\n\n打开网址后，用默认账号密码登录后，会要求修改密码。把密码改为： \nusername=admin  \npwd=admin123    \n\n按页面提示，填写修改相关信息即可。   \n\n### 修改配置（不修改则采用默认的配置）\n\nredmine的配置设置文件放在：config/configuration.yml。  \n如果要自己定义配置，则可以`copy config/configuration.yml.example to config/configuration.yml`，然后编辑`configuration.yml`文件即可。 \n\n记得：修改配置文件后重启redmine，否则不生效。  \n\n### 重启redmine\n\n采用直接kill掉：\n\n    lsof -i:3000\n    kill -9 pid\n    \n### 开机自启\n\n编辑启动文件\n\nvi /etc/rc.local\n\n最后一行或者适当的位置，加入一下内容。此处必须用绝对路径。注意根据实际redmine路径来填写。\n\n/usr/local/rvm/rubies/ruby-2.0.0-p598/bin/ruby /root/redmine-2.6.0/script/rails server webrick -e production -d    \n\n### 设置Email/SMTP服务器\n\n项目管理中，分配了任务或者测试提交了bug给某个开发人员，那么可以通过邮件及时的提醒他。    \n\n下面我们就来配置邮件服务器：  \n参考：http://www.redmine.org/projects/redmine/wiki/EmailConfiguration  \n\n1.编辑配置文件：config/configuration.yml\n\n添加邮箱服务器配置，异步发送邮件（qq邮箱为例子）：\n\n    email_delivery:\n        delivery_method: :async_smtp\n        async_smtp_settings:\n          address: \"smtp.qq.com\"\n          port: 25\n          authentication: :login\n          domain: 'qq.com'\n          user_name: '932852117@qq.com'\n          password: '××××××'\n              \n下面是实际操作内容：              \n\n    # default configuration options for all environments\n    default:\n      # Outgoing emails configuration\n      # See the examples below and the Rails guide for more configuration options:\n      # http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration\n      email_delivery:\n        delivery_method: :async_smtp\n        async_smtp_settings:\n          address: \"smtp.qq.com\"\n          port: 25\n          authentication: :login\n          domain: 'qq.com'\n          user_name: '932852117@qq.com'\n          password: '××××××'\n    \n      # ==== Simple SMTP server at localhost\n\n2.开启邮箱服务器\n\n{%asset_img b.png%}\n\n3.重启redmine并测试是否配置成功。 \n        \n登录redmine，在管理->配置中： \n\n{%asset_img c.png%}\n\n输入配置的邮箱地址后，保存。然后点击右下角的`发送测试邮件`：     \n\n{%asset_img d.png%}\n\n看到绿色提示`邮件已发送至 zhangmutian@xcsqjr.com`。证明配置已成功，可以愉快的使用了。\n\n\n### scm配置\n\n主要是svn和git版本库管理工具。  \n\n如：svn的  \n`scm_subversion_command: \"svn_replacement.exe\"`\n\n只需要安装svn或者git服务端，然后在配置文件指向即可。   \n\n### 其它的配置\n\n一般采用默认的就好了。 \n\n1.附件存储路径。`attachments_storage_path: /var/redmine/files`   \n2.日志保存路径。   \n\n等等……\n\n------------------------------------------------------\n\n恭喜恭喜，到此，你已成功安装redmine了，并且它已经具备了该有的基础功能了。赶紧来看下它帅帅的样子吧：\n\n{%asset_img a.png%}\n\n尽情的去探索redmine很多很多，酷酷的特性吧，让它正真成为你在项目管理中的瑞士军刀……\n\n\n\n\n\n          ","slug":"redmine-start","published":1,"updated":"2018-11-16T09:16:01.227Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38p300cqqcrg99n0g8g2","content":"<p>在软件开发过程中，项目管理的有效性直接会影响到项目开发的进度，质量，还有整个团队的协助。总之，没有一个好的项目管理系统，这对项目经理来说就像是上了战场，却没有任何武器一样，必定败仗。  </p>\n<p>下面介绍这款比较流行的项目管理工具redmine。有了它，项目经理就可以对整个项目的开发全过程进行管理。任务的分配、bug的跟踪、知识库的建立等等……</p>\n<p><a href=\"http://www.redmine.org\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"在ubuntu下安装\"><a href=\"#在ubuntu下安装\" class=\"headerlink\" title=\"在ubuntu下安装\"></a>在ubuntu下安装</h2><p>参考：<a href=\"http://www.redmine.org/projects/redmine/wiki/Guide\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/Guide</a></p>\n<p>###　下载redmine安装包</p>\n<p>网址：<a href=\"http://www.redmine.org/projects/redmine/wiki/Download\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/Download</a></p>\n<pre><code>wget http://www.redmine.org/releases/redmine-3.4.5.tar.gz\n</code></pre><h3 id=\"安装Ruby环境\"><a href=\"#安装Ruby环境\" class=\"headerlink\" title=\"安装Ruby环境\"></a>安装Ruby环境</h3><p>参考官网说明，注意redmine版本对ruby版本的要求。 </p>\n<p>1.下载地址：<a href=\"http://ftp.ruby-lang.org/pub/ruby/\" target=\"_blank\" rel=\"noopener\">http://ftp.ruby-lang.org/pub/ruby/</a>   </p>\n<pre><code>//下载\nzmt@zmt-Lenovo:~/Desktop/work/tools$ wget http://ftp.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz\nzmt@zmt-Lenovo:~/Desktop/work/tools$ tar -zxvf ruby-2.4.4.tar.gz \n\n//查询openssl安装路径\nzmt@zmt-Lenovo:~$ openssl version -a\nOpenSSL 1.1.0g  2 Nov 2017\nbuilt on: reproducible build, date unspecified\nplatform: debian-amd64\ncompiler: gcc -DDSO_DLFCN -DHAVE_DLFCN_H -DNDEBUG -DOPENSSL_THREADS -DOPENSSL_NO_STATIC_ENGINE -DOPENSSL_PIC -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DOPENSSLDIR=&quot;\\&quot;/usr/lib/ssl\\&quot;&quot; -DENGINESDIR=&quot;\\&quot;/usr/lib/x86_64-linux-gnu/engines-1.1\\&quot;&quot; \nOPENSSLDIR: &quot;/usr/lib/ssl&quot;\nENGINESDIR: &quot;/usr/lib/x86_64-linux-gnu/engines-1.1&quot;\n\n//看上面结果，确定openssl安装dir为：/usr/lib/ssl\n\n//安装：\n$ cd ruby-2.4.4\n$ ./configure  --with-openssl-dir=/usr/lib/ssl\n$ make\n$ sudo make install\n</code></pre><p>3.检查是否安装成功：    </p>\n<pre><code>zmt@zmt-Lenovo:~$ ruby -v\nruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-linux]\n</code></pre><p>看到上面显示说明安装成功。</p>\n<h3 id=\"创建空的数据库，并初始化用户\"><a href=\"#创建空的数据库，并初始化用户\" class=\"headerlink\" title=\"创建空的数据库，并初始化用户\"></a>创建空的数据库，并初始化用户</h3><p>一般数据库名为redmine,但是可以自己更改。</p>\n<p>1.MySQL</p>\n<p>创建数据库登录用户redmine，密码为redmine</p>\n<pre><code>//mysql要求５.6或以上版本\n\nCREATE DATABASE redmine CHARACTER SET utf8mb4;\nCREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;   \n\n//刷新权限\nflush privileges;\n</code></pre><h3 id=\"数据库连接配置设置\"><a href=\"#数据库连接配置设置\" class=\"headerlink\" title=\"数据库连接配置设置\"></a>数据库连接配置设置</h3><p>解压下载的<code>redmine-3.4.5.tar.gz</code>， 并进入解压包内。 在<code>config</code>目录下，可以看到文件<code>database.yml.example</code>，复制该文件命名为<code>database.yml</code>，放在同一个目录<code>config</code>下。下面就可以编辑文件<code>database.yml</code>了。  </p>\n<p>1.mysql的配置</p>\n<ul>\n<li><p>默认端口3306</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  username: redmine\n  password: redmine\n</code></pre></li>\n<li><p>不是3306端口，如下配置：</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  port: 3307\n  username: redmine\n  password: redmine\n</code></pre></li>\n</ul>\n<p>按照以上配置修改好，保存并退出。</p>\n<h3 id=\"redmine运行相关依赖包安装\"><a href=\"#redmine运行相关依赖包安装\" class=\"headerlink\" title=\"redmine运行相关依赖包安装\"></a>redmine运行相关依赖包安装</h3><p>Redmine uses <a href=\"http://gembundler.com/\" target=\"_blank\" rel=\"noopener\">Bundler</a> to manage gems dependencies.   </p>\n<p>1.首先按照Bundler</p>\n<pre><code>sudo gem install bundler\n</code></pre><p>报错误：</p>\n<pre><code>zmt@zmt-Lenovo:~$ gem install bundler\nERROR:  While executing gem ... (Gem::Exception)\n    Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources\n</code></pre><p>意思是，要要求系统按照OpenSSL，然后按上面步骤重新编译安装ruby。</p>\n<p>按照openssl：</p>\n<pre><code>sudo apt-get install openssl\n</code></pre><p>重新编译按照ruby后再执行<code>gem install bundler</code>。      </p>\n<p>还是不行，可能是因为不是以root用户安装的缘故。 </p>\n<p>_注：_  没关系，我们不通过网络安装，而是直接下载gem安装包安装。</p>\n<pre><code>安装RubyGems安装\n\n如果第一步能执行成功，不需要另外安装rubygems，因为安装ruby的时候已经安装。 \n\n网址：https://rubygems.org/\n\n下载并安装：\n\n    # wget https://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.6.tgz\n    # tar zxvf rubygems-2.6.6.tgz\n    # cd rubygems-2.6.6.tgz\n    # ruby setup.rb\n\n    //显示版本好，说民安装成功\n    zmt@zmt-Lenovo:~/Desktop/work/tools/rubygems-2.6.6$ gem -v\n    2.6.6\n\n安装成功，重新执行步骤1，即安装Bundler，执行：\n\n    gem install bundler\n</code></pre><p>2.然后可以利用bundler安装redmine相关依赖包</p>\n<p>Then you can install all the gems required by Redmine using the following command:</p>\n<pre><code>bundle install --without development test\n</code></pre><p>&lt;&lt;—-未完—&gt;&gt;</p>\n<h2 id=\"Centos7下安装全过程记录\"><a href=\"#Centos7下安装全过程记录\" class=\"headerlink\" title=\"Centos7下安装全过程记录\"></a>Centos7下安装全过程记录</h2><p>参考网址：<a href=\"http://www.redmine.org/projects/redmine/wiki/RedmineInstall\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/RedmineInstall</a></p>\n<p>应用版本信息：<br>redmine： redmine-3.4.6.tar.gz<br>ruby： ruby-2.3.6.tar.gz</p>\n<p>首先安装系统相关包：</p>\n<pre><code>yum -y install patch make gcc gcc-c++ gcc-g77 flex* bison file  \nyum -y install libtool libtool-libs libtool-ltdl-devel* autoconf kernel-devel automake libmcrypt*  \nyum -y install libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel  \nyum -y install freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel  \nyum -y install glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel  \nyum -y install ncurses ncurses-devel curl curl-devel e2fsprogs  \nyum -y install e2fsprogs-devel krb5 krb5-devel libidn libidn-devel  \nyum -y install openssl openssl-devel vim-minimal nano sendmail  \nyum -y install fonts-chinese gettext gettext-devel  \nyum -y install gmp-devel pspell-devel   \nyum -y install readline* libxslt* pcre* net-snmp* gmp* libtidy*  \nyum -y install ImageMagick* subversion*  \n</code></pre><h3 id=\"下载redmine安装包\"><a href=\"#下载redmine安装包\" class=\"headerlink\" title=\"下载redmine安装包\"></a>下载redmine安装包</h3><p>可以在官网下载正式发布的二进制包<a href=\"http://www.redmine.org/projects/redmine/wiki/Download\" target=\"_blank\" rel=\"noopener\">下载</a>。 </p>\n<h3 id=\"创建空的数据库以及相关数据库用户\"><a href=\"#创建空的数据库以及相关数据库用户\" class=\"headerlink\" title=\"创建空的数据库以及相关数据库用户\"></a>创建空的数据库以及相关数据库用户</h3><p>首先要保证已经安装好数据库。下面以mysql为例进行安装。mysql版本&gt;5.5.2。<br>创建脚本：    </p>\n<pre><code>CREATE DATABASE redmine CHARACTER SET utf8mb4;\n#CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;; #这样的，navicat客户端无法登录\nCREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;\n</code></pre><h3 id=\"为redmine配置数据库\"><a href=\"#为redmine配置数据库\" class=\"headerlink\" title=\"为redmine配置数据库\"></a>为redmine配置数据库</h3><p>首先，解压redmine包，并进入config目录。  </p>\n<p><code>[root@ymu config]# cp database.yml.example database.yml</code></p>\n<p>然后编辑<code>database.yml</code>：</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  port: 3307\n  username: redmine\n  password: redmine\n</code></pre><p>_注意_: 主机名用<code>localhost</code>可能报错，要改成<code>127.0.0.1</code>。      </p>\n<h3 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h3><p>1.安装ruby环境。</p>\n<ul>\n<li>安装上面描述方式，ruby源码包安装方式。选择版本安装。</li>\n<li>系统源安装。<code>yum install gem</code>。会自动安装ruby环境。</li>\n</ul>\n<p>下面采用源码编译安装方式。<br>检查是否安装成功：<br><code>ruby -v</code>   <code>gem -v</code></p>\n<p>问题解决：安装完ruby却提示<code>[/usr/bin/ruby: No such file or directory]</code></p>\n<p><code>ln -s /usr/local/bin/ruby /usr/bin/ruby</code><br><code>ln -s /usr/local/bin/gem /usr/bin/gem</code> </p>\n<p>2.安装<code>bundler</code></p>\n<p>redmine的依赖包都通过bundler来安装。   </p>\n<p><code>gem install bundler</code></p>\n<p>3.安装所有依赖</p>\n<p>执行下面命令前，记得要按照上面方法安装所有系统依赖包。</p>\n<pre><code>[root@ymu ~]# cd /server/tools/redmine-3.4.6/\n[root@ymu redmine-3.4.6]# bundle install --without development test\n</code></pre><h3 id=\"安全生成存储会话\"><a href=\"#安全生成存储会话\" class=\"headerlink\" title=\"安全生成存储会话\"></a>安全生成存储会话</h3><p><code>bundle exec rake generate_secret_token</code></p>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><pre><code>[root@ymu redmine-3.4.6]# bundle exec rake generate_secret_token\n[root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake db:migrate\n</code></pre><p>查看数据库，可以看到已经创建了很多表。     </p>\n<h3 id=\"设置数据库默认数据\"><a href=\"#设置数据库默认数据\" class=\"headerlink\" title=\"设置数据库默认数据\"></a>设置数据库默认数据</h3><pre><code>[root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake redmine:load_default_data\n\nSelect language: ar, az, bg, bs, ca, cs, da, de, el, en, en-GB, es, es-PA, et, eu, fa, fi, fr, gl, he, hr, hu, id, it, ja, ko, lt, lv, mk, mn, nl, no, pl, pt, pt-BR, ro, ru, sk, sl, sq, sr, sr-YU, sv, th, tr, uk, vi, zh, zh-TW [en] zh\n====================================\nDefault configuration data loaded.\n</code></pre><p>记得：输入zh，然后按下回车。否则会是英文版本数据。</p>\n<h3 id=\"设置文件权限\"><a href=\"#设置文件权限\" class=\"headerlink\" title=\"设置文件权限\"></a>设置文件权限</h3><ul>\n<li>如果上面的所有操作都是root用户，那么就不必要设置文件权限，可以跳过此步骤。 （<em>上面以root操作，跳过这步骤</em>）    </li>\n<li>如果不是在root超级用户下，则要设置文件权限，否则redmine应用程序无法操作一些文件权限。    </li>\n</ul>\n<p>在redmine解压根目录下，这些文件必须赋予权限：  </p>\n<pre><code>files (storage of attachments)\nlog (application log file production.log)\ntmp and tmp/pdf (create these ones if not present, used to generate PDF documents among other things)\npublic/plugin_assets (assets of plugins)\n</code></pre><p>如果没有这些文件：     </p>\n<pre><code>mkdir -p tmp tmp/pdf public/plugin_assets\nsudo chown -R redmine:redmine files log tmp public/plugin_assets\nsudo chmod -R 755 files log tmp public/plugin_assets\n</code></pre><p>如果都有：   </p>\n<pre><code>sudo chown -R redmine:redmine files log tmp public/plugin_assets\nsudo chmod -R 755 files log tmp public/plugin_assets\n</code></pre><p>_注意_:保证下面目录不包含可执行文件。</p>\n<pre><code>sudo find files log tmp public/plugin_assets -type f -exec chmod -x {} +    \n</code></pre><h3 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h3><p>按照下面经验执行操作：</p>\n<pre><code>bundle exec rails server webrick -e production   //在redmine安装目录下执行\n\n//注意，服务器端执行上面命令可能报错，可能是端口不可用，可以改变端口：\nbundle exec rails server webrick -e production -p 8889\n\n改变端口执行服务成功，但是在客户机子不能访问，此时要这么执行：\n bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889\n\nok搞定\n\n守护进程模式执行：\n nohup bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 &amp;\n或者：\nbundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 -d    \n</code></pre><p>然后就可以访问：http：//loaclhost:port。  </p>\n<h3 id=\"登录redmine\"><a href=\"#登录redmine\" class=\"headerlink\" title=\"登录redmine\"></a>登录redmine</h3><p>默认账号密码：<br>username=admin<br>pwd=admin</p>\n<p>打开网址后，用默认账号密码登录后，会要求修改密码。把密码改为：<br>username=admin<br>pwd=admin123    </p>\n<p>按页面提示，填写修改相关信息即可。   </p>\n<h3 id=\"修改配置（不修改则采用默认的配置）\"><a href=\"#修改配置（不修改则采用默认的配置）\" class=\"headerlink\" title=\"修改配置（不修改则采用默认的配置）\"></a>修改配置（不修改则采用默认的配置）</h3><p>redmine的配置设置文件放在：config/configuration.yml。<br>如果要自己定义配置，则可以<code>copy config/configuration.yml.example to config/configuration.yml</code>，然后编辑<code>configuration.yml</code>文件即可。 </p>\n<p>记得：修改配置文件后重启redmine，否则不生效。  </p>\n<h3 id=\"重启redmine\"><a href=\"#重启redmine\" class=\"headerlink\" title=\"重启redmine\"></a>重启redmine</h3><p>采用直接kill掉：</p>\n<pre><code>lsof -i:3000\nkill -9 pid\n</code></pre><h3 id=\"开机自启\"><a href=\"#开机自启\" class=\"headerlink\" title=\"开机自启\"></a>开机自启</h3><p>编辑启动文件</p>\n<p>vi /etc/rc.local</p>\n<p>最后一行或者适当的位置，加入一下内容。此处必须用绝对路径。注意根据实际redmine路径来填写。</p>\n<p>/usr/local/rvm/rubies/ruby-2.0.0-p598/bin/ruby /root/redmine-2.6.0/script/rails server webrick -e production -d    </p>\n<h3 id=\"设置Email-SMTP服务器\"><a href=\"#设置Email-SMTP服务器\" class=\"headerlink\" title=\"设置Email/SMTP服务器\"></a>设置Email/SMTP服务器</h3><p>项目管理中，分配了任务或者测试提交了bug给某个开发人员，那么可以通过邮件及时的提醒他。    </p>\n<p>下面我们就来配置邮件服务器：<br>参考：<a href=\"http://www.redmine.org/projects/redmine/wiki/EmailConfiguration\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/EmailConfiguration</a>  </p>\n<p>1.编辑配置文件：config/configuration.yml</p>\n<p>添加邮箱服务器配置，异步发送邮件（qq邮箱为例子）：</p>\n<pre><code>email_delivery:\n    delivery_method: :async_smtp\n    async_smtp_settings:\n      address: &quot;smtp.qq.com&quot;\n      port: 25\n      authentication: :login\n      domain: &apos;qq.com&apos;\n      user_name: &apos;932852117@qq.com&apos;\n      password: &apos;××××××&apos;\n</code></pre><p>下面是实际操作内容：              </p>\n<pre><code># default configuration options for all environments\ndefault:\n  # Outgoing emails configuration\n  # See the examples below and the Rails guide for more configuration options:\n  # http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration\n  email_delivery:\n    delivery_method: :async_smtp\n    async_smtp_settings:\n      address: &quot;smtp.qq.com&quot;\n      port: 25\n      authentication: :login\n      domain: &apos;qq.com&apos;\n      user_name: &apos;932852117@qq.com&apos;\n      password: &apos;××××××&apos;\n\n  # ==== Simple SMTP server at localhost\n</code></pre><p>2.开启邮箱服务器</p>\n<img src=\"/2018/06/01/redmine-start/b.png\">\n<p>3.重启redmine并测试是否配置成功。 </p>\n<p>登录redmine，在管理-&gt;配置中： </p>\n<img src=\"/2018/06/01/redmine-start/c.png\">\n<p>输入配置的邮箱地址后，保存。然后点击右下角的<code>发送测试邮件</code>：     </p>\n<img src=\"/2018/06/01/redmine-start/d.png\">\n<p>看到绿色提示<code>邮件已发送至 zhangmutian@xcsqjr.com</code>。证明配置已成功，可以愉快的使用了。</p>\n<h3 id=\"scm配置\"><a href=\"#scm配置\" class=\"headerlink\" title=\"scm配置\"></a>scm配置</h3><p>主要是svn和git版本库管理工具。  </p>\n<p>如：svn的<br><code>scm_subversion_command: &quot;svn_replacement.exe&quot;</code></p>\n<p>只需要安装svn或者git服务端，然后在配置文件指向即可。   </p>\n<h3 id=\"其它的配置\"><a href=\"#其它的配置\" class=\"headerlink\" title=\"其它的配置\"></a>其它的配置</h3><p>一般采用默认的就好了。 </p>\n<p>1.附件存储路径。<code>attachments_storage_path: /var/redmine/files</code><br>2.日志保存路径。   </p>\n<p>等等……</p>\n<hr>\n<p>恭喜恭喜，到此，你已成功安装redmine了，并且它已经具备了该有的基础功能了。赶紧来看下它帅帅的样子吧：</p>\n<img src=\"/2018/06/01/redmine-start/a.png\">\n<p>尽情的去探索redmine很多很多，酷酷的特性吧，让它正真成为你在项目管理中的瑞士军刀……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在软件开发过程中，项目管理的有效性直接会影响到项目开发的进度，质量，还有整个团队的协助。总之，没有一个好的项目管理系统，这对项目经理来说就像是上了战场，却没有任何武器一样，必定败仗。  </p>\n<p>下面介绍这款比较流行的项目管理工具redmine。有了它，项目经理就可以对整个项目的开发全过程进行管理。任务的分配、bug的跟踪、知识库的建立等等……</p>\n<p><a href=\"http://www.redmine.org\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h2 id=\"在ubuntu下安装\"><a href=\"#在ubuntu下安装\" class=\"headerlink\" title=\"在ubuntu下安装\"></a>在ubuntu下安装</h2><p>参考：<a href=\"http://www.redmine.org/projects/redmine/wiki/Guide\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/Guide</a></p>\n<p>###　下载redmine安装包</p>\n<p>网址：<a href=\"http://www.redmine.org/projects/redmine/wiki/Download\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/Download</a></p>\n<pre><code>wget http://www.redmine.org/releases/redmine-3.4.5.tar.gz\n</code></pre><h3 id=\"安装Ruby环境\"><a href=\"#安装Ruby环境\" class=\"headerlink\" title=\"安装Ruby环境\"></a>安装Ruby环境</h3><p>参考官网说明，注意redmine版本对ruby版本的要求。 </p>\n<p>1.下载地址：<a href=\"http://ftp.ruby-lang.org/pub/ruby/\" target=\"_blank\" rel=\"noopener\">http://ftp.ruby-lang.org/pub/ruby/</a>   </p>\n<pre><code>//下载\nzmt@zmt-Lenovo:~/Desktop/work/tools$ wget http://ftp.ruby-lang.org/pub/ruby/2.4/ruby-2.4.4.tar.gz\nzmt@zmt-Lenovo:~/Desktop/work/tools$ tar -zxvf ruby-2.4.4.tar.gz \n\n//查询openssl安装路径\nzmt@zmt-Lenovo:~$ openssl version -a\nOpenSSL 1.1.0g  2 Nov 2017\nbuilt on: reproducible build, date unspecified\nplatform: debian-amd64\ncompiler: gcc -DDSO_DLFCN -DHAVE_DLFCN_H -DNDEBUG -DOPENSSL_THREADS -DOPENSSL_NO_STATIC_ENGINE -DOPENSSL_PIC -DOPENSSL_IA32_SSE2 -DOPENSSL_BN_ASM_MONT -DOPENSSL_BN_ASM_MONT5 -DOPENSSL_BN_ASM_GF2m -DSHA1_ASM -DSHA256_ASM -DSHA512_ASM -DRC4_ASM -DMD5_ASM -DAES_ASM -DVPAES_ASM -DBSAES_ASM -DGHASH_ASM -DECP_NISTZ256_ASM -DPADLOCK_ASM -DPOLY1305_ASM -DOPENSSLDIR=&quot;\\&quot;/usr/lib/ssl\\&quot;&quot; -DENGINESDIR=&quot;\\&quot;/usr/lib/x86_64-linux-gnu/engines-1.1\\&quot;&quot; \nOPENSSLDIR: &quot;/usr/lib/ssl&quot;\nENGINESDIR: &quot;/usr/lib/x86_64-linux-gnu/engines-1.1&quot;\n\n//看上面结果，确定openssl安装dir为：/usr/lib/ssl\n\n//安装：\n$ cd ruby-2.4.4\n$ ./configure  --with-openssl-dir=/usr/lib/ssl\n$ make\n$ sudo make install\n</code></pre><p>3.检查是否安装成功：    </p>\n<pre><code>zmt@zmt-Lenovo:~$ ruby -v\nruby 2.4.4p296 (2018-03-28 revision 63013) [x86_64-linux]\n</code></pre><p>看到上面显示说明安装成功。</p>\n<h3 id=\"创建空的数据库，并初始化用户\"><a href=\"#创建空的数据库，并初始化用户\" class=\"headerlink\" title=\"创建空的数据库，并初始化用户\"></a>创建空的数据库，并初始化用户</h3><p>一般数据库名为redmine,但是可以自己更改。</p>\n<p>1.MySQL</p>\n<p>创建数据库登录用户redmine，密码为redmine</p>\n<pre><code>//mysql要求５.6或以上版本\n\nCREATE DATABASE redmine CHARACTER SET utf8mb4;\nCREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;   \n\n//刷新权限\nflush privileges;\n</code></pre><h3 id=\"数据库连接配置设置\"><a href=\"#数据库连接配置设置\" class=\"headerlink\" title=\"数据库连接配置设置\"></a>数据库连接配置设置</h3><p>解压下载的<code>redmine-3.4.5.tar.gz</code>， 并进入解压包内。 在<code>config</code>目录下，可以看到文件<code>database.yml.example</code>，复制该文件命名为<code>database.yml</code>，放在同一个目录<code>config</code>下。下面就可以编辑文件<code>database.yml</code>了。  </p>\n<p>1.mysql的配置</p>\n<ul>\n<li><p>默认端口3306</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  username: redmine\n  password: redmine\n</code></pre></li>\n<li><p>不是3306端口，如下配置：</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  port: 3307\n  username: redmine\n  password: redmine\n</code></pre></li>\n</ul>\n<p>按照以上配置修改好，保存并退出。</p>\n<h3 id=\"redmine运行相关依赖包安装\"><a href=\"#redmine运行相关依赖包安装\" class=\"headerlink\" title=\"redmine运行相关依赖包安装\"></a>redmine运行相关依赖包安装</h3><p>Redmine uses <a href=\"http://gembundler.com/\" target=\"_blank\" rel=\"noopener\">Bundler</a> to manage gems dependencies.   </p>\n<p>1.首先按照Bundler</p>\n<pre><code>sudo gem install bundler\n</code></pre><p>报错误：</p>\n<pre><code>zmt@zmt-Lenovo:~$ gem install bundler\nERROR:  While executing gem ... (Gem::Exception)\n    Unable to require openssl, install OpenSSL and rebuild ruby (preferred) or use non-HTTPS sources\n</code></pre><p>意思是，要要求系统按照OpenSSL，然后按上面步骤重新编译安装ruby。</p>\n<p>按照openssl：</p>\n<pre><code>sudo apt-get install openssl\n</code></pre><p>重新编译按照ruby后再执行<code>gem install bundler</code>。      </p>\n<p>还是不行，可能是因为不是以root用户安装的缘故。 </p>\n<p>_注：_  没关系，我们不通过网络安装，而是直接下载gem安装包安装。</p>\n<pre><code>安装RubyGems安装\n\n如果第一步能执行成功，不需要另外安装rubygems，因为安装ruby的时候已经安装。 \n\n网址：https://rubygems.org/\n\n下载并安装：\n\n    # wget https://rubygems.global.ssl.fastly.net/rubygems/rubygems-2.6.6.tgz\n    # tar zxvf rubygems-2.6.6.tgz\n    # cd rubygems-2.6.6.tgz\n    # ruby setup.rb\n\n    //显示版本好，说民安装成功\n    zmt@zmt-Lenovo:~/Desktop/work/tools/rubygems-2.6.6$ gem -v\n    2.6.6\n\n安装成功，重新执行步骤1，即安装Bundler，执行：\n\n    gem install bundler\n</code></pre><p>2.然后可以利用bundler安装redmine相关依赖包</p>\n<p>Then you can install all the gems required by Redmine using the following command:</p>\n<pre><code>bundle install --without development test\n</code></pre><p>&lt;&lt;—-未完—&gt;&gt;</p>\n<h2 id=\"Centos7下安装全过程记录\"><a href=\"#Centos7下安装全过程记录\" class=\"headerlink\" title=\"Centos7下安装全过程记录\"></a>Centos7下安装全过程记录</h2><p>参考网址：<a href=\"http://www.redmine.org/projects/redmine/wiki/RedmineInstall\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/RedmineInstall</a></p>\n<p>应用版本信息：<br>redmine： redmine-3.4.6.tar.gz<br>ruby： ruby-2.3.6.tar.gz</p>\n<p>首先安装系统相关包：</p>\n<pre><code>yum -y install patch make gcc gcc-c++ gcc-g77 flex* bison file  \nyum -y install libtool libtool-libs libtool-ltdl-devel* autoconf kernel-devel automake libmcrypt*  \nyum -y install libjpeg libjpeg-devel libpng libpng-devel libpng10 libpng10-devel gd gd-devel  \nyum -y install freetype freetype-devel libxml2 libxml2-devel zlib zlib-devel  \nyum -y install glib2 glib2-devel bzip2 bzip2-devel libevent libevent-devel  \nyum -y install ncurses ncurses-devel curl curl-devel e2fsprogs  \nyum -y install e2fsprogs-devel krb5 krb5-devel libidn libidn-devel  \nyum -y install openssl openssl-devel vim-minimal nano sendmail  \nyum -y install fonts-chinese gettext gettext-devel  \nyum -y install gmp-devel pspell-devel   \nyum -y install readline* libxslt* pcre* net-snmp* gmp* libtidy*  \nyum -y install ImageMagick* subversion*  \n</code></pre><h3 id=\"下载redmine安装包\"><a href=\"#下载redmine安装包\" class=\"headerlink\" title=\"下载redmine安装包\"></a>下载redmine安装包</h3><p>可以在官网下载正式发布的二进制包<a href=\"http://www.redmine.org/projects/redmine/wiki/Download\" target=\"_blank\" rel=\"noopener\">下载</a>。 </p>\n<h3 id=\"创建空的数据库以及相关数据库用户\"><a href=\"#创建空的数据库以及相关数据库用户\" class=\"headerlink\" title=\"创建空的数据库以及相关数据库用户\"></a>创建空的数据库以及相关数据库用户</h3><p>首先要保证已经安装好数据库。下面以mysql为例进行安装。mysql版本&gt;5.5.2。<br>创建脚本：    </p>\n<pre><code>CREATE DATABASE redmine CHARACTER SET utf8mb4;\n#CREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED BY &apos;my_password&apos;; #这样的，navicat客户端无法登录\nCREATE USER &apos;redmine&apos;@&apos;localhost&apos; IDENTIFIED WITH mysql_native_password BY &apos;my_password&apos;;\nGRANT ALL PRIVILEGES ON redmine.* TO &apos;redmine&apos;@&apos;localhost&apos;;\n</code></pre><h3 id=\"为redmine配置数据库\"><a href=\"#为redmine配置数据库\" class=\"headerlink\" title=\"为redmine配置数据库\"></a>为redmine配置数据库</h3><p>首先，解压redmine包，并进入config目录。  </p>\n<p><code>[root@ymu config]# cp database.yml.example database.yml</code></p>\n<p>然后编辑<code>database.yml</code>：</p>\n<pre><code>production:\n  adapter: mysql2\n  database: redmine\n  host: localhost\n  port: 3307\n  username: redmine\n  password: redmine\n</code></pre><p>_注意_: 主机名用<code>localhost</code>可能报错，要改成<code>127.0.0.1</code>。      </p>\n<h3 id=\"安装依赖包\"><a href=\"#安装依赖包\" class=\"headerlink\" title=\"安装依赖包\"></a>安装依赖包</h3><p>1.安装ruby环境。</p>\n<ul>\n<li>安装上面描述方式，ruby源码包安装方式。选择版本安装。</li>\n<li>系统源安装。<code>yum install gem</code>。会自动安装ruby环境。</li>\n</ul>\n<p>下面采用源码编译安装方式。<br>检查是否安装成功：<br><code>ruby -v</code>   <code>gem -v</code></p>\n<p>问题解决：安装完ruby却提示<code>[/usr/bin/ruby: No such file or directory]</code></p>\n<p><code>ln -s /usr/local/bin/ruby /usr/bin/ruby</code><br><code>ln -s /usr/local/bin/gem /usr/bin/gem</code> </p>\n<p>2.安装<code>bundler</code></p>\n<p>redmine的依赖包都通过bundler来安装。   </p>\n<p><code>gem install bundler</code></p>\n<p>3.安装所有依赖</p>\n<p>执行下面命令前，记得要按照上面方法安装所有系统依赖包。</p>\n<pre><code>[root@ymu ~]# cd /server/tools/redmine-3.4.6/\n[root@ymu redmine-3.4.6]# bundle install --without development test\n</code></pre><h3 id=\"安全生成存储会话\"><a href=\"#安全生成存储会话\" class=\"headerlink\" title=\"安全生成存储会话\"></a>安全生成存储会话</h3><p><code>bundle exec rake generate_secret_token</code></p>\n<h3 id=\"创建表\"><a href=\"#创建表\" class=\"headerlink\" title=\"创建表\"></a>创建表</h3><pre><code>[root@ymu redmine-3.4.6]# bundle exec rake generate_secret_token\n[root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake db:migrate\n</code></pre><p>查看数据库，可以看到已经创建了很多表。     </p>\n<h3 id=\"设置数据库默认数据\"><a href=\"#设置数据库默认数据\" class=\"headerlink\" title=\"设置数据库默认数据\"></a>设置数据库默认数据</h3><pre><code>[root@ymu redmine-3.4.6]# RAILS_ENV=production bundle exec rake redmine:load_default_data\n\nSelect language: ar, az, bg, bs, ca, cs, da, de, el, en, en-GB, es, es-PA, et, eu, fa, fi, fr, gl, he, hr, hu, id, it, ja, ko, lt, lv, mk, mn, nl, no, pl, pt, pt-BR, ro, ru, sk, sl, sq, sr, sr-YU, sv, th, tr, uk, vi, zh, zh-TW [en] zh\n====================================\nDefault configuration data loaded.\n</code></pre><p>记得：输入zh，然后按下回车。否则会是英文版本数据。</p>\n<h3 id=\"设置文件权限\"><a href=\"#设置文件权限\" class=\"headerlink\" title=\"设置文件权限\"></a>设置文件权限</h3><ul>\n<li>如果上面的所有操作都是root用户，那么就不必要设置文件权限，可以跳过此步骤。 （<em>上面以root操作，跳过这步骤</em>）    </li>\n<li>如果不是在root超级用户下，则要设置文件权限，否则redmine应用程序无法操作一些文件权限。    </li>\n</ul>\n<p>在redmine解压根目录下，这些文件必须赋予权限：  </p>\n<pre><code>files (storage of attachments)\nlog (application log file production.log)\ntmp and tmp/pdf (create these ones if not present, used to generate PDF documents among other things)\npublic/plugin_assets (assets of plugins)\n</code></pre><p>如果没有这些文件：     </p>\n<pre><code>mkdir -p tmp tmp/pdf public/plugin_assets\nsudo chown -R redmine:redmine files log tmp public/plugin_assets\nsudo chmod -R 755 files log tmp public/plugin_assets\n</code></pre><p>如果都有：   </p>\n<pre><code>sudo chown -R redmine:redmine files log tmp public/plugin_assets\nsudo chmod -R 755 files log tmp public/plugin_assets\n</code></pre><p>_注意_:保证下面目录不包含可执行文件。</p>\n<pre><code>sudo find files log tmp public/plugin_assets -type f -exec chmod -x {} +    \n</code></pre><h3 id=\"测试是否安装成功\"><a href=\"#测试是否安装成功\" class=\"headerlink\" title=\"测试是否安装成功\"></a>测试是否安装成功</h3><p>按照下面经验执行操作：</p>\n<pre><code>bundle exec rails server webrick -e production   //在redmine安装目录下执行\n\n//注意，服务器端执行上面命令可能报错，可能是端口不可用，可以改变端口：\nbundle exec rails server webrick -e production -p 8889\n\n改变端口执行服务成功，但是在客户机子不能访问，此时要这么执行：\n bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889\n\nok搞定\n\n守护进程模式执行：\n nohup bundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 &amp;\n或者：\nbundle exec rails server webrick -e production -b 0.0.0.0 -p 8889 -d    \n</code></pre><p>然后就可以访问：http：//loaclhost:port。  </p>\n<h3 id=\"登录redmine\"><a href=\"#登录redmine\" class=\"headerlink\" title=\"登录redmine\"></a>登录redmine</h3><p>默认账号密码：<br>username=admin<br>pwd=admin</p>\n<p>打开网址后，用默认账号密码登录后，会要求修改密码。把密码改为：<br>username=admin<br>pwd=admin123    </p>\n<p>按页面提示，填写修改相关信息即可。   </p>\n<h3 id=\"修改配置（不修改则采用默认的配置）\"><a href=\"#修改配置（不修改则采用默认的配置）\" class=\"headerlink\" title=\"修改配置（不修改则采用默认的配置）\"></a>修改配置（不修改则采用默认的配置）</h3><p>redmine的配置设置文件放在：config/configuration.yml。<br>如果要自己定义配置，则可以<code>copy config/configuration.yml.example to config/configuration.yml</code>，然后编辑<code>configuration.yml</code>文件即可。 </p>\n<p>记得：修改配置文件后重启redmine，否则不生效。  </p>\n<h3 id=\"重启redmine\"><a href=\"#重启redmine\" class=\"headerlink\" title=\"重启redmine\"></a>重启redmine</h3><p>采用直接kill掉：</p>\n<pre><code>lsof -i:3000\nkill -9 pid\n</code></pre><h3 id=\"开机自启\"><a href=\"#开机自启\" class=\"headerlink\" title=\"开机自启\"></a>开机自启</h3><p>编辑启动文件</p>\n<p>vi /etc/rc.local</p>\n<p>最后一行或者适当的位置，加入一下内容。此处必须用绝对路径。注意根据实际redmine路径来填写。</p>\n<p>/usr/local/rvm/rubies/ruby-2.0.0-p598/bin/ruby /root/redmine-2.6.0/script/rails server webrick -e production -d    </p>\n<h3 id=\"设置Email-SMTP服务器\"><a href=\"#设置Email-SMTP服务器\" class=\"headerlink\" title=\"设置Email/SMTP服务器\"></a>设置Email/SMTP服务器</h3><p>项目管理中，分配了任务或者测试提交了bug给某个开发人员，那么可以通过邮件及时的提醒他。    </p>\n<p>下面我们就来配置邮件服务器：<br>参考：<a href=\"http://www.redmine.org/projects/redmine/wiki/EmailConfiguration\" target=\"_blank\" rel=\"noopener\">http://www.redmine.org/projects/redmine/wiki/EmailConfiguration</a>  </p>\n<p>1.编辑配置文件：config/configuration.yml</p>\n<p>添加邮箱服务器配置，异步发送邮件（qq邮箱为例子）：</p>\n<pre><code>email_delivery:\n    delivery_method: :async_smtp\n    async_smtp_settings:\n      address: &quot;smtp.qq.com&quot;\n      port: 25\n      authentication: :login\n      domain: &apos;qq.com&apos;\n      user_name: &apos;932852117@qq.com&apos;\n      password: &apos;××××××&apos;\n</code></pre><p>下面是实际操作内容：              </p>\n<pre><code># default configuration options for all environments\ndefault:\n  # Outgoing emails configuration\n  # See the examples below and the Rails guide for more configuration options:\n  # http://guides.rubyonrails.org/action_mailer_basics.html#action-mailer-configuration\n  email_delivery:\n    delivery_method: :async_smtp\n    async_smtp_settings:\n      address: &quot;smtp.qq.com&quot;\n      port: 25\n      authentication: :login\n      domain: &apos;qq.com&apos;\n      user_name: &apos;932852117@qq.com&apos;\n      password: &apos;××××××&apos;\n\n  # ==== Simple SMTP server at localhost\n</code></pre><p>2.开启邮箱服务器</p>\n<img src=\"/2018/06/01/redmine-start/b.png\">\n<p>3.重启redmine并测试是否配置成功。 </p>\n<p>登录redmine，在管理-&gt;配置中： </p>\n<img src=\"/2018/06/01/redmine-start/c.png\">\n<p>输入配置的邮箱地址后，保存。然后点击右下角的<code>发送测试邮件</code>：     </p>\n<img src=\"/2018/06/01/redmine-start/d.png\">\n<p>看到绿色提示<code>邮件已发送至 zhangmutian@xcsqjr.com</code>。证明配置已成功，可以愉快的使用了。</p>\n<h3 id=\"scm配置\"><a href=\"#scm配置\" class=\"headerlink\" title=\"scm配置\"></a>scm配置</h3><p>主要是svn和git版本库管理工具。  </p>\n<p>如：svn的<br><code>scm_subversion_command: &quot;svn_replacement.exe&quot;</code></p>\n<p>只需要安装svn或者git服务端，然后在配置文件指向即可。   </p>\n<h3 id=\"其它的配置\"><a href=\"#其它的配置\" class=\"headerlink\" title=\"其它的配置\"></a>其它的配置</h3><p>一般采用默认的就好了。 </p>\n<p>1.附件存储路径。<code>attachments_storage_path: /var/redmine/files</code><br>2.日志保存路径。   </p>\n<p>等等……</p>\n<hr>\n<p>恭喜恭喜，到此，你已成功安装redmine了，并且它已经具备了该有的基础功能了。赶紧来看下它帅帅的样子吧：</p>\n<img src=\"/2018/06/01/redmine-start/a.png\">\n<p>尽情的去探索redmine很多很多，酷酷的特性吧，让它正真成为你在项目管理中的瑞士军刀……</p>\n"},{"title":"spring-boot过滤器篇","date":"2018-04-26T06:40:54.000Z","_content":"\n本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……\n\n## 在spring-boot项目中添加过滤器\n\n### 方式一\n\n1.创建类TestFilter,并实现Filter接口\n\n    package com.ymu.servicecommon.filter;\n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    import javax.servlet.*;\n    import java.io.IOException;\n    \n    /**\n     * 功能简述:<br>\n     *     过滤器配置测试。\n     *\n     * @author zmt\n     * @create 2018-04-26 下午5:15\n     * @updateTime\n     * @since 1.0.0\n     */\n    public class TestFilter implements Filter {\n    \n        protected final Logger logger = LogManager.getLogger(this.getClass());\n    \n        @Override\n        public void init(FilterConfig filterConfig) throws ServletException {\n            logger.debug(\">>>>testFilter init\");\n        }\n    \n        @Override\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n            logger.debug(\">>>>testFilter doFilter\");\n            filterChain.doFilter(servletRequest,servletResponse);\n        }\n    \n        @Override\n        public void destroy() {\n            logger.debug(\">>>>testFilter destroy\");\n        }\n    }\n\n2.注解bean\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean indexFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            return registration;\n        }\n    \n    }\n\n\n### 方式二\n\n1.创建过滤器IndexFilter2\n\n    package com.example.filter;\n    import java.io.IOException;\n    import javax.servlet.Filter;\n    import javax.servlet.FilterChain;\n    import javax.servlet.FilterConfig;\n    import javax.servlet.ServletException;\n    import javax.servlet.ServletRequest;\n    import javax.servlet.ServletResponse;\n    import javax.servlet.annotation.WebFilter;\n    \n    @WebFilter(urlPatterns = \"/*\", filterName = \"indexFilter2\")\n    public class IndexFilter2 implements Filter{\n      @Override\n      public void destroy() {\n        System.out.println(\"filter2 destroy method\");\n      }\n      @Override\n      public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n          throws IOException, ServletException {\n        System.out.println(\"filter2 doFilter method\");\n      }\n      @Override\n      public void init(FilterConfig arg0) throws ServletException {\n        System.out.println(\"filter2 init method\");\n      }\n    }\n\n2.在程序启动入库加入注解`ServletComponentScan`\n\n    @SpringBootApplication\n    @ServletComponentScan\n    public class SpringBootSimpleApplication {\n      public static void main(String[] args) {\n        SpringApplication.run(SpringBootSimpleApplication.class, args);\n      }\n    }\n\n## 多个过滤器调用顺序\n\n在spring-boot中通过注解`@Order`来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。\n\n1.代码设置\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.Test2Filter;\n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean testFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n        @Bean\n        public FilterRegistrationBean test2FilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"test2Filter\");\n            registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n    }\n    \n----------------------------------------------------    \n\n- 启动程序，观察执行顺序。\n\n{% asset_img a.png %} \n\n- 请求接口，观察执行顺序。\n\n{% asset_img b.png %}\n\n\n## 在过滤器中为请求添加http请求头信息\n\n1.定义类ModifyHttpServletRequestWrapper.java\n\n    package com.ymu.framework.web;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import javax.servlet.http.HttpServletRequestWrapper;\n    import java.util.*;\n    \n    public class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n     \n        private Map<String, String> customHeaders;\n     \n        public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n            super(request);\n            this.customHeaders = new HashMap<>();\n        }\n     \n        public void putHeader(String name, String value) {\n            this.customHeaders.put(name, value);\n        }\n     \n        public String getHeader(String name) {\n            String value = this.customHeaders.get(name);\n            if (value != null) {\n                return value;\n            }\n            return ((HttpServletRequest) getRequest()).getHeader(name);\n        }\n     \n        public Enumeration<String> getHeaderNames() {\n            Set<String> set = new HashSet<>(customHeaders.keySet());\n            Enumeration<String> enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n            while (enumeration.hasMoreElements()) {\n                String name = enumeration.nextElement();\n                set.add(name);\n            }\n            return Collections.enumeration(set);\n        }\n     \n    }\n    \n2.定义过滤器，编辑\n    \n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(\">>>>indexFilter doFilter\");\n\n        //添加或者更改header信息\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        String apiVersion = request.getHeader(\"Content-Version\");\n        if (null == apiVersion || \"\".equals(apiVersion)) {\n            ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n            requestWrapper.putHeader(\"Content-Version\",\"-1\");\n            filterChain.doFilter(requestWrapper,servletResponse);\n        } else {\n            filterChain.doFilter(request,servletResponse);\n        }\n    }   \n\n    重点代码：\n    ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n    requestWrapper.putHeader(\"Content-Version\",\"-1\");\n    filterChain.doFilter(requestWrapper,servletResponse);","source":"_posts/spring-boot-filter.md","raw":"---\ntitle: spring-boot过滤器篇\ndate: 2018-04-26 14:40:54\ncategories: spring-boot\ntags: spring-boot-filter\n---\n\n本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……\n\n## 在spring-boot项目中添加过滤器\n\n### 方式一\n\n1.创建类TestFilter,并实现Filter接口\n\n    package com.ymu.servicecommon.filter;\n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    import javax.servlet.*;\n    import java.io.IOException;\n    \n    /**\n     * 功能简述:<br>\n     *     过滤器配置测试。\n     *\n     * @author zmt\n     * @create 2018-04-26 下午5:15\n     * @updateTime\n     * @since 1.0.0\n     */\n    public class TestFilter implements Filter {\n    \n        protected final Logger logger = LogManager.getLogger(this.getClass());\n    \n        @Override\n        public void init(FilterConfig filterConfig) throws ServletException {\n            logger.debug(\">>>>testFilter init\");\n        }\n    \n        @Override\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n            logger.debug(\">>>>testFilter doFilter\");\n            filterChain.doFilter(servletRequest,servletResponse);\n        }\n    \n        @Override\n        public void destroy() {\n            logger.debug(\">>>>testFilter destroy\");\n        }\n    }\n\n2.注解bean\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean indexFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            return registration;\n        }\n    \n    }\n\n\n### 方式二\n\n1.创建过滤器IndexFilter2\n\n    package com.example.filter;\n    import java.io.IOException;\n    import javax.servlet.Filter;\n    import javax.servlet.FilterChain;\n    import javax.servlet.FilterConfig;\n    import javax.servlet.ServletException;\n    import javax.servlet.ServletRequest;\n    import javax.servlet.ServletResponse;\n    import javax.servlet.annotation.WebFilter;\n    \n    @WebFilter(urlPatterns = \"/*\", filterName = \"indexFilter2\")\n    public class IndexFilter2 implements Filter{\n      @Override\n      public void destroy() {\n        System.out.println(\"filter2 destroy method\");\n      }\n      @Override\n      public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n          throws IOException, ServletException {\n        System.out.println(\"filter2 doFilter method\");\n      }\n      @Override\n      public void init(FilterConfig arg0) throws ServletException {\n        System.out.println(\"filter2 init method\");\n      }\n    }\n\n2.在程序启动入库加入注解`ServletComponentScan`\n\n    @SpringBootApplication\n    @ServletComponentScan\n    public class SpringBootSimpleApplication {\n      public static void main(String[] args) {\n        SpringApplication.run(SpringBootSimpleApplication.class, args);\n      }\n    }\n\n## 多个过滤器调用顺序\n\n在spring-boot中通过注解`@Order`来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。\n\n1.代码设置\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.Test2Filter;\n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean testFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n        @Bean\n        public FilterRegistrationBean test2FilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"test2Filter\");\n            registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n    }\n    \n----------------------------------------------------    \n\n- 启动程序，观察执行顺序。\n\n{% asset_img a.png %} \n\n- 请求接口，观察执行顺序。\n\n{% asset_img b.png %}\n\n\n## 在过滤器中为请求添加http请求头信息\n\n1.定义类ModifyHttpServletRequestWrapper.java\n\n    package com.ymu.framework.web;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import javax.servlet.http.HttpServletRequestWrapper;\n    import java.util.*;\n    \n    public class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n     \n        private Map<String, String> customHeaders;\n     \n        public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n            super(request);\n            this.customHeaders = new HashMap<>();\n        }\n     \n        public void putHeader(String name, String value) {\n            this.customHeaders.put(name, value);\n        }\n     \n        public String getHeader(String name) {\n            String value = this.customHeaders.get(name);\n            if (value != null) {\n                return value;\n            }\n            return ((HttpServletRequest) getRequest()).getHeader(name);\n        }\n     \n        public Enumeration<String> getHeaderNames() {\n            Set<String> set = new HashSet<>(customHeaders.keySet());\n            Enumeration<String> enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n            while (enumeration.hasMoreElements()) {\n                String name = enumeration.nextElement();\n                set.add(name);\n            }\n            return Collections.enumeration(set);\n        }\n     \n    }\n    \n2.定义过滤器，编辑\n    \n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(\">>>>indexFilter doFilter\");\n\n        //添加或者更改header信息\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        String apiVersion = request.getHeader(\"Content-Version\");\n        if (null == apiVersion || \"\".equals(apiVersion)) {\n            ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n            requestWrapper.putHeader(\"Content-Version\",\"-1\");\n            filterChain.doFilter(requestWrapper,servletResponse);\n        } else {\n            filterChain.doFilter(request,servletResponse);\n        }\n    }   \n\n    重点代码：\n    ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n    requestWrapper.putHeader(\"Content-Version\",\"-1\");\n    filterChain.doFilter(requestWrapper,servletResponse);","slug":"spring-boot-filter","published":1,"updated":"2018-11-09T01:20:30.920Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38p400csqcrguerazsp7","content":"<p>本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……</p>\n<h2 id=\"在spring-boot项目中添加过滤器\"><a href=\"#在spring-boot项目中添加过滤器\" class=\"headerlink\" title=\"在spring-boot项目中添加过滤器\"></a>在spring-boot项目中添加过滤器</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>1.创建类TestFilter,并实现Filter接口</p>\n<pre><code>package com.ymu.servicecommon.filter;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\n/**\n * 功能简述:&lt;br&gt;\n *     过滤器配置测试。\n *\n * @author zmt\n * @create 2018-04-26 下午5:15\n * @updateTime\n * @since 1.0.0\n */\npublic class TestFilter implements Filter {\n\n    protected final Logger logger = LogManager.getLogger(this.getClass());\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter init&quot;);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter doFilter&quot;);\n        filterChain.doFilter(servletRequest,servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter destroy&quot;);\n    }\n}\n</code></pre><p>2.注解bean</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean indexFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        return registration;\n    }\n\n}\n</code></pre><h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>1.创建过滤器IndexFilter2</p>\n<pre><code>package com.example.filter;\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\n\n@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;indexFilter2&quot;)\npublic class IndexFilter2 implements Filter{\n  @Override\n  public void destroy() {\n    System.out.println(&quot;filter2 destroy method&quot;);\n  }\n  @Override\n  public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n      throws IOException, ServletException {\n    System.out.println(&quot;filter2 doFilter method&quot;);\n  }\n  @Override\n  public void init(FilterConfig arg0) throws ServletException {\n    System.out.println(&quot;filter2 init method&quot;);\n  }\n}\n</code></pre><p>2.在程序启动入库加入注解<code>ServletComponentScan</code></p>\n<pre><code>@SpringBootApplication\n@ServletComponentScan\npublic class SpringBootSimpleApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(SpringBootSimpleApplication.class, args);\n  }\n}\n</code></pre><h2 id=\"多个过滤器调用顺序\"><a href=\"#多个过滤器调用顺序\" class=\"headerlink\" title=\"多个过滤器调用顺序\"></a>多个过滤器调用顺序</h2><p>在spring-boot中通过注解<code>@Order</code>来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。</p>\n<p>1.代码设置</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.Test2Filter;\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n    @Bean\n    public FilterRegistrationBean test2FilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;test2Filter&quot;);\n        registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n}\n</code></pre><hr>\n<ul>\n<li>启动程序，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/a.png\"> \n<ul>\n<li>请求接口，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/b.png\">\n<h2 id=\"在过滤器中为请求添加http请求头信息\"><a href=\"#在过滤器中为请求添加http请求头信息\" class=\"headerlink\" title=\"在过滤器中为请求添加http请求头信息\"></a>在过滤器中为请求添加http请求头信息</h2><p>1.定义类ModifyHttpServletRequestWrapper.java</p>\n<pre><code>package com.ymu.framework.web;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.util.*;\n\npublic class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n\n    private Map&lt;String, String&gt; customHeaders;\n\n    public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n        super(request);\n        this.customHeaders = new HashMap&lt;&gt;();\n    }\n\n    public void putHeader(String name, String value) {\n        this.customHeaders.put(name, value);\n    }\n\n    public String getHeader(String name) {\n        String value = this.customHeaders.get(name);\n        if (value != null) {\n            return value;\n        }\n        return ((HttpServletRequest) getRequest()).getHeader(name);\n    }\n\n    public Enumeration&lt;String&gt; getHeaderNames() {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;(customHeaders.keySet());\n        Enumeration&lt;String&gt; enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n        while (enumeration.hasMoreElements()) {\n            String name = enumeration.nextElement();\n            set.add(name);\n        }\n        return Collections.enumeration(set);\n    }\n\n}\n</code></pre><p>2.定义过滤器，编辑</p>\n<pre><code>@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    logger.debug(&quot;&gt;&gt;&gt;&gt;indexFilter doFilter&quot;);\n\n    //添加或者更改header信息\n    HttpServletRequest request = (HttpServletRequest) servletRequest;\n    String apiVersion = request.getHeader(&quot;Content-Version&quot;);\n    if (null == apiVersion || &quot;&quot;.equals(apiVersion)) {\n        ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n        requestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\n        filterChain.doFilter(requestWrapper,servletResponse);\n    } else {\n        filterChain.doFilter(request,servletResponse);\n    }\n}   \n\n重点代码：\nModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\nrequestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\nfilterChain.doFilter(requestWrapper,servletResponse);\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……</p>\n<h2 id=\"在spring-boot项目中添加过滤器\"><a href=\"#在spring-boot项目中添加过滤器\" class=\"headerlink\" title=\"在spring-boot项目中添加过滤器\"></a>在spring-boot项目中添加过滤器</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>1.创建类TestFilter,并实现Filter接口</p>\n<pre><code>package com.ymu.servicecommon.filter;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\n/**\n * 功能简述:&lt;br&gt;\n *     过滤器配置测试。\n *\n * @author zmt\n * @create 2018-04-26 下午5:15\n * @updateTime\n * @since 1.0.0\n */\npublic class TestFilter implements Filter {\n\n    protected final Logger logger = LogManager.getLogger(this.getClass());\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter init&quot;);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter doFilter&quot;);\n        filterChain.doFilter(servletRequest,servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter destroy&quot;);\n    }\n}\n</code></pre><p>2.注解bean</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean indexFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        return registration;\n    }\n\n}\n</code></pre><h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>1.创建过滤器IndexFilter2</p>\n<pre><code>package com.example.filter;\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\n\n@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;indexFilter2&quot;)\npublic class IndexFilter2 implements Filter{\n  @Override\n  public void destroy() {\n    System.out.println(&quot;filter2 destroy method&quot;);\n  }\n  @Override\n  public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n      throws IOException, ServletException {\n    System.out.println(&quot;filter2 doFilter method&quot;);\n  }\n  @Override\n  public void init(FilterConfig arg0) throws ServletException {\n    System.out.println(&quot;filter2 init method&quot;);\n  }\n}\n</code></pre><p>2.在程序启动入库加入注解<code>ServletComponentScan</code></p>\n<pre><code>@SpringBootApplication\n@ServletComponentScan\npublic class SpringBootSimpleApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(SpringBootSimpleApplication.class, args);\n  }\n}\n</code></pre><h2 id=\"多个过滤器调用顺序\"><a href=\"#多个过滤器调用顺序\" class=\"headerlink\" title=\"多个过滤器调用顺序\"></a>多个过滤器调用顺序</h2><p>在spring-boot中通过注解<code>@Order</code>来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。</p>\n<p>1.代码设置</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.Test2Filter;\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n    @Bean\n    public FilterRegistrationBean test2FilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;test2Filter&quot;);\n        registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n}\n</code></pre><hr>\n<ul>\n<li>启动程序，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/a.png\"> \n<ul>\n<li>请求接口，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/b.png\">\n<h2 id=\"在过滤器中为请求添加http请求头信息\"><a href=\"#在过滤器中为请求添加http请求头信息\" class=\"headerlink\" title=\"在过滤器中为请求添加http请求头信息\"></a>在过滤器中为请求添加http请求头信息</h2><p>1.定义类ModifyHttpServletRequestWrapper.java</p>\n<pre><code>package com.ymu.framework.web;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.util.*;\n\npublic class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n\n    private Map&lt;String, String&gt; customHeaders;\n\n    public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n        super(request);\n        this.customHeaders = new HashMap&lt;&gt;();\n    }\n\n    public void putHeader(String name, String value) {\n        this.customHeaders.put(name, value);\n    }\n\n    public String getHeader(String name) {\n        String value = this.customHeaders.get(name);\n        if (value != null) {\n            return value;\n        }\n        return ((HttpServletRequest) getRequest()).getHeader(name);\n    }\n\n    public Enumeration&lt;String&gt; getHeaderNames() {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;(customHeaders.keySet());\n        Enumeration&lt;String&gt; enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n        while (enumeration.hasMoreElements()) {\n            String name = enumeration.nextElement();\n            set.add(name);\n        }\n        return Collections.enumeration(set);\n    }\n\n}\n</code></pre><p>2.定义过滤器，编辑</p>\n<pre><code>@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    logger.debug(&quot;&gt;&gt;&gt;&gt;indexFilter doFilter&quot;);\n\n    //添加或者更改header信息\n    HttpServletRequest request = (HttpServletRequest) servletRequest;\n    String apiVersion = request.getHeader(&quot;Content-Version&quot;);\n    if (null == apiVersion || &quot;&quot;.equals(apiVersion)) {\n        ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n        requestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\n        filterChain.doFilter(requestWrapper,servletResponse);\n    } else {\n        filterChain.doFilter(request,servletResponse);\n    }\n}   \n\n重点代码：\nModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\nrequestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\nfilterChain.doFilter(requestWrapper,servletResponse);\n</code></pre>"},{"title":"虚拟开发环境-Vagrant","date":"2018-01-23T02:04:27.000Z","_content":"\n介绍vagrant，为公司搭建统一的开发环境。最终会输出一个统一的虚拟开发环境，然后就可以分发给团队中所有的开发人员，大家在一致的开发环境中编辑，验证代码……\n\n从此,告别“在我的机子上运行没问题的……”这个看似很有道理的扯皮了。\n\n官网网址：https://www.vagrantup.com/\n\n## vagrant安装\n\n### 安装开源虚拟机VirtualBox\n\n注意安装版本和vagrant版本要对应，否则后面会出现各种问题。这里安装最新版本。  \n \n下载地址：https://www.virtualbox.org/wiki/Downloads \n\n选择自己电脑系统对应版本。\n\n{% asset_img a.png %}\n\n    axel -n 10 https://download.virtualbox.org/virtualbox/5.2.14/virtualbox-5.2_5.2.14-123301~Ubuntu~xenial_amd64.deb\n\n然后，执行安装命令`sudo dpkg -i *.deb`进行安装即可。\n\n安装过程中可能会缺少依赖包，把依赖包安装即可：\n\n{% asset_img b.png %}\n\n安装依赖包：`mutian@mutian-ThinkPad-T440p:~/Downloads$ sudo apt install libsdl1.2debian`\n\n重新执行安装命令：\n\n{% asset_img c.png %}\n\n安装没有任何错误。 已安装到系统。\n\n{% asset_img d.png %}\n\n### 安装vagrant\n\n安装最新版本。\n\n下载地址：https://www.vagrantup.com/downloads.html \n\n下载自己电脑系统对应版本。\n\n    axel -n 10 https://releases.hashicorp.com/vagrant/2.1.2/vagrant_2.1.2_x86_64.deb\n\n然后，执行安装命令`sudo dpkg -i vagrant_2.1.2_x86_64.deb`进行安装即可。\n\n查看安装是否成功：\n\n    mutian@mutian-ThinkPad-T440p:~/Downloads$ vagrant -v\n    Vagrant 2.1.2\n\n表明安装已经成功，版本`2.1.2`。\n\n## 添加Box\n\n官方box源：https://app.vagrantup.com/boxes/search \n\n网络不好，需要翻墙。或者通过其它途径下载想要的box。\n\n- 查看所有已下载box\n\n`vagrant box list`\n\n- 添加box\n\n`vagrant box add centos/7`\n\n执行上面命令会添加相应box到vagrant系统，如果没有，会先从box官源下载。   \n\n- 再次执行`vagrant box list`便可以看到。 \n\n## 创造自己box\n\n- 创建目录\n\n` mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ mkdir xcsqjr-dev/` \n\n- 初始化，创建配置文件\n\n\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ cd xcsqjr-dev/\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/xcsqjr-dev$ vagrant init centos/7\n    A `Vagrantfile` has been placed in this directory. You are now\n    ready to `vagrant up` your first virtual environment! Please read\n    the comments in the Vagrantfile as well as documentation on\n    `vagrantup.com` for more information on using Vagrant. \n\n会在当前目录下创建文件`Vagrantfile`。然后就可以编辑该文件，做一些配置：\n\n    # -*- mode: ruby -*-\n    # vi: set ft=ruby :\n    \n    # All Vagrant configuration is done below. The \"2\" in Vagrant.configure\n    # configures the configuration version (we support older styles for\n    # backwards compatibility). Please don't change it unless you know what\n    # you're doing.\n    Vagrant.configure(\"2\") do |config|\n      # The most common configuration options are documented and commented below.\n      # For a complete reference, please see the online documentation at\n      # https://docs.vagrantup.com.\n    \n      # Every Vagrant development environment requires a box. You can search for\n      # boxes at https://vagrantcloud.com/search.\n      \n      # ----------- 一些相关配置 start ----------------#\n      config.vm.box = \"centos/7\" #和已经下载的box名字一致\n      config.vm.hostname = \"ymu\"  \n      #config.vm.box_version = \"1.1.0\"\t\n      config.vm.box_url = \"http://ymu.box\"\n    \n      # 对虚拟机的一些配置 \t\n      config.vm.provider \"virtualbox\" do |vb|\n      #   # Display the VirtualBox GUI when booting the machine\n      #   vb.gui = true\n      #\n      #   # Customize the amount of memory on the VM:\n          vb.memory = \"1024\" #为虚拟机分配内存\n          vb.cpus = 2 #为虚拟机分配cup，分2核心\n          vb.name = \"centos7_ymu\" #虚拟机名称\n      end\n      \n      # ----------- 一些相关配置 end ----------------#\n    \n      # Disable automatic box update checking. If you disable this, then\n      # boxes will only be checked for updates when the user runs\n      # `vagrant box outdated`. This is not recommended.\n      # config.vm.box_check_update = false\n    \n      # Create a forwarded port mapping which allows access to a specific port\n      # within the machine from a port on the host machine. In the example below,\n      # accessing \"localhost:8080\" will access port 80 on the guest machine.\n      # NOTE: This will enable public access to the opened port\n      # config.vm.network \"forwarded_port\", guest: 80, host: 8080\n    \n      # Create a forwarded port mapping which allows access to a specific port\n      # within the machine from a port on the host machine and only allow access\n      # via 127.0.0.1 to disable public access\n      # config.vm.network \"forwarded_port\", guest: 80, host: 8080, host_ip: \"127.0.0.1\"\n    \n      # Create a private network, which allows host-only access to the machine\n      # using a specific IP.\n      # config.vm.network \"private_network\", ip: \"192.168.33.10\"\n    \n      # Create a public network, which generally matched to bridged network.\n      # Bridged networks make the machine appear as another physical device on\n      # your network.\n      # config.vm.network \"public_network\"\n    \n      # Share an additional folder to the guest VM. The first argument is\n      # the path on the host to the actual folder. The second argument is\n      # the path on the guest to mount the folder. And the optional third\n      # argument is a set of non-required options.\n      # config.vm.synced_folder \"../data\", \"/vagrant_data\"\n    \n      # Provider-specific configuration so you can fine-tune various\n      # backing providers for Vagrant. These expose provider-specific options.\n      # Example for VirtualBox:\n      #\n      # config.vm.provider \"virtualbox\" do |vb|\n      #   # Display the VirtualBox GUI when booting the machine\n      #   vb.gui = true\n      #\n      #   # Customize the amount of memory on the VM:\n      #   vb.memory = \"1024\"\n      # end\n      #\n      # View the documentation for the provider you are using for more\n      # information on available options.\n    \n      # Enable provisioning with a shell script. Additional provisioners such as\n      # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n      # documentation for more information about their specific syntax and use.\n      # config.vm.provision \"shell\", inline: <<-SHELL\n      #   apt-get update\n      #   apt-get install -y apache2\n      # SHELL\n    end\n\n- 启动虚拟机\n\n\n    mutian@mutian-ThinkPad-T440p:~$ cd dev/vagrant/ymu-dev/\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Clearing any previously set forwarded ports...\n    ==> default: Clearing any previously set network interfaces...\n    ==> default: Preparing network interfaces based on configuration...\n        default: Adapter 1: nat\n    ==> default: Forwarding ports...\n        default: 22 (guest) => 2222 (host) (adapter 1)\n    ==> default: Running 'pre-boot' VM customizations...\n    ==> default: Booting VM...\n    ==> default: Waiting for machine to boot. This may take a few minutes...\n        default: SSH address: 127.0.0.1:2222\n        default: SSH username: vagrant\n        default: SSH auth method: private key\n \n 打开virtualbox,可以看到centos7_ymu的虚拟机已经启动。\n        \n {%asset_img e.png%}  \n \n - 进入该虚拟机\n \n ` vagrant ssh`\n \n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant ssh\n    Last login: Mon Jul  9 07:40:01 2018 from 10.0.2.2\n    [vagrant@ymu ~]$ \n\n下面就可以在里面，类似在真实的服务器操作系统里面一样，安装各种开发软件，配置各种开发环境了。 \n\n- 登出虚拟机\n\n        [vagrant@ymu ~]$ logout\n        Connection to 127.0.0.1 closed.\n        mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ \n        \n- 停止运行虚拟机\n\n        mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant halt\n        ==> default: Attempting graceful shutdown of VM...\n\n- 挂起虚拟机\n\n`vagrant shutdown`\n\n- 重新加载配置启动\n\n`vagrant reload`\n\n### 配置\n\n    config.vm.box = \"centos/7\" #和已经下载的box名字一致\n    config.vm.hostname = \"ymu\"  \n    #config.vm.box_version = \"1.1.0\"\t\n    config.vm.box_url = \"http://ymu.box\"\n    config.vm.synced_folder \"/home/mutian/dev/java/github/ymu-micro-service\", \"/vagrant\", :ext4 => true #共享文件夹\n  \n#### 配置共享文件\n\n注：如果不配置共享目录，默认会把`Vagrantfile`文件所在的目录同步到虚拟机中的`、vagrant`目录下。\n\n`config.vm.synced_folder \"/home/mutian/dev/java/github/ymu-micro-service\", \"/vagrant\", :ext4 => true #共享文件夹`\n\n第一个路径为宿主电脑文件夹，第二个为同步的虚拟机文件夹。宿主机文件夹中所有内容将实时同步到虚拟机中文件夹下。\n\n注意文件类型。在`ubuntu`下查询自己系统文件类型执行命令`df -lhT`。\n\n登录虚拟机，进入`/vagrant`,将看到：\n\n    [vagrant@ymu vagrant]$ ls\n    logs    ymu-config-repo    ymu-hystrix-dashboard  ymu-server-eureka\n    target  ymu-config-server  ymu-hystrix-turbine    ymu-service-basic\n\n看到宿舍机相关目录下的内容同步过来了。\n\n所以，这个时候，你就可以只在宿主机编辑代码，在虚拟机里面编译执行了。\n\n#### 配置网络\n\n## 为自己的box安装各种应用环境\n\n### docker安装\n\n设置自启动：`systemctl enable docker.service`\n\n参考之前blog。\n\n### 安装`nginx`\n\n- docker运行方式\n- 传统按照方式。\n\n### 安装`redis`\n\n- docker运行方式\n\nhttps://hub.docker.com/_/redis/\n\n- 传统按照方式。\n\n## 打包分发\n\n1.打包，把上面自己定制的box打包。     \n命令： \n- `vagrant package --output xxx.box`\n-  `vagrant package --output xxx.box --base 虚拟机名称`  \n\n2.分发，把打好的包通过优盘等，给其它人用。\n\n3.更新软件\n\n- 老用户\n\n- 新用户   \n用最新的打包即可。\n\n\n\n## 学习资源\n\n- http://www.imooc.com/learn/805\n- https://github.com/apanly/mooc","source":"_posts/vagrant-start.md","raw":"---\ntitle: 虚拟开发环境-Vagrant\ndate: 2018-01-23 10:04:27\ncategories: vagrant\ntags: vagrant-start\n---\n\n介绍vagrant，为公司搭建统一的开发环境。最终会输出一个统一的虚拟开发环境，然后就可以分发给团队中所有的开发人员，大家在一致的开发环境中编辑，验证代码……\n\n从此,告别“在我的机子上运行没问题的……”这个看似很有道理的扯皮了。\n\n官网网址：https://www.vagrantup.com/\n\n## vagrant安装\n\n### 安装开源虚拟机VirtualBox\n\n注意安装版本和vagrant版本要对应，否则后面会出现各种问题。这里安装最新版本。  \n \n下载地址：https://www.virtualbox.org/wiki/Downloads \n\n选择自己电脑系统对应版本。\n\n{% asset_img a.png %}\n\n    axel -n 10 https://download.virtualbox.org/virtualbox/5.2.14/virtualbox-5.2_5.2.14-123301~Ubuntu~xenial_amd64.deb\n\n然后，执行安装命令`sudo dpkg -i *.deb`进行安装即可。\n\n安装过程中可能会缺少依赖包，把依赖包安装即可：\n\n{% asset_img b.png %}\n\n安装依赖包：`mutian@mutian-ThinkPad-T440p:~/Downloads$ sudo apt install libsdl1.2debian`\n\n重新执行安装命令：\n\n{% asset_img c.png %}\n\n安装没有任何错误。 已安装到系统。\n\n{% asset_img d.png %}\n\n### 安装vagrant\n\n安装最新版本。\n\n下载地址：https://www.vagrantup.com/downloads.html \n\n下载自己电脑系统对应版本。\n\n    axel -n 10 https://releases.hashicorp.com/vagrant/2.1.2/vagrant_2.1.2_x86_64.deb\n\n然后，执行安装命令`sudo dpkg -i vagrant_2.1.2_x86_64.deb`进行安装即可。\n\n查看安装是否成功：\n\n    mutian@mutian-ThinkPad-T440p:~/Downloads$ vagrant -v\n    Vagrant 2.1.2\n\n表明安装已经成功，版本`2.1.2`。\n\n## 添加Box\n\n官方box源：https://app.vagrantup.com/boxes/search \n\n网络不好，需要翻墙。或者通过其它途径下载想要的box。\n\n- 查看所有已下载box\n\n`vagrant box list`\n\n- 添加box\n\n`vagrant box add centos/7`\n\n执行上面命令会添加相应box到vagrant系统，如果没有，会先从box官源下载。   \n\n- 再次执行`vagrant box list`便可以看到。 \n\n## 创造自己box\n\n- 创建目录\n\n` mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ mkdir xcsqjr-dev/` \n\n- 初始化，创建配置文件\n\n\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ cd xcsqjr-dev/\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/xcsqjr-dev$ vagrant init centos/7\n    A `Vagrantfile` has been placed in this directory. You are now\n    ready to `vagrant up` your first virtual environment! Please read\n    the comments in the Vagrantfile as well as documentation on\n    `vagrantup.com` for more information on using Vagrant. \n\n会在当前目录下创建文件`Vagrantfile`。然后就可以编辑该文件，做一些配置：\n\n    # -*- mode: ruby -*-\n    # vi: set ft=ruby :\n    \n    # All Vagrant configuration is done below. The \"2\" in Vagrant.configure\n    # configures the configuration version (we support older styles for\n    # backwards compatibility). Please don't change it unless you know what\n    # you're doing.\n    Vagrant.configure(\"2\") do |config|\n      # The most common configuration options are documented and commented below.\n      # For a complete reference, please see the online documentation at\n      # https://docs.vagrantup.com.\n    \n      # Every Vagrant development environment requires a box. You can search for\n      # boxes at https://vagrantcloud.com/search.\n      \n      # ----------- 一些相关配置 start ----------------#\n      config.vm.box = \"centos/7\" #和已经下载的box名字一致\n      config.vm.hostname = \"ymu\"  \n      #config.vm.box_version = \"1.1.0\"\t\n      config.vm.box_url = \"http://ymu.box\"\n    \n      # 对虚拟机的一些配置 \t\n      config.vm.provider \"virtualbox\" do |vb|\n      #   # Display the VirtualBox GUI when booting the machine\n      #   vb.gui = true\n      #\n      #   # Customize the amount of memory on the VM:\n          vb.memory = \"1024\" #为虚拟机分配内存\n          vb.cpus = 2 #为虚拟机分配cup，分2核心\n          vb.name = \"centos7_ymu\" #虚拟机名称\n      end\n      \n      # ----------- 一些相关配置 end ----------------#\n    \n      # Disable automatic box update checking. If you disable this, then\n      # boxes will only be checked for updates when the user runs\n      # `vagrant box outdated`. This is not recommended.\n      # config.vm.box_check_update = false\n    \n      # Create a forwarded port mapping which allows access to a specific port\n      # within the machine from a port on the host machine. In the example below,\n      # accessing \"localhost:8080\" will access port 80 on the guest machine.\n      # NOTE: This will enable public access to the opened port\n      # config.vm.network \"forwarded_port\", guest: 80, host: 8080\n    \n      # Create a forwarded port mapping which allows access to a specific port\n      # within the machine from a port on the host machine and only allow access\n      # via 127.0.0.1 to disable public access\n      # config.vm.network \"forwarded_port\", guest: 80, host: 8080, host_ip: \"127.0.0.1\"\n    \n      # Create a private network, which allows host-only access to the machine\n      # using a specific IP.\n      # config.vm.network \"private_network\", ip: \"192.168.33.10\"\n    \n      # Create a public network, which generally matched to bridged network.\n      # Bridged networks make the machine appear as another physical device on\n      # your network.\n      # config.vm.network \"public_network\"\n    \n      # Share an additional folder to the guest VM. The first argument is\n      # the path on the host to the actual folder. The second argument is\n      # the path on the guest to mount the folder. And the optional third\n      # argument is a set of non-required options.\n      # config.vm.synced_folder \"../data\", \"/vagrant_data\"\n    \n      # Provider-specific configuration so you can fine-tune various\n      # backing providers for Vagrant. These expose provider-specific options.\n      # Example for VirtualBox:\n      #\n      # config.vm.provider \"virtualbox\" do |vb|\n      #   # Display the VirtualBox GUI when booting the machine\n      #   vb.gui = true\n      #\n      #   # Customize the amount of memory on the VM:\n      #   vb.memory = \"1024\"\n      # end\n      #\n      # View the documentation for the provider you are using for more\n      # information on available options.\n    \n      # Enable provisioning with a shell script. Additional provisioners such as\n      # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n      # documentation for more information about their specific syntax and use.\n      # config.vm.provision \"shell\", inline: <<-SHELL\n      #   apt-get update\n      #   apt-get install -y apache2\n      # SHELL\n    end\n\n- 启动虚拟机\n\n\n    mutian@mutian-ThinkPad-T440p:~$ cd dev/vagrant/ymu-dev/\n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant up\n    Bringing machine 'default' up with 'virtualbox' provider...\n    ==> default: Checking if box 'centos/7' is up to date...\n    ==> default: Clearing any previously set forwarded ports...\n    ==> default: Clearing any previously set network interfaces...\n    ==> default: Preparing network interfaces based on configuration...\n        default: Adapter 1: nat\n    ==> default: Forwarding ports...\n        default: 22 (guest) => 2222 (host) (adapter 1)\n    ==> default: Running 'pre-boot' VM customizations...\n    ==> default: Booting VM...\n    ==> default: Waiting for machine to boot. This may take a few minutes...\n        default: SSH address: 127.0.0.1:2222\n        default: SSH username: vagrant\n        default: SSH auth method: private key\n \n 打开virtualbox,可以看到centos7_ymu的虚拟机已经启动。\n        \n {%asset_img e.png%}  \n \n - 进入该虚拟机\n \n ` vagrant ssh`\n \n    mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant ssh\n    Last login: Mon Jul  9 07:40:01 2018 from 10.0.2.2\n    [vagrant@ymu ~]$ \n\n下面就可以在里面，类似在真实的服务器操作系统里面一样，安装各种开发软件，配置各种开发环境了。 \n\n- 登出虚拟机\n\n        [vagrant@ymu ~]$ logout\n        Connection to 127.0.0.1 closed.\n        mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ \n        \n- 停止运行虚拟机\n\n        mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant halt\n        ==> default: Attempting graceful shutdown of VM...\n\n- 挂起虚拟机\n\n`vagrant shutdown`\n\n- 重新加载配置启动\n\n`vagrant reload`\n\n### 配置\n\n    config.vm.box = \"centos/7\" #和已经下载的box名字一致\n    config.vm.hostname = \"ymu\"  \n    #config.vm.box_version = \"1.1.0\"\t\n    config.vm.box_url = \"http://ymu.box\"\n    config.vm.synced_folder \"/home/mutian/dev/java/github/ymu-micro-service\", \"/vagrant\", :ext4 => true #共享文件夹\n  \n#### 配置共享文件\n\n注：如果不配置共享目录，默认会把`Vagrantfile`文件所在的目录同步到虚拟机中的`、vagrant`目录下。\n\n`config.vm.synced_folder \"/home/mutian/dev/java/github/ymu-micro-service\", \"/vagrant\", :ext4 => true #共享文件夹`\n\n第一个路径为宿主电脑文件夹，第二个为同步的虚拟机文件夹。宿主机文件夹中所有内容将实时同步到虚拟机中文件夹下。\n\n注意文件类型。在`ubuntu`下查询自己系统文件类型执行命令`df -lhT`。\n\n登录虚拟机，进入`/vagrant`,将看到：\n\n    [vagrant@ymu vagrant]$ ls\n    logs    ymu-config-repo    ymu-hystrix-dashboard  ymu-server-eureka\n    target  ymu-config-server  ymu-hystrix-turbine    ymu-service-basic\n\n看到宿舍机相关目录下的内容同步过来了。\n\n所以，这个时候，你就可以只在宿主机编辑代码，在虚拟机里面编译执行了。\n\n#### 配置网络\n\n## 为自己的box安装各种应用环境\n\n### docker安装\n\n设置自启动：`systemctl enable docker.service`\n\n参考之前blog。\n\n### 安装`nginx`\n\n- docker运行方式\n- 传统按照方式。\n\n### 安装`redis`\n\n- docker运行方式\n\nhttps://hub.docker.com/_/redis/\n\n- 传统按照方式。\n\n## 打包分发\n\n1.打包，把上面自己定制的box打包。     \n命令： \n- `vagrant package --output xxx.box`\n-  `vagrant package --output xxx.box --base 虚拟机名称`  \n\n2.分发，把打好的包通过优盘等，给其它人用。\n\n3.更新软件\n\n- 老用户\n\n- 新用户   \n用最新的打包即可。\n\n\n\n## 学习资源\n\n- http://www.imooc.com/learn/805\n- https://github.com/apanly/mooc","slug":"vagrant-start","published":1,"updated":"2018-11-09T01:20:30.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38p600cwqcrge3hsnka7","content":"<p>介绍vagrant，为公司搭建统一的开发环境。最终会输出一个统一的虚拟开发环境，然后就可以分发给团队中所有的开发人员，大家在一致的开发环境中编辑，验证代码……</p>\n<p>从此,告别“在我的机子上运行没问题的……”这个看似很有道理的扯皮了。</p>\n<p>官网网址：<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a></p>\n<h2 id=\"vagrant安装\"><a href=\"#vagrant安装\" class=\"headerlink\" title=\"vagrant安装\"></a>vagrant安装</h2><h3 id=\"安装开源虚拟机VirtualBox\"><a href=\"#安装开源虚拟机VirtualBox\" class=\"headerlink\" title=\"安装开源虚拟机VirtualBox\"></a>安装开源虚拟机VirtualBox</h3><p>注意安装版本和vagrant版本要对应，否则后面会出现各种问题。这里安装最新版本。  </p>\n<p>下载地址：<a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/wiki/Downloads</a> </p>\n<p>选择自己电脑系统对应版本。</p>\n<img src=\"/2018/01/23/vagrant-start/a.png\">\n<pre><code>axel -n 10 https://download.virtualbox.org/virtualbox/5.2.14/virtualbox-5.2_5.2.14-123301~Ubuntu~xenial_amd64.deb\n</code></pre><p>然后，执行安装命令<code>sudo dpkg -i *.deb</code>进行安装即可。</p>\n<p>安装过程中可能会缺少依赖包，把依赖包安装即可：</p>\n<img src=\"/2018/01/23/vagrant-start/b.png\">\n<p>安装依赖包：<code>mutian@mutian-ThinkPad-T440p:~/Downloads$ sudo apt install libsdl1.2debian</code></p>\n<p>重新执行安装命令：</p>\n<img src=\"/2018/01/23/vagrant-start/c.png\">\n<p>安装没有任何错误。 已安装到系统。</p>\n<img src=\"/2018/01/23/vagrant-start/d.png\">\n<h3 id=\"安装vagrant\"><a href=\"#安装vagrant\" class=\"headerlink\" title=\"安装vagrant\"></a>安装vagrant</h3><p>安装最新版本。</p>\n<p>下载地址：<a href=\"https://www.vagrantup.com/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/downloads.html</a> </p>\n<p>下载自己电脑系统对应版本。</p>\n<pre><code>axel -n 10 https://releases.hashicorp.com/vagrant/2.1.2/vagrant_2.1.2_x86_64.deb\n</code></pre><p>然后，执行安装命令<code>sudo dpkg -i vagrant_2.1.2_x86_64.deb</code>进行安装即可。</p>\n<p>查看安装是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/Downloads$ vagrant -v\nVagrant 2.1.2\n</code></pre><p>表明安装已经成功，版本<code>2.1.2</code>。</p>\n<h2 id=\"添加Box\"><a href=\"#添加Box\" class=\"headerlink\" title=\"添加Box\"></a>添加Box</h2><p>官方box源：<a href=\"https://app.vagrantup.com/boxes/search\" target=\"_blank\" rel=\"noopener\">https://app.vagrantup.com/boxes/search</a> </p>\n<p>网络不好，需要翻墙。或者通过其它途径下载想要的box。</p>\n<ul>\n<li>查看所有已下载box</li>\n</ul>\n<p><code>vagrant box list</code></p>\n<ul>\n<li>添加box</li>\n</ul>\n<p><code>vagrant box add centos/7</code></p>\n<p>执行上面命令会添加相应box到vagrant系统，如果没有，会先从box官源下载。   </p>\n<ul>\n<li>再次执行<code>vagrant box list</code>便可以看到。 </li>\n</ul>\n<h2 id=\"创造自己box\"><a href=\"#创造自己box\" class=\"headerlink\" title=\"创造自己box\"></a>创造自己box</h2><ul>\n<li>创建目录</li>\n</ul>\n<p><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ mkdir xcsqjr-dev/</code> </p>\n<ul>\n<li>初始化，创建配置文件</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ cd xcsqjr-dev/\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/xcsqjr-dev$ vagrant init centos/7\nA `Vagrantfile` has been placed in this directory. You are now\nready to `vagrant up` your first virtual environment! Please read\nthe comments in the Vagrantfile as well as documentation on\n`vagrantup.com` for more information on using Vagrant. \n</code></pre><p>会在当前目录下创建文件<code>Vagrantfile</code>。然后就可以编辑该文件，做一些配置：</p>\n<pre><code># -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n# All Vagrant configuration is done below. The &quot;2&quot; in Vagrant.configure\n# configures the configuration version (we support older styles for\n# backwards compatibility). Please don&apos;t change it unless you know what\n# you&apos;re doing.\nVagrant.configure(&quot;2&quot;) do |config|\n  # The most common configuration options are documented and commented below.\n  # For a complete reference, please see the online documentation at\n  # https://docs.vagrantup.com.\n\n  # Every Vagrant development environment requires a box. You can search for\n  # boxes at https://vagrantcloud.com/search.\n\n  # ----------- 一些相关配置 start ----------------#\n  config.vm.box = &quot;centos/7&quot; #和已经下载的box名字一致\n  config.vm.hostname = &quot;ymu&quot;  \n  #config.vm.box_version = &quot;1.1.0&quot;    \n  config.vm.box_url = &quot;http://ymu.box&quot;\n\n  # 对虚拟机的一些配置     \n  config.vm.provider &quot;virtualbox&quot; do |vb|\n  #   # Display the VirtualBox GUI when booting the machine\n  #   vb.gui = true\n  #\n  #   # Customize the amount of memory on the VM:\n      vb.memory = &quot;1024&quot; #为虚拟机分配内存\n      vb.cpus = 2 #为虚拟机分配cup，分2核心\n      vb.name = &quot;centos7_ymu&quot; #虚拟机名称\n  end\n\n  # ----------- 一些相关配置 end ----------------#\n\n  # Disable automatic box update checking. If you disable this, then\n  # boxes will only be checked for updates when the user runs\n  # `vagrant box outdated`. This is not recommended.\n  # config.vm.box_check_update = false\n\n  # Create a forwarded port mapping which allows access to a specific port\n  # within the machine from a port on the host machine. In the example below,\n  # accessing &quot;localhost:8080&quot; will access port 80 on the guest machine.\n  # NOTE: This will enable public access to the opened port\n  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080\n\n  # Create a forwarded port mapping which allows access to a specific port\n  # within the machine from a port on the host machine and only allow access\n  # via 127.0.0.1 to disable public access\n  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080, host_ip: &quot;127.0.0.1&quot;\n\n  # Create a private network, which allows host-only access to the machine\n  # using a specific IP.\n  # config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;\n\n  # Create a public network, which generally matched to bridged network.\n  # Bridged networks make the machine appear as another physical device on\n  # your network.\n  # config.vm.network &quot;public_network&quot;\n\n  # Share an additional folder to the guest VM. The first argument is\n  # the path on the host to the actual folder. The second argument is\n  # the path on the guest to mount the folder. And the optional third\n  # argument is a set of non-required options.\n  # config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;\n\n  # Provider-specific configuration so you can fine-tune various\n  # backing providers for Vagrant. These expose provider-specific options.\n  # Example for VirtualBox:\n  #\n  # config.vm.provider &quot;virtualbox&quot; do |vb|\n  #   # Display the VirtualBox GUI when booting the machine\n  #   vb.gui = true\n  #\n  #   # Customize the amount of memory on the VM:\n  #   vb.memory = &quot;1024&quot;\n  # end\n  #\n  # View the documentation for the provider you are using for more\n  # information on available options.\n\n  # Enable provisioning with a shell script. Additional provisioners such as\n  # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n  # documentation for more information about their specific syntax and use.\n  # config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL\n  #   apt-get update\n  #   apt-get install -y apache2\n  # SHELL\nend\n</code></pre><ul>\n<li>启动虚拟机</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd dev/vagrant/ymu-dev/\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Clearing any previously set forwarded ports...\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Running &apos;pre-boot&apos; VM customizations...\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n</code></pre><p> 打开virtualbox,可以看到centos7_ymu的虚拟机已经启动。</p>\n <img src=\"/2018/01/23/vagrant-start/e.png\">  \n<ul>\n<li><p>进入该虚拟机</p>\n<p><code>vagrant ssh</code></p>\n<p> mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant ssh<br> Last login: Mon Jul  9 07:40:01 2018 from 10.0.2.2<br> [vagrant@ymu ~]$ </p>\n</li>\n</ul>\n<p>下面就可以在里面，类似在真实的服务器操作系统里面一样，安装各种开发软件，配置各种开发环境了。 </p>\n<ul>\n<li><p>登出虚拟机</p>\n<pre><code>[vagrant@ymu ~]$ logout\nConnection to 127.0.0.1 closed.\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ \n</code></pre></li>\n<li><p>停止运行虚拟机</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant halt\n==&gt; default: Attempting graceful shutdown of VM...\n</code></pre></li>\n<li><p>挂起虚拟机</p>\n</li>\n</ul>\n<p><code>vagrant shutdown</code></p>\n<ul>\n<li>重新加载配置启动</li>\n</ul>\n<p><code>vagrant reload</code></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><pre><code>config.vm.box = &quot;centos/7&quot; #和已经下载的box名字一致\nconfig.vm.hostname = &quot;ymu&quot;  \n#config.vm.box_version = &quot;1.1.0&quot;    \nconfig.vm.box_url = &quot;http://ymu.box&quot;\nconfig.vm.synced_folder &quot;/home/mutian/dev/java/github/ymu-micro-service&quot;, &quot;/vagrant&quot;, :ext4 =&gt; true #共享文件夹\n</code></pre><h4 id=\"配置共享文件\"><a href=\"#配置共享文件\" class=\"headerlink\" title=\"配置共享文件\"></a>配置共享文件</h4><p>注：如果不配置共享目录，默认会把<code>Vagrantfile</code>文件所在的目录同步到虚拟机中的<code>、vagrant</code>目录下。</p>\n<p><code>config.vm.synced_folder &quot;/home/mutian/dev/java/github/ymu-micro-service&quot;, &quot;/vagrant&quot;, :ext4 =&gt; true #共享文件夹</code></p>\n<p>第一个路径为宿主电脑文件夹，第二个为同步的虚拟机文件夹。宿主机文件夹中所有内容将实时同步到虚拟机中文件夹下。</p>\n<p>注意文件类型。在<code>ubuntu</code>下查询自己系统文件类型执行命令<code>df -lhT</code>。</p>\n<p>登录虚拟机，进入<code>/vagrant</code>,将看到：</p>\n<pre><code>[vagrant@ymu vagrant]$ ls\nlogs    ymu-config-repo    ymu-hystrix-dashboard  ymu-server-eureka\ntarget  ymu-config-server  ymu-hystrix-turbine    ymu-service-basic\n</code></pre><p>看到宿舍机相关目录下的内容同步过来了。</p>\n<p>所以，这个时候，你就可以只在宿主机编辑代码，在虚拟机里面编译执行了。</p>\n<h4 id=\"配置网络\"><a href=\"#配置网络\" class=\"headerlink\" title=\"配置网络\"></a>配置网络</h4><h2 id=\"为自己的box安装各种应用环境\"><a href=\"#为自己的box安装各种应用环境\" class=\"headerlink\" title=\"为自己的box安装各种应用环境\"></a>为自己的box安装各种应用环境</h2><h3 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h3><p>设置自启动：<code>systemctl enable docker.service</code></p>\n<p>参考之前blog。</p>\n<h3 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装<code>nginx</code></h3><ul>\n<li>docker运行方式</li>\n<li>传统按照方式。</li>\n</ul>\n<h3 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装<code>redis</code></h3><ul>\n<li>docker运行方式</li>\n</ul>\n<p><a href=\"https://hub.docker.com/_/redis/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/redis/</a></p>\n<ul>\n<li>传统按照方式。</li>\n</ul>\n<h2 id=\"打包分发\"><a href=\"#打包分发\" class=\"headerlink\" title=\"打包分发\"></a>打包分发</h2><p>1.打包，把上面自己定制的box打包。<br>命令： </p>\n<ul>\n<li><code>vagrant package --output xxx.box</code></li>\n<li><code>vagrant package --output xxx.box --base 虚拟机名称</code>  </li>\n</ul>\n<p>2.分发，把打好的包通过优盘等，给其它人用。</p>\n<p>3.更新软件</p>\n<ul>\n<li><p>老用户</p>\n</li>\n<li><p>新用户<br>用最新的打包即可。</p>\n</li>\n</ul>\n<h2 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h2><ul>\n<li><a href=\"http://www.imooc.com/learn/805\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/learn/805</a></li>\n<li><a href=\"https://github.com/apanly/mooc\" target=\"_blank\" rel=\"noopener\">https://github.com/apanly/mooc</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍vagrant，为公司搭建统一的开发环境。最终会输出一个统一的虚拟开发环境，然后就可以分发给团队中所有的开发人员，大家在一致的开发环境中编辑，验证代码……</p>\n<p>从此,告别“在我的机子上运行没问题的……”这个看似很有道理的扯皮了。</p>\n<p>官网网址：<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a></p>\n<h2 id=\"vagrant安装\"><a href=\"#vagrant安装\" class=\"headerlink\" title=\"vagrant安装\"></a>vagrant安装</h2><h3 id=\"安装开源虚拟机VirtualBox\"><a href=\"#安装开源虚拟机VirtualBox\" class=\"headerlink\" title=\"安装开源虚拟机VirtualBox\"></a>安装开源虚拟机VirtualBox</h3><p>注意安装版本和vagrant版本要对应，否则后面会出现各种问题。这里安装最新版本。  </p>\n<p>下载地址：<a href=\"https://www.virtualbox.org/wiki/Downloads\" target=\"_blank\" rel=\"noopener\">https://www.virtualbox.org/wiki/Downloads</a> </p>\n<p>选择自己电脑系统对应版本。</p>\n<img src=\"/2018/01/23/vagrant-start/a.png\">\n<pre><code>axel -n 10 https://download.virtualbox.org/virtualbox/5.2.14/virtualbox-5.2_5.2.14-123301~Ubuntu~xenial_amd64.deb\n</code></pre><p>然后，执行安装命令<code>sudo dpkg -i *.deb</code>进行安装即可。</p>\n<p>安装过程中可能会缺少依赖包，把依赖包安装即可：</p>\n<img src=\"/2018/01/23/vagrant-start/b.png\">\n<p>安装依赖包：<code>mutian@mutian-ThinkPad-T440p:~/Downloads$ sudo apt install libsdl1.2debian</code></p>\n<p>重新执行安装命令：</p>\n<img src=\"/2018/01/23/vagrant-start/c.png\">\n<p>安装没有任何错误。 已安装到系统。</p>\n<img src=\"/2018/01/23/vagrant-start/d.png\">\n<h3 id=\"安装vagrant\"><a href=\"#安装vagrant\" class=\"headerlink\" title=\"安装vagrant\"></a>安装vagrant</h3><p>安装最新版本。</p>\n<p>下载地址：<a href=\"https://www.vagrantup.com/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/downloads.html</a> </p>\n<p>下载自己电脑系统对应版本。</p>\n<pre><code>axel -n 10 https://releases.hashicorp.com/vagrant/2.1.2/vagrant_2.1.2_x86_64.deb\n</code></pre><p>然后，执行安装命令<code>sudo dpkg -i vagrant_2.1.2_x86_64.deb</code>进行安装即可。</p>\n<p>查看安装是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/Downloads$ vagrant -v\nVagrant 2.1.2\n</code></pre><p>表明安装已经成功，版本<code>2.1.2</code>。</p>\n<h2 id=\"添加Box\"><a href=\"#添加Box\" class=\"headerlink\" title=\"添加Box\"></a>添加Box</h2><p>官方box源：<a href=\"https://app.vagrantup.com/boxes/search\" target=\"_blank\" rel=\"noopener\">https://app.vagrantup.com/boxes/search</a> </p>\n<p>网络不好，需要翻墙。或者通过其它途径下载想要的box。</p>\n<ul>\n<li>查看所有已下载box</li>\n</ul>\n<p><code>vagrant box list</code></p>\n<ul>\n<li>添加box</li>\n</ul>\n<p><code>vagrant box add centos/7</code></p>\n<p>执行上面命令会添加相应box到vagrant系统，如果没有，会先从box官源下载。   </p>\n<ul>\n<li>再次执行<code>vagrant box list</code>便可以看到。 </li>\n</ul>\n<h2 id=\"创造自己box\"><a href=\"#创造自己box\" class=\"headerlink\" title=\"创造自己box\"></a>创造自己box</h2><ul>\n<li>创建目录</li>\n</ul>\n<p><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ mkdir xcsqjr-dev/</code> </p>\n<ul>\n<li>初始化，创建配置文件</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant$ cd xcsqjr-dev/\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/xcsqjr-dev$ vagrant init centos/7\nA `Vagrantfile` has been placed in this directory. You are now\nready to `vagrant up` your first virtual environment! Please read\nthe comments in the Vagrantfile as well as documentation on\n`vagrantup.com` for more information on using Vagrant. \n</code></pre><p>会在当前目录下创建文件<code>Vagrantfile</code>。然后就可以编辑该文件，做一些配置：</p>\n<pre><code># -*- mode: ruby -*-\n# vi: set ft=ruby :\n\n# All Vagrant configuration is done below. The &quot;2&quot; in Vagrant.configure\n# configures the configuration version (we support older styles for\n# backwards compatibility). Please don&apos;t change it unless you know what\n# you&apos;re doing.\nVagrant.configure(&quot;2&quot;) do |config|\n  # The most common configuration options are documented and commented below.\n  # For a complete reference, please see the online documentation at\n  # https://docs.vagrantup.com.\n\n  # Every Vagrant development environment requires a box. You can search for\n  # boxes at https://vagrantcloud.com/search.\n\n  # ----------- 一些相关配置 start ----------------#\n  config.vm.box = &quot;centos/7&quot; #和已经下载的box名字一致\n  config.vm.hostname = &quot;ymu&quot;  \n  #config.vm.box_version = &quot;1.1.0&quot;    \n  config.vm.box_url = &quot;http://ymu.box&quot;\n\n  # 对虚拟机的一些配置     \n  config.vm.provider &quot;virtualbox&quot; do |vb|\n  #   # Display the VirtualBox GUI when booting the machine\n  #   vb.gui = true\n  #\n  #   # Customize the amount of memory on the VM:\n      vb.memory = &quot;1024&quot; #为虚拟机分配内存\n      vb.cpus = 2 #为虚拟机分配cup，分2核心\n      vb.name = &quot;centos7_ymu&quot; #虚拟机名称\n  end\n\n  # ----------- 一些相关配置 end ----------------#\n\n  # Disable automatic box update checking. If you disable this, then\n  # boxes will only be checked for updates when the user runs\n  # `vagrant box outdated`. This is not recommended.\n  # config.vm.box_check_update = false\n\n  # Create a forwarded port mapping which allows access to a specific port\n  # within the machine from a port on the host machine. In the example below,\n  # accessing &quot;localhost:8080&quot; will access port 80 on the guest machine.\n  # NOTE: This will enable public access to the opened port\n  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080\n\n  # Create a forwarded port mapping which allows access to a specific port\n  # within the machine from a port on the host machine and only allow access\n  # via 127.0.0.1 to disable public access\n  # config.vm.network &quot;forwarded_port&quot;, guest: 80, host: 8080, host_ip: &quot;127.0.0.1&quot;\n\n  # Create a private network, which allows host-only access to the machine\n  # using a specific IP.\n  # config.vm.network &quot;private_network&quot;, ip: &quot;192.168.33.10&quot;\n\n  # Create a public network, which generally matched to bridged network.\n  # Bridged networks make the machine appear as another physical device on\n  # your network.\n  # config.vm.network &quot;public_network&quot;\n\n  # Share an additional folder to the guest VM. The first argument is\n  # the path on the host to the actual folder. The second argument is\n  # the path on the guest to mount the folder. And the optional third\n  # argument is a set of non-required options.\n  # config.vm.synced_folder &quot;../data&quot;, &quot;/vagrant_data&quot;\n\n  # Provider-specific configuration so you can fine-tune various\n  # backing providers for Vagrant. These expose provider-specific options.\n  # Example for VirtualBox:\n  #\n  # config.vm.provider &quot;virtualbox&quot; do |vb|\n  #   # Display the VirtualBox GUI when booting the machine\n  #   vb.gui = true\n  #\n  #   # Customize the amount of memory on the VM:\n  #   vb.memory = &quot;1024&quot;\n  # end\n  #\n  # View the documentation for the provider you are using for more\n  # information on available options.\n\n  # Enable provisioning with a shell script. Additional provisioners such as\n  # Puppet, Chef, Ansible, Salt, and Docker are also available. Please see the\n  # documentation for more information about their specific syntax and use.\n  # config.vm.provision &quot;shell&quot;, inline: &lt;&lt;-SHELL\n  #   apt-get update\n  #   apt-get install -y apache2\n  # SHELL\nend\n</code></pre><ul>\n<li>启动虚拟机</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd dev/vagrant/ymu-dev/\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant up\nBringing machine &apos;default&apos; up with &apos;virtualbox&apos; provider...\n==&gt; default: Checking if box &apos;centos/7&apos; is up to date...\n==&gt; default: Clearing any previously set forwarded ports...\n==&gt; default: Clearing any previously set network interfaces...\n==&gt; default: Preparing network interfaces based on configuration...\n    default: Adapter 1: nat\n==&gt; default: Forwarding ports...\n    default: 22 (guest) =&gt; 2222 (host) (adapter 1)\n==&gt; default: Running &apos;pre-boot&apos; VM customizations...\n==&gt; default: Booting VM...\n==&gt; default: Waiting for machine to boot. This may take a few minutes...\n    default: SSH address: 127.0.0.1:2222\n    default: SSH username: vagrant\n    default: SSH auth method: private key\n</code></pre><p> 打开virtualbox,可以看到centos7_ymu的虚拟机已经启动。</p>\n <img src=\"/2018/01/23/vagrant-start/e.png\">  \n<ul>\n<li><p>进入该虚拟机</p>\n<p><code>vagrant ssh</code></p>\n<p> mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant ssh<br> Last login: Mon Jul  9 07:40:01 2018 from 10.0.2.2<br> [vagrant@ymu ~]$ </p>\n</li>\n</ul>\n<p>下面就可以在里面，类似在真实的服务器操作系统里面一样，安装各种开发软件，配置各种开发环境了。 </p>\n<ul>\n<li><p>登出虚拟机</p>\n<pre><code>[vagrant@ymu ~]$ logout\nConnection to 127.0.0.1 closed.\nmutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ \n</code></pre></li>\n<li><p>停止运行虚拟机</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/dev/vagrant/ymu-dev$ vagrant halt\n==&gt; default: Attempting graceful shutdown of VM...\n</code></pre></li>\n<li><p>挂起虚拟机</p>\n</li>\n</ul>\n<p><code>vagrant shutdown</code></p>\n<ul>\n<li>重新加载配置启动</li>\n</ul>\n<p><code>vagrant reload</code></p>\n<h3 id=\"配置\"><a href=\"#配置\" class=\"headerlink\" title=\"配置\"></a>配置</h3><pre><code>config.vm.box = &quot;centos/7&quot; #和已经下载的box名字一致\nconfig.vm.hostname = &quot;ymu&quot;  \n#config.vm.box_version = &quot;1.1.0&quot;    \nconfig.vm.box_url = &quot;http://ymu.box&quot;\nconfig.vm.synced_folder &quot;/home/mutian/dev/java/github/ymu-micro-service&quot;, &quot;/vagrant&quot;, :ext4 =&gt; true #共享文件夹\n</code></pre><h4 id=\"配置共享文件\"><a href=\"#配置共享文件\" class=\"headerlink\" title=\"配置共享文件\"></a>配置共享文件</h4><p>注：如果不配置共享目录，默认会把<code>Vagrantfile</code>文件所在的目录同步到虚拟机中的<code>、vagrant</code>目录下。</p>\n<p><code>config.vm.synced_folder &quot;/home/mutian/dev/java/github/ymu-micro-service&quot;, &quot;/vagrant&quot;, :ext4 =&gt; true #共享文件夹</code></p>\n<p>第一个路径为宿主电脑文件夹，第二个为同步的虚拟机文件夹。宿主机文件夹中所有内容将实时同步到虚拟机中文件夹下。</p>\n<p>注意文件类型。在<code>ubuntu</code>下查询自己系统文件类型执行命令<code>df -lhT</code>。</p>\n<p>登录虚拟机，进入<code>/vagrant</code>,将看到：</p>\n<pre><code>[vagrant@ymu vagrant]$ ls\nlogs    ymu-config-repo    ymu-hystrix-dashboard  ymu-server-eureka\ntarget  ymu-config-server  ymu-hystrix-turbine    ymu-service-basic\n</code></pre><p>看到宿舍机相关目录下的内容同步过来了。</p>\n<p>所以，这个时候，你就可以只在宿主机编辑代码，在虚拟机里面编译执行了。</p>\n<h4 id=\"配置网络\"><a href=\"#配置网络\" class=\"headerlink\" title=\"配置网络\"></a>配置网络</h4><h2 id=\"为自己的box安装各种应用环境\"><a href=\"#为自己的box安装各种应用环境\" class=\"headerlink\" title=\"为自己的box安装各种应用环境\"></a>为自己的box安装各种应用环境</h2><h3 id=\"docker安装\"><a href=\"#docker安装\" class=\"headerlink\" title=\"docker安装\"></a>docker安装</h3><p>设置自启动：<code>systemctl enable docker.service</code></p>\n<p>参考之前blog。</p>\n<h3 id=\"安装nginx\"><a href=\"#安装nginx\" class=\"headerlink\" title=\"安装nginx\"></a>安装<code>nginx</code></h3><ul>\n<li>docker运行方式</li>\n<li>传统按照方式。</li>\n</ul>\n<h3 id=\"安装redis\"><a href=\"#安装redis\" class=\"headerlink\" title=\"安装redis\"></a>安装<code>redis</code></h3><ul>\n<li>docker运行方式</li>\n</ul>\n<p><a href=\"https://hub.docker.com/_/redis/\" target=\"_blank\" rel=\"noopener\">https://hub.docker.com/_/redis/</a></p>\n<ul>\n<li>传统按照方式。</li>\n</ul>\n<h2 id=\"打包分发\"><a href=\"#打包分发\" class=\"headerlink\" title=\"打包分发\"></a>打包分发</h2><p>1.打包，把上面自己定制的box打包。<br>命令： </p>\n<ul>\n<li><code>vagrant package --output xxx.box</code></li>\n<li><code>vagrant package --output xxx.box --base 虚拟机名称</code>  </li>\n</ul>\n<p>2.分发，把打好的包通过优盘等，给其它人用。</p>\n<p>3.更新软件</p>\n<ul>\n<li><p>老用户</p>\n</li>\n<li><p>新用户<br>用最新的打包即可。</p>\n</li>\n</ul>\n<h2 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h2><ul>\n<li><a href=\"http://www.imooc.com/learn/805\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/learn/805</a></li>\n<li><a href=\"https://github.com/apanly/mooc\" target=\"_blank\" rel=\"noopener\">https://github.com/apanly/mooc</a></li>\n</ul>\n"},{"title":"Vault学习","date":"2018-03-09T02:11:17.000Z","_content":"\nValut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……\n\n特性：\n\n1.安全的私密信息存储 \n\n2.动态的私密信息支持\n\n3.提供对于私密信息的更新，延长有效时间的功能\n\n4.灵活的权限控制\n\n5.多种客户端登录验证方式\n\n参考：\nhttps://www.vaultproject.io/intro/index.html\n\n## 安装Valut\n\n1.下载地址：https://www.vaultproject.io/downloads.html\n\n2.解压\n解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。\n\n配置环境变量，把vault可执行文件所在目录添加到环境变量：\n\n`export PATH=$PATH:/home/mutian/dev/bin`\n\n检验是否成功：\n    \n    mutian@mutian-ThinkPad-T440p:~$ vault \n    Usage: vault <command> [args]\n    \n    Common commands:\n        read        Read data and retrieves secrets\n        write       Write data, configuration, and secrets\n        delete      Delete secrets and configuration\n        list        List data or secrets\n        login       Authenticate locally\n        server      Start a Vault server\n        status      Print seal and HA status\n        unwrap      Unwrap a wrapped secret\n    \n    Other commands:\n        audit          Interact with audit devices\n        auth           Interact with auth methods\n        lease          Interact with leases\n        operator       Perform operator-specific tasks\n        path-help      Retrieve API help for paths\n        policy         Interact with policies\n        secrets        Interact with secrets engines\n        ssh            Initiate an SSH session\n        token          Interact with tokens\n\n表示环境变量添加准确，已经安装成功。\n\n\n3.install completions\n\n    $ vault -autocomplete-install\n    \n然后重新启动shell窗口，输入命令`vault`，然后按Tab键，将出现命令参数提示。如下：    \n\n    mutian@mutian-ThinkPad-T440p:~$ vault \n    audit      lease      operator   read       ssh        unwrap     \n    auth       list       path-help  secrets    status     write      \n    delete     login      policy     server     token      \n    mutian@mutian-ThinkPad-T440p:~$ vault \n\n##　启动服务\n\n#### 启动开发环境\n\n开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n    ==> Vault server configuration:\n    \n                         Cgo: disabled\n             Cluster Address: https://127.0.0.1:8201\n                  Listener 1: tcp (addr: \"127.0.0.1:8200\", cluster address: \"127.0.0.1:8201\", tls: \"disabled\")\n                   Log Level: info\n                       Mlock: supported: true, enabled: false\n            Redirect Address: http://127.0.0.1:8200\n                     Storage: inmem\n                     Version: Vault v0.9.5\n                 Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n    \n    WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\n    and starts unsealed with a single unseal key. The root token is already\n    authenticated to the CLI, so you can immediately begin using Vault.\n    \n    You may need to set the following environment variable:\n    \n        $ export VAULT_ADDR='http://127.0.0.1:8200'\n    \n    The unseal key and root token are displayed below in case you want to\n    seal/unseal the Vault or re-authenticate.\n    \n    Unseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\n    Root Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n    \n    Development mode should NOT be used in production installations!\n    \n    ==> Vault server started! Log data will stream in below:\n\n看到上面内容说明已经启动成功，在前台运行的。\n\n验证服务是否在成功运行：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status \n    Error checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\n    mutian@mutian-ThinkPad-T440p:~$ \n\n看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：\n\n     export VAULT_ADDR=http://127.0.0.1:8200\n     \n再次查看vault服务运行状态:\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status\n    Key             Value\n    ---             -----\n    Seal Type       shamir\n    Sealed          false\n    Total Shares    1\n    Threshold       1\n    Version         0.9.5\n    Cluster Name    vault-cluster-bcf3f2f8\n    Cluster ID      c2649684-fe35-3820-983b-f324a51b115c\n    HA Enabled      false\n         \n看到了上面的内容，则证明服务启动成功。\n\n为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效， \n命令：\n\n| 功能      | 命令    |  说明  |\n| --------   | -----   | :---- |\n| 设置vault访问地址       | export VAULT_ADDR=http://127.0.0.1:8200     |   vault命令作用的vault服务的地址    |\n| 设置Vault PATH        | export PATH=$PATH:< vault install path >      |   vault install path：vault安装路径    |\n| 设置访问token        | \texport VAULT_TOKEN=< token >      |   token：登录vault时的token，首次登录可使用root token    |\n| 设置是否跳过核查        | \texport VAULT_SKIP_VERIFY=false      |    使用TSL访问时需要设置，未使用证书忽略此项    |\n| 设置访问证书        | \texport VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem      |   使用TSL访问时需要设置，未使用证书忽略此项    |\n\n     \n- 保存私密信息\n\n下面是简单的写入信息命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\n    Success! Data written to: secret/hello\n\n这会把键值对信息写入到路劲`secret/hello`中。　键为value,值为world。\n\n也可以一次性写入多个键值保存：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n\n- 读取私密信息\n    \n显示该路径下所有保存键值对：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \n    Key                 Value\n    ---                 -----\n    refresh_interval    768h\n    excited             yes\n    value               world    \n\n获取单个的值：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\n    world\n\n- 删除路径下键值\n\n删除所有：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \n    Success! Data deleted (if it existed) at: secret/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\n    No value found at secret/hello\n\n看上面命令，说明已经把保存到路径`secret/hello`下的键值信息全部删除。\n\n## 秘密引擎\n\n上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径`secret/hello`下面，这个是默认的。当你试图保存到其他路径下时候，将报错。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\n    Error writing data to home/mutian/dev: Error making API request.\n    \n    URL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\n    Code: 404. Errors:\n    \n    * no handler for route 'home/mutian/dev'\n\n默认下，在路劲`secret/.`Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    \n\n- 开启一个新的kv私密引擎\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv\n    Success! Enabled the kv secrets engine at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    abs/          kv           n/a\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n\n通过命令`vault secrets list`可以看到，第一个就是就是我们刚才开启的新私密引擎。\n\n往该新建私密引擎保存私密信息：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\n    Success! Data written to: abs/my-secret\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\n    Success! Data written to: abs/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\n    Success! Data written to: abs/airplane\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n查看该私密引擎下所有key\n\n    mutian@mutian-ThinkPad-T440p:~$ vault list abs\n    Keys\n    ----\n    airplane\n    hello\n    my-secret\n\n- 关闭私密引擎\n\n当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　\n当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\n    Success! Disabled the secrets engine (if it existed) at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n    \n上面结果中，已经再看不到私密引擎`abs/`\n\n- 什么是私密引擎（Secrets Engine）\n\n上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？\n\n实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　\n这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　\n\n\n## 动态私密信息保存\n\n\n\n    \n","source":"_posts/vault-study.md","raw":"---\ntitle: Vault学习\ndate: 2018-03-09 10:11:17\ncategories: 密码\ntags: vault\n---\n\nValut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……\n\n特性：\n\n1.安全的私密信息存储 \n\n2.动态的私密信息支持\n\n3.提供对于私密信息的更新，延长有效时间的功能\n\n4.灵活的权限控制\n\n5.多种客户端登录验证方式\n\n参考：\nhttps://www.vaultproject.io/intro/index.html\n\n## 安装Valut\n\n1.下载地址：https://www.vaultproject.io/downloads.html\n\n2.解压\n解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。\n\n配置环境变量，把vault可执行文件所在目录添加到环境变量：\n\n`export PATH=$PATH:/home/mutian/dev/bin`\n\n检验是否成功：\n    \n    mutian@mutian-ThinkPad-T440p:~$ vault \n    Usage: vault <command> [args]\n    \n    Common commands:\n        read        Read data and retrieves secrets\n        write       Write data, configuration, and secrets\n        delete      Delete secrets and configuration\n        list        List data or secrets\n        login       Authenticate locally\n        server      Start a Vault server\n        status      Print seal and HA status\n        unwrap      Unwrap a wrapped secret\n    \n    Other commands:\n        audit          Interact with audit devices\n        auth           Interact with auth methods\n        lease          Interact with leases\n        operator       Perform operator-specific tasks\n        path-help      Retrieve API help for paths\n        policy         Interact with policies\n        secrets        Interact with secrets engines\n        ssh            Initiate an SSH session\n        token          Interact with tokens\n\n表示环境变量添加准确，已经安装成功。\n\n\n3.install completions\n\n    $ vault -autocomplete-install\n    \n然后重新启动shell窗口，输入命令`vault`，然后按Tab键，将出现命令参数提示。如下：    \n\n    mutian@mutian-ThinkPad-T440p:~$ vault \n    audit      lease      operator   read       ssh        unwrap     \n    auth       list       path-help  secrets    status     write      \n    delete     login      policy     server     token      \n    mutian@mutian-ThinkPad-T440p:~$ vault \n\n##　启动服务\n\n#### 启动开发环境\n\n开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n    ==> Vault server configuration:\n    \n                         Cgo: disabled\n             Cluster Address: https://127.0.0.1:8201\n                  Listener 1: tcp (addr: \"127.0.0.1:8200\", cluster address: \"127.0.0.1:8201\", tls: \"disabled\")\n                   Log Level: info\n                       Mlock: supported: true, enabled: false\n            Redirect Address: http://127.0.0.1:8200\n                     Storage: inmem\n                     Version: Vault v0.9.5\n                 Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n    \n    WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\n    and starts unsealed with a single unseal key. The root token is already\n    authenticated to the CLI, so you can immediately begin using Vault.\n    \n    You may need to set the following environment variable:\n    \n        $ export VAULT_ADDR='http://127.0.0.1:8200'\n    \n    The unseal key and root token are displayed below in case you want to\n    seal/unseal the Vault or re-authenticate.\n    \n    Unseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\n    Root Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n    \n    Development mode should NOT be used in production installations!\n    \n    ==> Vault server started! Log data will stream in below:\n\n看到上面内容说明已经启动成功，在前台运行的。\n\n验证服务是否在成功运行：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status \n    Error checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\n    mutian@mutian-ThinkPad-T440p:~$ \n\n看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：\n\n     export VAULT_ADDR=http://127.0.0.1:8200\n     \n再次查看vault服务运行状态:\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status\n    Key             Value\n    ---             -----\n    Seal Type       shamir\n    Sealed          false\n    Total Shares    1\n    Threshold       1\n    Version         0.9.5\n    Cluster Name    vault-cluster-bcf3f2f8\n    Cluster ID      c2649684-fe35-3820-983b-f324a51b115c\n    HA Enabled      false\n         \n看到了上面的内容，则证明服务启动成功。\n\n为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效， \n命令：\n\n| 功能      | 命令    |  说明  |\n| --------   | -----   | :---- |\n| 设置vault访问地址       | export VAULT_ADDR=http://127.0.0.1:8200     |   vault命令作用的vault服务的地址    |\n| 设置Vault PATH        | export PATH=$PATH:< vault install path >      |   vault install path：vault安装路径    |\n| 设置访问token        | \texport VAULT_TOKEN=< token >      |   token：登录vault时的token，首次登录可使用root token    |\n| 设置是否跳过核查        | \texport VAULT_SKIP_VERIFY=false      |    使用TSL访问时需要设置，未使用证书忽略此项    |\n| 设置访问证书        | \texport VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem      |   使用TSL访问时需要设置，未使用证书忽略此项    |\n\n     \n- 保存私密信息\n\n下面是简单的写入信息命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\n    Success! Data written to: secret/hello\n\n这会把键值对信息写入到路劲`secret/hello`中。　键为value,值为world。\n\n也可以一次性写入多个键值保存：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n\n- 读取私密信息\n    \n显示该路径下所有保存键值对：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \n    Key                 Value\n    ---                 -----\n    refresh_interval    768h\n    excited             yes\n    value               world    \n\n获取单个的值：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\n    world\n\n- 删除路径下键值\n\n删除所有：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \n    Success! Data deleted (if it existed) at: secret/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\n    No value found at secret/hello\n\n看上面命令，说明已经把保存到路径`secret/hello`下的键值信息全部删除。\n\n## 秘密引擎\n\n上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径`secret/hello`下面，这个是默认的。当你试图保存到其他路径下时候，将报错。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\n    Error writing data to home/mutian/dev: Error making API request.\n    \n    URL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\n    Code: 404. Errors:\n    \n    * no handler for route 'home/mutian/dev'\n\n默认下，在路劲`secret/.`Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    \n\n- 开启一个新的kv私密引擎\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv\n    Success! Enabled the kv secrets engine at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    abs/          kv           n/a\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n\n通过命令`vault secrets list`可以看到，第一个就是就是我们刚才开启的新私密引擎。\n\n往该新建私密引擎保存私密信息：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\n    Success! Data written to: abs/my-secret\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\n    Success! Data written to: abs/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\n    Success! Data written to: abs/airplane\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n查看该私密引擎下所有key\n\n    mutian@mutian-ThinkPad-T440p:~$ vault list abs\n    Keys\n    ----\n    airplane\n    hello\n    my-secret\n\n- 关闭私密引擎\n\n当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　\n当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\n    Success! Disabled the secrets engine (if it existed) at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n    \n上面结果中，已经再看不到私密引擎`abs/`\n\n- 什么是私密引擎（Secrets Engine）\n\n上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？\n\n实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　\n这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　\n\n\n## 动态私密信息保存\n\n\n\n    \n","slug":"vault-study","published":1,"updated":"2018-11-09T01:20:30.951Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38p700cyqcrgvpmruzrh","content":"<p>Valut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……</p>\n<p>特性：</p>\n<p>1.安全的私密信息存储 </p>\n<p>2.动态的私密信息支持</p>\n<p>3.提供对于私密信息的更新，延长有效时间的功能</p>\n<p>4.灵活的权限控制</p>\n<p>5.多种客户端登录验证方式</p>\n<p>参考：<br><a href=\"https://www.vaultproject.io/intro/index.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/intro/index.html</a></p>\n<h2 id=\"安装Valut\"><a href=\"#安装Valut\" class=\"headerlink\" title=\"安装Valut\"></a>安装Valut</h2><p>1.下载地址：<a href=\"https://www.vaultproject.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/downloads.html</a></p>\n<p>2.解压<br>解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。</p>\n<p>配置环境变量，把vault可执行文件所在目录添加到环境变量：</p>\n<p><code>export PATH=$PATH:/home/mutian/dev/bin</code></p>\n<p>检验是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \nUsage: vault &lt;command&gt; [args]\n\nCommon commands:\n    read        Read data and retrieves secrets\n    write       Write data, configuration, and secrets\n    delete      Delete secrets and configuration\n    list        List data or secrets\n    login       Authenticate locally\n    server      Start a Vault server\n    status      Print seal and HA status\n    unwrap      Unwrap a wrapped secret\n\nOther commands:\n    audit          Interact with audit devices\n    auth           Interact with auth methods\n    lease          Interact with leases\n    operator       Perform operator-specific tasks\n    path-help      Retrieve API help for paths\n    policy         Interact with policies\n    secrets        Interact with secrets engines\n    ssh            Initiate an SSH session\n    token          Interact with tokens\n</code></pre><p>表示环境变量添加准确，已经安装成功。</p>\n<p>3.install completions</p>\n<pre><code>$ vault -autocomplete-install\n</code></pre><p>然后重新启动shell窗口，输入命令<code>vault</code>，然后按Tab键，将出现命令参数提示。如下：    </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \naudit      lease      operator   read       ssh        unwrap     \nauth       list       path-help  secrets    status     write      \ndelete     login      policy     server     token      \nmutian@mutian-ThinkPad-T440p:~$ vault \n</code></pre><p>##　启动服务</p>\n<h4 id=\"启动开发环境\"><a href=\"#启动开发环境\" class=\"headerlink\" title=\"启动开发环境\"></a>启动开发环境</h4><p>开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n==&gt; Vault server configuration:\n\n                     Cgo: disabled\n         Cluster Address: https://127.0.0.1:8201\n              Listener 1: tcp (addr: &quot;127.0.0.1:8200&quot;, cluster address: &quot;127.0.0.1:8201&quot;, tls: &quot;disabled&quot;)\n               Log Level: info\n                   Mlock: supported: true, enabled: false\n        Redirect Address: http://127.0.0.1:8200\n                 Storage: inmem\n                 Version: Vault v0.9.5\n             Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\nand starts unsealed with a single unseal key. The root token is already\nauthenticated to the CLI, so you can immediately begin using Vault.\n\nYou may need to set the following environment variable:\n\n    $ export VAULT_ADDR=&apos;http://127.0.0.1:8200&apos;\n\nThe unseal key and root token are displayed below in case you want to\nseal/unseal the Vault or re-authenticate.\n\nUnseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\nRoot Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n\nDevelopment mode should NOT be used in production installations!\n\n==&gt; Vault server started! Log data will stream in below:\n</code></pre><p>看到上面内容说明已经启动成功，在前台运行的。</p>\n<p>验证服务是否在成功运行：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status \nError checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：</p>\n<pre><code>export VAULT_ADDR=http://127.0.0.1:8200\n</code></pre><p>再次查看vault服务运行状态:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status\nKey             Value\n---             -----\nSeal Type       shamir\nSealed          false\nTotal Shares    1\nThreshold       1\nVersion         0.9.5\nCluster Name    vault-cluster-bcf3f2f8\nCluster ID      c2649684-fe35-3820-983b-f324a51b115c\nHA Enabled      false\n</code></pre><p>看到了上面的内容，则证明服务启动成功。</p>\n<p>为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效，<br>命令：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置vault访问地址</td>\n<td>export VAULT_ADDR=<a href=\"http://127.0.0.1:8200\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8200</a></td>\n<td style=\"text-align:left\">vault命令作用的vault服务的地址</td>\n</tr>\n<tr>\n<td>设置Vault PATH</td>\n<td>export PATH=$PATH:&lt; vault install path &gt;</td>\n<td style=\"text-align:left\">vault install path：vault安装路径</td>\n</tr>\n<tr>\n<td>设置访问token</td>\n<td>export VAULT_TOKEN=&lt; token &gt;</td>\n<td style=\"text-align:left\">token：登录vault时的token，首次登录可使用root token</td>\n</tr>\n<tr>\n<td>设置是否跳过核查</td>\n<td>export VAULT_SKIP_VERIFY=false</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n<tr>\n<td>设置访问证书</td>\n<td>export VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>保存私密信息</li>\n</ul>\n<p>下面是简单的写入信息命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\nSuccess! Data written to: secret/hello\n</code></pre><p>这会把键值对信息写入到路劲<code>secret/hello</code>中。　键为value,值为world。</p>\n<p>也可以一次性写入多个键值保存：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n</code></pre><ul>\n<li>读取私密信息</li>\n</ul>\n<p>显示该路径下所有保存键值对：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \nKey                 Value\n---                 -----\nrefresh_interval    768h\nexcited             yes\nvalue               world    \n</code></pre><p>获取单个的值：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\nworld\n</code></pre><ul>\n<li>删除路径下键值</li>\n</ul>\n<p>删除所有：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \nSuccess! Data deleted (if it existed) at: secret/hello\nmutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\nNo value found at secret/hello\n</code></pre><p>看上面命令，说明已经把保存到路径<code>secret/hello</code>下的键值信息全部删除。</p>\n<h2 id=\"秘密引擎\"><a href=\"#秘密引擎\" class=\"headerlink\" title=\"秘密引擎\"></a>秘密引擎</h2><p>上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径<code>secret/hello</code>下面，这个是默认的。当你试图保存到其他路径下时候，将报错。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\nError writing data to home/mutian/dev: Error making API request.\n\nURL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\nCode: 404. Errors:\n\n* no handler for route &apos;home/mutian/dev&apos;\n</code></pre><p>默认下，在路劲<code>secret/.</code>Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    </p>\n<ul>\n<li><p>开启一个新的kv私密引擎</p>\n<p>  mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv<br>  Success! Enabled the kv secrets engine at: abs/<br>  mutian@mutian-ThinkPad-T440p:~$ vault secrets list<br>  Path          Type         Description</p>\n<hr>\n<p>  abs/          kv           n/a<br>  cubbyhole/    cubbyhole    per-token private secret storage<br>  identity/     identity     identity store<br>  secret/       kv           key/value secret storage<br>  sys/          system       system endpoints used for control, policy and debugging</p>\n</li>\n</ul>\n<p>通过命令<code>vault secrets list</code>可以看到，第一个就是就是我们刚才开启的新私密引擎。</p>\n<p>往该新建私密引擎保存私密信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\nSuccess! Data written to: abs/my-secret\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\nSuccess! Data written to: abs/hello\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\nSuccess! Data written to: abs/airplane\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>查看该私密引擎下所有key</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault list abs\nKeys\n----\nairplane\nhello\nmy-secret\n</code></pre><ul>\n<li>关闭私密引擎</li>\n</ul>\n<p>当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　<br>当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\nSuccess! Disabled the secrets engine (if it existed) at: abs/\nmutian@mutian-ThinkPad-T440p:~$ vault secrets list\nPath          Type         Description\n----          ----         -----------\ncubbyhole/    cubbyhole    per-token private secret storage\nidentity/     identity     identity store\nsecret/       kv           key/value secret storage\nsys/          system       system endpoints used for control, policy and debugging\n</code></pre><p>上面结果中，已经再看不到私密引擎<code>abs/</code></p>\n<ul>\n<li>什么是私密引擎（Secrets Engine）</li>\n</ul>\n<p>上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？</p>\n<p>实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　<br>这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　</p>\n<h2 id=\"动态私密信息保存\"><a href=\"#动态私密信息保存\" class=\"headerlink\" title=\"动态私密信息保存\"></a>动态私密信息保存</h2>","site":{"data":{}},"excerpt":"","more":"<p>Valut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……</p>\n<p>特性：</p>\n<p>1.安全的私密信息存储 </p>\n<p>2.动态的私密信息支持</p>\n<p>3.提供对于私密信息的更新，延长有效时间的功能</p>\n<p>4.灵活的权限控制</p>\n<p>5.多种客户端登录验证方式</p>\n<p>参考：<br><a href=\"https://www.vaultproject.io/intro/index.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/intro/index.html</a></p>\n<h2 id=\"安装Valut\"><a href=\"#安装Valut\" class=\"headerlink\" title=\"安装Valut\"></a>安装Valut</h2><p>1.下载地址：<a href=\"https://www.vaultproject.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/downloads.html</a></p>\n<p>2.解压<br>解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。</p>\n<p>配置环境变量，把vault可执行文件所在目录添加到环境变量：</p>\n<p><code>export PATH=$PATH:/home/mutian/dev/bin</code></p>\n<p>检验是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \nUsage: vault &lt;command&gt; [args]\n\nCommon commands:\n    read        Read data and retrieves secrets\n    write       Write data, configuration, and secrets\n    delete      Delete secrets and configuration\n    list        List data or secrets\n    login       Authenticate locally\n    server      Start a Vault server\n    status      Print seal and HA status\n    unwrap      Unwrap a wrapped secret\n\nOther commands:\n    audit          Interact with audit devices\n    auth           Interact with auth methods\n    lease          Interact with leases\n    operator       Perform operator-specific tasks\n    path-help      Retrieve API help for paths\n    policy         Interact with policies\n    secrets        Interact with secrets engines\n    ssh            Initiate an SSH session\n    token          Interact with tokens\n</code></pre><p>表示环境变量添加准确，已经安装成功。</p>\n<p>3.install completions</p>\n<pre><code>$ vault -autocomplete-install\n</code></pre><p>然后重新启动shell窗口，输入命令<code>vault</code>，然后按Tab键，将出现命令参数提示。如下：    </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \naudit      lease      operator   read       ssh        unwrap     \nauth       list       path-help  secrets    status     write      \ndelete     login      policy     server     token      \nmutian@mutian-ThinkPad-T440p:~$ vault \n</code></pre><p>##　启动服务</p>\n<h4 id=\"启动开发环境\"><a href=\"#启动开发环境\" class=\"headerlink\" title=\"启动开发环境\"></a>启动开发环境</h4><p>开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n==&gt; Vault server configuration:\n\n                     Cgo: disabled\n         Cluster Address: https://127.0.0.1:8201\n              Listener 1: tcp (addr: &quot;127.0.0.1:8200&quot;, cluster address: &quot;127.0.0.1:8201&quot;, tls: &quot;disabled&quot;)\n               Log Level: info\n                   Mlock: supported: true, enabled: false\n        Redirect Address: http://127.0.0.1:8200\n                 Storage: inmem\n                 Version: Vault v0.9.5\n             Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\nand starts unsealed with a single unseal key. The root token is already\nauthenticated to the CLI, so you can immediately begin using Vault.\n\nYou may need to set the following environment variable:\n\n    $ export VAULT_ADDR=&apos;http://127.0.0.1:8200&apos;\n\nThe unseal key and root token are displayed below in case you want to\nseal/unseal the Vault or re-authenticate.\n\nUnseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\nRoot Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n\nDevelopment mode should NOT be used in production installations!\n\n==&gt; Vault server started! Log data will stream in below:\n</code></pre><p>看到上面内容说明已经启动成功，在前台运行的。</p>\n<p>验证服务是否在成功运行：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status \nError checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：</p>\n<pre><code>export VAULT_ADDR=http://127.0.0.1:8200\n</code></pre><p>再次查看vault服务运行状态:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status\nKey             Value\n---             -----\nSeal Type       shamir\nSealed          false\nTotal Shares    1\nThreshold       1\nVersion         0.9.5\nCluster Name    vault-cluster-bcf3f2f8\nCluster ID      c2649684-fe35-3820-983b-f324a51b115c\nHA Enabled      false\n</code></pre><p>看到了上面的内容，则证明服务启动成功。</p>\n<p>为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效，<br>命令：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置vault访问地址</td>\n<td>export VAULT_ADDR=<a href=\"http://127.0.0.1:8200\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8200</a></td>\n<td style=\"text-align:left\">vault命令作用的vault服务的地址</td>\n</tr>\n<tr>\n<td>设置Vault PATH</td>\n<td>export PATH=$PATH:&lt; vault install path &gt;</td>\n<td style=\"text-align:left\">vault install path：vault安装路径</td>\n</tr>\n<tr>\n<td>设置访问token</td>\n<td>export VAULT_TOKEN=&lt; token &gt;</td>\n<td style=\"text-align:left\">token：登录vault时的token，首次登录可使用root token</td>\n</tr>\n<tr>\n<td>设置是否跳过核查</td>\n<td>export VAULT_SKIP_VERIFY=false</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n<tr>\n<td>设置访问证书</td>\n<td>export VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>保存私密信息</li>\n</ul>\n<p>下面是简单的写入信息命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\nSuccess! Data written to: secret/hello\n</code></pre><p>这会把键值对信息写入到路劲<code>secret/hello</code>中。　键为value,值为world。</p>\n<p>也可以一次性写入多个键值保存：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n</code></pre><ul>\n<li>读取私密信息</li>\n</ul>\n<p>显示该路径下所有保存键值对：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \nKey                 Value\n---                 -----\nrefresh_interval    768h\nexcited             yes\nvalue               world    \n</code></pre><p>获取单个的值：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\nworld\n</code></pre><ul>\n<li>删除路径下键值</li>\n</ul>\n<p>删除所有：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \nSuccess! Data deleted (if it existed) at: secret/hello\nmutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\nNo value found at secret/hello\n</code></pre><p>看上面命令，说明已经把保存到路径<code>secret/hello</code>下的键值信息全部删除。</p>\n<h2 id=\"秘密引擎\"><a href=\"#秘密引擎\" class=\"headerlink\" title=\"秘密引擎\"></a>秘密引擎</h2><p>上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径<code>secret/hello</code>下面，这个是默认的。当你试图保存到其他路径下时候，将报错。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\nError writing data to home/mutian/dev: Error making API request.\n\nURL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\nCode: 404. Errors:\n\n* no handler for route &apos;home/mutian/dev&apos;\n</code></pre><p>默认下，在路劲<code>secret/.</code>Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    </p>\n<ul>\n<li><p>开启一个新的kv私密引擎</p>\n<p>  mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv<br>  Success! Enabled the kv secrets engine at: abs/<br>  mutian@mutian-ThinkPad-T440p:~$ vault secrets list<br>  Path          Type         Description</p>\n<hr>\n<p>  abs/          kv           n/a<br>  cubbyhole/    cubbyhole    per-token private secret storage<br>  identity/     identity     identity store<br>  secret/       kv           key/value secret storage<br>  sys/          system       system endpoints used for control, policy and debugging</p>\n</li>\n</ul>\n<p>通过命令<code>vault secrets list</code>可以看到，第一个就是就是我们刚才开启的新私密引擎。</p>\n<p>往该新建私密引擎保存私密信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\nSuccess! Data written to: abs/my-secret\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\nSuccess! Data written to: abs/hello\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\nSuccess! Data written to: abs/airplane\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>查看该私密引擎下所有key</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault list abs\nKeys\n----\nairplane\nhello\nmy-secret\n</code></pre><ul>\n<li>关闭私密引擎</li>\n</ul>\n<p>当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　<br>当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\nSuccess! Disabled the secrets engine (if it existed) at: abs/\nmutian@mutian-ThinkPad-T440p:~$ vault secrets list\nPath          Type         Description\n----          ----         -----------\ncubbyhole/    cubbyhole    per-token private secret storage\nidentity/     identity     identity store\nsecret/       kv           key/value secret storage\nsys/          system       system endpoints used for control, policy and debugging\n</code></pre><p>上面结果中，已经再看不到私密引擎<code>abs/</code></p>\n<ul>\n<li>什么是私密引擎（Secrets Engine）</li>\n</ul>\n<p>上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？</p>\n<p>实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　<br>这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　</p>\n<h2 id=\"动态私密信息保存\"><a href=\"#动态私密信息保存\" class=\"headerlink\" title=\"动态私密信息保存\"></a>动态私密信息保存</h2>"},{"title":"hibernate表关系映射示例","date":"2017-11-01T09:18:44.000Z","_content":"\n## 1. OneToOne\n一对一关系，存在n+1问题。\n\n#### 1.1 单向 @OneToOne\n- 实体：\n\n\n        @Entity(name = \"Phone\")\n        public static class Phone {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            @Column(name = \"`number`\")\n            private String number;\n        \n            @OneToOne\n            @JoinColumn(name = \"details_id\")\n            private PhoneDetails details;\n        \n            public Phone() {\n            }\n        \n            public Phone(String number) {\n                this.number = number;\n            }\n        \n            public Long getId() {\n                return id;\n            }\n        \n            public String getNumber() {\n                return number;\n            }\n        \n            public PhoneDetails getDetails() {\n                return details;\n            }\n        \n            public void setDetails(PhoneDetails details) {\n                this.details = details;\n            }\n        }\n\t\n---\t\n        @Entity(name = \"PhoneDetails\")\n        public static class PhoneDetails {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            private String provider;\n        \n            private String technology;\n        \n            public PhoneDetails() {\n            }\n        \n            public PhoneDetails(String provider, String technology) {\n                this.provider = provider;\n                this.technology = technology;\n            }\n        \n            public String getProvider() {\n                return provider;\n            }\n        \n            public String getTechnology() {\n                return technology;\n            }\n        \n            public void setTechnology(String technology) {\n                this.technology = technology;\n            }\n        }\n\t\n- *生成sql*：\n\n        CREATE TABLE Phone (\n            id BIGINT NOT NULL ,\n            number VARCHAR(255) ,\n            details_id BIGINT ,\n            PRIMARY KEY ( id )\n        )\n        \n        CREATE TABLE PhoneDetails (\n            id BIGINT NOT NULL ,\n            provider VARCHAR(255) ,\n            technology VARCHAR(255) ,\n            PRIMARY KEY ( id )\n        )\n        \n        ALTER TABLE Phone\n        ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\n        FOREIGN KEY (details_id) REFERENCES PhoneDetails\n\t\n\t\n- *操作*：\n\t作为外键，相当于ManyToOne作为外键操作\n\n---\n\t\n#### 1.2 双向 @OneToOne\n\n- 实体：\n\n\n    @Entity(name = \"Phone\")\n    public static class Phone {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n    \n        @Column(name = \"`number`\")\n        private String number;\n    \n        @OneToOne(mappedBy = \"phone\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n        private PhoneDetails details;\n    \n        public Phone() {\n        }\n    \n        public Phone(String number) {\n            this.number = number;\n        }\n    \n        public Long getId() {\n            return id;\n        }\n    \n        public String getNumber() {\n            return number;\n        }\n    \n        public PhoneDetails getDetails() {\n            return details;\n        }\n    \n        public void addDetails(PhoneDetails details) {\n            details.setPhone( this );\n            this.details = details;\n        }\n    \n        public void removeDetails() {\n            if ( details != null ) {\n                details.setPhone( null );\n                this.details = null;\n            }\n        }\n    }\n\t\n---\n\t\n\t@Entity(name = \"PhoneDetails\")\n\tpublic static class PhoneDetails {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String provider;\n\t\n\t    private String technology;\n\t\n\t    @OneToOne(fetch = FetchType.LAZY)\n\t    @JoinColumn(name = \"phone_id\")\n\t    private Phone phone;\n\t\n\t    public PhoneDetails() {\n\t    }\n\t\n\t    public PhoneDetails(String provider, String technology) {\n\t        this.provider = provider;\n\t        this.technology = technology;\n\t    }\n\t\n\t    public String getProvider() {\n\t        return provider;\n\t    }\n\t\n\t    public String getTechnology() {\n\t        return technology;\n\t    }\n\t\n\t    public void setTechnology(String technology) {\n\t        this.technology = technology;\n\t    }\n\t\n\t    public Phone getPhone() {\n\t        return phone;\n\t    }\n\t\n\t    public void setPhone(Phone phone) {\n\t        this.phone = phone;\n\t    }\n\t}\n\n- *生成sql*：\n\n\n    CREATE TABLE Phone (\n        id BIGINT NOT NULL ,\n        number VARCHAR(255) ,\n        PRIMARY KEY ( id )\n    )\n    \n    CREATE TABLE PhoneDetails (\n        id BIGINT NOT NULL ,\n        provider VARCHAR(255) ,\n        technology VARCHAR(255) ,\n        phone_id BIGINT ,\n        PRIMARY KEY ( id )\n    )\n    \n    ALTER TABLE PhoneDetails\n    ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\n    FOREIGN KEY (phone_id) REFERENCES Phone\n\n- *操作*：\n\n\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tPhoneDetails details = new PhoneDetails( \"T-Mobile\", \"GSM\" );\n\t\n\tphone.addDetails( details );\n\tentityManager.persist( phone );\n\t\n\t-------------------------------------\n\tINSERT INTO Phone ( number, id )\n\tVALUES ( '123 - 456 - 7890', 1 )\n\t\n\tINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\n\tVALUES ( 1, 'T - Mobile, GSM', 2 )\n\t\n\n---\n## 2. OneToMany\n一对多关系，一般在多的一段维护，也可双边维护关系。\n\n#### 2.1 单向 @OneToMany association\n\n- 实体:\n\n\n    @Entity(name = \"Person\")\n    public static class Person {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n        @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n        private List<Phone> phones = new ArrayList<>();\n    \n        public Person() {\n        }\n    \n        public List<Phone> getPhones() {\n            return phones;\n        }\n    }\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\n\tCREATE TABLE Person_Phone (\n\t    Person_id BIGINT NOT NULL ,\n\t    phones_id BIGINT NOT NULL\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\n\tUNIQUE (phones_id)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\n\tFOREIGN KEY (phones_id) REFERENCES Phone\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\n- *操作代码*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.getPhones().add( phone1 );\n\tperson.getPhones().add( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.getPhones().remove( phone1 );\n\t\n\t-----------------------------------------------\n\tINSERT INTO Person\n       ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '123 - 456 - 7890', 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '321 - 654 - 0987', 3 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Person_Phone\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n#### 2.2 双向@OneToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<Phone> phones = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(Long id) {\n\t        this.id = id;\n\t    }\n\t\n\t    public List<Phone> getPhones() {\n\t        return phones;\n\t    }\n\t\n\t    public void addPhone(Phone phone) {\n\t        phones.add( phone );\n\t        phone.setPerson( this );\n\t    }\n\t\n\t    public void removePhone(Phone phone) {\n\t        phones.remove( phone );\n\t        phone.setPerson( null );\n\t    }\n\t}\t\t\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    @Column(name = \"`number`\", unique = true)\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Phone phone = (Phone) o;\n\t        return Objects.equals( number, phone.number );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( number );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\n\tUNIQUE (number)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\n\tFOREIGN KEY (person_id) REFERENCES Person\n\n- *操作*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.addPhone( phone1 );\n\tperson.addPhone( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.removePhone( phone1 );\t\n\t\n\t-----------------------------------------\n\t\n\tINSERT INTO Phone\n       ( number, person_id, id )\n\tVALUES ( '123-456-7890', NULL, 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, person_id, id )\n\tVALUES ( '321-654-0987', NULL, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n---\n## 3. ManyToOne\n多对一关系\n\n#### 3.1 @ManyToOne association\n相当于外键\n\n- 实体\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t\t@Id\n\t\t@GeneratedValue\n\t\tprivate Long id;\n\t\t\n\t\tpublic Person() {\n\t\t\n\t\t}\n\t}\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    @JoinColumn(name = \"person_id\",\n\t            foreignKey = @ForeignKey(name = \"PERSON_ID_FK\")\n\t    )\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT PERSON_ID_FK\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n- *生命周期*:\n\n\n\tPerson person = new Person();\n\tentityManager.persist( person );\n\t\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tphone.setPerson( person );\n\tentityManager.persist( phone );\n\t\n\tentityManager.flush();\n\tphone.setPerson( null );\n\t\n\t实际sql：\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone ( number, person_id, id )\n\tVALUES ( '123-456-7890', 1, 2 )\n\t\n\tUPDATE Phone\n\tSET    number = '123-456-7890',\n\t       person_id = NULL\n\tWHERE  id = 2\n\n---\t\n## 4. ManyToMany\n多对多关系，两边都要维护。\n\n#### 4.1 单向 @ManyToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number) {\n\t        this.street = street;\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    Person_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person();\n\tPerson person2 = new Person();\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\" );\n\t\n\tperson1.getAddresses().add( address1 );\n\tperson1.getAddresses().add( address2 );\n\t\n\tperson2.getAddresses().add( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.getAddresses().remove( address1 );\n\t\n\t-------------------------------------------\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '12A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '18B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( id )\n\tVALUES ( 4 )\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 2 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.2 双向 @ManyToMany\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        addresses.add( address );\n\t        address.getOwners().add( this );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        addresses.remove( address );\n\t        address.getOwners().remove( this );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @ManyToMany(mappedBy = \"addresses\")\n\t    private List<Person> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<Person> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    owners_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\n\tFOREIGN KEY (owners_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.removeAddress( address1 );\n\t\n\t------------------------------------------\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'ABC-123', 1 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '12A', '4005A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '18B', '4007B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'DEF-456', 4 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  owners_id = 1\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.3 双向 many-to-many with a link entity\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public List<PersonAddress> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        addresses.add( personAddress );\n\t        address.getOwners().add( personAddress );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        address.getOwners().remove( personAddress );\n\t        addresses.remove( personAddress );\n\t        personAddress.setPerson( null );\n\t        personAddress.setAddress( null );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"PersonAddress\")\n\tpublic static class PersonAddress implements Serializable {\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Address address;\n\t\n\t    public PersonAddress() {\n\t    }\n\t\n\t    public PersonAddress(Person person, Address address) {\n\t        this.person = person;\n\t        this.address = address;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    public Address getAddress() {\n\t        return address;\n\t    }\n\t\n\t    public void setAddress(Address address) {\n\t        this.address = address;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        PersonAddress that = (PersonAddress) o;\n\t        return Objects.equals( person, that.person ) &&\n\t                Objects.equals( address, that.address );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( person, address );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @OneToMany(mappedBy = \"address\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<PersonAddress> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE PersonAddress (\n\t    person_id BIGINT NOT NULL ,\n\t    address_id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( person_id, address_id )\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\n\tFOREIGN KEY (address_id) REFERENCES Address\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.persist( address1 );\n\tentityManager.persist( address2 );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.flush();\n\t\n\tlog.info( \"Removing address\" );\n\tperson1.removeAddress( address1 );\n\t---------------------------------------------------\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'ABC-123', 1 )\n\t\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'DEF-456', 2 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '12A', '4005A', '12th Avenue', 3 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '18B', '4007B', '18th Avenue', 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 3 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 2, 3 )\n\t\n\tDELETE  FROM PersonAddress\n\tWHERE   person_id = 1 AND address_id = 3\n\t\n\n\t","source":"_posts/hibernate-relation-mapping.md","raw":"---\ntitle: hibernate表关系映射示例\ndate: 2017-11-01 17:18:44\ncategories: jpa/hibernate\ntags: hibernate-relation\n---\n\n## 1. OneToOne\n一对一关系，存在n+1问题。\n\n#### 1.1 单向 @OneToOne\n- 实体：\n\n\n        @Entity(name = \"Phone\")\n        public static class Phone {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            @Column(name = \"`number`\")\n            private String number;\n        \n            @OneToOne\n            @JoinColumn(name = \"details_id\")\n            private PhoneDetails details;\n        \n            public Phone() {\n            }\n        \n            public Phone(String number) {\n                this.number = number;\n            }\n        \n            public Long getId() {\n                return id;\n            }\n        \n            public String getNumber() {\n                return number;\n            }\n        \n            public PhoneDetails getDetails() {\n                return details;\n            }\n        \n            public void setDetails(PhoneDetails details) {\n                this.details = details;\n            }\n        }\n\t\n---\t\n        @Entity(name = \"PhoneDetails\")\n        public static class PhoneDetails {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            private String provider;\n        \n            private String technology;\n        \n            public PhoneDetails() {\n            }\n        \n            public PhoneDetails(String provider, String technology) {\n                this.provider = provider;\n                this.technology = technology;\n            }\n        \n            public String getProvider() {\n                return provider;\n            }\n        \n            public String getTechnology() {\n                return technology;\n            }\n        \n            public void setTechnology(String technology) {\n                this.technology = technology;\n            }\n        }\n\t\n- *生成sql*：\n\n        CREATE TABLE Phone (\n            id BIGINT NOT NULL ,\n            number VARCHAR(255) ,\n            details_id BIGINT ,\n            PRIMARY KEY ( id )\n        )\n        \n        CREATE TABLE PhoneDetails (\n            id BIGINT NOT NULL ,\n            provider VARCHAR(255) ,\n            technology VARCHAR(255) ,\n            PRIMARY KEY ( id )\n        )\n        \n        ALTER TABLE Phone\n        ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\n        FOREIGN KEY (details_id) REFERENCES PhoneDetails\n\t\n\t\n- *操作*：\n\t作为外键，相当于ManyToOne作为外键操作\n\n---\n\t\n#### 1.2 双向 @OneToOne\n\n- 实体：\n\n\n    @Entity(name = \"Phone\")\n    public static class Phone {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n    \n        @Column(name = \"`number`\")\n        private String number;\n    \n        @OneToOne(mappedBy = \"phone\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n        private PhoneDetails details;\n    \n        public Phone() {\n        }\n    \n        public Phone(String number) {\n            this.number = number;\n        }\n    \n        public Long getId() {\n            return id;\n        }\n    \n        public String getNumber() {\n            return number;\n        }\n    \n        public PhoneDetails getDetails() {\n            return details;\n        }\n    \n        public void addDetails(PhoneDetails details) {\n            details.setPhone( this );\n            this.details = details;\n        }\n    \n        public void removeDetails() {\n            if ( details != null ) {\n                details.setPhone( null );\n                this.details = null;\n            }\n        }\n    }\n\t\n---\n\t\n\t@Entity(name = \"PhoneDetails\")\n\tpublic static class PhoneDetails {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String provider;\n\t\n\t    private String technology;\n\t\n\t    @OneToOne(fetch = FetchType.LAZY)\n\t    @JoinColumn(name = \"phone_id\")\n\t    private Phone phone;\n\t\n\t    public PhoneDetails() {\n\t    }\n\t\n\t    public PhoneDetails(String provider, String technology) {\n\t        this.provider = provider;\n\t        this.technology = technology;\n\t    }\n\t\n\t    public String getProvider() {\n\t        return provider;\n\t    }\n\t\n\t    public String getTechnology() {\n\t        return technology;\n\t    }\n\t\n\t    public void setTechnology(String technology) {\n\t        this.technology = technology;\n\t    }\n\t\n\t    public Phone getPhone() {\n\t        return phone;\n\t    }\n\t\n\t    public void setPhone(Phone phone) {\n\t        this.phone = phone;\n\t    }\n\t}\n\n- *生成sql*：\n\n\n    CREATE TABLE Phone (\n        id BIGINT NOT NULL ,\n        number VARCHAR(255) ,\n        PRIMARY KEY ( id )\n    )\n    \n    CREATE TABLE PhoneDetails (\n        id BIGINT NOT NULL ,\n        provider VARCHAR(255) ,\n        technology VARCHAR(255) ,\n        phone_id BIGINT ,\n        PRIMARY KEY ( id )\n    )\n    \n    ALTER TABLE PhoneDetails\n    ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\n    FOREIGN KEY (phone_id) REFERENCES Phone\n\n- *操作*：\n\n\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tPhoneDetails details = new PhoneDetails( \"T-Mobile\", \"GSM\" );\n\t\n\tphone.addDetails( details );\n\tentityManager.persist( phone );\n\t\n\t-------------------------------------\n\tINSERT INTO Phone ( number, id )\n\tVALUES ( '123 - 456 - 7890', 1 )\n\t\n\tINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\n\tVALUES ( 1, 'T - Mobile, GSM', 2 )\n\t\n\n---\n## 2. OneToMany\n一对多关系，一般在多的一段维护，也可双边维护关系。\n\n#### 2.1 单向 @OneToMany association\n\n- 实体:\n\n\n    @Entity(name = \"Person\")\n    public static class Person {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n        @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n        private List<Phone> phones = new ArrayList<>();\n    \n        public Person() {\n        }\n    \n        public List<Phone> getPhones() {\n            return phones;\n        }\n    }\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\n\tCREATE TABLE Person_Phone (\n\t    Person_id BIGINT NOT NULL ,\n\t    phones_id BIGINT NOT NULL\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\n\tUNIQUE (phones_id)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\n\tFOREIGN KEY (phones_id) REFERENCES Phone\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\n- *操作代码*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.getPhones().add( phone1 );\n\tperson.getPhones().add( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.getPhones().remove( phone1 );\n\t\n\t-----------------------------------------------\n\tINSERT INTO Person\n       ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '123 - 456 - 7890', 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '321 - 654 - 0987', 3 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Person_Phone\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n#### 2.2 双向@OneToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<Phone> phones = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(Long id) {\n\t        this.id = id;\n\t    }\n\t\n\t    public List<Phone> getPhones() {\n\t        return phones;\n\t    }\n\t\n\t    public void addPhone(Phone phone) {\n\t        phones.add( phone );\n\t        phone.setPerson( this );\n\t    }\n\t\n\t    public void removePhone(Phone phone) {\n\t        phones.remove( phone );\n\t        phone.setPerson( null );\n\t    }\n\t}\t\t\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    @Column(name = \"`number`\", unique = true)\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Phone phone = (Phone) o;\n\t        return Objects.equals( number, phone.number );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( number );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\n\tUNIQUE (number)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\n\tFOREIGN KEY (person_id) REFERENCES Person\n\n- *操作*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.addPhone( phone1 );\n\tperson.addPhone( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.removePhone( phone1 );\t\n\t\n\t-----------------------------------------\n\t\n\tINSERT INTO Phone\n       ( number, person_id, id )\n\tVALUES ( '123-456-7890', NULL, 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, person_id, id )\n\tVALUES ( '321-654-0987', NULL, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n---\n## 3. ManyToOne\n多对一关系\n\n#### 3.1 @ManyToOne association\n相当于外键\n\n- 实体\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t\t@Id\n\t\t@GeneratedValue\n\t\tprivate Long id;\n\t\t\n\t\tpublic Person() {\n\t\t\n\t\t}\n\t}\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    @JoinColumn(name = \"person_id\",\n\t            foreignKey = @ForeignKey(name = \"PERSON_ID_FK\")\n\t    )\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT PERSON_ID_FK\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n- *生命周期*:\n\n\n\tPerson person = new Person();\n\tentityManager.persist( person );\n\t\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tphone.setPerson( person );\n\tentityManager.persist( phone );\n\t\n\tentityManager.flush();\n\tphone.setPerson( null );\n\t\n\t实际sql：\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone ( number, person_id, id )\n\tVALUES ( '123-456-7890', 1, 2 )\n\t\n\tUPDATE Phone\n\tSET    number = '123-456-7890',\n\t       person_id = NULL\n\tWHERE  id = 2\n\n---\t\n## 4. ManyToMany\n多对多关系，两边都要维护。\n\n#### 4.1 单向 @ManyToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number) {\n\t        this.street = street;\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    Person_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person();\n\tPerson person2 = new Person();\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\" );\n\t\n\tperson1.getAddresses().add( address1 );\n\tperson1.getAddresses().add( address2 );\n\t\n\tperson2.getAddresses().add( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.getAddresses().remove( address1 );\n\t\n\t-------------------------------------------\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '12A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '18B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( id )\n\tVALUES ( 4 )\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 2 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.2 双向 @ManyToMany\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        addresses.add( address );\n\t        address.getOwners().add( this );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        addresses.remove( address );\n\t        address.getOwners().remove( this );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @ManyToMany(mappedBy = \"addresses\")\n\t    private List<Person> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<Person> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    owners_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\n\tFOREIGN KEY (owners_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.removeAddress( address1 );\n\t\n\t------------------------------------------\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'ABC-123', 1 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '12A', '4005A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '18B', '4007B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'DEF-456', 4 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  owners_id = 1\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.3 双向 many-to-many with a link entity\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public List<PersonAddress> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        addresses.add( personAddress );\n\t        address.getOwners().add( personAddress );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        address.getOwners().remove( personAddress );\n\t        addresses.remove( personAddress );\n\t        personAddress.setPerson( null );\n\t        personAddress.setAddress( null );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"PersonAddress\")\n\tpublic static class PersonAddress implements Serializable {\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Address address;\n\t\n\t    public PersonAddress() {\n\t    }\n\t\n\t    public PersonAddress(Person person, Address address) {\n\t        this.person = person;\n\t        this.address = address;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    public Address getAddress() {\n\t        return address;\n\t    }\n\t\n\t    public void setAddress(Address address) {\n\t        this.address = address;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        PersonAddress that = (PersonAddress) o;\n\t        return Objects.equals( person, that.person ) &&\n\t                Objects.equals( address, that.address );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( person, address );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @OneToMany(mappedBy = \"address\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<PersonAddress> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE PersonAddress (\n\t    person_id BIGINT NOT NULL ,\n\t    address_id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( person_id, address_id )\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\n\tFOREIGN KEY (address_id) REFERENCES Address\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.persist( address1 );\n\tentityManager.persist( address2 );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.flush();\n\t\n\tlog.info( \"Removing address\" );\n\tperson1.removeAddress( address1 );\n\t---------------------------------------------------\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'ABC-123', 1 )\n\t\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'DEF-456', 2 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '12A', '4005A', '12th Avenue', 3 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '18B', '4007B', '18th Avenue', 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 3 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 2, 3 )\n\t\n\tDELETE  FROM PersonAddress\n\tWHERE   person_id = 1 AND address_id = 3\n\t\n\n\t","slug":"hibernate-relation-mapping","published":1,"updated":"2018-11-09T01:20:30.108Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38rv00ddqcrgyr2vifa9","content":"<h2 id=\"1-OneToOne\"><a href=\"#1-OneToOne\" class=\"headerlink\" title=\"1. OneToOne\"></a>1. OneToOne</h2><p>一对一关系，存在n+1问题。</p>\n<h4 id=\"1-1-单向-OneToOne\"><a href=\"#1-1-单向-OneToOne\" class=\"headerlink\" title=\"1.1 单向 @OneToOne\"></a>1.1 单向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne\n    @JoinColumn(name = &quot;details_id&quot;)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void setDetails(PhoneDetails details) {\n        this.details = details;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n}\n</code></pre><ul>\n<li><p><em>生成sql</em>：</p>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    details_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\nFOREIGN KEY (details_id) REFERENCES PhoneDetails\n</code></pre></li>\n</ul>\n<ul>\n<li><em>操作</em>：<br>  作为外键，相当于ManyToOne作为外键操作</li>\n</ul>\n<hr>\n<h4 id=\"1-2-双向-OneToOne\"><a href=\"#1-2-双向-OneToOne\" class=\"headerlink\" title=\"1.2 双向 @OneToOne\"></a>1.2 双向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne(mappedBy = &quot;phone&quot;, cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void addDetails(PhoneDetails details) {\n        details.setPhone( this );\n        this.details = details;\n    }\n\n    public void removeDetails() {\n        if ( details != null ) {\n            details.setPhone( null );\n            this.details = null;\n        }\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    @OneToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;phone_id&quot;)\n    private Phone phone;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    phone_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE PhoneDetails\nADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\nFOREIGN KEY (phone_id) REFERENCES Phone\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Phone phone = new Phone( &quot;123-456-7890&quot; );\nPhoneDetails details = new PhoneDetails( &quot;T-Mobile&quot;, &quot;GSM&quot; );\n\nphone.addDetails( details );\nentityManager.persist( phone );\n\n-------------------------------------\nINSERT INTO Phone ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 1 )\n\nINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\nVALUES ( 1, &apos;T - Mobile, GSM&apos;, 2 )\n</code></pre><hr>\n<h2 id=\"2-OneToMany\"><a href=\"#2-OneToMany\" class=\"headerlink\" title=\"2. OneToMany\"></a>2. OneToMany</h2><p>一对多关系，一般在多的一段维护，也可双边维护关系。</p>\n<h4 id=\"2-1-单向-OneToMany-association\"><a href=\"#2-1-单向-OneToMany-association\" class=\"headerlink\" title=\"2.1 单向 @OneToMany association\"></a>2.1 单向 @OneToMany association</h4><ul>\n<li>实体:</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Phone (\n    Person_id BIGINT NOT NULL ,\n    phones_id BIGINT NOT NULL\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\nUNIQUE (phones_id)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\nFOREIGN KEY (phones_id) REFERENCES Phone\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作代码</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.getPhones().add( phone1 );\nperson.getPhones().add( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.getPhones().remove( phone1 );\n\n-----------------------------------------------\nINSERT INTO Person\n   ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 2 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;321 - 654 - 0987&apos;, 3 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Person_Phone\nWHERE  Person_id = 1\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><h4 id=\"2-2-双向-OneToMany\"><a href=\"#2-2-双向-OneToMany\" class=\"headerlink\" title=\"2.2 双向@OneToMany\"></a>2.2 双向@OneToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(Long id) {\n        this.id = id;\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n\n    public void addPhone(Phone phone) {\n        phones.add( phone );\n        phone.setPerson( this );\n    }\n\n    public void removePhone(Phone phone) {\n        phones.remove( phone );\n        phone.setPerson( null );\n    }\n}        \n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    @Column(name = &quot;`number`&quot;, unique = true)\n    private String number;\n\n    @ManyToOne\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Phone phone = (Phone) o;\n        return Objects.equals( number, phone.number );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( number );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\nUNIQUE (number)\n\nALTER TABLE Phone\nADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.addPhone( phone1 );\nperson.addPhone( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.removePhone( phone1 );    \n\n-----------------------------------------\n\nINSERT INTO Phone\n   ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, NULL, 2 )\n\nINSERT INTO Phone\n       ( number, person_id, id )\nVALUES ( &apos;321-654-0987&apos;, NULL, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"3-ManyToOne\"><a href=\"#3-ManyToOne\" class=\"headerlink\" title=\"3. ManyToOne\"></a>3. ManyToOne</h2><p>多对一关系</p>\n<h4 id=\"3-1-ManyToOne-association\"><a href=\"#3-1-ManyToOne-association\" class=\"headerlink\" title=\"3.1 @ManyToOne association\"></a>3.1 @ManyToOne association</h4><p>相当于外键</p>\n<ul>\n<li>实体</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    public Person() {\n\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;person_id&quot;,\n            foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;)\n    )\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT PERSON_ID_FK\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>生命周期</em>:</li>\n</ul>\n<pre><code>Person person = new Person();\nentityManager.persist( person );\n\nPhone phone = new Phone( &quot;123-456-7890&quot; );\nphone.setPerson( person );\nentityManager.persist( phone );\n\nentityManager.flush();\nphone.setPerson( null );\n\n实际sql：\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, 1, 2 )\n\nUPDATE Phone\nSET    number = &apos;123-456-7890&apos;,\n       person_id = NULL\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"4-ManyToMany\"><a href=\"#4-ManyToMany\" class=\"headerlink\" title=\"4. ManyToMany\"></a>4. ManyToMany</h2><p>多对多关系，两边都要维护。</p>\n<h4 id=\"4-1-单向-ManyToMany\"><a href=\"#4-1-单向-ManyToMany\" class=\"headerlink\" title=\"4.1 单向 @ManyToMany\"></a>4.1 单向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Address() {\n    }\n\n    public Address(String street, String number) {\n        this.street = street;\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    Person_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person();\nPerson person2 = new Person();\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot; );\n\nperson1.getAddresses().add( address1 );\nperson1.getAddresses().add( address2 );\n\nperson2.getAddresses().add( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.getAddresses().remove( address1 );\n\n-------------------------------------------\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;12A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;18B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( id )\nVALUES ( 4 )\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 2 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  Person_id = 1\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-2-双向-ManyToMany\"><a href=\"#4-2-双向-ManyToMany\" class=\"headerlink\" title=\"4.2 双向 @ManyToMany\"></a>4.2 双向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        addresses.add( address );\n        address.getOwners().add( this );\n    }\n\n    public void removeAddress(Address address) {\n        addresses.remove( address );\n        address.getOwners().remove( this );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @ManyToMany(mappedBy = &quot;addresses&quot;)\n    private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;Person&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    owners_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\nFOREIGN KEY (owners_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.removeAddress( address1 );\n\n------------------------------------------\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;ABC-123&apos;, 1 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;DEF-456&apos;, 4 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  owners_id = 1\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-3-双向-many-to-many-with-a-link-entity\"><a href=\"#4-3-双向-many-to-many-with-a-link-entity\" class=\"headerlink\" title=\"4.3 双向 many-to-many with a link entity\"></a>4.3 双向 many-to-many with a link entity</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public List&lt;PersonAddress&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        addresses.add( personAddress );\n        address.getOwners().add( personAddress );\n    }\n\n    public void removeAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        address.getOwners().remove( personAddress );\n        addresses.remove( personAddress );\n        personAddress.setPerson( null );\n        personAddress.setAddress( null );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PersonAddress&quot;)\npublic static class PersonAddress implements Serializable {\n\n    @Id\n    @ManyToOne\n    private Person person;\n\n    @Id\n    @ManyToOne\n    private Address address;\n\n    public PersonAddress() {\n    }\n\n    public PersonAddress(Person person, Address address) {\n        this.person = person;\n        this.address = address;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        PersonAddress that = (PersonAddress) o;\n        return Objects.equals( person, that.person ) &amp;&amp;\n                Objects.equals( address, that.address );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( person, address );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;PersonAddress&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PersonAddress (\n    person_id BIGINT NOT NULL ,\n    address_id BIGINT NOT NULL ,\n    PRIMARY KEY ( person_id, address_id )\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\nFOREIGN KEY (person_id) REFERENCES Person\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\nFOREIGN KEY (address_id) REFERENCES Address\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.persist( address1 );\nentityManager.persist( address2 );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.flush();\n\nlog.info( &quot;Removing address&quot; );\nperson1.removeAddress( address1 );\n---------------------------------------------------\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;ABC-123&apos;, 1 )\n\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;DEF-456&apos;, 2 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 3 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 3 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 2, 3 )\n\nDELETE  FROM PersonAddress\nWHERE   person_id = 1 AND address_id = 3\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-OneToOne\"><a href=\"#1-OneToOne\" class=\"headerlink\" title=\"1. OneToOne\"></a>1. OneToOne</h2><p>一对一关系，存在n+1问题。</p>\n<h4 id=\"1-1-单向-OneToOne\"><a href=\"#1-1-单向-OneToOne\" class=\"headerlink\" title=\"1.1 单向 @OneToOne\"></a>1.1 单向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne\n    @JoinColumn(name = &quot;details_id&quot;)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void setDetails(PhoneDetails details) {\n        this.details = details;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n}\n</code></pre><ul>\n<li><p><em>生成sql</em>：</p>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    details_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\nFOREIGN KEY (details_id) REFERENCES PhoneDetails\n</code></pre></li>\n</ul>\n<ul>\n<li><em>操作</em>：<br>  作为外键，相当于ManyToOne作为外键操作</li>\n</ul>\n<hr>\n<h4 id=\"1-2-双向-OneToOne\"><a href=\"#1-2-双向-OneToOne\" class=\"headerlink\" title=\"1.2 双向 @OneToOne\"></a>1.2 双向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne(mappedBy = &quot;phone&quot;, cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void addDetails(PhoneDetails details) {\n        details.setPhone( this );\n        this.details = details;\n    }\n\n    public void removeDetails() {\n        if ( details != null ) {\n            details.setPhone( null );\n            this.details = null;\n        }\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    @OneToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;phone_id&quot;)\n    private Phone phone;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    phone_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE PhoneDetails\nADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\nFOREIGN KEY (phone_id) REFERENCES Phone\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Phone phone = new Phone( &quot;123-456-7890&quot; );\nPhoneDetails details = new PhoneDetails( &quot;T-Mobile&quot;, &quot;GSM&quot; );\n\nphone.addDetails( details );\nentityManager.persist( phone );\n\n-------------------------------------\nINSERT INTO Phone ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 1 )\n\nINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\nVALUES ( 1, &apos;T - Mobile, GSM&apos;, 2 )\n</code></pre><hr>\n<h2 id=\"2-OneToMany\"><a href=\"#2-OneToMany\" class=\"headerlink\" title=\"2. OneToMany\"></a>2. OneToMany</h2><p>一对多关系，一般在多的一段维护，也可双边维护关系。</p>\n<h4 id=\"2-1-单向-OneToMany-association\"><a href=\"#2-1-单向-OneToMany-association\" class=\"headerlink\" title=\"2.1 单向 @OneToMany association\"></a>2.1 单向 @OneToMany association</h4><ul>\n<li>实体:</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Phone (\n    Person_id BIGINT NOT NULL ,\n    phones_id BIGINT NOT NULL\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\nUNIQUE (phones_id)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\nFOREIGN KEY (phones_id) REFERENCES Phone\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作代码</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.getPhones().add( phone1 );\nperson.getPhones().add( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.getPhones().remove( phone1 );\n\n-----------------------------------------------\nINSERT INTO Person\n   ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 2 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;321 - 654 - 0987&apos;, 3 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Person_Phone\nWHERE  Person_id = 1\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><h4 id=\"2-2-双向-OneToMany\"><a href=\"#2-2-双向-OneToMany\" class=\"headerlink\" title=\"2.2 双向@OneToMany\"></a>2.2 双向@OneToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(Long id) {\n        this.id = id;\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n\n    public void addPhone(Phone phone) {\n        phones.add( phone );\n        phone.setPerson( this );\n    }\n\n    public void removePhone(Phone phone) {\n        phones.remove( phone );\n        phone.setPerson( null );\n    }\n}        \n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    @Column(name = &quot;`number`&quot;, unique = true)\n    private String number;\n\n    @ManyToOne\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Phone phone = (Phone) o;\n        return Objects.equals( number, phone.number );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( number );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\nUNIQUE (number)\n\nALTER TABLE Phone\nADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.addPhone( phone1 );\nperson.addPhone( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.removePhone( phone1 );    \n\n-----------------------------------------\n\nINSERT INTO Phone\n   ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, NULL, 2 )\n\nINSERT INTO Phone\n       ( number, person_id, id )\nVALUES ( &apos;321-654-0987&apos;, NULL, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"3-ManyToOne\"><a href=\"#3-ManyToOne\" class=\"headerlink\" title=\"3. ManyToOne\"></a>3. ManyToOne</h2><p>多对一关系</p>\n<h4 id=\"3-1-ManyToOne-association\"><a href=\"#3-1-ManyToOne-association\" class=\"headerlink\" title=\"3.1 @ManyToOne association\"></a>3.1 @ManyToOne association</h4><p>相当于外键</p>\n<ul>\n<li>实体</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    public Person() {\n\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;person_id&quot;,\n            foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;)\n    )\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT PERSON_ID_FK\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>生命周期</em>:</li>\n</ul>\n<pre><code>Person person = new Person();\nentityManager.persist( person );\n\nPhone phone = new Phone( &quot;123-456-7890&quot; );\nphone.setPerson( person );\nentityManager.persist( phone );\n\nentityManager.flush();\nphone.setPerson( null );\n\n实际sql：\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, 1, 2 )\n\nUPDATE Phone\nSET    number = &apos;123-456-7890&apos;,\n       person_id = NULL\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"4-ManyToMany\"><a href=\"#4-ManyToMany\" class=\"headerlink\" title=\"4. ManyToMany\"></a>4. ManyToMany</h2><p>多对多关系，两边都要维护。</p>\n<h4 id=\"4-1-单向-ManyToMany\"><a href=\"#4-1-单向-ManyToMany\" class=\"headerlink\" title=\"4.1 单向 @ManyToMany\"></a>4.1 单向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Address() {\n    }\n\n    public Address(String street, String number) {\n        this.street = street;\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    Person_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person();\nPerson person2 = new Person();\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot; );\n\nperson1.getAddresses().add( address1 );\nperson1.getAddresses().add( address2 );\n\nperson2.getAddresses().add( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.getAddresses().remove( address1 );\n\n-------------------------------------------\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;12A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;18B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( id )\nVALUES ( 4 )\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 2 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  Person_id = 1\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-2-双向-ManyToMany\"><a href=\"#4-2-双向-ManyToMany\" class=\"headerlink\" title=\"4.2 双向 @ManyToMany\"></a>4.2 双向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        addresses.add( address );\n        address.getOwners().add( this );\n    }\n\n    public void removeAddress(Address address) {\n        addresses.remove( address );\n        address.getOwners().remove( this );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @ManyToMany(mappedBy = &quot;addresses&quot;)\n    private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;Person&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    owners_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\nFOREIGN KEY (owners_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.removeAddress( address1 );\n\n------------------------------------------\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;ABC-123&apos;, 1 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;DEF-456&apos;, 4 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  owners_id = 1\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-3-双向-many-to-many-with-a-link-entity\"><a href=\"#4-3-双向-many-to-many-with-a-link-entity\" class=\"headerlink\" title=\"4.3 双向 many-to-many with a link entity\"></a>4.3 双向 many-to-many with a link entity</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public List&lt;PersonAddress&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        addresses.add( personAddress );\n        address.getOwners().add( personAddress );\n    }\n\n    public void removeAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        address.getOwners().remove( personAddress );\n        addresses.remove( personAddress );\n        personAddress.setPerson( null );\n        personAddress.setAddress( null );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PersonAddress&quot;)\npublic static class PersonAddress implements Serializable {\n\n    @Id\n    @ManyToOne\n    private Person person;\n\n    @Id\n    @ManyToOne\n    private Address address;\n\n    public PersonAddress() {\n    }\n\n    public PersonAddress(Person person, Address address) {\n        this.person = person;\n        this.address = address;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        PersonAddress that = (PersonAddress) o;\n        return Objects.equals( person, that.person ) &amp;&amp;\n                Objects.equals( address, that.address );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( person, address );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;PersonAddress&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PersonAddress (\n    person_id BIGINT NOT NULL ,\n    address_id BIGINT NOT NULL ,\n    PRIMARY KEY ( person_id, address_id )\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\nFOREIGN KEY (person_id) REFERENCES Person\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\nFOREIGN KEY (address_id) REFERENCES Address\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.persist( address1 );\nentityManager.persist( address2 );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.flush();\n\nlog.info( &quot;Removing address&quot; );\nperson1.removeAddress( address1 );\n---------------------------------------------------\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;ABC-123&apos;, 1 )\n\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;DEF-456&apos;, 2 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 3 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 3 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 2, 3 )\n\nDELETE  FROM PersonAddress\nWHERE   person_id = 1 AND address_id = 3\n</code></pre>"},{"title":"docker学习-第三课：镜像","date":"2018-02-02T13:36:08.000Z","_content":"\nDocker\t运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker\t会从镜像仓库下载(默认是\nDocker\tHub\t公共注册服务器中的仓库)。\n\n本章将介绍更多关于镜像的内容,包括:\n- 从仓库获取镜像;\n- 管理本地主机上的镜像;\n- 介绍镜像实现的基本原理。\n\n## 获取镜像\n\n在官方[Docker Hub](https://hub.docker.com/explore/)有大量高质量可用镜像。下面我们来看怎样获取这些镜像。\n\n从Docker\t镜像仓库获取镜像的命令是docker\tpull。其命令格式为: \n\n    docker pull\t[选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n具体的先选可以通过`docker pull\t--help`命令查看。镜像名称的格式：\n\n- Docker 镜像仓库地址:地址的格式一般是`<域名/IP>[:端口号]`。默认地址是Docker Hub。\n- 仓库名:如之前所说,这里的仓库名是两段式名称,即`<用户名>/<软件名>`。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。\n\n比如:\n\n    $\tdocker\tpull\tubuntu:16.04\n    16.04:\tPulling\tfrom\tlibrary/ubuntu\n    bf5d46315322:\tPull\tcomplete\n    9f13e0ac480c:\tPull\tcomplete\n    e8988b5b3097:\tPull\tcomplete\n    40af181810e7:\tPull\tcomplete\n    e6f7c7e5c03e:\tPull\tcomplete\n    Digest:\tsha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\n    Status:\tDownloaded\tnewer\timage\tfor\tubuntu:16.04\n    \n上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04\t,因此将会获取官方镜像library/ubuntu\t仓库中标签为16.04的镜像。    \n\n例子： \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n    [sudo] password for mutian: \n    Using default tag: latest\n    latest: Pulling from library/centos\n    af4b0a2388c6: Pull complete \n    Digest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n    Status: Downloaded newer image for centos:latest\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n\n## 运行\n\n有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。\n\n`sudo docker run -it --rm centos bash`\n\n    [root@5f6c0a6b41c1 ~]# cat /etc/os-release \n    NAME=\"CentOS Linux\"\n    VERSION=\"7 (Core)\"\n    ID=\"centos\"\n    ID_LIKE=\"rhel fedora\"\n    VERSION_ID=\"7\"\n    PRETTY_NAME=\"CentOS Linux 7 (Core)\"\n    ANSI_COLOR=\"0;31\"\n    CPE_NAME=\"cpe:/o:centos:centos:7\"\n    HOME_URL=\"https://www.centos.org/\"\n    BUG_REPORT_URL=\"https://bugs.centos.org/\"\n    \n    CENTOS_MANTISBT_PROJECT=\"CentOS-7\"\n    CENTOS_MANTISBT_PROJECT_VERSION=\"7\"\n    REDHAT_SUPPORT_PRODUCT=\"centos\"\n    REDHAT_SUPPORT_PRODUCT_VERSION=\"7\"\n    \n    [root@5f6c0a6b41c1 ~]# \n\n通过上面信息我们可以看到容器内系统信息。\n\n命令说明：\n\n`docker\trun`就是运行容器的命令,具体格式我们会在\t容器\t一节进行详细讲解,我们这里简要的说明一下上面用到的参数。\n\n- `-it`:这是两个参数,一个是`-i`:交互式操作,一个是`-t`终端。我们这里打算进入`bash`执行一些命令并查看返回结果,因此我们需要交互式终端。\n- `--rm`:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动`docker\trm`。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用`--rm`可以避免浪费空间。\n- `centos`:这是指用`centos`镜像为基础来启动容器。\n- `bash`:放在镜像名后的是命令,这里我们希望有个交互式`Shell`,因此用的是`bash`。\n\n进入系统后我们可以执行任何linux下的命令。\n\n最后我们通过`exit`退出了这个容器。\n退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了`--rm`命令。\n\n## 列出所有的镜像\n\n想列出所有已经下载的镜像，可以使用命令`docker\timage ls`\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    [sudo] password for mutian: \n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest              f2a91732366c        3 months ago        1.85kB\n\n\n上面列表包含了`仓库名`、`标签`、`镜像ID`、`创建时间`以及所占用空间。\n镜像\tID\t则是镜像的唯一标识,一个镜像可以对应多个标签。\n\n- 镜像体积SIZE：\n上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比\n每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。\n\n你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\n    TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\n    Images              2                   1                   207.2MB             207.2MB (99%)\n    Containers          1                   0                   0B                  0B\n    Local Volumes       0                   0                   0B                  0B\n    Build Cache \n\n\n- 虚悬镜像\n\n{%asset_img a.png %}\n\n如上图，命令查出来的就是虚悬镜像。其产生的原因是：\n由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。\n\n这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：\n\n    $ sudo docker image\tprune\n\n- 中间层镜像\n为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可\n能会看到一些依赖的中间层镜像。默认的`docker image\tls`列表中只会显示顶层镜像,如果\n希望显示包括中间层镜像在内的所有镜像的话,需要加\t`-a`参数。\n\n\n    $ sudo docker image ls -a\n\n这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 \n\n- 列出部分镜像\n上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。\n\n根据仓库名称列出镜像：\n    \n    sudo docker image ls centos\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n\n列出特定的某个镜像,也就是说指定仓库名和标签\n\n{%asset_img b.png%}\n\n过滤查找镜像，使用`--filter`。具体使用请百度。\n\n- 以特定格式显示\n\n只显示ID列：\n\n    sudo docker image ls -q\n    ff426288ea90\n    f2a91732366c\n\n用go模板语法定制格式显示\n比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"{{.ID}}:{{.Repository}}\"\n    ff426288ea90:centos\n    f2a91732366c:hello-world\n\n或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n    IMAGE ID            REPOSITORY          TAG\n    ff426288ea90        centos              latest\n    f2a91732366c        hello-world         latest\n\n## 删除本地镜像\n\n可以使用`docker\timage\trm`命令来删除本地镜像。格式如下：\n\n    $\tdocker image rm [选项] <镜像1> [<镜像2> ...]\n\n- 用\tID、镜像名、摘要删除镜像\n\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest        \n\n    #删除hello-world，段id，id一部分，能区分就行。\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n\n用仓库名删除：\n    \n    $ sudo docker image\trm\thello-world    \n\n当然,更精确的是使用镜像摘要删除镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n\n- 用\t`docker\timage\tls`命令来配合\n\n比如,我们需要删除所有仓库名为redis的镜像:\n\n    $ docker image rm $(docker image ls -q redis)\n\n## 利用commit理解镜像构成\n镜像是一层一层构成的。\n\n现在让我们以定制一个Web\t服务器为例子,来讲解镜像是如何构建的。\n\n    docker run --name webserver -d -p 80:80 nginx\n\n在浏览器可查看：\n\n{%asset_img c.png%}\n\n现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎\tDocker的文字,我们可以使用`docker\texec`命令进入容器,修改其内容 \n\n    > sudo docker exec -it webserver bash\n    root@3729b97e8226:/# echo '<h1>Hello,Docker!</h1>' >\t/usr/share/nginx/html/index.html\n    root@3729b97e8226:/#\texit\n\n然后刷新浏览器，就可以看到更改了。\n\n我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过`docker\tdiff`命令看到具体的改动。\n\n下面我们可以用下面的命令将容器保存为镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n    > --author \"zmt\" \\\n    > --message \"修改了默认页面\" \\\n    > webserver \\\n    > nginx:v2\n    sha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n    \n    #查看\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               v2                  e8023c09eed5        8 seconds ago       109MB\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest  \n\n查看镜像内历史记录：\n\n    $ docker history nginx:v2\n\n新的镜像定制好后,我们可以来运行这个镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n\n\n在浏览器查看：http://localhost:81/\n\n停止容器：`sudo docker kill --signal=SIGINT web2`\n    \n至此,我们第一次完成了定制镜像,使用的是`docker\tcommit`命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。\n\n> 注意：通常不会使用`docker commit`来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。\n\n## 使用Dockerfile定制镜像\n从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。\n\nDockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,\n因此每一条指令的内容,就是描述该层应当如何构建。\n\n### 简单例子：\n\n1.创建Dockerfile文件\n\n    mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\n    mutian@mutian-ThinkPad-T440p:~$ cd mynginx/\n    mutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n\n2.打开Dockerfile文件，编辑如下内容：\n    \n    FROM nginx\n    RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n\n3.构建镜像\n进入Dockerfile所在目录，执行命令：\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\n    Sending build context to Docker daemon  2.048kB\n    Step 1/2 : FROM nginx\n     ---> e548f1a579cf\n    Step 2/2 : RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n     ---> Running in d8c0149adf7e\n    Removing intermediate container d8c0149adf7e\n     ---> b92f375b41f0\n    Successfully built b92f375b41f0\n    Successfully tagged nginx:v3\n\n4.查看\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\n    nginx               v3                  b92f375b41f0        About a minute ago   109MB\n    nginx               v2                  e8023c09eed5        17 hours ago         109MB\n    nginx               latest              e548f1a579cf        8 days ago           109MB\n    centos              latest              ff426288ea90        7 weeks ago          207MB\n    hello-world         latest              f2a91732366c        3 months ago    \n    \n我们看到，TAG为v3的镜像就是我们刚才构建。    \n\n### FROM指定基础镜像\n\n定制镜像必须是以一个镜像为基础来构建，基础镜像是必须要指定的，而FROM命令就是指定基础镜像，且第一步就要指定。   \n\n除了选择一些先前定制好的镜像作为基础镜像，Docker还存在一个特殊的镜像，名为`scratch`，表示空镜像，是个虚拟的概念，不实际存在。\n\n    FROM\tscratch\n    ...\n    \n如果以`scratch`为基础，则意味着不以任何镜像为基础，后面所写的命令将作为镜像的第一层存在。\n\n对于一些二进制的可执行文件，直接最为第一层存在，不依赖其它运行时系统支持，可以用空镜像。类似go语言编译的程序。\n\n### RUN 执行命令\n\nRUN命令是用来执行命令行命令的，就像shell脚本一样，用来执行linux命令。\n\n注意避免错误：\n\n    FROM\tdebian:jessie\n    RUN\tapt-get\tupdate\n    RUN\tapt-get\tinstall\t-y\tgcc\tlibc6-dev\tmake\n    RUN\twget\t-O\tredis.tar.gz\t\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\n    RUN\tmkdir\t-p\t/usr/src/redis\n    RUN\ttar\t-xzf\tredis.tar.gz\t-C\t/usr/src/redis\t--strip-components=1\n    RUN\tmake\t-C\t/usr/src/redis\n    RUN\tmake\t-C\t/usr/src/redis\tinstall\n    \n每一个指令都会创建一层，每层都会带有上层垃圾，因此一定要避免这样写。正确的写法如下： \n\n    FROM\tdebian:jessie\n    RUN\tbuildDeps='gcc\tlibc6-dev\tmake'\t\\\n    \t\t\t\t&&\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\t$buildDeps\t\\\n    \t\t\t\t&&\twget\t-O\tredis.tar.gz\t\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\t\\\n    \t\t\t\t&&\tmkdir\t-p\t/usr/src/redis\t\\\n    \t\t\t\t&&\ttar\t-xzf\tredis.tar.gz\t-C\t/usr/src/redis\t--strip-components=1\t\\\n    \t\t\t\t&&\tmake\t-C\t/usr/src/redis\t\\\n    \t\t\t\t&&\tmake\t-C\t/usr/src/redis\tinstall\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\t\\\n    \t\t\t\t&&\trm\tredis.tar.gz\t\\\n    \t\t\t\t&&\trm\t-r\t/usr/src/redis\t\\\n    \t\t\t\t&&\tapt-get\tpurge\t-y\t--auto-remove\t$buildDeps\n    \t\t\t\t\n用了`&&`，这和`shell`执行命令一样，就相当一个命令，所以算一层。执行完后，一定要记得删除不必要的垃圾数据，垃圾包。  \n在编写`Dockerfile`时候，一定要面向类似事件的思维，比如，安装redis环境，是一个事件，算一层。安装mysql，算一个事件，一层。  \n\n## Dockerfile指令详解 \n\n上面我们已经了解了`From`、`RUN`指令，下面我们来介绍其余的……\n\n### COPY复制文件\n\n格式：\n\n- `COPY\t<源路径>...\t<目标路径>`\n\n- `COPY\t[\"<源路径1>\",...\t\"<目标路径>\"]`\n\n源路径指当前电脑系统文件路径，目标路径指容器的文件路径。  \n\n`COPY`指令将从构建上下文目录中<源路径>的文件/目录复制到新的一层的镜像内的<目标路\n径>位置。比如:  \n\n    COPY\tpackage.json\t/usr/src/app/\n    \n`<源路径>`可以是多个，甚至可以是通配符，只要满足`GO`的[filepath.Match](https://golang.org/pkg/path/filepath/#Match)规则，如： \n\n    COPY\thom*\t/mydir/\n    COPY\thom?.txt\t/mydir/\n    \n`<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）       \n\n_注意一点_： \n\n使用\t`COPY`指令,源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。\n   \t\t\n\n### ADD\t更高级的复制文件   \n\n`ADD`指令和`COPY`指令本质上是一样的，只是添加了更多功能。 它的源文件可以是个url，也可以是tar，如果是tar还可以自动解压。  \n\n但是，如果是url，下载下来后，还要新建一层解压，授权，因此不如用`COPY` ，然后用`wget`命令。  \n\n在某个场景下，自动解压缩功能非常有用。 如： \n\n    FROM\tscratch\n    ADD\tubuntu-xenial-core-cloudimg-amd64-root.tar.gz\t/\n    ...\n    \n_注意_：  \n\n在`COPY`\t和`ADD`指令中选择的时候,可以遵循这样的原则,所有的文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD。 \n\n### CMD容器启动命令\n\n也有两种格式：\n\n- `shell`格式：`CMD <命令>`\n- `exec`格式：`CMD\t[\"可执行文件\",\t\"参数1\",\t\"参数2\"...]`    \n- 参数列表格式: \t`CMD\t[\"参数1\",\t\"参数2\"...]`\t 。在指定了`ENTRYPOINT`指令后,用`CMD`指定具体的参数。\n\n在指令格式上，推荐`exec`格式。  \n\nDocker不是虚拟机，只是一个进程。因此，在容器中启动程序，不要以后台形式启动，要以前台形式启动。   \n容器内没有后台概念。 \n\n不要这样启动：\n\n`CMD service ginx start`\n\n直接启动可执行文件，并以前台形式启动：\n\n`CMD [\"nginx\",\"-g\",\"daemon off;\"]`\n\n### ENTRYPOINT入口点\n\n也分为：`exec`格式和`shell`格式\n\n当指定了`ENTRYPOINT`后，就会把`CMD`的内容作为参数传给`ENTRYPOINT\t`指令，换句话说实际执行时，将变为：\n\n    <ENTRYPOINT>\t\"<CMD>\"\n\n_场景一_：\n把镜像当成命令一样使用。\n\n    FROM\tubuntu:16.04\n    RUN\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\tcurl\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\n    CMD\t[\t\"curl\",\t\"-s\",\t\"http://ip.cn\"\t]\n    \n执行：\n\n    $\tdocker\trun\tmyip\n    当前\tIP:61.148.226.66\t来自:北京市\t联通    \n\n再执行：\n    \n    $\tdocker\trun\tmyip\t-i\n    docker:\tError\tresponse\tfrom\tdaemon:\tinvalid\theader\tfield\tvalue\t\"oci\truntime\terror:\tcon\n    tainer_linux.go:247:\tstarting\tcontainer\tprocess\tcaused\t\\\"exec:\t\\\\\\\"-i\\\\\\\":\texecutable\t\n    file\tnot\tfound\tin\t$PATH\\\"\\n\".\n\n可以看到，报错了，因为`-i`不能参数不能传到`CMD`上去。\n\n正确方式：\n\n    FROM\tubuntu:16.04\n    RUN\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\tcurl\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\n    ENTRYPOINT\t[\t\"curl\",\t\"-s\",\t\"http://ip.cn\"\t]\n    \n执行：\n\n    $\tdocker\trun\tmyip\n    当前\tIP:61.148.226.66\t来自:北京市\t联通\n    \n    $\tdocker\trun\tmyip\t-i\n    HTTP/1.1\t200\tOK\n    Server:\tnginx/1.8.0\n    Date:\tTue,\t22\tNov\t2016\t05:12:40\tGMT\n    Content-Type:\ttext/html;\tcharset=UTF-8\n    Vary:\tAccept-Encoding\n    X-Powered-By:\tPHP/5.6.24-1~dotdeb+7.1\n    X-Cache:\tMISS\tfrom\tcache-2\n    X-Cache-Lookup:\tMISS\tfrom\tcache-2:80\n    X-Cache:\tMISS\tfrom\tproxy-2_6\n    Transfer-Encoding:\tchunked\n    Via:\t1.1\tcache-2:80,\t1.1\tproxy-2_6:8006\n    Connection:\tkeep-alive\n    当前\tIP:61.148.226.66\t来自:北京市\t联通\n    \n可以看到,这次成功了。这是因为当存在`ENTRYPOINT`后,`CMD`的内容将会作为参数传给`ENTRYPOINT`,而这里`-i`就是新的`CMD`,因此会作为参数传给`curl`,从而达到了我们预`期的效果。      \n\n_场景二_：\n\n在应用程序启动前等做一些初始化工作。 \n\n比如启动redis，不以`root`，而以`redis`用户身份启动。 \n\n    FROM alpine:3.4\n    ...\n    RUN addgroup -S\tredis && adduser -S -G redis redis\n    ...\n    ENTRYPOINT [\"docker-entrypoint.sh\"]\n    EXPOSE\t6379\n    CMD [\"redis-server\"]\n    \n可以看到其中为了`redis`服务创建了`redis\t`用户,并在最后指定了`ENTRYPOINT`为`docker-entrypoint.sh`脚本。   \n\n    #!/bin/sh\n    ...\n    #allow the container to be started with\t`--user`\n    if [\"$1\" = 'redis-server' -a \"$(id -u)\"\t= '0'];\tthen\n    \t\t\t\tchown -R redis\t.\n    \t\t\t\texec su-exec redis \"$0\" \"$@\"\n    fi\n    exec \"$@\"\n    \n执行：\n\n    $ docker run -it redis id\n    uid=0(root) gid=0(root) groups=0(root)\n    \n### ENV\t设置环境变量\n\n格式有两种:\n\n- `ENV\t<key>\t<value>\t`    \n- `\tENV\t<key1>=<value1>\t<key2>=<value2>...`  \n\n如：\n    \n    ENV\tVERSION=1.0\tDEBUG=on \\\n    \tNAME=\"Happy\tFeet\"   \n    \t\n这里展示了用法，还展示了换行，有空格的话用双引号。 \n\n定义了变量，后面的命令中就可以使用了。可以使用它的命令如下一些： \n\n    ADD\t 、 \tCOPY\t 、 \tENV\t 、 \tEXPOSE\t 、 \tLABEL\t 、 \tUSER\t 、 \tWORKDIR\t 、 \tVOLUME\t 、 \tSTOPSIGNAL\t 、 \tONBU\n    ILD\t\n    \nnode官方Dockerfile例子：\n\n    ENV\tNODE_VERSION\t7.2.0\n    RUN\tcurl\t-SLO\t\"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta\n    r.xz\"\t\\\n    \t\t&&\tcurl\t-SLO\t\"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\"\t\\\n    \t\t&&\tgpg\t--batch\t--decrypt\t--output\tSHASUMS256.txt\tSHASUMS256.txt.asc\t\\\n    \t\t&&\tgrep\t\"\tnode-v$NODE_VERSION-linux-x64.tar.xz\\$\"\tSHASUMS256.txt\t|\tsha256sum\t-c\t-\t\\\n    \t\t&&\ttar\t-xJf\t\"node-v$NODE_VERSION-linux-x64.tar.xz\"\t-C\t/usr/local\t--strip-components=\n    1\t\\\n    \t\t&&\trm\t\"node-v$NODE_VERSION-linux-x64.tar.xz\"\tSHASUMS25    \n    \t\n可以看到，定义了变量，后面就可以不断重复引入使用。改变的时候，只需要改一个地方。同时可以创建不同的多个镜像。 \n\n### ARG\t构建参数\n\n构建参数和`ENV`的效果一样,都是设置环境变量。所不同的是,`ARG`所设置的构建环境的环境变量,在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用`ARG`保存密码之类的信息,因为`docker\thistory`还是可以看到所有值的。 \n\n### VOLUME\t定义匿名卷\n\n两种格式：\n\n- `VOLUME\t[\"<路径1>\",\t\"<路径2>\"...]`\n- `VOLUME\t<路径>`\n\n不应该在容器存储层发生写操作。这样容器就能保持无状态的。对于动态数据，文件，我们应该保存到卷中。为了防止用户在运行时将动态文件写到存储层， \n所以要预先指定动态文件写入的目录挂载为卷，如下： \n\n    VOLUME\t/data\n    \n这里，指定`/data`为匿名卷，任何写入该目录下的数据都不会写入到容器存储层。这样容器就是无状态的。可以运行时替换掉所挂载卷： \n\n    docker\trun\t-d\t-v\tmydata:/data\txxxx\n    \n在这行命令中,就使用了`mydata`这个命名卷挂载到了`/data`这个位置,替代了`Dockerfile`中定义的匿名卷的挂载配置。  \n\n### EXPOSE\t声明端口\n\n格式：`EXPOSE\t<端口1>\t[<端口2>...]\t`    \n\n`EXPOSE`指令是声明运行时容器提供服务端口,这只是一个声明,在运行时并不会因为这个声明应用就会开启这个端口的服务。   \n\n要将`EXPOSE`和在运行时使用`-p\t<宿主端口>:<容器端口>`区分开来。`-p\t`,是映射宿主端口和容器端口,换句话说,就是将容器的对应端口服务公开给外界访问,而`EXPOSE`仅仅是声明容器打算使用什么端口而已,并不会自动在宿主进行端口映射。\n\n### WORKDIR指定工作目录\n\n格式：`WORKDIR\t<工作目录路径>`\n\n该命令可以指定工作目录（当前目录），后面各层都使用该指定目录。该目录如果不存在，则会创建空目录。\n\n写`Dockerfile`千万不能按照`shell`的思维写，应为`docker`是分层的。比如下面错误写法：\n\n     RUN cd /app\n     RUN echo \"hello\" > world.txt\n     \n构建后，你会发现找不到`/app/world.txt`文件。原因是：在`shell`中执行命令，是在同一进程中，操作的是同样的内存。但是在`docker`中不是。你知道，每一个`RUN`命令都是构建一层的，启动不同的容器。第一次`RUN`只是操作进入`/app`目录，没有操作任何文件变更，只是内存的变化而已，第二次启动了个新的容器，跟第一层的容器完全没关系了。\n所以：在写`Dockerfile`到时候，一定要有分层的思维，每一个完整的操作要在同一层里面做。\n\n如果要改变以后各层的工作目录都在指定的工作目录，那么`WORKDIR`指令就派上用场了。\n\n### `USER`指定当前用户\n\n格式:`USER <用户名>`  用户名系统已经添加好\n\n和`WORKDIR`一样，都会影响后面的每一层。改变执行后面命令的执行身份。\n\n下面建立用户，并切换到该用户，启动`redis`：\n\n    RUN groupadd -r redis && useradd -r -g redis edis\n    USER redis\n    RUN [\"redis-server\"]\n\n如果以`root`执行脚本，在执行期间想切换用户，可以参考下面做法：\n\n    # 建立redis用户,并使用gosu换另一个用户执行命令\n    RUN groupadd -r redis && useradd -r -g redis redis\n    #下载gosu\n    RUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.7/\n    gosu-amd64\" \\\n        && chmod +x /usr/local/bin/gosu\t\\\n            && gosu nobody true\n    #设置CMD,并以另外的用户执行\n    CMD [\"exec\",\"gosu\",\"redis\",\"redis-server\"]\n    \n`gosu`使用更多信息参考：https://github.com/tianon/gosu\n\n### HEALTHCHECK 健康检查    \n\n格式：\n- `HEALTHCHECK [选项] CMD <命令>`:设置检查容器健康状况的命令\t\n- `HEALTHCHECK NONE`:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。\n\n该指令是告诉`Docker`应该如何进行判断容器的状态是否正常。\n\n### ONBUILD\t为他人做嫁衣裳\n\n格式: `ONBUILD <其它指令>\t`\n\n`ONBUILD` 后面的指令，在当前镜像构建的时候是不会执行的，只有以它所在的镜像为基础镜像的镜像在构建的时候才会执行。 \n\n`Docker`中其它的命令都是为了定制当前的镜像准备的，只有`ONBUILD`是为了他人而准备。   \n\n所以，这里就可以看出，该指令可以用来做命令的继承。类似`maven`中的父`pom`。把`ONBUILD`后面的命令都看做各个子`Dockerfile`的共用命令。\n\n    FROM node:slim\n    RUN mkdir /app\n    WORKDIR\t/app\n    ONBUILD\tCOPY ./package.json /app\n    ONBUILD RUN [\"npm\",\t\"install\"]\n    ONBUILD\tCOPY . /app/\n    CMD [\"npm\", \"start\"]\n    \n 后面每一个子`Dockerfile`只需要以上面镜像伟基础镜像:\n \n    FROM my-node  \n    \n这样，`ONBUILD`后面的指令都会在每个子`Dockerfile`中执行。     \n\n\n## 删除本地镜像\n\n可以使用命令`docker rmi`，格式：\n\n    `docker\trmi\t[选项]\t<镜像1>\t[<镜像2>\t...]`\n    \n    _注意_: docker rm 命令是删除容器,不要混淆。\n\n可以用ID、镜像名、摘要删除镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker images\n    [sudo] password for mutian: \n    REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\n    mysql/mysql-server   latest              02d081b9c73e        2 months ago        300MB\n    nginx                v3                  b92f375b41f0        4 months ago        109MB\n    nginx                v2                  e8023c09eed5        4 months ago        109MB\n    nginx                latest              e548f1a579cf        4 months ago        109MB\n    centos               latest              ff426288ea90        5 months ago        207MB\n    hello-world          latest              f2a91732366c        7 months ago        1.85kB\n    season/fastdfs       latest              c6cc94c34f8e        2 years ago         205MB\n\n1. 用短id删除，人工输入的时候使用，方便：\n\n`$\tdocker\trmi\tff4`\n\n2. 用长id，一般使用脚本的时候：\n\n`$\tdocker\trmi\tf2a91732366c`\n\n3. 用镜像名,`<仓库名>:<标签>`：\n\n`docker\trmi\tnginx：v3`\n\n4. 使用摘要，最精确： \n    \n查看摘要：\n    \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker images --digests\n    REPOSITORY           TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\n    mysql/mysql-server   latest              sha256:f1cb1e3f0124601b1496f485e9f4401ad10138294b5a38d932089daafd555e34   02d081b9c73e        2 months ago        300MB\n    nginx                v3                  <none>                                                                    b92f375b41f0        4 months ago        109MB\n    nginx                v2                  <none>                                                                    e8023c09eed5        4 months ago        109MB\n    nginx                latest              sha256:4771d09578c7c6a65299e110b3ee1c0a2592f5ea2618d23e4ffe7a4cab1ce5de   e548f1a579cf        4 months ago        109MB\n    centos               latest              sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce   ff426288ea90        5 months ago        207MB\n    hello-world          latest              sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7   f2a91732366c        7 months ago        1.85kB\n    season/fastdfs       latest              sha256:408acdebaa278e8ed875f7c63aa0c7ac8e633cf92f615d8295d279e137217003   c6cc94c34f8e        2 years ago         205MB\n\n    \n删除：\n\n    docker rmi centos@sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n \n\n### Untagged和Deleted\n\n仔细观察，发现两种删除行为。\n\n实际上，镜像都是一层层的，一个镜像有多个标签，只有每个标签都取消了，才有可能删除镜像。删除的时候从上最上层往下，逐步判断删除。 \n\n### 用`docker images`命令来配合\n\n配合`docker\timages\t-q`，可以成批的删除你想要删除的镜像，可以指定你想要删除的镜像。\n\n删除虚悬镜像：\n\n`$\tdocker\trmi\t$(docker\timages\t-q\t-f\tdangling=true)`\n\n删除所有仓库名为redis的镜像:\n\n`$\tdocker\trmi\t$(docker\timages\t-q\tredis)`\n\n删除所有在mongo:3.2之前的镜像:\n\n`$\tdocker\trmi\t$(docker\timages\t-q\t-f\tbefore=mongo:3.2)`\n\n\n### docker image\n\n后面版本，推荐使用`docker image`来管理镜像。\n\n如删除：\n\n`$\tdocker\timage\trm`\n\n## 镜像的实现原理\n\n[UnionFS](https://en.wikipedia.org/wiki/UnionFS)\n\n## 配置镜像加速器\n\n注册阿里云账号后，即可在阿里云控制台（https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。\n\n{% asset_img yy.png %}\n\n按照上图说明配置即可。 \n\n   ","source":"_posts/docker-lesson3-images.md","raw":"---\ntitle: docker学习-第三课：镜像\ndate: 2018-02-02 21:36:08\ncategories: docker\ntags: docker镜像\n---\n\nDocker\t运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker\t会从镜像仓库下载(默认是\nDocker\tHub\t公共注册服务器中的仓库)。\n\n本章将介绍更多关于镜像的内容,包括:\n- 从仓库获取镜像;\n- 管理本地主机上的镜像;\n- 介绍镜像实现的基本原理。\n\n## 获取镜像\n\n在官方[Docker Hub](https://hub.docker.com/explore/)有大量高质量可用镜像。下面我们来看怎样获取这些镜像。\n\n从Docker\t镜像仓库获取镜像的命令是docker\tpull。其命令格式为: \n\n    docker pull\t[选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n具体的先选可以通过`docker pull\t--help`命令查看。镜像名称的格式：\n\n- Docker 镜像仓库地址:地址的格式一般是`<域名/IP>[:端口号]`。默认地址是Docker Hub。\n- 仓库名:如之前所说,这里的仓库名是两段式名称,即`<用户名>/<软件名>`。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。\n\n比如:\n\n    $\tdocker\tpull\tubuntu:16.04\n    16.04:\tPulling\tfrom\tlibrary/ubuntu\n    bf5d46315322:\tPull\tcomplete\n    9f13e0ac480c:\tPull\tcomplete\n    e8988b5b3097:\tPull\tcomplete\n    40af181810e7:\tPull\tcomplete\n    e6f7c7e5c03e:\tPull\tcomplete\n    Digest:\tsha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\n    Status:\tDownloaded\tnewer\timage\tfor\tubuntu:16.04\n    \n上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04\t,因此将会获取官方镜像library/ubuntu\t仓库中标签为16.04的镜像。    \n\n例子： \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n    [sudo] password for mutian: \n    Using default tag: latest\n    latest: Pulling from library/centos\n    af4b0a2388c6: Pull complete \n    Digest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n    Status: Downloaded newer image for centos:latest\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n\n## 运行\n\n有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。\n\n`sudo docker run -it --rm centos bash`\n\n    [root@5f6c0a6b41c1 ~]# cat /etc/os-release \n    NAME=\"CentOS Linux\"\n    VERSION=\"7 (Core)\"\n    ID=\"centos\"\n    ID_LIKE=\"rhel fedora\"\n    VERSION_ID=\"7\"\n    PRETTY_NAME=\"CentOS Linux 7 (Core)\"\n    ANSI_COLOR=\"0;31\"\n    CPE_NAME=\"cpe:/o:centos:centos:7\"\n    HOME_URL=\"https://www.centos.org/\"\n    BUG_REPORT_URL=\"https://bugs.centos.org/\"\n    \n    CENTOS_MANTISBT_PROJECT=\"CentOS-7\"\n    CENTOS_MANTISBT_PROJECT_VERSION=\"7\"\n    REDHAT_SUPPORT_PRODUCT=\"centos\"\n    REDHAT_SUPPORT_PRODUCT_VERSION=\"7\"\n    \n    [root@5f6c0a6b41c1 ~]# \n\n通过上面信息我们可以看到容器内系统信息。\n\n命令说明：\n\n`docker\trun`就是运行容器的命令,具体格式我们会在\t容器\t一节进行详细讲解,我们这里简要的说明一下上面用到的参数。\n\n- `-it`:这是两个参数,一个是`-i`:交互式操作,一个是`-t`终端。我们这里打算进入`bash`执行一些命令并查看返回结果,因此我们需要交互式终端。\n- `--rm`:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动`docker\trm`。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用`--rm`可以避免浪费空间。\n- `centos`:这是指用`centos`镜像为基础来启动容器。\n- `bash`:放在镜像名后的是命令,这里我们希望有个交互式`Shell`,因此用的是`bash`。\n\n进入系统后我们可以执行任何linux下的命令。\n\n最后我们通过`exit`退出了这个容器。\n退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了`--rm`命令。\n\n## 列出所有的镜像\n\n想列出所有已经下载的镜像，可以使用命令`docker\timage ls`\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    [sudo] password for mutian: \n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest              f2a91732366c        3 months ago        1.85kB\n\n\n上面列表包含了`仓库名`、`标签`、`镜像ID`、`创建时间`以及所占用空间。\n镜像\tID\t则是镜像的唯一标识,一个镜像可以对应多个标签。\n\n- 镜像体积SIZE：\n上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比\n每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。\n\n你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\n    TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\n    Images              2                   1                   207.2MB             207.2MB (99%)\n    Containers          1                   0                   0B                  0B\n    Local Volumes       0                   0                   0B                  0B\n    Build Cache \n\n\n- 虚悬镜像\n\n{%asset_img a.png %}\n\n如上图，命令查出来的就是虚悬镜像。其产生的原因是：\n由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。\n\n这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：\n\n    $ sudo docker image\tprune\n\n- 中间层镜像\n为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可\n能会看到一些依赖的中间层镜像。默认的`docker image\tls`列表中只会显示顶层镜像,如果\n希望显示包括中间层镜像在内的所有镜像的话,需要加\t`-a`参数。\n\n\n    $ sudo docker image ls -a\n\n这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 \n\n- 列出部分镜像\n上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。\n\n根据仓库名称列出镜像：\n    \n    sudo docker image ls centos\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n\n列出特定的某个镜像,也就是说指定仓库名和标签\n\n{%asset_img b.png%}\n\n过滤查找镜像，使用`--filter`。具体使用请百度。\n\n- 以特定格式显示\n\n只显示ID列：\n\n    sudo docker image ls -q\n    ff426288ea90\n    f2a91732366c\n\n用go模板语法定制格式显示\n比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"{{.ID}}:{{.Repository}}\"\n    ff426288ea90:centos\n    f2a91732366c:hello-world\n\n或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n    IMAGE ID            REPOSITORY          TAG\n    ff426288ea90        centos              latest\n    f2a91732366c        hello-world         latest\n\n## 删除本地镜像\n\n可以使用`docker\timage\trm`命令来删除本地镜像。格式如下：\n\n    $\tdocker image rm [选项] <镜像1> [<镜像2> ...]\n\n- 用\tID、镜像名、摘要删除镜像\n\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest        \n\n    #删除hello-world，段id，id一部分，能区分就行。\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n\n用仓库名删除：\n    \n    $ sudo docker image\trm\thello-world    \n\n当然,更精确的是使用镜像摘要删除镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n\n- 用\t`docker\timage\tls`命令来配合\n\n比如,我们需要删除所有仓库名为redis的镜像:\n\n    $ docker image rm $(docker image ls -q redis)\n\n## 利用commit理解镜像构成\n镜像是一层一层构成的。\n\n现在让我们以定制一个Web\t服务器为例子,来讲解镜像是如何构建的。\n\n    docker run --name webserver -d -p 80:80 nginx\n\n在浏览器可查看：\n\n{%asset_img c.png%}\n\n现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎\tDocker的文字,我们可以使用`docker\texec`命令进入容器,修改其内容 \n\n    > sudo docker exec -it webserver bash\n    root@3729b97e8226:/# echo '<h1>Hello,Docker!</h1>' >\t/usr/share/nginx/html/index.html\n    root@3729b97e8226:/#\texit\n\n然后刷新浏览器，就可以看到更改了。\n\n我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过`docker\tdiff`命令看到具体的改动。\n\n下面我们可以用下面的命令将容器保存为镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n    > --author \"zmt\" \\\n    > --message \"修改了默认页面\" \\\n    > webserver \\\n    > nginx:v2\n    sha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n    \n    #查看\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               v2                  e8023c09eed5        8 seconds ago       109MB\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest  \n\n查看镜像内历史记录：\n\n    $ docker history nginx:v2\n\n新的镜像定制好后,我们可以来运行这个镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n\n\n在浏览器查看：http://localhost:81/\n\n停止容器：`sudo docker kill --signal=SIGINT web2`\n    \n至此,我们第一次完成了定制镜像,使用的是`docker\tcommit`命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。\n\n> 注意：通常不会使用`docker commit`来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。\n\n## 使用Dockerfile定制镜像\n从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。\n\nDockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,\n因此每一条指令的内容,就是描述该层应当如何构建。\n\n### 简单例子：\n\n1.创建Dockerfile文件\n\n    mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\n    mutian@mutian-ThinkPad-T440p:~$ cd mynginx/\n    mutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n\n2.打开Dockerfile文件，编辑如下内容：\n    \n    FROM nginx\n    RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n\n3.构建镜像\n进入Dockerfile所在目录，执行命令：\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\n    Sending build context to Docker daemon  2.048kB\n    Step 1/2 : FROM nginx\n     ---> e548f1a579cf\n    Step 2/2 : RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n     ---> Running in d8c0149adf7e\n    Removing intermediate container d8c0149adf7e\n     ---> b92f375b41f0\n    Successfully built b92f375b41f0\n    Successfully tagged nginx:v3\n\n4.查看\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\n    nginx               v3                  b92f375b41f0        About a minute ago   109MB\n    nginx               v2                  e8023c09eed5        17 hours ago         109MB\n    nginx               latest              e548f1a579cf        8 days ago           109MB\n    centos              latest              ff426288ea90        7 weeks ago          207MB\n    hello-world         latest              f2a91732366c        3 months ago    \n    \n我们看到，TAG为v3的镜像就是我们刚才构建。    \n\n### FROM指定基础镜像\n\n定制镜像必须是以一个镜像为基础来构建，基础镜像是必须要指定的，而FROM命令就是指定基础镜像，且第一步就要指定。   \n\n除了选择一些先前定制好的镜像作为基础镜像，Docker还存在一个特殊的镜像，名为`scratch`，表示空镜像，是个虚拟的概念，不实际存在。\n\n    FROM\tscratch\n    ...\n    \n如果以`scratch`为基础，则意味着不以任何镜像为基础，后面所写的命令将作为镜像的第一层存在。\n\n对于一些二进制的可执行文件，直接最为第一层存在，不依赖其它运行时系统支持，可以用空镜像。类似go语言编译的程序。\n\n### RUN 执行命令\n\nRUN命令是用来执行命令行命令的，就像shell脚本一样，用来执行linux命令。\n\n注意避免错误：\n\n    FROM\tdebian:jessie\n    RUN\tapt-get\tupdate\n    RUN\tapt-get\tinstall\t-y\tgcc\tlibc6-dev\tmake\n    RUN\twget\t-O\tredis.tar.gz\t\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\n    RUN\tmkdir\t-p\t/usr/src/redis\n    RUN\ttar\t-xzf\tredis.tar.gz\t-C\t/usr/src/redis\t--strip-components=1\n    RUN\tmake\t-C\t/usr/src/redis\n    RUN\tmake\t-C\t/usr/src/redis\tinstall\n    \n每一个指令都会创建一层，每层都会带有上层垃圾，因此一定要避免这样写。正确的写法如下： \n\n    FROM\tdebian:jessie\n    RUN\tbuildDeps='gcc\tlibc6-dev\tmake'\t\\\n    \t\t\t\t&&\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\t$buildDeps\t\\\n    \t\t\t\t&&\twget\t-O\tredis.tar.gz\t\"http://download.redis.io/releases/redis-3.2.5.tar.gz\"\t\\\n    \t\t\t\t&&\tmkdir\t-p\t/usr/src/redis\t\\\n    \t\t\t\t&&\ttar\t-xzf\tredis.tar.gz\t-C\t/usr/src/redis\t--strip-components=1\t\\\n    \t\t\t\t&&\tmake\t-C\t/usr/src/redis\t\\\n    \t\t\t\t&&\tmake\t-C\t/usr/src/redis\tinstall\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\t\\\n    \t\t\t\t&&\trm\tredis.tar.gz\t\\\n    \t\t\t\t&&\trm\t-r\t/usr/src/redis\t\\\n    \t\t\t\t&&\tapt-get\tpurge\t-y\t--auto-remove\t$buildDeps\n    \t\t\t\t\n用了`&&`，这和`shell`执行命令一样，就相当一个命令，所以算一层。执行完后，一定要记得删除不必要的垃圾数据，垃圾包。  \n在编写`Dockerfile`时候，一定要面向类似事件的思维，比如，安装redis环境，是一个事件，算一层。安装mysql，算一个事件，一层。  \n\n## Dockerfile指令详解 \n\n上面我们已经了解了`From`、`RUN`指令，下面我们来介绍其余的……\n\n### COPY复制文件\n\n格式：\n\n- `COPY\t<源路径>...\t<目标路径>`\n\n- `COPY\t[\"<源路径1>\",...\t\"<目标路径>\"]`\n\n源路径指当前电脑系统文件路径，目标路径指容器的文件路径。  \n\n`COPY`指令将从构建上下文目录中<源路径>的文件/目录复制到新的一层的镜像内的<目标路\n径>位置。比如:  \n\n    COPY\tpackage.json\t/usr/src/app/\n    \n`<源路径>`可以是多个，甚至可以是通配符，只要满足`GO`的[filepath.Match](https://golang.org/pkg/path/filepath/#Match)规则，如： \n\n    COPY\thom*\t/mydir/\n    COPY\thom?.txt\t/mydir/\n    \n`<目标路径>` 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）       \n\n_注意一点_： \n\n使用\t`COPY`指令,源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。\n   \t\t\n\n### ADD\t更高级的复制文件   \n\n`ADD`指令和`COPY`指令本质上是一样的，只是添加了更多功能。 它的源文件可以是个url，也可以是tar，如果是tar还可以自动解压。  \n\n但是，如果是url，下载下来后，还要新建一层解压，授权，因此不如用`COPY` ，然后用`wget`命令。  \n\n在某个场景下，自动解压缩功能非常有用。 如： \n\n    FROM\tscratch\n    ADD\tubuntu-xenial-core-cloudimg-amd64-root.tar.gz\t/\n    ...\n    \n_注意_：  \n\n在`COPY`\t和`ADD`指令中选择的时候,可以遵循这样的原则,所有的文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD。 \n\n### CMD容器启动命令\n\n也有两种格式：\n\n- `shell`格式：`CMD <命令>`\n- `exec`格式：`CMD\t[\"可执行文件\",\t\"参数1\",\t\"参数2\"...]`    \n- 参数列表格式: \t`CMD\t[\"参数1\",\t\"参数2\"...]`\t 。在指定了`ENTRYPOINT`指令后,用`CMD`指定具体的参数。\n\n在指令格式上，推荐`exec`格式。  \n\nDocker不是虚拟机，只是一个进程。因此，在容器中启动程序，不要以后台形式启动，要以前台形式启动。   \n容器内没有后台概念。 \n\n不要这样启动：\n\n`CMD service ginx start`\n\n直接启动可执行文件，并以前台形式启动：\n\n`CMD [\"nginx\",\"-g\",\"daemon off;\"]`\n\n### ENTRYPOINT入口点\n\n也分为：`exec`格式和`shell`格式\n\n当指定了`ENTRYPOINT`后，就会把`CMD`的内容作为参数传给`ENTRYPOINT\t`指令，换句话说实际执行时，将变为：\n\n    <ENTRYPOINT>\t\"<CMD>\"\n\n_场景一_：\n把镜像当成命令一样使用。\n\n    FROM\tubuntu:16.04\n    RUN\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\tcurl\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\n    CMD\t[\t\"curl\",\t\"-s\",\t\"http://ip.cn\"\t]\n    \n执行：\n\n    $\tdocker\trun\tmyip\n    当前\tIP:61.148.226.66\t来自:北京市\t联通    \n\n再执行：\n    \n    $\tdocker\trun\tmyip\t-i\n    docker:\tError\tresponse\tfrom\tdaemon:\tinvalid\theader\tfield\tvalue\t\"oci\truntime\terror:\tcon\n    tainer_linux.go:247:\tstarting\tcontainer\tprocess\tcaused\t\\\"exec:\t\\\\\\\"-i\\\\\\\":\texecutable\t\n    file\tnot\tfound\tin\t$PATH\\\"\\n\".\n\n可以看到，报错了，因为`-i`不能参数不能传到`CMD`上去。\n\n正确方式：\n\n    FROM\tubuntu:16.04\n    RUN\tapt-get\tupdate\t\\\n    \t\t\t\t&&\tapt-get\tinstall\t-y\tcurl\t\\\n    \t\t\t\t&&\trm\t-rf\t/var/lib/apt/lists/*\n    ENTRYPOINT\t[\t\"curl\",\t\"-s\",\t\"http://ip.cn\"\t]\n    \n执行：\n\n    $\tdocker\trun\tmyip\n    当前\tIP:61.148.226.66\t来自:北京市\t联通\n    \n    $\tdocker\trun\tmyip\t-i\n    HTTP/1.1\t200\tOK\n    Server:\tnginx/1.8.0\n    Date:\tTue,\t22\tNov\t2016\t05:12:40\tGMT\n    Content-Type:\ttext/html;\tcharset=UTF-8\n    Vary:\tAccept-Encoding\n    X-Powered-By:\tPHP/5.6.24-1~dotdeb+7.1\n    X-Cache:\tMISS\tfrom\tcache-2\n    X-Cache-Lookup:\tMISS\tfrom\tcache-2:80\n    X-Cache:\tMISS\tfrom\tproxy-2_6\n    Transfer-Encoding:\tchunked\n    Via:\t1.1\tcache-2:80,\t1.1\tproxy-2_6:8006\n    Connection:\tkeep-alive\n    当前\tIP:61.148.226.66\t来自:北京市\t联通\n    \n可以看到,这次成功了。这是因为当存在`ENTRYPOINT`后,`CMD`的内容将会作为参数传给`ENTRYPOINT`,而这里`-i`就是新的`CMD`,因此会作为参数传给`curl`,从而达到了我们预`期的效果。      \n\n_场景二_：\n\n在应用程序启动前等做一些初始化工作。 \n\n比如启动redis，不以`root`，而以`redis`用户身份启动。 \n\n    FROM alpine:3.4\n    ...\n    RUN addgroup -S\tredis && adduser -S -G redis redis\n    ...\n    ENTRYPOINT [\"docker-entrypoint.sh\"]\n    EXPOSE\t6379\n    CMD [\"redis-server\"]\n    \n可以看到其中为了`redis`服务创建了`redis\t`用户,并在最后指定了`ENTRYPOINT`为`docker-entrypoint.sh`脚本。   \n\n    #!/bin/sh\n    ...\n    #allow the container to be started with\t`--user`\n    if [\"$1\" = 'redis-server' -a \"$(id -u)\"\t= '0'];\tthen\n    \t\t\t\tchown -R redis\t.\n    \t\t\t\texec su-exec redis \"$0\" \"$@\"\n    fi\n    exec \"$@\"\n    \n执行：\n\n    $ docker run -it redis id\n    uid=0(root) gid=0(root) groups=0(root)\n    \n### ENV\t设置环境变量\n\n格式有两种:\n\n- `ENV\t<key>\t<value>\t`    \n- `\tENV\t<key1>=<value1>\t<key2>=<value2>...`  \n\n如：\n    \n    ENV\tVERSION=1.0\tDEBUG=on \\\n    \tNAME=\"Happy\tFeet\"   \n    \t\n这里展示了用法，还展示了换行，有空格的话用双引号。 \n\n定义了变量，后面的命令中就可以使用了。可以使用它的命令如下一些： \n\n    ADD\t 、 \tCOPY\t 、 \tENV\t 、 \tEXPOSE\t 、 \tLABEL\t 、 \tUSER\t 、 \tWORKDIR\t 、 \tVOLUME\t 、 \tSTOPSIGNAL\t 、 \tONBU\n    ILD\t\n    \nnode官方Dockerfile例子：\n\n    ENV\tNODE_VERSION\t7.2.0\n    RUN\tcurl\t-SLO\t\"https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta\n    r.xz\"\t\\\n    \t\t&&\tcurl\t-SLO\t\"https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc\"\t\\\n    \t\t&&\tgpg\t--batch\t--decrypt\t--output\tSHASUMS256.txt\tSHASUMS256.txt.asc\t\\\n    \t\t&&\tgrep\t\"\tnode-v$NODE_VERSION-linux-x64.tar.xz\\$\"\tSHASUMS256.txt\t|\tsha256sum\t-c\t-\t\\\n    \t\t&&\ttar\t-xJf\t\"node-v$NODE_VERSION-linux-x64.tar.xz\"\t-C\t/usr/local\t--strip-components=\n    1\t\\\n    \t\t&&\trm\t\"node-v$NODE_VERSION-linux-x64.tar.xz\"\tSHASUMS25    \n    \t\n可以看到，定义了变量，后面就可以不断重复引入使用。改变的时候，只需要改一个地方。同时可以创建不同的多个镜像。 \n\n### ARG\t构建参数\n\n构建参数和`ENV`的效果一样,都是设置环境变量。所不同的是,`ARG`所设置的构建环境的环境变量,在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用`ARG`保存密码之类的信息,因为`docker\thistory`还是可以看到所有值的。 \n\n### VOLUME\t定义匿名卷\n\n两种格式：\n\n- `VOLUME\t[\"<路径1>\",\t\"<路径2>\"...]`\n- `VOLUME\t<路径>`\n\n不应该在容器存储层发生写操作。这样容器就能保持无状态的。对于动态数据，文件，我们应该保存到卷中。为了防止用户在运行时将动态文件写到存储层， \n所以要预先指定动态文件写入的目录挂载为卷，如下： \n\n    VOLUME\t/data\n    \n这里，指定`/data`为匿名卷，任何写入该目录下的数据都不会写入到容器存储层。这样容器就是无状态的。可以运行时替换掉所挂载卷： \n\n    docker\trun\t-d\t-v\tmydata:/data\txxxx\n    \n在这行命令中,就使用了`mydata`这个命名卷挂载到了`/data`这个位置,替代了`Dockerfile`中定义的匿名卷的挂载配置。  \n\n### EXPOSE\t声明端口\n\n格式：`EXPOSE\t<端口1>\t[<端口2>...]\t`    \n\n`EXPOSE`指令是声明运行时容器提供服务端口,这只是一个声明,在运行时并不会因为这个声明应用就会开启这个端口的服务。   \n\n要将`EXPOSE`和在运行时使用`-p\t<宿主端口>:<容器端口>`区分开来。`-p\t`,是映射宿主端口和容器端口,换句话说,就是将容器的对应端口服务公开给外界访问,而`EXPOSE`仅仅是声明容器打算使用什么端口而已,并不会自动在宿主进行端口映射。\n\n### WORKDIR指定工作目录\n\n格式：`WORKDIR\t<工作目录路径>`\n\n该命令可以指定工作目录（当前目录），后面各层都使用该指定目录。该目录如果不存在，则会创建空目录。\n\n写`Dockerfile`千万不能按照`shell`的思维写，应为`docker`是分层的。比如下面错误写法：\n\n     RUN cd /app\n     RUN echo \"hello\" > world.txt\n     \n构建后，你会发现找不到`/app/world.txt`文件。原因是：在`shell`中执行命令，是在同一进程中，操作的是同样的内存。但是在`docker`中不是。你知道，每一个`RUN`命令都是构建一层的，启动不同的容器。第一次`RUN`只是操作进入`/app`目录，没有操作任何文件变更，只是内存的变化而已，第二次启动了个新的容器，跟第一层的容器完全没关系了。\n所以：在写`Dockerfile`到时候，一定要有分层的思维，每一个完整的操作要在同一层里面做。\n\n如果要改变以后各层的工作目录都在指定的工作目录，那么`WORKDIR`指令就派上用场了。\n\n### `USER`指定当前用户\n\n格式:`USER <用户名>`  用户名系统已经添加好\n\n和`WORKDIR`一样，都会影响后面的每一层。改变执行后面命令的执行身份。\n\n下面建立用户，并切换到该用户，启动`redis`：\n\n    RUN groupadd -r redis && useradd -r -g redis edis\n    USER redis\n    RUN [\"redis-server\"]\n\n如果以`root`执行脚本，在执行期间想切换用户，可以参考下面做法：\n\n    # 建立redis用户,并使用gosu换另一个用户执行命令\n    RUN groupadd -r redis && useradd -r -g redis redis\n    #下载gosu\n    RUN wget -O /usr/local/bin/gosu \"https://github.com/tianon/gosu/releases/download/1.7/\n    gosu-amd64\" \\\n        && chmod +x /usr/local/bin/gosu\t\\\n            && gosu nobody true\n    #设置CMD,并以另外的用户执行\n    CMD [\"exec\",\"gosu\",\"redis\",\"redis-server\"]\n    \n`gosu`使用更多信息参考：https://github.com/tianon/gosu\n\n### HEALTHCHECK 健康检查    \n\n格式：\n- `HEALTHCHECK [选项] CMD <命令>`:设置检查容器健康状况的命令\t\n- `HEALTHCHECK NONE`:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。\n\n该指令是告诉`Docker`应该如何进行判断容器的状态是否正常。\n\n### ONBUILD\t为他人做嫁衣裳\n\n格式: `ONBUILD <其它指令>\t`\n\n`ONBUILD` 后面的指令，在当前镜像构建的时候是不会执行的，只有以它所在的镜像为基础镜像的镜像在构建的时候才会执行。 \n\n`Docker`中其它的命令都是为了定制当前的镜像准备的，只有`ONBUILD`是为了他人而准备。   \n\n所以，这里就可以看出，该指令可以用来做命令的继承。类似`maven`中的父`pom`。把`ONBUILD`后面的命令都看做各个子`Dockerfile`的共用命令。\n\n    FROM node:slim\n    RUN mkdir /app\n    WORKDIR\t/app\n    ONBUILD\tCOPY ./package.json /app\n    ONBUILD RUN [\"npm\",\t\"install\"]\n    ONBUILD\tCOPY . /app/\n    CMD [\"npm\", \"start\"]\n    \n 后面每一个子`Dockerfile`只需要以上面镜像伟基础镜像:\n \n    FROM my-node  \n    \n这样，`ONBUILD`后面的指令都会在每个子`Dockerfile`中执行。     \n\n\n## 删除本地镜像\n\n可以使用命令`docker rmi`，格式：\n\n    `docker\trmi\t[选项]\t<镜像1>\t[<镜像2>\t...]`\n    \n    _注意_: docker rm 命令是删除容器,不要混淆。\n\n可以用ID、镜像名、摘要删除镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker images\n    [sudo] password for mutian: \n    REPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\n    mysql/mysql-server   latest              02d081b9c73e        2 months ago        300MB\n    nginx                v3                  b92f375b41f0        4 months ago        109MB\n    nginx                v2                  e8023c09eed5        4 months ago        109MB\n    nginx                latest              e548f1a579cf        4 months ago        109MB\n    centos               latest              ff426288ea90        5 months ago        207MB\n    hello-world          latest              f2a91732366c        7 months ago        1.85kB\n    season/fastdfs       latest              c6cc94c34f8e        2 years ago         205MB\n\n1. 用短id删除，人工输入的时候使用，方便：\n\n`$\tdocker\trmi\tff4`\n\n2. 用长id，一般使用脚本的时候：\n\n`$\tdocker\trmi\tf2a91732366c`\n\n3. 用镜像名,`<仓库名>:<标签>`：\n\n`docker\trmi\tnginx：v3`\n\n4. 使用摘要，最精确： \n    \n查看摘要：\n    \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker images --digests\n    REPOSITORY           TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\n    mysql/mysql-server   latest              sha256:f1cb1e3f0124601b1496f485e9f4401ad10138294b5a38d932089daafd555e34   02d081b9c73e        2 months ago        300MB\n    nginx                v3                  <none>                                                                    b92f375b41f0        4 months ago        109MB\n    nginx                v2                  <none>                                                                    e8023c09eed5        4 months ago        109MB\n    nginx                latest              sha256:4771d09578c7c6a65299e110b3ee1c0a2592f5ea2618d23e4ffe7a4cab1ce5de   e548f1a579cf        4 months ago        109MB\n    centos               latest              sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce   ff426288ea90        5 months ago        207MB\n    hello-world          latest              sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7   f2a91732366c        7 months ago        1.85kB\n    season/fastdfs       latest              sha256:408acdebaa278e8ed875f7c63aa0c7ac8e633cf92f615d8295d279e137217003   c6cc94c34f8e        2 years ago         205MB\n\n    \n删除：\n\n    docker rmi centos@sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n \n\n### Untagged和Deleted\n\n仔细观察，发现两种删除行为。\n\n实际上，镜像都是一层层的，一个镜像有多个标签，只有每个标签都取消了，才有可能删除镜像。删除的时候从上最上层往下，逐步判断删除。 \n\n### 用`docker images`命令来配合\n\n配合`docker\timages\t-q`，可以成批的删除你想要删除的镜像，可以指定你想要删除的镜像。\n\n删除虚悬镜像：\n\n`$\tdocker\trmi\t$(docker\timages\t-q\t-f\tdangling=true)`\n\n删除所有仓库名为redis的镜像:\n\n`$\tdocker\trmi\t$(docker\timages\t-q\tredis)`\n\n删除所有在mongo:3.2之前的镜像:\n\n`$\tdocker\trmi\t$(docker\timages\t-q\t-f\tbefore=mongo:3.2)`\n\n\n### docker image\n\n后面版本，推荐使用`docker image`来管理镜像。\n\n如删除：\n\n`$\tdocker\timage\trm`\n\n## 镜像的实现原理\n\n[UnionFS](https://en.wikipedia.org/wiki/UnionFS)\n\n## 配置镜像加速器\n\n注册阿里云账号后，即可在阿里云控制台（https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。\n\n{% asset_img yy.png %}\n\n按照上图说明配置即可。 \n\n   ","slug":"docker-lesson3-images","published":1,"updated":"2018-11-09T01:20:30.062Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38rx00deqcrgrcrtgt55","content":"<p>Docker    运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker    会从镜像仓库下载(默认是<br>Docker    Hub    公共注册服务器中的仓库)。</p>\n<p>本章将介绍更多关于镜像的内容,包括:</p>\n<ul>\n<li>从仓库获取镜像;</li>\n<li>管理本地主机上的镜像;</li>\n<li>介绍镜像实现的基本原理。</li>\n</ul>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>在官方<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>有大量高质量可用镜像。下面我们来看怎样获取这些镜像。</p>\n<p>从Docker    镜像仓库获取镜像的命令是docker    pull。其命令格式为: </p>\n<pre><code>docker pull    [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n</code></pre><p>具体的先选可以通过<code>docker pull    --help</code>命令查看。镜像名称的格式：</p>\n<ul>\n<li>Docker 镜像仓库地址:地址的格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub。</li>\n<li>仓库名:如之前所说,这里的仓库名是两段式名称,即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。</li>\n</ul>\n<p>比如:</p>\n<pre><code>$    docker    pull    ubuntu:16.04\n16.04:    Pulling    from    library/ubuntu\nbf5d46315322:    Pull    complete\n9f13e0ac480c:    Pull    complete\ne8988b5b3097:    Pull    complete\n40af181810e7:    Pull    complete\ne6f7c7e5c03e:    Pull    complete\nDigest:    sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\nStatus:    Downloaded    newer    image    for    ubuntu:16.04\n</code></pre><p>上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04    ,因此将会获取官方镜像library/ubuntu    仓库中标签为16.04的镜像。    </p>\n<p>例子： </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n[sudo] password for mutian: \nUsing default tag: latest\nlatest: Pulling from library/centos\naf4b0a2388c6: Pull complete \nDigest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\nStatus: Downloaded newer image for centos:latest\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。</p>\n<p><code>sudo docker run -it --rm centos bash</code></p>\n<pre><code>[root@5f6c0a6b41c1 ~]# cat /etc/os-release \nNAME=&quot;CentOS Linux&quot;\nVERSION=&quot;7 (Core)&quot;\nID=&quot;centos&quot;\nID_LIKE=&quot;rhel fedora&quot;\nVERSION_ID=&quot;7&quot;\nPRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;\nANSI_COLOR=&quot;0;31&quot;\nCPE_NAME=&quot;cpe:/o:centos:centos:7&quot;\nHOME_URL=&quot;https://www.centos.org/&quot;\nBUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;\n\nCENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;\nCENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;\nREDHAT_SUPPORT_PRODUCT=&quot;centos&quot;\nREDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;\n\n[root@5f6c0a6b41c1 ~]# \n</code></pre><p>通过上面信息我们可以看到容器内系统信息。</p>\n<p>命令说明：</p>\n<p><code>docker    run</code>就是运行容器的命令,具体格式我们会在    容器    一节进行详细讲解,我们这里简要的说明一下上面用到的参数。</p>\n<ul>\n<li><code>-it</code>:这是两个参数,一个是<code>-i</code>:交互式操作,一个是<code>-t</code>终端。我们这里打算进入<code>bash</code>执行一些命令并查看返回结果,因此我们需要交互式终端。</li>\n<li><code>--rm</code>:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动<code>docker    rm</code>。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用<code>--rm</code>可以避免浪费空间。</li>\n<li><code>centos</code>:这是指用<code>centos</code>镜像为基础来启动容器。</li>\n<li><code>bash</code>:放在镜像名后的是命令,这里我们希望有个交互式<code>Shell</code>,因此用的是<code>bash</code>。</li>\n</ul>\n<p>进入系统后我们可以执行任何linux下的命令。</p>\n<p>最后我们通过<code>exit</code>退出了这个容器。<br>退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了<code>--rm</code>命令。</p>\n<h2 id=\"列出所有的镜像\"><a href=\"#列出所有的镜像\" class=\"headerlink\" title=\"列出所有的镜像\"></a>列出所有的镜像</h2><p>想列出所有已经下载的镜像，可以使用命令<code>docker    image ls</code></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n[sudo] password for mutian: \nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest              f2a91732366c        3 months ago        1.85kB\n</code></pre><p>上面列表包含了<code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code>以及所占用空间。<br>镜像    ID    则是镜像的唯一标识,一个镜像可以对应多个标签。</p>\n<ul>\n<li>镜像体积SIZE：<br>上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比<br>每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。</li>\n</ul>\n<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\nTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\nImages              2                   1                   207.2MB             207.2MB (99%)\nContainers          1                   0                   0B                  0B\nLocal Volumes       0                   0                   0B                  0B\nBuild Cache \n</code></pre><ul>\n<li>虚悬镜像</li>\n</ul>\n<img src=\"/2018/02/02/docker-lesson3-images/a.png\">\n<p>如上图，命令查出来的就是虚悬镜像。其产生的原因是：<br>由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。</none></p>\n<p>这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：</p>\n<pre><code>$ sudo docker image    prune\n</code></pre><ul>\n<li>中间层镜像<br>为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可<br>能会看到一些依赖的中间层镜像。默认的<code>docker image    ls</code>列表中只会显示顶层镜像,如果<br>希望显示包括中间层镜像在内的所有镜像的话,需要加    <code>-a</code>参数。</li>\n</ul>\n<pre><code>$ sudo docker image ls -a\n</code></pre><p>这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 </p>\n<ul>\n<li>列出部分镜像<br>上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。</li>\n</ul>\n<p>根据仓库名称列出镜像：</p>\n<pre><code>sudo docker image ls centos\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\n</code></pre><p>列出特定的某个镜像,也就是说指定仓库名和标签</p>\n<img src=\"/2018/02/02/docker-lesson3-images/b.png\">\n<p>过滤查找镜像，使用<code>--filter</code>。具体使用请百度。</p>\n<ul>\n<li>以特定格式显示</li>\n</ul>\n<p>只显示ID列：</p>\n<pre><code>sudo docker image ls -q\nff426288ea90\nf2a91732366c\n</code></pre><p>用go模板语法定制格式显示<br>比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;{{.ID}}:{{.Repository}}&quot;\nff426288ea90:centos\nf2a91732366c:hello-world\n</code></pre><p>或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}&quot;\nIMAGE ID            REPOSITORY          TAG\nff426288ea90        centos              latest\nf2a91732366c        hello-world         latest\n</code></pre><h2 id=\"删除本地镜像\"><a href=\"#删除本地镜像\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用<code>docker    image    rm</code>命令来删除本地镜像。格式如下：</p>\n<pre><code>$    docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]\n</code></pre><ul>\n<li>用    ID、镜像名、摘要删除镜像</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest        \n\n#删除hello-world，段id，id一部分，能区分就行。\nmutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n</code></pre><p>用仓库名删除：</p>\n<pre><code>$ sudo docker image    rm    hello-world    \n</code></pre><p>当然,更精确的是使用镜像摘要删除镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n</code></pre><ul>\n<li>用    <code>docker    image    ls</code>命令来配合</li>\n</ul>\n<p>比如,我们需要删除所有仓库名为redis的镜像:</p>\n<pre><code>$ docker image rm $(docker image ls -q redis)\n</code></pre><h2 id=\"利用commit理解镜像构成\"><a href=\"#利用commit理解镜像构成\" class=\"headerlink\" title=\"利用commit理解镜像构成\"></a>利用commit理解镜像构成</h2><p>镜像是一层一层构成的。</p>\n<p>现在让我们以定制一个Web    服务器为例子,来讲解镜像是如何构建的。</p>\n<pre><code>docker run --name webserver -d -p 80:80 nginx\n</code></pre><p>在浏览器可查看：</p>\n<img src=\"/2018/02/02/docker-lesson3-images/c.png\">\n<p>现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎    Docker的文字,我们可以使用<code>docker    exec</code>命令进入容器,修改其内容 </p>\n<pre><code>&gt; sudo docker exec -it webserver bash\nroot@3729b97e8226:/# echo &apos;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&apos; &gt;    /usr/share/nginx/html/index.html\nroot@3729b97e8226:/#    exit\n</code></pre><p>然后刷新浏览器，就可以看到更改了。</p>\n<p>我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过<code>docker    diff</code>命令看到具体的改动。</p>\n<p>下面我们可以用下面的命令将容器保存为镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n&gt; --author &quot;zmt&quot; \\\n&gt; --message &quot;修改了默认页面&quot; \\\n&gt; webserver \\\n&gt; nginx:v2\nsha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n\n#查看\nmutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               v2                  e8023c09eed5        8 seconds ago       109MB\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest  \n</code></pre><p>查看镜像内历史记录：</p>\n<pre><code>$ docker history nginx:v2\n</code></pre><p>新的镜像定制好后,我们可以来运行这个镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n</code></pre><p>在浏览器查看：<a href=\"http://localhost:81/\" target=\"_blank\" rel=\"noopener\">http://localhost:81/</a></p>\n<p>停止容器：<code>sudo docker kill --signal=SIGINT web2</code></p>\n<p>至此,我们第一次完成了定制镜像,使用的是<code>docker    commit</code>命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。</p>\n<blockquote>\n<p>注意：通常不会使用<code>docker commit</code>来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。</p>\n</blockquote>\n<h2 id=\"使用Dockerfile定制镜像\"><a href=\"#使用Dockerfile定制镜像\" class=\"headerlink\" title=\"使用Dockerfile定制镜像\"></a>使用Dockerfile定制镜像</h2><p>从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。</p>\n<p>Dockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,<br>因此每一条指令的内容,就是描述该层应当如何构建。</p>\n<h3 id=\"简单例子：\"><a href=\"#简单例子：\" class=\"headerlink\" title=\"简单例子：\"></a>简单例子：</h3><p>1.创建Dockerfile文件</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\nmutian@mutian-ThinkPad-T440p:~$ cd mynginx/\nmutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n</code></pre><p>2.打开Dockerfile文件，编辑如下内容：</p>\n<pre><code>FROM nginx\nRUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n</code></pre><p>3.构建镜像<br>进入Dockerfile所在目录，执行命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\nSending build context to Docker daemon  2.048kB\nStep 1/2 : FROM nginx\n ---&gt; e548f1a579cf\nStep 2/2 : RUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n ---&gt; Running in d8c0149adf7e\nRemoving intermediate container d8c0149adf7e\n ---&gt; b92f375b41f0\nSuccessfully built b92f375b41f0\nSuccessfully tagged nginx:v3\n</code></pre><p>4.查看</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\nnginx               v3                  b92f375b41f0        About a minute ago   109MB\nnginx               v2                  e8023c09eed5        17 hours ago         109MB\nnginx               latest              e548f1a579cf        8 days ago           109MB\ncentos              latest              ff426288ea90        7 weeks ago          207MB\nhello-world         latest              f2a91732366c        3 months ago    \n</code></pre><p>我们看到，TAG为v3的镜像就是我们刚才构建。    </p>\n<h3 id=\"FROM指定基础镜像\"><a href=\"#FROM指定基础镜像\" class=\"headerlink\" title=\"FROM指定基础镜像\"></a>FROM指定基础镜像</h3><p>定制镜像必须是以一个镜像为基础来构建，基础镜像是必须要指定的，而FROM命令就是指定基础镜像，且第一步就要指定。   </p>\n<p>除了选择一些先前定制好的镜像作为基础镜像，Docker还存在一个特殊的镜像，名为<code>scratch</code>，表示空镜像，是个虚拟的概念，不实际存在。</p>\n<pre><code>FROM    scratch\n...\n</code></pre><p>如果以<code>scratch</code>为基础，则意味着不以任何镜像为基础，后面所写的命令将作为镜像的第一层存在。</p>\n<p>对于一些二进制的可执行文件，直接最为第一层存在，不依赖其它运行时系统支持，可以用空镜像。类似go语言编译的程序。</p>\n<h3 id=\"RUN-执行命令\"><a href=\"#RUN-执行命令\" class=\"headerlink\" title=\"RUN 执行命令\"></a>RUN 执行命令</h3><p>RUN命令是用来执行命令行命令的，就像shell脚本一样，用来执行linux命令。</p>\n<p>注意避免错误：</p>\n<pre><code>FROM    debian:jessie\nRUN    apt-get    update\nRUN    apt-get    install    -y    gcc    libc6-dev    make\nRUN    wget    -O    redis.tar.gz    &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;\nRUN    mkdir    -p    /usr/src/redis\nRUN    tar    -xzf    redis.tar.gz    -C    /usr/src/redis    --strip-components=1\nRUN    make    -C    /usr/src/redis\nRUN    make    -C    /usr/src/redis    install\n</code></pre><p>每一个指令都会创建一层，每层都会带有上层垃圾，因此一定要避免这样写。正确的写法如下： </p>\n<pre><code>FROM    debian:jessie\nRUN    buildDeps=&apos;gcc    libc6-dev    make&apos;    \\\n                &amp;&amp;    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    $buildDeps    \\\n                &amp;&amp;    wget    -O    redis.tar.gz    &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;    \\\n                &amp;&amp;    mkdir    -p    /usr/src/redis    \\\n                &amp;&amp;    tar    -xzf    redis.tar.gz    -C    /usr/src/redis    --strip-components=1    \\\n                &amp;&amp;    make    -C    /usr/src/redis    \\\n                &amp;&amp;    make    -C    /usr/src/redis    install    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*    \\\n                &amp;&amp;    rm    redis.tar.gz    \\\n                &amp;&amp;    rm    -r    /usr/src/redis    \\\n                &amp;&amp;    apt-get    purge    -y    --auto-remove    $buildDeps\n</code></pre><p>用了<code>&amp;&amp;</code>，这和<code>shell</code>执行命令一样，就相当一个命令，所以算一层。执行完后，一定要记得删除不必要的垃圾数据，垃圾包。<br>在编写<code>Dockerfile</code>时候，一定要面向类似事件的思维，比如，安装redis环境，是一个事件，算一层。安装mysql，算一个事件，一层。  </p>\n<h2 id=\"Dockerfile指令详解\"><a href=\"#Dockerfile指令详解\" class=\"headerlink\" title=\"Dockerfile指令详解\"></a>Dockerfile指令详解</h2><p>上面我们已经了解了<code>From</code>、<code>RUN</code>指令，下面我们来介绍其余的……</p>\n<h3 id=\"COPY复制文件\"><a href=\"#COPY复制文件\" class=\"headerlink\" title=\"COPY复制文件\"></a>COPY复制文件</h3><p>格式：</p>\n<ul>\n<li><p><code>COPY    &lt;源路径&gt;...    &lt;目标路径&gt;</code></p>\n</li>\n<li><p><code>COPY    [&quot;&lt;源路径1&gt;&quot;,...    &quot;&lt;目标路径&gt;&quot;]</code></p>\n</li>\n</ul>\n<p>源路径指当前电脑系统文件路径，目标路径指容器的文件路径。  </p>\n<p><code>COPY</code>指令将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路<br>径&gt;位置。比如:  </p>\n<pre><code>COPY    package.json    /usr/src/app/\n</code></pre><p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，只要满足<code>GO</code>的<a href=\"https://golang.org/pkg/path/filepath/#Match\" target=\"_blank\" rel=\"noopener\">filepath.Match</a>规则，如： </p>\n<pre><code>COPY    hom*    /mydir/\nCOPY    hom?.txt    /mydir/\n</code></pre><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）       </p>\n<p><em>注意一点</em>： </p>\n<p>使用    <code>COPY</code>指令,源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p>\n<h3 id=\"ADD-更高级的复制文件\"><a href=\"#ADD-更高级的复制文件\" class=\"headerlink\" title=\"ADD    更高级的复制文件\"></a>ADD    更高级的复制文件</h3><p><code>ADD</code>指令和<code>COPY</code>指令本质上是一样的，只是添加了更多功能。 它的源文件可以是个url，也可以是tar，如果是tar还可以自动解压。  </p>\n<p>但是，如果是url，下载下来后，还要新建一层解压，授权，因此不如用<code>COPY</code> ，然后用<code>wget</code>命令。  </p>\n<p>在某个场景下，自动解压缩功能非常有用。 如： </p>\n<pre><code>FROM    scratch\nADD    ubuntu-xenial-core-cloudimg-amd64-root.tar.gz    /\n...\n</code></pre><p>_注意_：  </p>\n<p>在<code>COPY</code>    和<code>ADD</code>指令中选择的时候,可以遵循这样的原则,所有的文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD。 </p>\n<h3 id=\"CMD容器启动命令\"><a href=\"#CMD容器启动命令\" class=\"headerlink\" title=\"CMD容器启动命令\"></a>CMD容器启动命令</h3><p>也有两种格式：</p>\n<ul>\n<li><code>shell</code>格式：<code>CMD &lt;命令&gt;</code></li>\n<li><code>exec</code>格式：<code>CMD    [&quot;可执行文件&quot;,    &quot;参数1&quot;,    &quot;参数2&quot;...]</code>    </li>\n<li>参数列表格式:     <code>CMD    [&quot;参数1&quot;,    &quot;参数2&quot;...]</code>     。在指定了<code>ENTRYPOINT</code>指令后,用<code>CMD</code>指定具体的参数。</li>\n</ul>\n<p>在指令格式上，推荐<code>exec</code>格式。  </p>\n<p>Docker不是虚拟机，只是一个进程。因此，在容器中启动程序，不要以后台形式启动，要以前台形式启动。<br>容器内没有后台概念。 </p>\n<p>不要这样启动：</p>\n<p><code>CMD service ginx start</code></p>\n<p>直接启动可执行文件，并以前台形式启动：</p>\n<p><code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></p>\n<h3 id=\"ENTRYPOINT入口点\"><a href=\"#ENTRYPOINT入口点\" class=\"headerlink\" title=\"ENTRYPOINT入口点\"></a>ENTRYPOINT入口点</h3><p>也分为：<code>exec</code>格式和<code>shell</code>格式</p>\n<p>当指定了<code>ENTRYPOINT</code>后，就会把<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令，换句话说实际执行时，将变为：</p>\n<pre><code>&lt;ENTRYPOINT&gt;    &quot;&lt;CMD&gt;&quot;\n</code></pre><p><em>场景一</em>：<br>把镜像当成命令一样使用。</p>\n<pre><code>FROM    ubuntu:16.04\nRUN    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    curl    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*\nCMD    [    &quot;curl&quot;,    &quot;-s&quot;,    &quot;http://ip.cn&quot;    ]\n</code></pre><p>执行：</p>\n<pre><code>$    docker    run    myip\n当前    IP:61.148.226.66    来自:北京市    联通    \n</code></pre><p>再执行：</p>\n<pre><code>$    docker    run    myip    -i\ndocker:    Error    response    from    daemon:    invalid    header    field    value    &quot;oci    runtime    error:    con\ntainer_linux.go:247:    starting    container    process    caused    \\&quot;exec:    \\\\\\&quot;-i\\\\\\&quot;:    executable    \nfile    not    found    in    $PATH\\&quot;\\n&quot;.\n</code></pre><p>可以看到，报错了，因为<code>-i</code>不能参数不能传到<code>CMD</code>上去。</p>\n<p>正确方式：</p>\n<pre><code>FROM    ubuntu:16.04\nRUN    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    curl    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*\nENTRYPOINT    [    &quot;curl&quot;,    &quot;-s&quot;,    &quot;http://ip.cn&quot;    ]\n</code></pre><p>执行：</p>\n<pre><code>$    docker    run    myip\n当前    IP:61.148.226.66    来自:北京市    联通\n\n$    docker    run    myip    -i\nHTTP/1.1    200    OK\nServer:    nginx/1.8.0\nDate:    Tue,    22    Nov    2016    05:12:40    GMT\nContent-Type:    text/html;    charset=UTF-8\nVary:    Accept-Encoding\nX-Powered-By:    PHP/5.6.24-1~dotdeb+7.1\nX-Cache:    MISS    from    cache-2\nX-Cache-Lookup:    MISS    from    cache-2:80\nX-Cache:    MISS    from    proxy-2_6\nTransfer-Encoding:    chunked\nVia:    1.1    cache-2:80,    1.1    proxy-2_6:8006\nConnection:    keep-alive\n当前    IP:61.148.226.66    来自:北京市    联通\n</code></pre><p>可以看到,这次成功了。这是因为当存在<code>ENTRYPOINT</code>后,<code>CMD</code>的内容将会作为参数传给<code>ENTRYPOINT</code>,而这里<code>-i</code>就是新的<code>CMD</code>,因此会作为参数传给<code>curl</code>,从而达到了我们预`期的效果。      </p>\n<p><em>场景二</em>：</p>\n<p>在应用程序启动前等做一些初始化工作。 </p>\n<p>比如启动redis，不以<code>root</code>，而以<code>redis</code>用户身份启动。 </p>\n<pre><code>FROM alpine:3.4\n...\nRUN addgroup -S    redis &amp;&amp; adduser -S -G redis redis\n...\nENTRYPOINT [&quot;docker-entrypoint.sh&quot;]\nEXPOSE    6379\nCMD [&quot;redis-server&quot;]\n</code></pre><p>可以看到其中为了<code>redis</code>服务创建了<code>redis</code>用户,并在最后指定了<code>ENTRYPOINT</code>为<code>docker-entrypoint.sh</code>脚本。   </p>\n<pre><code>#!/bin/sh\n...\n#allow the container to be started with    `--user`\nif [&quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot;    = &apos;0&apos;];    then\n                chown -R redis    .\n                exec su-exec redis &quot;$0&quot; &quot;$@&quot;\nfi\nexec &quot;$@&quot;\n</code></pre><p>执行：</p>\n<pre><code>$ docker run -it redis id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre><h3 id=\"ENV-设置环境变量\"><a href=\"#ENV-设置环境变量\" class=\"headerlink\" title=\"ENV    设置环境变量\"></a>ENV    设置环境变量</h3><p>格式有两种:</p>\n<ul>\n<li><code>ENV    &lt;key&gt;    &lt;value&gt;</code>    </li>\n<li><code>ENV    &lt;key1&gt;=&lt;value1&gt;    &lt;key2&gt;=&lt;value2&gt;...</code>  </li>\n</ul>\n<p>如：</p>\n<pre><code>ENV    VERSION=1.0    DEBUG=on \\\n    NAME=&quot;Happy    Feet&quot;   \n</code></pre><p>这里展示了用法，还展示了换行，有空格的话用双引号。 </p>\n<p>定义了变量，后面的命令中就可以使用了。可以使用它的命令如下一些： </p>\n<pre><code>ADD     、     COPY     、     ENV     、     EXPOSE     、     LABEL     、     USER     、     WORKDIR     、     VOLUME     、     STOPSIGNAL     、     ONBU\nILD    \n</code></pre><p>node官方Dockerfile例子：</p>\n<pre><code>ENV    NODE_VERSION    7.2.0\nRUN    curl    -SLO    &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta\nr.xz&quot;    \\\n        &amp;&amp;    curl    -SLO    &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;    \\\n        &amp;&amp;    gpg    --batch    --decrypt    --output    SHASUMS256.txt    SHASUMS256.txt.asc    \\\n        &amp;&amp;    grep    &quot;    node-v$NODE_VERSION-linux-x64.tar.xz\\$&quot;    SHASUMS256.txt    |    sha256sum    -c    -    \\\n        &amp;&amp;    tar    -xJf    &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;    -C    /usr/local    --strip-components=\n1    \\\n        &amp;&amp;    rm    &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;    SHASUMS25    \n</code></pre><p>可以看到，定义了变量，后面就可以不断重复引入使用。改变的时候，只需要改一个地方。同时可以创建不同的多个镜像。 </p>\n<h3 id=\"ARG-构建参数\"><a href=\"#ARG-构建参数\" class=\"headerlink\" title=\"ARG    构建参数\"></a>ARG    构建参数</h3><p>构建参数和<code>ENV</code>的效果一样,都是设置环境变量。所不同的是,<code>ARG</code>所设置的构建环境的环境变量,在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用<code>ARG</code>保存密码之类的信息,因为<code>docker    history</code>还是可以看到所有值的。 </p>\n<h3 id=\"VOLUME-定义匿名卷\"><a href=\"#VOLUME-定义匿名卷\" class=\"headerlink\" title=\"VOLUME    定义匿名卷\"></a>VOLUME    定义匿名卷</h3><p>两种格式：</p>\n<ul>\n<li><code>VOLUME    [&quot;&lt;路径1&gt;&quot;,    &quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><code>VOLUME    &lt;路径&gt;</code></li>\n</ul>\n<p>不应该在容器存储层发生写操作。这样容器就能保持无状态的。对于动态数据，文件，我们应该保存到卷中。为了防止用户在运行时将动态文件写到存储层，<br>所以要预先指定动态文件写入的目录挂载为卷，如下： </p>\n<pre><code>VOLUME    /data\n</code></pre><p>这里，指定<code>/data</code>为匿名卷，任何写入该目录下的数据都不会写入到容器存储层。这样容器就是无状态的。可以运行时替换掉所挂载卷： </p>\n<pre><code>docker    run    -d    -v    mydata:/data    xxxx\n</code></pre><p>在这行命令中,就使用了<code>mydata</code>这个命名卷挂载到了<code>/data</code>这个位置,替代了<code>Dockerfile</code>中定义的匿名卷的挂载配置。  </p>\n<h3 id=\"EXPOSE-声明端口\"><a href=\"#EXPOSE-声明端口\" class=\"headerlink\" title=\"EXPOSE    声明端口\"></a>EXPOSE    声明端口</h3><p>格式：<code>EXPOSE    &lt;端口1&gt;    [&lt;端口2&gt;...]</code>    </p>\n<p><code>EXPOSE</code>指令是声明运行时容器提供服务端口,这只是一个声明,在运行时并不会因为这个声明应用就会开启这个端口的服务。   </p>\n<p>要将<code>EXPOSE</code>和在运行时使用<code>-p    &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开来。<code>-p</code>,是映射宿主端口和容器端口,换句话说,就是将容器的对应端口服务公开给外界访问,而<code>EXPOSE</code>仅仅是声明容器打算使用什么端口而已,并不会自动在宿主进行端口映射。</p>\n<h3 id=\"WORKDIR指定工作目录\"><a href=\"#WORKDIR指定工作目录\" class=\"headerlink\" title=\"WORKDIR指定工作目录\"></a>WORKDIR指定工作目录</h3><p>格式：<code>WORKDIR    &lt;工作目录路径&gt;</code></p>\n<p>该命令可以指定工作目录（当前目录），后面各层都使用该指定目录。该目录如果不存在，则会创建空目录。</p>\n<p>写<code>Dockerfile</code>千万不能按照<code>shell</code>的思维写，应为<code>docker</code>是分层的。比如下面错误写法：</p>\n<pre><code>RUN cd /app\nRUN echo &quot;hello&quot; &gt; world.txt\n</code></pre><p>构建后，你会发现找不到<code>/app/world.txt</code>文件。原因是：在<code>shell</code>中执行命令，是在同一进程中，操作的是同样的内存。但是在<code>docker</code>中不是。你知道，每一个<code>RUN</code>命令都是构建一层的，启动不同的容器。第一次<code>RUN</code>只是操作进入<code>/app</code>目录，没有操作任何文件变更，只是内存的变化而已，第二次启动了个新的容器，跟第一层的容器完全没关系了。<br>所以：在写<code>Dockerfile</code>到时候，一定要有分层的思维，每一个完整的操作要在同一层里面做。</p>\n<p>如果要改变以后各层的工作目录都在指定的工作目录，那么<code>WORKDIR</code>指令就派上用场了。</p>\n<h3 id=\"USER指定当前用户\"><a href=\"#USER指定当前用户\" class=\"headerlink\" title=\"USER指定当前用户\"></a><code>USER</code>指定当前用户</h3><p>格式:<code>USER &lt;用户名&gt;</code>  用户名系统已经添加好</p>\n<p>和<code>WORKDIR</code>一样，都会影响后面的每一层。改变执行后面命令的执行身份。</p>\n<p>下面建立用户，并切换到该用户，启动<code>redis</code>：</p>\n<pre><code>RUN groupadd -r redis &amp;&amp; useradd -r -g redis edis\nUSER redis\nRUN [&quot;redis-server&quot;]\n</code></pre><p>如果以<code>root</code>执行脚本，在执行期间想切换用户，可以参考下面做法：</p>\n<pre><code># 建立redis用户,并使用gosu换另一个用户执行命令\nRUN groupadd -r redis &amp;&amp; useradd -r -g redis redis\n#下载gosu\nRUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/\ngosu-amd64&quot; \\\n    &amp;&amp; chmod +x /usr/local/bin/gosu    \\\n        &amp;&amp; gosu nobody true\n#设置CMD,并以另外的用户执行\nCMD [&quot;exec&quot;,&quot;gosu&quot;,&quot;redis&quot;,&quot;redis-server&quot;]\n</code></pre><p><code>gosu</code>使用更多信息参考：<a href=\"https://github.com/tianon/gosu\" target=\"_blank\" rel=\"noopener\">https://github.com/tianon/gosu</a></p>\n<h3 id=\"HEALTHCHECK-健康检查\"><a href=\"#HEALTHCHECK-健康检查\" class=\"headerlink\" title=\"HEALTHCHECK 健康检查\"></a>HEALTHCHECK 健康检查</h3><p>格式：</p>\n<ul>\n<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令    </li>\n<li><code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。</li>\n</ul>\n<p>该指令是告诉<code>Docker</code>应该如何进行判断容器的状态是否正常。</p>\n<h3 id=\"ONBUILD-为他人做嫁衣裳\"><a href=\"#ONBUILD-为他人做嫁衣裳\" class=\"headerlink\" title=\"ONBUILD    为他人做嫁衣裳\"></a>ONBUILD    为他人做嫁衣裳</h3><p>格式: <code>ONBUILD &lt;其它指令&gt;</code></p>\n<p><code>ONBUILD</code> 后面的指令，在当前镜像构建的时候是不会执行的，只有以它所在的镜像为基础镜像的镜像在构建的时候才会执行。 </p>\n<p><code>Docker</code>中其它的命令都是为了定制当前的镜像准备的，只有<code>ONBUILD</code>是为了他人而准备。   </p>\n<p>所以，这里就可以看出，该指令可以用来做命令的继承。类似<code>maven</code>中的父<code>pom</code>。把<code>ONBUILD</code>后面的命令都看做各个子<code>Dockerfile</code>的共用命令。</p>\n<pre><code>FROM node:slim\nRUN mkdir /app\nWORKDIR    /app\nONBUILD    COPY ./package.json /app\nONBUILD RUN [&quot;npm&quot;,    &quot;install&quot;]\nONBUILD    COPY . /app/\nCMD [&quot;npm&quot;, &quot;start&quot;]\n</code></pre><p> 后面每一个子<code>Dockerfile</code>只需要以上面镜像伟基础镜像:</p>\n<pre><code>FROM my-node  \n</code></pre><p>这样，<code>ONBUILD</code>后面的指令都会在每个子<code>Dockerfile</code>中执行。     </p>\n<h2 id=\"删除本地镜像-1\"><a href=\"#删除本地镜像-1\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用命令<code>docker rmi</code>，格式：</p>\n<pre><code>`docker    rmi    [选项]    &lt;镜像1&gt;    [&lt;镜像2&gt;    ...]`\n\n_注意_: docker rm 命令是删除容器,不要混淆。\n</code></pre><p>可以用ID、镜像名、摘要删除镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker images\n[sudo] password for mutian: \nREPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\nmysql/mysql-server   latest              02d081b9c73e        2 months ago        300MB\nnginx                v3                  b92f375b41f0        4 months ago        109MB\nnginx                v2                  e8023c09eed5        4 months ago        109MB\nnginx                latest              e548f1a579cf        4 months ago        109MB\ncentos               latest              ff426288ea90        5 months ago        207MB\nhello-world          latest              f2a91732366c        7 months ago        1.85kB\nseason/fastdfs       latest              c6cc94c34f8e        2 years ago         205MB\n</code></pre><ol>\n<li>用短id删除，人工输入的时候使用，方便：</li>\n</ol>\n<p><code>$    docker    rmi    ff4</code></p>\n<ol start=\"2\">\n<li>用长id，一般使用脚本的时候：</li>\n</ol>\n<p><code>$    docker    rmi    f2a91732366c</code></p>\n<ol start=\"3\">\n<li>用镜像名,<code>&lt;仓库名&gt;:&lt;标签&gt;</code>：</li>\n</ol>\n<p><code>docker    rmi    nginx：v3</code></p>\n<ol start=\"4\">\n<li>使用摘要，最精确： </li>\n</ol>\n<p>查看摘要：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker images --digests\nREPOSITORY           TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\nmysql/mysql-server   latest              sha256:f1cb1e3f0124601b1496f485e9f4401ad10138294b5a38d932089daafd555e34   02d081b9c73e        2 months ago        300MB\nnginx                v3                  &lt;none&gt;                                                                    b92f375b41f0        4 months ago        109MB\nnginx                v2                  &lt;none&gt;                                                                    e8023c09eed5        4 months ago        109MB\nnginx                latest              sha256:4771d09578c7c6a65299e110b3ee1c0a2592f5ea2618d23e4ffe7a4cab1ce5de   e548f1a579cf        4 months ago        109MB\ncentos               latest              sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce   ff426288ea90        5 months ago        207MB\nhello-world          latest              sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7   f2a91732366c        7 months ago        1.85kB\nseason/fastdfs       latest              sha256:408acdebaa278e8ed875f7c63aa0c7ac8e633cf92f615d8295d279e137217003   c6cc94c34f8e        2 years ago         205MB\n</code></pre><p>删除：</p>\n<pre><code>docker rmi centos@sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n</code></pre><h3 id=\"Untagged和Deleted\"><a href=\"#Untagged和Deleted\" class=\"headerlink\" title=\"Untagged和Deleted\"></a>Untagged和Deleted</h3><p>仔细观察，发现两种删除行为。</p>\n<p>实际上，镜像都是一层层的，一个镜像有多个标签，只有每个标签都取消了，才有可能删除镜像。删除的时候从上最上层往下，逐步判断删除。 </p>\n<h3 id=\"用docker-images命令来配合\"><a href=\"#用docker-images命令来配合\" class=\"headerlink\" title=\"用docker images命令来配合\"></a>用<code>docker images</code>命令来配合</h3><p>配合<code>docker    images    -q</code>，可以成批的删除你想要删除的镜像，可以指定你想要删除的镜像。</p>\n<p>删除虚悬镜像：</p>\n<p><code>$    docker    rmi    $(docker    images    -q    -f    dangling=true)</code></p>\n<p>删除所有仓库名为redis的镜像:</p>\n<p><code>$    docker    rmi    $(docker    images    -q    redis)</code></p>\n<p>删除所有在mongo:3.2之前的镜像:</p>\n<p><code>$    docker    rmi    $(docker    images    -q    -f    before=mongo:3.2)</code></p>\n<h3 id=\"docker-image\"><a href=\"#docker-image\" class=\"headerlink\" title=\"docker image\"></a>docker image</h3><p>后面版本，推荐使用<code>docker image</code>来管理镜像。</p>\n<p>如删除：</p>\n<p><code>$    docker    image    rm</code></p>\n<h2 id=\"镜像的实现原理\"><a href=\"#镜像的实现原理\" class=\"headerlink\" title=\"镜像的实现原理\"></a>镜像的实现原理</h2><p><a href=\"https://en.wikipedia.org/wiki/UnionFS\" target=\"_blank\" rel=\"noopener\">UnionFS</a></p>\n<h2 id=\"配置镜像加速器\"><a href=\"#配置镜像加速器\" class=\"headerlink\" title=\"配置镜像加速器\"></a>配置镜像加速器</h2><p>注册阿里云账号后，即可在阿里云控制台（<a href=\"https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。\" target=\"_blank\" rel=\"noopener\">https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。</a></p>\n<img src=\"/2018/02/02/docker-lesson3-images/yy.png\">\n<p>按照上图说明配置即可。 </p>\n","site":{"data":{}},"excerpt":"","more":"<p>Docker    运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker    会从镜像仓库下载(默认是<br>Docker    Hub    公共注册服务器中的仓库)。</p>\n<p>本章将介绍更多关于镜像的内容,包括:</p>\n<ul>\n<li>从仓库获取镜像;</li>\n<li>管理本地主机上的镜像;</li>\n<li>介绍镜像实现的基本原理。</li>\n</ul>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>在官方<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>有大量高质量可用镜像。下面我们来看怎样获取这些镜像。</p>\n<p>从Docker    镜像仓库获取镜像的命令是docker    pull。其命令格式为: </p>\n<pre><code>docker pull    [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n</code></pre><p>具体的先选可以通过<code>docker pull    --help</code>命令查看。镜像名称的格式：</p>\n<ul>\n<li>Docker 镜像仓库地址:地址的格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub。</li>\n<li>仓库名:如之前所说,这里的仓库名是两段式名称,即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。</li>\n</ul>\n<p>比如:</p>\n<pre><code>$    docker    pull    ubuntu:16.04\n16.04:    Pulling    from    library/ubuntu\nbf5d46315322:    Pull    complete\n9f13e0ac480c:    Pull    complete\ne8988b5b3097:    Pull    complete\n40af181810e7:    Pull    complete\ne6f7c7e5c03e:    Pull    complete\nDigest:    sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\nStatus:    Downloaded    newer    image    for    ubuntu:16.04\n</code></pre><p>上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04    ,因此将会获取官方镜像library/ubuntu    仓库中标签为16.04的镜像。    </p>\n<p>例子： </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n[sudo] password for mutian: \nUsing default tag: latest\nlatest: Pulling from library/centos\naf4b0a2388c6: Pull complete \nDigest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\nStatus: Downloaded newer image for centos:latest\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。</p>\n<p><code>sudo docker run -it --rm centos bash</code></p>\n<pre><code>[root@5f6c0a6b41c1 ~]# cat /etc/os-release \nNAME=&quot;CentOS Linux&quot;\nVERSION=&quot;7 (Core)&quot;\nID=&quot;centos&quot;\nID_LIKE=&quot;rhel fedora&quot;\nVERSION_ID=&quot;7&quot;\nPRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;\nANSI_COLOR=&quot;0;31&quot;\nCPE_NAME=&quot;cpe:/o:centos:centos:7&quot;\nHOME_URL=&quot;https://www.centos.org/&quot;\nBUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;\n\nCENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;\nCENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;\nREDHAT_SUPPORT_PRODUCT=&quot;centos&quot;\nREDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;\n\n[root@5f6c0a6b41c1 ~]# \n</code></pre><p>通过上面信息我们可以看到容器内系统信息。</p>\n<p>命令说明：</p>\n<p><code>docker    run</code>就是运行容器的命令,具体格式我们会在    容器    一节进行详细讲解,我们这里简要的说明一下上面用到的参数。</p>\n<ul>\n<li><code>-it</code>:这是两个参数,一个是<code>-i</code>:交互式操作,一个是<code>-t</code>终端。我们这里打算进入<code>bash</code>执行一些命令并查看返回结果,因此我们需要交互式终端。</li>\n<li><code>--rm</code>:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动<code>docker    rm</code>。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用<code>--rm</code>可以避免浪费空间。</li>\n<li><code>centos</code>:这是指用<code>centos</code>镜像为基础来启动容器。</li>\n<li><code>bash</code>:放在镜像名后的是命令,这里我们希望有个交互式<code>Shell</code>,因此用的是<code>bash</code>。</li>\n</ul>\n<p>进入系统后我们可以执行任何linux下的命令。</p>\n<p>最后我们通过<code>exit</code>退出了这个容器。<br>退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了<code>--rm</code>命令。</p>\n<h2 id=\"列出所有的镜像\"><a href=\"#列出所有的镜像\" class=\"headerlink\" title=\"列出所有的镜像\"></a>列出所有的镜像</h2><p>想列出所有已经下载的镜像，可以使用命令<code>docker    image ls</code></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n[sudo] password for mutian: \nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest              f2a91732366c        3 months ago        1.85kB\n</code></pre><p>上面列表包含了<code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code>以及所占用空间。<br>镜像    ID    则是镜像的唯一标识,一个镜像可以对应多个标签。</p>\n<ul>\n<li>镜像体积SIZE：<br>上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比<br>每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。</li>\n</ul>\n<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\nTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\nImages              2                   1                   207.2MB             207.2MB (99%)\nContainers          1                   0                   0B                  0B\nLocal Volumes       0                   0                   0B                  0B\nBuild Cache \n</code></pre><ul>\n<li>虚悬镜像</li>\n</ul>\n<img src=\"/2018/02/02/docker-lesson3-images/a.png\">\n<p>如上图，命令查出来的就是虚悬镜像。其产生的原因是：<br>由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。</none></p>\n<p>这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：</p>\n<pre><code>$ sudo docker image    prune\n</code></pre><ul>\n<li>中间层镜像<br>为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可<br>能会看到一些依赖的中间层镜像。默认的<code>docker image    ls</code>列表中只会显示顶层镜像,如果<br>希望显示包括中间层镜像在内的所有镜像的话,需要加    <code>-a</code>参数。</li>\n</ul>\n<pre><code>$ sudo docker image ls -a\n</code></pre><p>这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 </p>\n<ul>\n<li>列出部分镜像<br>上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。</li>\n</ul>\n<p>根据仓库名称列出镜像：</p>\n<pre><code>sudo docker image ls centos\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\n</code></pre><p>列出特定的某个镜像,也就是说指定仓库名和标签</p>\n<img src=\"/2018/02/02/docker-lesson3-images/b.png\">\n<p>过滤查找镜像，使用<code>--filter</code>。具体使用请百度。</p>\n<ul>\n<li>以特定格式显示</li>\n</ul>\n<p>只显示ID列：</p>\n<pre><code>sudo docker image ls -q\nff426288ea90\nf2a91732366c\n</code></pre><p>用go模板语法定制格式显示<br>比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;{{.ID}}:{{.Repository}}&quot;\nff426288ea90:centos\nf2a91732366c:hello-world\n</code></pre><p>或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}&quot;\nIMAGE ID            REPOSITORY          TAG\nff426288ea90        centos              latest\nf2a91732366c        hello-world         latest\n</code></pre><h2 id=\"删除本地镜像\"><a href=\"#删除本地镜像\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用<code>docker    image    rm</code>命令来删除本地镜像。格式如下：</p>\n<pre><code>$    docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]\n</code></pre><ul>\n<li>用    ID、镜像名、摘要删除镜像</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest        \n\n#删除hello-world，段id，id一部分，能区分就行。\nmutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n</code></pre><p>用仓库名删除：</p>\n<pre><code>$ sudo docker image    rm    hello-world    \n</code></pre><p>当然,更精确的是使用镜像摘要删除镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n</code></pre><ul>\n<li>用    <code>docker    image    ls</code>命令来配合</li>\n</ul>\n<p>比如,我们需要删除所有仓库名为redis的镜像:</p>\n<pre><code>$ docker image rm $(docker image ls -q redis)\n</code></pre><h2 id=\"利用commit理解镜像构成\"><a href=\"#利用commit理解镜像构成\" class=\"headerlink\" title=\"利用commit理解镜像构成\"></a>利用commit理解镜像构成</h2><p>镜像是一层一层构成的。</p>\n<p>现在让我们以定制一个Web    服务器为例子,来讲解镜像是如何构建的。</p>\n<pre><code>docker run --name webserver -d -p 80:80 nginx\n</code></pre><p>在浏览器可查看：</p>\n<img src=\"/2018/02/02/docker-lesson3-images/c.png\">\n<p>现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎    Docker的文字,我们可以使用<code>docker    exec</code>命令进入容器,修改其内容 </p>\n<pre><code>&gt; sudo docker exec -it webserver bash\nroot@3729b97e8226:/# echo &apos;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&apos; &gt;    /usr/share/nginx/html/index.html\nroot@3729b97e8226:/#    exit\n</code></pre><p>然后刷新浏览器，就可以看到更改了。</p>\n<p>我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过<code>docker    diff</code>命令看到具体的改动。</p>\n<p>下面我们可以用下面的命令将容器保存为镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n&gt; --author &quot;zmt&quot; \\\n&gt; --message &quot;修改了默认页面&quot; \\\n&gt; webserver \\\n&gt; nginx:v2\nsha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n\n#查看\nmutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               v2                  e8023c09eed5        8 seconds ago       109MB\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest  \n</code></pre><p>查看镜像内历史记录：</p>\n<pre><code>$ docker history nginx:v2\n</code></pre><p>新的镜像定制好后,我们可以来运行这个镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n</code></pre><p>在浏览器查看：<a href=\"http://localhost:81/\" target=\"_blank\" rel=\"noopener\">http://localhost:81/</a></p>\n<p>停止容器：<code>sudo docker kill --signal=SIGINT web2</code></p>\n<p>至此,我们第一次完成了定制镜像,使用的是<code>docker    commit</code>命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。</p>\n<blockquote>\n<p>注意：通常不会使用<code>docker commit</code>来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。</p>\n</blockquote>\n<h2 id=\"使用Dockerfile定制镜像\"><a href=\"#使用Dockerfile定制镜像\" class=\"headerlink\" title=\"使用Dockerfile定制镜像\"></a>使用Dockerfile定制镜像</h2><p>从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。</p>\n<p>Dockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,<br>因此每一条指令的内容,就是描述该层应当如何构建。</p>\n<h3 id=\"简单例子：\"><a href=\"#简单例子：\" class=\"headerlink\" title=\"简单例子：\"></a>简单例子：</h3><p>1.创建Dockerfile文件</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\nmutian@mutian-ThinkPad-T440p:~$ cd mynginx/\nmutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n</code></pre><p>2.打开Dockerfile文件，编辑如下内容：</p>\n<pre><code>FROM nginx\nRUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n</code></pre><p>3.构建镜像<br>进入Dockerfile所在目录，执行命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\nSending build context to Docker daemon  2.048kB\nStep 1/2 : FROM nginx\n ---&gt; e548f1a579cf\nStep 2/2 : RUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n ---&gt; Running in d8c0149adf7e\nRemoving intermediate container d8c0149adf7e\n ---&gt; b92f375b41f0\nSuccessfully built b92f375b41f0\nSuccessfully tagged nginx:v3\n</code></pre><p>4.查看</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\nnginx               v3                  b92f375b41f0        About a minute ago   109MB\nnginx               v2                  e8023c09eed5        17 hours ago         109MB\nnginx               latest              e548f1a579cf        8 days ago           109MB\ncentos              latest              ff426288ea90        7 weeks ago          207MB\nhello-world         latest              f2a91732366c        3 months ago    \n</code></pre><p>我们看到，TAG为v3的镜像就是我们刚才构建。    </p>\n<h3 id=\"FROM指定基础镜像\"><a href=\"#FROM指定基础镜像\" class=\"headerlink\" title=\"FROM指定基础镜像\"></a>FROM指定基础镜像</h3><p>定制镜像必须是以一个镜像为基础来构建，基础镜像是必须要指定的，而FROM命令就是指定基础镜像，且第一步就要指定。   </p>\n<p>除了选择一些先前定制好的镜像作为基础镜像，Docker还存在一个特殊的镜像，名为<code>scratch</code>，表示空镜像，是个虚拟的概念，不实际存在。</p>\n<pre><code>FROM    scratch\n...\n</code></pre><p>如果以<code>scratch</code>为基础，则意味着不以任何镜像为基础，后面所写的命令将作为镜像的第一层存在。</p>\n<p>对于一些二进制的可执行文件，直接最为第一层存在，不依赖其它运行时系统支持，可以用空镜像。类似go语言编译的程序。</p>\n<h3 id=\"RUN-执行命令\"><a href=\"#RUN-执行命令\" class=\"headerlink\" title=\"RUN 执行命令\"></a>RUN 执行命令</h3><p>RUN命令是用来执行命令行命令的，就像shell脚本一样，用来执行linux命令。</p>\n<p>注意避免错误：</p>\n<pre><code>FROM    debian:jessie\nRUN    apt-get    update\nRUN    apt-get    install    -y    gcc    libc6-dev    make\nRUN    wget    -O    redis.tar.gz    &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;\nRUN    mkdir    -p    /usr/src/redis\nRUN    tar    -xzf    redis.tar.gz    -C    /usr/src/redis    --strip-components=1\nRUN    make    -C    /usr/src/redis\nRUN    make    -C    /usr/src/redis    install\n</code></pre><p>每一个指令都会创建一层，每层都会带有上层垃圾，因此一定要避免这样写。正确的写法如下： </p>\n<pre><code>FROM    debian:jessie\nRUN    buildDeps=&apos;gcc    libc6-dev    make&apos;    \\\n                &amp;&amp;    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    $buildDeps    \\\n                &amp;&amp;    wget    -O    redis.tar.gz    &quot;http://download.redis.io/releases/redis-3.2.5.tar.gz&quot;    \\\n                &amp;&amp;    mkdir    -p    /usr/src/redis    \\\n                &amp;&amp;    tar    -xzf    redis.tar.gz    -C    /usr/src/redis    --strip-components=1    \\\n                &amp;&amp;    make    -C    /usr/src/redis    \\\n                &amp;&amp;    make    -C    /usr/src/redis    install    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*    \\\n                &amp;&amp;    rm    redis.tar.gz    \\\n                &amp;&amp;    rm    -r    /usr/src/redis    \\\n                &amp;&amp;    apt-get    purge    -y    --auto-remove    $buildDeps\n</code></pre><p>用了<code>&amp;&amp;</code>，这和<code>shell</code>执行命令一样，就相当一个命令，所以算一层。执行完后，一定要记得删除不必要的垃圾数据，垃圾包。<br>在编写<code>Dockerfile</code>时候，一定要面向类似事件的思维，比如，安装redis环境，是一个事件，算一层。安装mysql，算一个事件，一层。  </p>\n<h2 id=\"Dockerfile指令详解\"><a href=\"#Dockerfile指令详解\" class=\"headerlink\" title=\"Dockerfile指令详解\"></a>Dockerfile指令详解</h2><p>上面我们已经了解了<code>From</code>、<code>RUN</code>指令，下面我们来介绍其余的……</p>\n<h3 id=\"COPY复制文件\"><a href=\"#COPY复制文件\" class=\"headerlink\" title=\"COPY复制文件\"></a>COPY复制文件</h3><p>格式：</p>\n<ul>\n<li><p><code>COPY    &lt;源路径&gt;...    &lt;目标路径&gt;</code></p>\n</li>\n<li><p><code>COPY    [&quot;&lt;源路径1&gt;&quot;,...    &quot;&lt;目标路径&gt;&quot;]</code></p>\n</li>\n</ul>\n<p>源路径指当前电脑系统文件路径，目标路径指容器的文件路径。  </p>\n<p><code>COPY</code>指令将从构建上下文目录中&lt;源路径&gt;的文件/目录复制到新的一层的镜像内的&lt;目标路<br>径&gt;位置。比如:  </p>\n<pre><code>COPY    package.json    /usr/src/app/\n</code></pre><p><code>&lt;源路径&gt;</code>可以是多个，甚至可以是通配符，只要满足<code>GO</code>的<a href=\"https://golang.org/pkg/path/filepath/#Match\" target=\"_blank\" rel=\"noopener\">filepath.Match</a>规则，如： </p>\n<pre><code>COPY    hom*    /mydir/\nCOPY    hom?.txt    /mydir/\n</code></pre><p><code>&lt;目标路径&gt;</code> 可以是容器内的绝对路径，也可以是相对于工作目录的相对路径（工作目录可以用WORKDIR指令来指定）       </p>\n<p><em>注意一点</em>： </p>\n<p>使用    <code>COPY</code>指令,源文件的各种元数据都会保留。比如读、写、执行权限、文件变更时间等。</p>\n<h3 id=\"ADD-更高级的复制文件\"><a href=\"#ADD-更高级的复制文件\" class=\"headerlink\" title=\"ADD    更高级的复制文件\"></a>ADD    更高级的复制文件</h3><p><code>ADD</code>指令和<code>COPY</code>指令本质上是一样的，只是添加了更多功能。 它的源文件可以是个url，也可以是tar，如果是tar还可以自动解压。  </p>\n<p>但是，如果是url，下载下来后，还要新建一层解压，授权，因此不如用<code>COPY</code> ，然后用<code>wget</code>命令。  </p>\n<p>在某个场景下，自动解压缩功能非常有用。 如： </p>\n<pre><code>FROM    scratch\nADD    ubuntu-xenial-core-cloudimg-amd64-root.tar.gz    /\n...\n</code></pre><p>_注意_：  </p>\n<p>在<code>COPY</code>    和<code>ADD</code>指令中选择的时候,可以遵循这样的原则,所有的文件复制均使用COPY指令,仅在需要自动解压缩的场合使用ADD。 </p>\n<h3 id=\"CMD容器启动命令\"><a href=\"#CMD容器启动命令\" class=\"headerlink\" title=\"CMD容器启动命令\"></a>CMD容器启动命令</h3><p>也有两种格式：</p>\n<ul>\n<li><code>shell</code>格式：<code>CMD &lt;命令&gt;</code></li>\n<li><code>exec</code>格式：<code>CMD    [&quot;可执行文件&quot;,    &quot;参数1&quot;,    &quot;参数2&quot;...]</code>    </li>\n<li>参数列表格式:     <code>CMD    [&quot;参数1&quot;,    &quot;参数2&quot;...]</code>     。在指定了<code>ENTRYPOINT</code>指令后,用<code>CMD</code>指定具体的参数。</li>\n</ul>\n<p>在指令格式上，推荐<code>exec</code>格式。  </p>\n<p>Docker不是虚拟机，只是一个进程。因此，在容器中启动程序，不要以后台形式启动，要以前台形式启动。<br>容器内没有后台概念。 </p>\n<p>不要这样启动：</p>\n<p><code>CMD service ginx start</code></p>\n<p>直接启动可执行文件，并以前台形式启动：</p>\n<p><code>CMD [&quot;nginx&quot;,&quot;-g&quot;,&quot;daemon off;&quot;]</code></p>\n<h3 id=\"ENTRYPOINT入口点\"><a href=\"#ENTRYPOINT入口点\" class=\"headerlink\" title=\"ENTRYPOINT入口点\"></a>ENTRYPOINT入口点</h3><p>也分为：<code>exec</code>格式和<code>shell</code>格式</p>\n<p>当指定了<code>ENTRYPOINT</code>后，就会把<code>CMD</code>的内容作为参数传给<code>ENTRYPOINT</code>指令，换句话说实际执行时，将变为：</p>\n<pre><code>&lt;ENTRYPOINT&gt;    &quot;&lt;CMD&gt;&quot;\n</code></pre><p><em>场景一</em>：<br>把镜像当成命令一样使用。</p>\n<pre><code>FROM    ubuntu:16.04\nRUN    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    curl    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*\nCMD    [    &quot;curl&quot;,    &quot;-s&quot;,    &quot;http://ip.cn&quot;    ]\n</code></pre><p>执行：</p>\n<pre><code>$    docker    run    myip\n当前    IP:61.148.226.66    来自:北京市    联通    \n</code></pre><p>再执行：</p>\n<pre><code>$    docker    run    myip    -i\ndocker:    Error    response    from    daemon:    invalid    header    field    value    &quot;oci    runtime    error:    con\ntainer_linux.go:247:    starting    container    process    caused    \\&quot;exec:    \\\\\\&quot;-i\\\\\\&quot;:    executable    \nfile    not    found    in    $PATH\\&quot;\\n&quot;.\n</code></pre><p>可以看到，报错了，因为<code>-i</code>不能参数不能传到<code>CMD</code>上去。</p>\n<p>正确方式：</p>\n<pre><code>FROM    ubuntu:16.04\nRUN    apt-get    update    \\\n                &amp;&amp;    apt-get    install    -y    curl    \\\n                &amp;&amp;    rm    -rf    /var/lib/apt/lists/*\nENTRYPOINT    [    &quot;curl&quot;,    &quot;-s&quot;,    &quot;http://ip.cn&quot;    ]\n</code></pre><p>执行：</p>\n<pre><code>$    docker    run    myip\n当前    IP:61.148.226.66    来自:北京市    联通\n\n$    docker    run    myip    -i\nHTTP/1.1    200    OK\nServer:    nginx/1.8.0\nDate:    Tue,    22    Nov    2016    05:12:40    GMT\nContent-Type:    text/html;    charset=UTF-8\nVary:    Accept-Encoding\nX-Powered-By:    PHP/5.6.24-1~dotdeb+7.1\nX-Cache:    MISS    from    cache-2\nX-Cache-Lookup:    MISS    from    cache-2:80\nX-Cache:    MISS    from    proxy-2_6\nTransfer-Encoding:    chunked\nVia:    1.1    cache-2:80,    1.1    proxy-2_6:8006\nConnection:    keep-alive\n当前    IP:61.148.226.66    来自:北京市    联通\n</code></pre><p>可以看到,这次成功了。这是因为当存在<code>ENTRYPOINT</code>后,<code>CMD</code>的内容将会作为参数传给<code>ENTRYPOINT</code>,而这里<code>-i</code>就是新的<code>CMD</code>,因此会作为参数传给<code>curl</code>,从而达到了我们预`期的效果。      </p>\n<p><em>场景二</em>：</p>\n<p>在应用程序启动前等做一些初始化工作。 </p>\n<p>比如启动redis，不以<code>root</code>，而以<code>redis</code>用户身份启动。 </p>\n<pre><code>FROM alpine:3.4\n...\nRUN addgroup -S    redis &amp;&amp; adduser -S -G redis redis\n...\nENTRYPOINT [&quot;docker-entrypoint.sh&quot;]\nEXPOSE    6379\nCMD [&quot;redis-server&quot;]\n</code></pre><p>可以看到其中为了<code>redis</code>服务创建了<code>redis</code>用户,并在最后指定了<code>ENTRYPOINT</code>为<code>docker-entrypoint.sh</code>脚本。   </p>\n<pre><code>#!/bin/sh\n...\n#allow the container to be started with    `--user`\nif [&quot;$1&quot; = &apos;redis-server&apos; -a &quot;$(id -u)&quot;    = &apos;0&apos;];    then\n                chown -R redis    .\n                exec su-exec redis &quot;$0&quot; &quot;$@&quot;\nfi\nexec &quot;$@&quot;\n</code></pre><p>执行：</p>\n<pre><code>$ docker run -it redis id\nuid=0(root) gid=0(root) groups=0(root)\n</code></pre><h3 id=\"ENV-设置环境变量\"><a href=\"#ENV-设置环境变量\" class=\"headerlink\" title=\"ENV    设置环境变量\"></a>ENV    设置环境变量</h3><p>格式有两种:</p>\n<ul>\n<li><code>ENV    &lt;key&gt;    &lt;value&gt;</code>    </li>\n<li><code>ENV    &lt;key1&gt;=&lt;value1&gt;    &lt;key2&gt;=&lt;value2&gt;...</code>  </li>\n</ul>\n<p>如：</p>\n<pre><code>ENV    VERSION=1.0    DEBUG=on \\\n    NAME=&quot;Happy    Feet&quot;   \n</code></pre><p>这里展示了用法，还展示了换行，有空格的话用双引号。 </p>\n<p>定义了变量，后面的命令中就可以使用了。可以使用它的命令如下一些： </p>\n<pre><code>ADD     、     COPY     、     ENV     、     EXPOSE     、     LABEL     、     USER     、     WORKDIR     、     VOLUME     、     STOPSIGNAL     、     ONBU\nILD    \n</code></pre><p>node官方Dockerfile例子：</p>\n<pre><code>ENV    NODE_VERSION    7.2.0\nRUN    curl    -SLO    &quot;https://nodejs.org/dist/v$NODE_VERSION/node-v$NODE_VERSION-linux-x64.ta\nr.xz&quot;    \\\n        &amp;&amp;    curl    -SLO    &quot;https://nodejs.org/dist/v$NODE_VERSION/SHASUMS256.txt.asc&quot;    \\\n        &amp;&amp;    gpg    --batch    --decrypt    --output    SHASUMS256.txt    SHASUMS256.txt.asc    \\\n        &amp;&amp;    grep    &quot;    node-v$NODE_VERSION-linux-x64.tar.xz\\$&quot;    SHASUMS256.txt    |    sha256sum    -c    -    \\\n        &amp;&amp;    tar    -xJf    &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;    -C    /usr/local    --strip-components=\n1    \\\n        &amp;&amp;    rm    &quot;node-v$NODE_VERSION-linux-x64.tar.xz&quot;    SHASUMS25    \n</code></pre><p>可以看到，定义了变量，后面就可以不断重复引入使用。改变的时候，只需要改一个地方。同时可以创建不同的多个镜像。 </p>\n<h3 id=\"ARG-构建参数\"><a href=\"#ARG-构建参数\" class=\"headerlink\" title=\"ARG    构建参数\"></a>ARG    构建参数</h3><p>构建参数和<code>ENV</code>的效果一样,都是设置环境变量。所不同的是,<code>ARG</code>所设置的构建环境的环境变量,在将来容器运行时是不会存在这些环境变量的。但是不要因此就使用<code>ARG</code>保存密码之类的信息,因为<code>docker    history</code>还是可以看到所有值的。 </p>\n<h3 id=\"VOLUME-定义匿名卷\"><a href=\"#VOLUME-定义匿名卷\" class=\"headerlink\" title=\"VOLUME    定义匿名卷\"></a>VOLUME    定义匿名卷</h3><p>两种格式：</p>\n<ul>\n<li><code>VOLUME    [&quot;&lt;路径1&gt;&quot;,    &quot;&lt;路径2&gt;&quot;...]</code></li>\n<li><code>VOLUME    &lt;路径&gt;</code></li>\n</ul>\n<p>不应该在容器存储层发生写操作。这样容器就能保持无状态的。对于动态数据，文件，我们应该保存到卷中。为了防止用户在运行时将动态文件写到存储层，<br>所以要预先指定动态文件写入的目录挂载为卷，如下： </p>\n<pre><code>VOLUME    /data\n</code></pre><p>这里，指定<code>/data</code>为匿名卷，任何写入该目录下的数据都不会写入到容器存储层。这样容器就是无状态的。可以运行时替换掉所挂载卷： </p>\n<pre><code>docker    run    -d    -v    mydata:/data    xxxx\n</code></pre><p>在这行命令中,就使用了<code>mydata</code>这个命名卷挂载到了<code>/data</code>这个位置,替代了<code>Dockerfile</code>中定义的匿名卷的挂载配置。  </p>\n<h3 id=\"EXPOSE-声明端口\"><a href=\"#EXPOSE-声明端口\" class=\"headerlink\" title=\"EXPOSE    声明端口\"></a>EXPOSE    声明端口</h3><p>格式：<code>EXPOSE    &lt;端口1&gt;    [&lt;端口2&gt;...]</code>    </p>\n<p><code>EXPOSE</code>指令是声明运行时容器提供服务端口,这只是一个声明,在运行时并不会因为这个声明应用就会开启这个端口的服务。   </p>\n<p>要将<code>EXPOSE</code>和在运行时使用<code>-p    &lt;宿主端口&gt;:&lt;容器端口&gt;</code>区分开来。<code>-p</code>,是映射宿主端口和容器端口,换句话说,就是将容器的对应端口服务公开给外界访问,而<code>EXPOSE</code>仅仅是声明容器打算使用什么端口而已,并不会自动在宿主进行端口映射。</p>\n<h3 id=\"WORKDIR指定工作目录\"><a href=\"#WORKDIR指定工作目录\" class=\"headerlink\" title=\"WORKDIR指定工作目录\"></a>WORKDIR指定工作目录</h3><p>格式：<code>WORKDIR    &lt;工作目录路径&gt;</code></p>\n<p>该命令可以指定工作目录（当前目录），后面各层都使用该指定目录。该目录如果不存在，则会创建空目录。</p>\n<p>写<code>Dockerfile</code>千万不能按照<code>shell</code>的思维写，应为<code>docker</code>是分层的。比如下面错误写法：</p>\n<pre><code>RUN cd /app\nRUN echo &quot;hello&quot; &gt; world.txt\n</code></pre><p>构建后，你会发现找不到<code>/app/world.txt</code>文件。原因是：在<code>shell</code>中执行命令，是在同一进程中，操作的是同样的内存。但是在<code>docker</code>中不是。你知道，每一个<code>RUN</code>命令都是构建一层的，启动不同的容器。第一次<code>RUN</code>只是操作进入<code>/app</code>目录，没有操作任何文件变更，只是内存的变化而已，第二次启动了个新的容器，跟第一层的容器完全没关系了。<br>所以：在写<code>Dockerfile</code>到时候，一定要有分层的思维，每一个完整的操作要在同一层里面做。</p>\n<p>如果要改变以后各层的工作目录都在指定的工作目录，那么<code>WORKDIR</code>指令就派上用场了。</p>\n<h3 id=\"USER指定当前用户\"><a href=\"#USER指定当前用户\" class=\"headerlink\" title=\"USER指定当前用户\"></a><code>USER</code>指定当前用户</h3><p>格式:<code>USER &lt;用户名&gt;</code>  用户名系统已经添加好</p>\n<p>和<code>WORKDIR</code>一样，都会影响后面的每一层。改变执行后面命令的执行身份。</p>\n<p>下面建立用户，并切换到该用户，启动<code>redis</code>：</p>\n<pre><code>RUN groupadd -r redis &amp;&amp; useradd -r -g redis edis\nUSER redis\nRUN [&quot;redis-server&quot;]\n</code></pre><p>如果以<code>root</code>执行脚本，在执行期间想切换用户，可以参考下面做法：</p>\n<pre><code># 建立redis用户,并使用gosu换另一个用户执行命令\nRUN groupadd -r redis &amp;&amp; useradd -r -g redis redis\n#下载gosu\nRUN wget -O /usr/local/bin/gosu &quot;https://github.com/tianon/gosu/releases/download/1.7/\ngosu-amd64&quot; \\\n    &amp;&amp; chmod +x /usr/local/bin/gosu    \\\n        &amp;&amp; gosu nobody true\n#设置CMD,并以另外的用户执行\nCMD [&quot;exec&quot;,&quot;gosu&quot;,&quot;redis&quot;,&quot;redis-server&quot;]\n</code></pre><p><code>gosu</code>使用更多信息参考：<a href=\"https://github.com/tianon/gosu\" target=\"_blank\" rel=\"noopener\">https://github.com/tianon/gosu</a></p>\n<h3 id=\"HEALTHCHECK-健康检查\"><a href=\"#HEALTHCHECK-健康检查\" class=\"headerlink\" title=\"HEALTHCHECK 健康检查\"></a>HEALTHCHECK 健康检查</h3><p>格式：</p>\n<ul>\n<li><code>HEALTHCHECK [选项] CMD &lt;命令&gt;</code>:设置检查容器健康状况的命令    </li>\n<li><code>HEALTHCHECK NONE</code>:如果基础镜像有健康检查指令,使用这行可以屏蔽掉其健康检查指令。</li>\n</ul>\n<p>该指令是告诉<code>Docker</code>应该如何进行判断容器的状态是否正常。</p>\n<h3 id=\"ONBUILD-为他人做嫁衣裳\"><a href=\"#ONBUILD-为他人做嫁衣裳\" class=\"headerlink\" title=\"ONBUILD    为他人做嫁衣裳\"></a>ONBUILD    为他人做嫁衣裳</h3><p>格式: <code>ONBUILD &lt;其它指令&gt;</code></p>\n<p><code>ONBUILD</code> 后面的指令，在当前镜像构建的时候是不会执行的，只有以它所在的镜像为基础镜像的镜像在构建的时候才会执行。 </p>\n<p><code>Docker</code>中其它的命令都是为了定制当前的镜像准备的，只有<code>ONBUILD</code>是为了他人而准备。   </p>\n<p>所以，这里就可以看出，该指令可以用来做命令的继承。类似<code>maven</code>中的父<code>pom</code>。把<code>ONBUILD</code>后面的命令都看做各个子<code>Dockerfile</code>的共用命令。</p>\n<pre><code>FROM node:slim\nRUN mkdir /app\nWORKDIR    /app\nONBUILD    COPY ./package.json /app\nONBUILD RUN [&quot;npm&quot;,    &quot;install&quot;]\nONBUILD    COPY . /app/\nCMD [&quot;npm&quot;, &quot;start&quot;]\n</code></pre><p> 后面每一个子<code>Dockerfile</code>只需要以上面镜像伟基础镜像:</p>\n<pre><code>FROM my-node  \n</code></pre><p>这样，<code>ONBUILD</code>后面的指令都会在每个子<code>Dockerfile</code>中执行。     </p>\n<h2 id=\"删除本地镜像-1\"><a href=\"#删除本地镜像-1\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用命令<code>docker rmi</code>，格式：</p>\n<pre><code>`docker    rmi    [选项]    &lt;镜像1&gt;    [&lt;镜像2&gt;    ...]`\n\n_注意_: docker rm 命令是删除容器,不要混淆。\n</code></pre><p>可以用ID、镜像名、摘要删除镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker images\n[sudo] password for mutian: \nREPOSITORY           TAG                 IMAGE ID            CREATED             SIZE\nmysql/mysql-server   latest              02d081b9c73e        2 months ago        300MB\nnginx                v3                  b92f375b41f0        4 months ago        109MB\nnginx                v2                  e8023c09eed5        4 months ago        109MB\nnginx                latest              e548f1a579cf        4 months ago        109MB\ncentos               latest              ff426288ea90        5 months ago        207MB\nhello-world          latest              f2a91732366c        7 months ago        1.85kB\nseason/fastdfs       latest              c6cc94c34f8e        2 years ago         205MB\n</code></pre><ol>\n<li>用短id删除，人工输入的时候使用，方便：</li>\n</ol>\n<p><code>$    docker    rmi    ff4</code></p>\n<ol start=\"2\">\n<li>用长id，一般使用脚本的时候：</li>\n</ol>\n<p><code>$    docker    rmi    f2a91732366c</code></p>\n<ol start=\"3\">\n<li>用镜像名,<code>&lt;仓库名&gt;:&lt;标签&gt;</code>：</li>\n</ol>\n<p><code>docker    rmi    nginx：v3</code></p>\n<ol start=\"4\">\n<li>使用摘要，最精确： </li>\n</ol>\n<p>查看摘要：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker images --digests\nREPOSITORY           TAG                 DIGEST                                                                    IMAGE ID            CREATED             SIZE\nmysql/mysql-server   latest              sha256:f1cb1e3f0124601b1496f485e9f4401ad10138294b5a38d932089daafd555e34   02d081b9c73e        2 months ago        300MB\nnginx                v3                  &lt;none&gt;                                                                    b92f375b41f0        4 months ago        109MB\nnginx                v2                  &lt;none&gt;                                                                    e8023c09eed5        4 months ago        109MB\nnginx                latest              sha256:4771d09578c7c6a65299e110b3ee1c0a2592f5ea2618d23e4ffe7a4cab1ce5de   e548f1a579cf        4 months ago        109MB\ncentos               latest              sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce   ff426288ea90        5 months ago        207MB\nhello-world          latest              sha256:083de497cff944f969d8499ab94f07134c50bcf5e6b9559b27182d3fa80ce3f7   f2a91732366c        7 months ago        1.85kB\nseason/fastdfs       latest              sha256:408acdebaa278e8ed875f7c63aa0c7ac8e633cf92f615d8295d279e137217003   c6cc94c34f8e        2 years ago         205MB\n</code></pre><p>删除：</p>\n<pre><code>docker rmi centos@sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n</code></pre><h3 id=\"Untagged和Deleted\"><a href=\"#Untagged和Deleted\" class=\"headerlink\" title=\"Untagged和Deleted\"></a>Untagged和Deleted</h3><p>仔细观察，发现两种删除行为。</p>\n<p>实际上，镜像都是一层层的，一个镜像有多个标签，只有每个标签都取消了，才有可能删除镜像。删除的时候从上最上层往下，逐步判断删除。 </p>\n<h3 id=\"用docker-images命令来配合\"><a href=\"#用docker-images命令来配合\" class=\"headerlink\" title=\"用docker images命令来配合\"></a>用<code>docker images</code>命令来配合</h3><p>配合<code>docker    images    -q</code>，可以成批的删除你想要删除的镜像，可以指定你想要删除的镜像。</p>\n<p>删除虚悬镜像：</p>\n<p><code>$    docker    rmi    $(docker    images    -q    -f    dangling=true)</code></p>\n<p>删除所有仓库名为redis的镜像:</p>\n<p><code>$    docker    rmi    $(docker    images    -q    redis)</code></p>\n<p>删除所有在mongo:3.2之前的镜像:</p>\n<p><code>$    docker    rmi    $(docker    images    -q    -f    before=mongo:3.2)</code></p>\n<h3 id=\"docker-image\"><a href=\"#docker-image\" class=\"headerlink\" title=\"docker image\"></a>docker image</h3><p>后面版本，推荐使用<code>docker image</code>来管理镜像。</p>\n<p>如删除：</p>\n<p><code>$    docker    image    rm</code></p>\n<h2 id=\"镜像的实现原理\"><a href=\"#镜像的实现原理\" class=\"headerlink\" title=\"镜像的实现原理\"></a>镜像的实现原理</h2><p><a href=\"https://en.wikipedia.org/wiki/UnionFS\" target=\"_blank\" rel=\"noopener\">UnionFS</a></p>\n<h2 id=\"配置镜像加速器\"><a href=\"#配置镜像加速器\" class=\"headerlink\" title=\"配置镜像加速器\"></a>配置镜像加速器</h2><p>注册阿里云账号后，即可在阿里云控制台（<a href=\"https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。\" target=\"_blank\" rel=\"noopener\">https://cr.console.aliyun.com/#/accelerator）看到类似如下的页面。</a></p>\n<img src=\"/2018/02/02/docker-lesson3-images/yy.png\">\n<p>按照上图说明配置即可。 </p>\n"},{"title":"mysql性能优化神器explain","date":"2017-11-21T05:36:04.000Z","_content":"\nMySQL 性能优化神器 Explain 使用分析\n\nmysql mysql优化  永顺 1月16日发布\n赞  |   6收藏  |  50\n3.2k 次浏览\n简介\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n\nEXPLAIN SELECT * from user_info WHERE id < 300;\n准备\n为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:\n\n    CREATE TABLE `user_info` (\n      `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `name` VARCHAR(50) NOT NULL DEFAULT '',\n      `age`  INT(11)              DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `name_index` (`name`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO user_info (name, age) VALUES ('xys', 20);\n    INSERT INTO user_info (name, age) VALUES ('a', 21);\n    INSERT INTO user_info (name, age) VALUES ('b', 23);\n    INSERT INTO user_info (name, age) VALUES ('c', 50);\n    INSERT INTO user_info (name, age) VALUES ('d', 15);\n    INSERT INTO user_info (name, age) VALUES ('e', 20);\n    INSERT INTO user_info (name, age) VALUES ('f', 21);\n    INSERT INTO user_info (name, age) VALUES ('g', 23);\n    INSERT INTO user_info (name, age) VALUES ('h', 50);\n    INSERT INTO user_info (name, age) VALUES ('i', 15);\n    CREATE TABLE `order_info` (\n      `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `user_id`      BIGINT(20)           DEFAULT NULL,\n      `product_name` VARCHAR(50) NOT NULL DEFAULT '',\n      `productor`    VARCHAR(30)          DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE');\nEXPLAIN 输出格式\nEXPLAIN 命令的输出内容大致如下:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n各列的含义如下:\n\n- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n- select_type: SELECT 查询的类型.\n- table: 查询的是哪个表\n- partitions: 匹配的分区\n- type: join 类型\n- possible_keys: 此次查询中可能选用的索引\n- key: 此次查询中确切使用到的索引.\n- ref: 哪个字段或常数与 key 一起被使用\n- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n- filtered: 表示此查询条件所过滤的数据的百分比\n- extra: 额外的信息\n接下来我们来重点看一下比较重要的几个字段.\n\nselect_type  \nselect_type 表示了查询的类型, 它的常用取值有:\n\nSIMPLE, 表示此查询不包含 UNION 查询或子查询  \nPRIMARY, 表示此查询是最外层的查询  \nUNION, 表示此查询是 UNION 的第二或随后的查询  \nDEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询  \nUNION RESULT, UNION 的结果  \nSUBQUERY, 子查询中的第一个 SELECT  \nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.   \n最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:\n\n    mysql> EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n        -> UNION\n        -> (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    |  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.00 sec)\n    table\n表示查询涉及的表或衍生表\n\n- type  \ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.   \ntype 常用类型   \ntype 常用的取值有:   \nsystem: 表中只有一条数据. 这个类型是特殊的 const 类型.   \nconst: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.   \n例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   \n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n    \n- eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 314\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using where; Using index\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: eq_ref\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: test.order_info.user_id\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        2 rows in set, 1 warning (0.00 sec)\n        \n- ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. \n例如下面这个例子中, 就使用到了 ref 类型的查询:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: const\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: Using index\n        2 rows in set, 1 warning (0.01 sec)\n\n- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.  \n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\n例如下面的例子就是一个范围查询:  \n\n        mysql> EXPLAIN SELECT *\n            ->         FROM user_info\n            ->         WHERE id BETWEEN 2 AND 8 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: range\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: NULL\n                 rows: 7\n             filtered: 100.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n    \n- index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.  \nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.  \n例如:  \n\n        mysql> EXPLAIN SELECT name FROM  user_info \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: name_index\n              key_len: 152\n                  ref: NULL\n                 rows: 10\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n    \n上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  \n\n- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.   \n下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   \n\n        mysql> EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: ALL\n        possible_keys: NULL\n                  key: NULL\n              key_len: NULL\n                  ref: NULL\n                 rows: 10\n             filtered: 10.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n        \n- type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\nALL < index < range ~ index_merge < ref < eq_ref < const < system\nALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\npossible_keys\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\nkey\n此字段是 MySQL 在当前查询时所真正使用到的索引.\nkey_len\n表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\nkey_len 的计算规则如下:\n字符串\nchar(n): n 字节长度\nvarchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.\n数值类型:\nTINYINT: 1字节\nSMALLINT: 2字节\nMEDIUMINT: 3字节\nINT: 4字节\nBIGINT: 8字节\n时间类型\nDATE: 3字节\nTIMESTAMP: 4字节\nDATETIME: 8字节\n字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n我们来举两个简单的栗子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: range\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: NULL\n                 rows: 5\n             filtered: 11.11\n                Extra: Using where; Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:\n\n- `KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n不过此查询语句 WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT '0', 则 key_length 应该是8.\n\n上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.\n\n接下来我们来看一下下一个例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \\G;\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 161\n                  ref: const,const\n                 rows: 2\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = 'p1' 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161\n\n- rows\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n\n- Extra\nEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:\n\n- Using filesort\n当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n例如下面的例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index; Using filesort\n        1 row in set, 1 warning (0.00 sec)\n        \n我们的索引是\n\n`KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.\n如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n- Using index\n\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n-   Using temporary\n查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","source":"_posts/mysql-explain.md","raw":"---\ntitle: mysql性能优化神器explain\ndate: 2017-11-21 13:36:04\ncategories: mysql\ntags: mysql-expain\n---\n\nMySQL 性能优化神器 Explain 使用分析\n\nmysql mysql优化  永顺 1月16日发布\n赞  |   6收藏  |  50\n3.2k 次浏览\n简介\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n\nEXPLAIN SELECT * from user_info WHERE id < 300;\n准备\n为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:\n\n    CREATE TABLE `user_info` (\n      `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `name` VARCHAR(50) NOT NULL DEFAULT '',\n      `age`  INT(11)              DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `name_index` (`name`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO user_info (name, age) VALUES ('xys', 20);\n    INSERT INTO user_info (name, age) VALUES ('a', 21);\n    INSERT INTO user_info (name, age) VALUES ('b', 23);\n    INSERT INTO user_info (name, age) VALUES ('c', 50);\n    INSERT INTO user_info (name, age) VALUES ('d', 15);\n    INSERT INTO user_info (name, age) VALUES ('e', 20);\n    INSERT INTO user_info (name, age) VALUES ('f', 21);\n    INSERT INTO user_info (name, age) VALUES ('g', 23);\n    INSERT INTO user_info (name, age) VALUES ('h', 50);\n    INSERT INTO user_info (name, age) VALUES ('i', 15);\n    CREATE TABLE `order_info` (\n      `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `user_id`      BIGINT(20)           DEFAULT NULL,\n      `product_name` VARCHAR(50) NOT NULL DEFAULT '',\n      `productor`    VARCHAR(30)          DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE');\nEXPLAIN 输出格式\nEXPLAIN 命令的输出内容大致如下:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n各列的含义如下:\n\n- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n- select_type: SELECT 查询的类型.\n- table: 查询的是哪个表\n- partitions: 匹配的分区\n- type: join 类型\n- possible_keys: 此次查询中可能选用的索引\n- key: 此次查询中确切使用到的索引.\n- ref: 哪个字段或常数与 key 一起被使用\n- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n- filtered: 表示此查询条件所过滤的数据的百分比\n- extra: 额外的信息\n接下来我们来重点看一下比较重要的几个字段.\n\nselect_type  \nselect_type 表示了查询的类型, 它的常用取值有:\n\nSIMPLE, 表示此查询不包含 UNION 查询或子查询  \nPRIMARY, 表示此查询是最外层的查询  \nUNION, 表示此查询是 UNION 的第二或随后的查询  \nDEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询  \nUNION RESULT, UNION 的结果  \nSUBQUERY, 子查询中的第一个 SELECT  \nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.   \n最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:\n\n    mysql> EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n        -> UNION\n        -> (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    |  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.00 sec)\n    table\n表示查询涉及的表或衍生表\n\n- type  \ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.   \ntype 常用类型   \ntype 常用的取值有:   \nsystem: 表中只有一条数据. 这个类型是特殊的 const 类型.   \nconst: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.   \n例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   \n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n    \n- eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 314\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using where; Using index\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: eq_ref\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: test.order_info.user_id\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        2 rows in set, 1 warning (0.00 sec)\n        \n- ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. \n例如下面这个例子中, 就使用到了 ref 类型的查询:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: const\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: Using index\n        2 rows in set, 1 warning (0.01 sec)\n\n- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.  \n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\n例如下面的例子就是一个范围查询:  \n\n        mysql> EXPLAIN SELECT *\n            ->         FROM user_info\n            ->         WHERE id BETWEEN 2 AND 8 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: range\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: NULL\n                 rows: 7\n             filtered: 100.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n    \n- index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.  \nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.  \n例如:  \n\n        mysql> EXPLAIN SELECT name FROM  user_info \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: name_index\n              key_len: 152\n                  ref: NULL\n                 rows: 10\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n    \n上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  \n\n- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.   \n下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   \n\n        mysql> EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: ALL\n        possible_keys: NULL\n                  key: NULL\n              key_len: NULL\n                  ref: NULL\n                 rows: 10\n             filtered: 10.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n        \n- type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\nALL < index < range ~ index_merge < ref < eq_ref < const < system\nALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\npossible_keys\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\nkey\n此字段是 MySQL 在当前查询时所真正使用到的索引.\nkey_len\n表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\nkey_len 的计算规则如下:\n字符串\nchar(n): n 字节长度\nvarchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.\n数值类型:\nTINYINT: 1字节\nSMALLINT: 2字节\nMEDIUMINT: 3字节\nINT: 4字节\nBIGINT: 8字节\n时间类型\nDATE: 3字节\nTIMESTAMP: 4字节\nDATETIME: 8字节\n字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n我们来举两个简单的栗子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: range\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: NULL\n                 rows: 5\n             filtered: 11.11\n                Extra: Using where; Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:\n\n- `KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n不过此查询语句 WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT '0', 则 key_length 应该是8.\n\n上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.\n\n接下来我们来看一下下一个例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \\G;\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 161\n                  ref: const,const\n                 rows: 2\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = 'p1' 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161\n\n- rows\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n\n- Extra\nEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:\n\n- Using filesort\n当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n例如下面的例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index; Using filesort\n        1 row in set, 1 warning (0.00 sec)\n        \n我们的索引是\n\n`KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.\n如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n- Using index\n\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n-   Using temporary\n查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","slug":"mysql-explain","published":1,"updated":"2018-11-09T01:20:30.280Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38s000dhqcrgdvnnjpkz","content":"<p>MySQL 性能优化神器 Explain 使用分析</p>\n<p>mysql mysql优化  永顺 1月16日发布<br>赞  |   6收藏  |  50<br>3.2k 次浏览<br>简介<br>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>\n<p>EXPLAIN SELECT * from user_info WHERE id &lt; 300;<br>准备<br>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>\n<pre><code>CREATE TABLE `user_info` (\n  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `age`  INT(11)              DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name_index` (`name`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);\nINSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);\nCREATE TABLE `order_info` (\n  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `user_id`      BIGINT(20)           DEFAULT NULL,\n  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `productor`    VARCHAR(30)          DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);\n</code></pre><p>EXPLAIN 输出格式<br>EXPLAIN 命令的输出内容大致如下:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>各列的含义如下:</p>\n<ul>\n<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li>select_type: SELECT 查询的类型.</li>\n<li>table: 查询的是哪个表</li>\n<li>partitions: 匹配的分区</li>\n<li>type: join 类型</li>\n<li>possible_keys: 此次查询中可能选用的索引</li>\n<li>key: 此次查询中确切使用到的索引.</li>\n<li>ref: 哪个字段或常数与 key 一起被使用</li>\n<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>\n<li>filtered: 表示此查询条件所过滤的数据的百分比</li>\n<li>extra: 额外的信息<br>接下来我们来重点看一下比较重要的几个字段.</li>\n</ul>\n<p>select_type<br>select_type 表示了查询的类型, 它的常用取值有:</p>\n<p>SIMPLE, 表示此查询不包含 UNION 查询或子查询<br>PRIMARY, 表示此查询是最外层的查询<br>UNION, 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>SUBQUERY, 子查询中的第一个 SELECT<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.<br>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>\n<pre><code>mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n    -&gt; UNION\n    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n3 rows in set, 1 warning (0.00 sec)\ntable\n</code></pre><p>表示查询涉及的表或衍生表</p>\n<ul>\n<li><p>type<br>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>type 常用类型<br>type 常用的取值有:<br>system: 表中只有一条数据. 这个类型是特殊的 const 类型.<br>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   </p>\n<p>  mysql&gt; explain select <em> from user_info where id = 2\\G<br>  <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>\n<pre><code>         id: 1\nselect_type: SIMPLE\n      table: user_info\n partitions: NULL\n       type: const\n</code></pre><p>  possible_keys: PRIMARY</p>\n<pre><code>     key: PRIMARY\n key_len: 8\n     ref: const\n    rows: 1\nfiltered: 100.00\n   Extra: NULL\n</code></pre><p>  1 row in set, 1 warning (0.00 sec)</p>\n</li>\n<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 314\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using where; Using index\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: eq_ref\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: test.order_info.user_id\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n2 rows in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index\n2 rows in set, 1 warning (0.01 sec)\n</code></pre></li>\n<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.<br>例如下面的例子就是一个范围查询:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT *\n    -&gt;         FROM user_info\n    -&gt;         WHERE id BETWEEN 2 AND 8 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 7\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.<br>例如:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT name FROM  user_info \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: name_index\n      key_len: 152\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  </p>\n<ul>\n<li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   </p>\n<pre><code>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 10.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.<br>possible_keys<br>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.<br>key<br>此字段是 MySQL 在当前查询时所真正使用到的索引.<br>key_len<br>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:<br>字符串<br>char(n): n 字节长度<br>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.<br>数值类型:<br>TINYINT: 1字节<br>SMALLINT: 2字节<br>MEDIUMINT: 3字节<br>INT: 4字节<br>BIGINT: 8字节<br>时间类型<br>DATE: 3字节<br>TIMESTAMP: 4字节<br>DATETIME: 8字节<br>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.<br>我们来举两个简单的栗子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: range\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: NULL\n         rows: 5\n     filtered: 11.11\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>\n<ul>\n<li><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</li>\n</ul>\n<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>\n<p>接下来我们来看一下下一个例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 161\n          ref: const,const\n         rows: 2\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>\n<ul>\n<li><p>rows<br>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n</li>\n<li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.<br>例如下面的例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index; Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>我们的索引是</p>\n<p><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><ul>\n<li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>MySQL 性能优化神器 Explain 使用分析</p>\n<p>mysql mysql优化  永顺 1月16日发布<br>赞  |   6收藏  |  50<br>3.2k 次浏览<br>简介<br>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>\n<p>EXPLAIN SELECT * from user_info WHERE id &lt; 300;<br>准备<br>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>\n<pre><code>CREATE TABLE `user_info` (\n  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `age`  INT(11)              DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name_index` (`name`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);\nINSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);\nCREATE TABLE `order_info` (\n  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `user_id`      BIGINT(20)           DEFAULT NULL,\n  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `productor`    VARCHAR(30)          DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);\n</code></pre><p>EXPLAIN 输出格式<br>EXPLAIN 命令的输出内容大致如下:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>各列的含义如下:</p>\n<ul>\n<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li>select_type: SELECT 查询的类型.</li>\n<li>table: 查询的是哪个表</li>\n<li>partitions: 匹配的分区</li>\n<li>type: join 类型</li>\n<li>possible_keys: 此次查询中可能选用的索引</li>\n<li>key: 此次查询中确切使用到的索引.</li>\n<li>ref: 哪个字段或常数与 key 一起被使用</li>\n<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>\n<li>filtered: 表示此查询条件所过滤的数据的百分比</li>\n<li>extra: 额外的信息<br>接下来我们来重点看一下比较重要的几个字段.</li>\n</ul>\n<p>select_type<br>select_type 表示了查询的类型, 它的常用取值有:</p>\n<p>SIMPLE, 表示此查询不包含 UNION 查询或子查询<br>PRIMARY, 表示此查询是最外层的查询<br>UNION, 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>SUBQUERY, 子查询中的第一个 SELECT<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.<br>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>\n<pre><code>mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n    -&gt; UNION\n    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n3 rows in set, 1 warning (0.00 sec)\ntable\n</code></pre><p>表示查询涉及的表或衍生表</p>\n<ul>\n<li><p>type<br>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>type 常用类型<br>type 常用的取值有:<br>system: 表中只有一条数据. 这个类型是特殊的 const 类型.<br>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   </p>\n<p>  mysql&gt; explain select <em> from user_info where id = 2\\G<br>  <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></p>\n<pre><code>         id: 1\nselect_type: SIMPLE\n      table: user_info\n partitions: NULL\n       type: const\n</code></pre><p>  possible_keys: PRIMARY</p>\n<pre><code>     key: PRIMARY\n key_len: 8\n     ref: const\n    rows: 1\nfiltered: 100.00\n   Extra: NULL\n</code></pre><p>  1 row in set, 1 warning (0.00 sec)</p>\n</li>\n<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 314\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using where; Using index\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: eq_ref\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: test.order_info.user_id\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n2 rows in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index\n2 rows in set, 1 warning (0.01 sec)\n</code></pre></li>\n<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.<br>例如下面的例子就是一个范围查询:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT *\n    -&gt;         FROM user_info\n    -&gt;         WHERE id BETWEEN 2 AND 8 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 7\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.<br>例如:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT name FROM  user_info \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: name_index\n      key_len: 152\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  </p>\n<ul>\n<li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   </p>\n<pre><code>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 10.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.<br>possible_keys<br>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.<br>key<br>此字段是 MySQL 在当前查询时所真正使用到的索引.<br>key_len<br>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:<br>字符串<br>char(n): n 字节长度<br>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.<br>数值类型:<br>TINYINT: 1字节<br>SMALLINT: 2字节<br>MEDIUMINT: 3字节<br>INT: 4字节<br>BIGINT: 8字节<br>时间类型<br>DATE: 3字节<br>TIMESTAMP: 4字节<br>DATETIME: 8字节<br>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.<br>我们来举两个简单的栗子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: range\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: NULL\n         rows: 5\n     filtered: 11.11\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>\n<ul>\n<li><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</li>\n</ul>\n<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>\n<p>接下来我们来看一下下一个例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 161\n          ref: const,const\n         rows: 2\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>\n<ul>\n<li><p>rows<br>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n</li>\n<li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.<br>例如下面的例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index; Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>我们的索引是</p>\n<p><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><ul>\n<li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n"},{"title":"spring-data-jpa动态数据源读写分离","date":"2017-11-08T15:02:49.000Z","_content":"\n在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。\n\n## 1. 配置数据源\n\n采用阿里druid数据源配置连接池。\n\n具体配置如下：\n\n    package service.basic.user.config.ds;\n    \n    import com.alibaba.druid.filter.Filter;\n    import com.alibaba.druid.filter.logging.Log4j2Filter;\n    import com.alibaba.druid.filter.stat.StatFilter;\n    import com.alibaba.druid.pool.DruidDataSource;\n    import com.alibaba.druid.wall.WallConfig;\n    import com.alibaba.druid.wall.WallFilter;\n    import com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.context.annotation.*;\n    import org.springframework.core.env.Environment;\n    \n    import javax.sql.DataSource;\n    import java.sql.SQLException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    \n    \n    /**\n     * 配置数据源\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        /**\n         * druid监控filter配置。\n         * @return\n         */\n        @Bean\n        public StatFilter statFilter() {\n            StatFilter statFilter = new StatFilter();\n            statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n            statFilter.setLogSlowSql(true); //日志记录慢sql\n            statFilter.setMergeSql(true); //相同sql合并\n            return statFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 start ---------//\n    \n        @Bean\n        public WallConfig wallConfig() {\n            WallConfig wallConfig = new WallConfig();\n            wallConfig.setDir(\"classpath:druid/wall/mysql\"); //sql过滤规则装载位置。\n            return wallConfig;\n        }\n    \n        @Bean\n        public WallFilter wallFilter() {\n            WallFilter wallFilter = new WallFilter();\n            wallFilter.setDbType(\"mysql\"); //指定数据库类型。\n            wallFilter.setConfig(wallConfig());\n            return wallFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 end ---------//\n    \n    \n        /**\n         * 打印sql语句。\n         * @return\n         */\n        @Bean(name = \"log4j2Filter\")\n        public Log4j2Filter log4j2Filter() {\n            Log4j2Filter log4j2Filter = new Log4j2Filter();\n            log4j2Filter.setConnectionLogEnabled(false);\n            log4j2Filter.setResultSetLogEnabled(true); //显示sql\n            log4j2Filter.setDataSourceLogEnabled(false);\n            log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n            log4j2Filter.setStatementLogEnabled(false);\n            return log4j2Filter;\n        }\n    \n    \n    \n        //-------------- 数据源配置 start ---------------//\n    \n        /**\n         * 会员主库（spcs_user）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceWrite\")\n        @Qualifier(\"spcsUserDataSourceWrite\")\n        public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n        /**\n         * 会员从库（spcs_user_slave）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceRead_0\")\n        @Qualifier(\"spcsUserDataSourceRead_0\")\n        public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"spcsUserDataSourceWrite\",\"spcsUserDataSourceRead_0\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"spcsUserDataSourceWrite\") DataSource spcsUserDataSource,\n                                              @Qualifier(\"spcsUserDataSourceRead_0\") DataSource spcsUserSlaveDataSource) {\n            // 配置多数据源\n            Map<Object, Object> dsMap = new HashMap<>(5);\n            dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n            dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n    \n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            // 默认数据源\n            dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n            dynamicDataSource.setTargetDataSources(dsMap);\n            return dynamicDataSource;\n        }\n    \n    }\n\n> *注意*：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。\n\n## 2. 实现自己的数据源路由（关键）\n\n相当于多数据源的路由功能。\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n    \n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            log.debug(\"数据源为{}\", DataSourceContextHolder.getDS());\n            //可以做一个简单的负载均衡策略\n            return DataSourceContextHolder.getDS();\n        }\n    \n    }\n    \n## 3. 持有数据源\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    public class DataSourceContextHolder {\n    \n        private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n    \n        private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n    \n        /**\n         * 设置数据源名。\n         * @param dbType\n         */\n        public static void setDS(String dbType) {\n            if (dbType == null) {\n                throw new NullPointerException(\"数据源不能null\");\n            }\n            LOGGER.debug(\"切换到{}数据源\", dbType);\n            contextHolder.set(dbType);\n        }\n    \n        /**\n         * 获取数据源名。\n         * @return\n         */\n        public static String getDS() {\n            return (contextHolder.get());\n        }\n    \n        /**\n         * 清除数据源名。\n         */\n        public static void clearDS() {\n            contextHolder.remove();\n        }\n    }\n    \n## 4. 通过aop，注解方式持有数据源\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.ds.DSInject;\n    import com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.annotation.After;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.aspectj.lang.annotation.Before;\n    import org.aspectj.lang.reflect.MethodSignature;\n    import org.springframework.stereotype.Component;\n    \n    import java.lang.reflect.Method;\n    \n    /**\n     *  解析注入的数据源。\n     */\n    @Aspect\n    @Component\n    public class DynamicDataSourceAspect {\n    \n    \t@Before(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void beforeSwitchDS(JoinPoint point) {\n    \n    \t\t// 获得当前访问的class\n    \t\tClass<?> className = point.getTarget().getClass();\n    \n    \t\t// 获得访问的方法名\n    \t\tString methodName = point.getSignature().getName();\n    \t\t// 得到方法的参数的类型\n    \t\tClass[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n    \t\tString dataSource = DSType.SPCS_USER.name(); //默认主库\n    \t\ttry {\n    \t\t\t// 得到访问的方法对象\n    \t\t\tMethod method = className.getMethod(methodName, argClass);\n    \n    \t\t\t// 判断是否存在@DBInject注解\n    \t\t\tif (method.isAnnotationPresent(DSInject.class)) {\n    \t\t\t\tDSInject annotation = method.getAnnotation(DSInject.class);\n    \t\t\t\t// 取出注解中的数据源名\n    \t\t\t\tdataSource = annotation.value();\n    \t\t\t}\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t}\n    \n    \t\t// 切换数据源\n    \t\tDataSourceContextHolder.setDS(dataSource);\n    \n    \t}\n    \n    \t@After(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void afterSwitchDS(JoinPoint point) {\n    \t\tDataSourceContextHolder.clearDS();\n    \t}\n    }\n\n---\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Target({ ElementType.PARAMETER, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface DSInject {\n    \tString value() default \"\";\n    }\n\n## 5. 配置jpa\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\n    import net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\n    import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.core.env.Environment;\n    import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n    import org.springframework.orm.jpa.JpaTransactionManager;\n    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n    import org.springframework.transaction.PlatformTransactionManager;\n    import org.springframework.transaction.annotation.EnableTransactionManagement;\n    import service.basic.user.common.Constants;\n    \n    import javax.persistence.EntityManager;\n    import javax.sql.DataSource;\n    import java.util.Map;\n    \n    @Configuration\n    @EnableTransactionManagement\n    @EnableJpaRepositories(entityManagerFactoryRef = \"entityManagerFactorySpcsUserDB\", transactionManagerRef = \"transactionManagerSpcsUserDB\", basePackages = {\n            Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\n    public class SpcsUserDBConfig {\n    \n        @Autowired\n        Environment ev;\n    \n        @Autowired\n        @Qualifier(\"dataSource\")\n        private DataSource dataSource; // 数据源\n    \n        @Primary\n        @Bean(name = \"entityManagerSpcsUser\")\n        public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n            return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n        }\n    \n        @Primary\n        @Bean(name = \"entityManagerFactorySpcsUserDB\")\n        public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n            if (ev.acceptsProfiles(\"dev\") || ev.acceptsProfiles(\"test\")\n                    || ev.acceptsProfiles(\"update\")) {\n                dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n            }\n            return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                    .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                    .persistenceUnit(\"spcsUserUnit\").build(); //实体管理器别名,多数据元要设置。\n        }\n    \n        private Map<String, String> getVendorProperties(DataSource dataSource) {\n            JpaProperties jpaProperties = new JpaProperties();\n            return jpaProperties.getHibernateProperties(dataSource);\n        }\n    \n        /**\n         * 开启事务。\n         *\n         * @param builder\n         * @return\n         */\n        @Primary\n        @Bean(name = \"transactionManagerSpcsUserDB\")\n        public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n            return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n        }\n    \n    }\n    \n> *注意*: 注入的数据源为上面配置的动态数据源。\n@Autowired\n@Qualifier(\"dataSource\")\nprivate DataSource dataSource; // 数据源    \n\n\n## 6. 配置spring jdbcTemplate\n\n    package service.basic.user.config.ds;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import javax.sql.DataSource;\n    \n    @Configuration\n    @AutoConfigureAfter(DataSourceConfig.class)\n    public class JdbcTemplateConfig {\n    \n        @Autowired\n        @Qualifier(value = \"dataSource\")\n        private DataSource dataSource;\n    \n        /**\n         * spring jdbc。\n         *\n         * @return\n         */\n        @Bean(name = \"jdbcTemplate\")\n        @Qualifier(\"jdbcTemplate\")\n        public JdbcTemplate jdbcTemplate() {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n\n## 7. 使用\n\n- 方式一：\n可在service层，也可在dao层做。\n在开始操作数据库前调用：\n\n\n    DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n    \n    //查询数据\n    \n    DataSourceContextHolder.clearDS();\n    \n- 方式二：\n通过注解，可在service层，也可在dao层做。\n\n\n    @DSInject(value = Constants.SPCS_USER_SLAVE)\n    @Override\n    public User getUserByMobile(String mobile) {\n        return userDao.findUserByMobile(mobile);\n    }    ","source":"_posts/spring-jpa-multiple-datasource.md","raw":"---\ntitle: spring-data-jpa动态数据源读写分离\ndate: 2017-11-08 23:02:49\ncategories: spring-boot\ntags: jpa读写分离配置\n---\n\n在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。\n\n## 1. 配置数据源\n\n采用阿里druid数据源配置连接池。\n\n具体配置如下：\n\n    package service.basic.user.config.ds;\n    \n    import com.alibaba.druid.filter.Filter;\n    import com.alibaba.druid.filter.logging.Log4j2Filter;\n    import com.alibaba.druid.filter.stat.StatFilter;\n    import com.alibaba.druid.pool.DruidDataSource;\n    import com.alibaba.druid.wall.WallConfig;\n    import com.alibaba.druid.wall.WallFilter;\n    import com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.context.annotation.*;\n    import org.springframework.core.env.Environment;\n    \n    import javax.sql.DataSource;\n    import java.sql.SQLException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    \n    \n    /**\n     * 配置数据源\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        /**\n         * druid监控filter配置。\n         * @return\n         */\n        @Bean\n        public StatFilter statFilter() {\n            StatFilter statFilter = new StatFilter();\n            statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n            statFilter.setLogSlowSql(true); //日志记录慢sql\n            statFilter.setMergeSql(true); //相同sql合并\n            return statFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 start ---------//\n    \n        @Bean\n        public WallConfig wallConfig() {\n            WallConfig wallConfig = new WallConfig();\n            wallConfig.setDir(\"classpath:druid/wall/mysql\"); //sql过滤规则装载位置。\n            return wallConfig;\n        }\n    \n        @Bean\n        public WallFilter wallFilter() {\n            WallFilter wallFilter = new WallFilter();\n            wallFilter.setDbType(\"mysql\"); //指定数据库类型。\n            wallFilter.setConfig(wallConfig());\n            return wallFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 end ---------//\n    \n    \n        /**\n         * 打印sql语句。\n         * @return\n         */\n        @Bean(name = \"log4j2Filter\")\n        public Log4j2Filter log4j2Filter() {\n            Log4j2Filter log4j2Filter = new Log4j2Filter();\n            log4j2Filter.setConnectionLogEnabled(false);\n            log4j2Filter.setResultSetLogEnabled(true); //显示sql\n            log4j2Filter.setDataSourceLogEnabled(false);\n            log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n            log4j2Filter.setStatementLogEnabled(false);\n            return log4j2Filter;\n        }\n    \n    \n    \n        //-------------- 数据源配置 start ---------------//\n    \n        /**\n         * 会员主库（spcs_user）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceWrite\")\n        @Qualifier(\"spcsUserDataSourceWrite\")\n        public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n        /**\n         * 会员从库（spcs_user_slave）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceRead_0\")\n        @Qualifier(\"spcsUserDataSourceRead_0\")\n        public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"spcsUserDataSourceWrite\",\"spcsUserDataSourceRead_0\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"spcsUserDataSourceWrite\") DataSource spcsUserDataSource,\n                                              @Qualifier(\"spcsUserDataSourceRead_0\") DataSource spcsUserSlaveDataSource) {\n            // 配置多数据源\n            Map<Object, Object> dsMap = new HashMap<>(5);\n            dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n            dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n    \n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            // 默认数据源\n            dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n            dynamicDataSource.setTargetDataSources(dsMap);\n            return dynamicDataSource;\n        }\n    \n    }\n\n> *注意*：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。\n\n## 2. 实现自己的数据源路由（关键）\n\n相当于多数据源的路由功能。\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n    \n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            log.debug(\"数据源为{}\", DataSourceContextHolder.getDS());\n            //可以做一个简单的负载均衡策略\n            return DataSourceContextHolder.getDS();\n        }\n    \n    }\n    \n## 3. 持有数据源\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    public class DataSourceContextHolder {\n    \n        private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n    \n        private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n    \n        /**\n         * 设置数据源名。\n         * @param dbType\n         */\n        public static void setDS(String dbType) {\n            if (dbType == null) {\n                throw new NullPointerException(\"数据源不能null\");\n            }\n            LOGGER.debug(\"切换到{}数据源\", dbType);\n            contextHolder.set(dbType);\n        }\n    \n        /**\n         * 获取数据源名。\n         * @return\n         */\n        public static String getDS() {\n            return (contextHolder.get());\n        }\n    \n        /**\n         * 清除数据源名。\n         */\n        public static void clearDS() {\n            contextHolder.remove();\n        }\n    }\n    \n## 4. 通过aop，注解方式持有数据源\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.ds.DSInject;\n    import com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.annotation.After;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.aspectj.lang.annotation.Before;\n    import org.aspectj.lang.reflect.MethodSignature;\n    import org.springframework.stereotype.Component;\n    \n    import java.lang.reflect.Method;\n    \n    /**\n     *  解析注入的数据源。\n     */\n    @Aspect\n    @Component\n    public class DynamicDataSourceAspect {\n    \n    \t@Before(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void beforeSwitchDS(JoinPoint point) {\n    \n    \t\t// 获得当前访问的class\n    \t\tClass<?> className = point.getTarget().getClass();\n    \n    \t\t// 获得访问的方法名\n    \t\tString methodName = point.getSignature().getName();\n    \t\t// 得到方法的参数的类型\n    \t\tClass[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n    \t\tString dataSource = DSType.SPCS_USER.name(); //默认主库\n    \t\ttry {\n    \t\t\t// 得到访问的方法对象\n    \t\t\tMethod method = className.getMethod(methodName, argClass);\n    \n    \t\t\t// 判断是否存在@DBInject注解\n    \t\t\tif (method.isAnnotationPresent(DSInject.class)) {\n    \t\t\t\tDSInject annotation = method.getAnnotation(DSInject.class);\n    \t\t\t\t// 取出注解中的数据源名\n    \t\t\t\tdataSource = annotation.value();\n    \t\t\t}\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t}\n    \n    \t\t// 切换数据源\n    \t\tDataSourceContextHolder.setDS(dataSource);\n    \n    \t}\n    \n    \t@After(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void afterSwitchDS(JoinPoint point) {\n    \t\tDataSourceContextHolder.clearDS();\n    \t}\n    }\n\n---\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Target({ ElementType.PARAMETER, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface DSInject {\n    \tString value() default \"\";\n    }\n\n## 5. 配置jpa\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\n    import net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\n    import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.core.env.Environment;\n    import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n    import org.springframework.orm.jpa.JpaTransactionManager;\n    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n    import org.springframework.transaction.PlatformTransactionManager;\n    import org.springframework.transaction.annotation.EnableTransactionManagement;\n    import service.basic.user.common.Constants;\n    \n    import javax.persistence.EntityManager;\n    import javax.sql.DataSource;\n    import java.util.Map;\n    \n    @Configuration\n    @EnableTransactionManagement\n    @EnableJpaRepositories(entityManagerFactoryRef = \"entityManagerFactorySpcsUserDB\", transactionManagerRef = \"transactionManagerSpcsUserDB\", basePackages = {\n            Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\n    public class SpcsUserDBConfig {\n    \n        @Autowired\n        Environment ev;\n    \n        @Autowired\n        @Qualifier(\"dataSource\")\n        private DataSource dataSource; // 数据源\n    \n        @Primary\n        @Bean(name = \"entityManagerSpcsUser\")\n        public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n            return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n        }\n    \n        @Primary\n        @Bean(name = \"entityManagerFactorySpcsUserDB\")\n        public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n            if (ev.acceptsProfiles(\"dev\") || ev.acceptsProfiles(\"test\")\n                    || ev.acceptsProfiles(\"update\")) {\n                dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n            }\n            return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                    .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                    .persistenceUnit(\"spcsUserUnit\").build(); //实体管理器别名,多数据元要设置。\n        }\n    \n        private Map<String, String> getVendorProperties(DataSource dataSource) {\n            JpaProperties jpaProperties = new JpaProperties();\n            return jpaProperties.getHibernateProperties(dataSource);\n        }\n    \n        /**\n         * 开启事务。\n         *\n         * @param builder\n         * @return\n         */\n        @Primary\n        @Bean(name = \"transactionManagerSpcsUserDB\")\n        public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n            return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n        }\n    \n    }\n    \n> *注意*: 注入的数据源为上面配置的动态数据源。\n@Autowired\n@Qualifier(\"dataSource\")\nprivate DataSource dataSource; // 数据源    \n\n\n## 6. 配置spring jdbcTemplate\n\n    package service.basic.user.config.ds;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import javax.sql.DataSource;\n    \n    @Configuration\n    @AutoConfigureAfter(DataSourceConfig.class)\n    public class JdbcTemplateConfig {\n    \n        @Autowired\n        @Qualifier(value = \"dataSource\")\n        private DataSource dataSource;\n    \n        /**\n         * spring jdbc。\n         *\n         * @return\n         */\n        @Bean(name = \"jdbcTemplate\")\n        @Qualifier(\"jdbcTemplate\")\n        public JdbcTemplate jdbcTemplate() {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n\n## 7. 使用\n\n- 方式一：\n可在service层，也可在dao层做。\n在开始操作数据库前调用：\n\n\n    DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n    \n    //查询数据\n    \n    DataSourceContextHolder.clearDS();\n    \n- 方式二：\n通过注解，可在service层，也可在dao层做。\n\n\n    @DSInject(value = Constants.SPCS_USER_SLAVE)\n    @Override\n    public User getUserByMobile(String mobile) {\n        return userDao.findUserByMobile(mobile);\n    }    ","slug":"spring-jpa-multiple-datasource","published":1,"updated":"2018-11-09T01:20:30.935Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38s200diqcrg8ynkl0qn","content":"<p>在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。</p>\n<h2 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h2><p>采用阿里druid数据源配置连接池。</p>\n<p>具体配置如下：</p>\n<pre><code>package service.basic.user.config.ds;\n\nimport com.alibaba.druid.filter.Filter;\nimport com.alibaba.druid.filter.logging.Log4j2Filter;\nimport com.alibaba.druid.filter.stat.StatFilter;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.wall.WallConfig;\nimport com.alibaba.druid.wall.WallFilter;\nimport com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.*;\nimport org.springframework.core.env.Environment;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * 配置数据源\n */\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * druid监控filter配置。\n     * @return\n     */\n    @Bean\n    public StatFilter statFilter() {\n        StatFilter statFilter = new StatFilter();\n        statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n        statFilter.setLogSlowSql(true); //日志记录慢sql\n        statFilter.setMergeSql(true); //相同sql合并\n        return statFilter;\n    }\n\n    //----------- sql注入攻击防御配置 start ---------//\n\n    @Bean\n    public WallConfig wallConfig() {\n        WallConfig wallConfig = new WallConfig();\n        wallConfig.setDir(&quot;classpath:druid/wall/mysql&quot;); //sql过滤规则装载位置。\n        return wallConfig;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n        WallFilter wallFilter = new WallFilter();\n        wallFilter.setDbType(&quot;mysql&quot;); //指定数据库类型。\n        wallFilter.setConfig(wallConfig());\n        return wallFilter;\n    }\n\n    //----------- sql注入攻击防御配置 end ---------//\n\n\n    /**\n     * 打印sql语句。\n     * @return\n     */\n    @Bean(name = &quot;log4j2Filter&quot;)\n    public Log4j2Filter log4j2Filter() {\n        Log4j2Filter log4j2Filter = new Log4j2Filter();\n        log4j2Filter.setConnectionLogEnabled(false);\n        log4j2Filter.setResultSetLogEnabled(true); //显示sql\n        log4j2Filter.setDataSourceLogEnabled(false);\n        log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n        log4j2Filter.setStatementLogEnabled(false);\n        return log4j2Filter;\n    }\n\n\n\n    //-------------- 数据源配置 start ---------------//\n\n    /**\n     * 会员主库（spcs_user）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceWrite&quot;)\n    @Qualifier(&quot;spcsUserDataSourceWrite&quot;)\n    public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n    /**\n     * 会员从库（spcs_user_slave）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceRead_0&quot;)\n    @Qualifier(&quot;spcsUserDataSourceRead_0&quot;)\n    public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;spcsUserDataSourceWrite&quot;,&quot;spcsUserDataSourceRead_0&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;spcsUserDataSourceWrite&quot;) DataSource spcsUserDataSource,\n                                          @Qualifier(&quot;spcsUserDataSourceRead_0&quot;) DataSource spcsUserSlaveDataSource) {\n        // 配置多数据源\n        Map&lt;Object, Object&gt; dsMap = new HashMap&lt;&gt;(5);\n        dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n        dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        // 默认数据源\n        dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n        dynamicDataSource.setTargetDataSources(dsMap);\n        return dynamicDataSource;\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。</p>\n</blockquote>\n<h2 id=\"2-实现自己的数据源路由（关键）\"><a href=\"#2-实现自己的数据源路由（关键）\" class=\"headerlink\" title=\"2. 实现自己的数据源路由（关键）\"></a>2. 实现自己的数据源路由（关键）</h2><p>相当于多数据源的路由功能。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.debug(&quot;数据源为{}&quot;, DataSourceContextHolder.getDS());\n        //可以做一个简单的负载均衡策略\n        return DataSourceContextHolder.getDS();\n    }\n\n}\n</code></pre><h2 id=\"3-持有数据源\"><a href=\"#3-持有数据源\" class=\"headerlink\" title=\"3. 持有数据源\"></a>3. 持有数据源</h2><pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class DataSourceContextHolder {\n\n    private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n\n    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();\n\n    /**\n     * 设置数据源名。\n     * @param dbType\n     */\n    public static void setDS(String dbType) {\n        if (dbType == null) {\n            throw new NullPointerException(&quot;数据源不能null&quot;);\n        }\n        LOGGER.debug(&quot;切换到{}数据源&quot;, dbType);\n        contextHolder.set(dbType);\n    }\n\n    /**\n     * 获取数据源名。\n     * @return\n     */\n    public static String getDS() {\n        return (contextHolder.get());\n    }\n\n    /**\n     * 清除数据源名。\n     */\n    public static void clearDS() {\n        contextHolder.remove();\n    }\n}\n</code></pre><h2 id=\"4-通过aop，注解方式持有数据源\"><a href=\"#4-通过aop，注解方式持有数据源\" class=\"headerlink\" title=\"4. 通过aop，注解方式持有数据源\"></a>4. 通过aop，注解方式持有数据源</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.ds.DSInject;\nimport com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n *  解析注入的数据源。\n */\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    @Before(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void beforeSwitchDS(JoinPoint point) {\n\n        // 获得当前访问的class\n        Class&lt;?&gt; className = point.getTarget().getClass();\n\n        // 获得访问的方法名\n        String methodName = point.getSignature().getName();\n        // 得到方法的参数的类型\n        Class[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n        String dataSource = DSType.SPCS_USER.name(); //默认主库\n        try {\n            // 得到访问的方法对象\n            Method method = className.getMethod(methodName, argClass);\n\n            // 判断是否存在@DBInject注解\n            if (method.isAnnotationPresent(DSInject.class)) {\n                DSInject annotation = method.getAnnotation(DSInject.class);\n                // 取出注解中的数据源名\n                dataSource = annotation.value();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 切换数据源\n        DataSourceContextHolder.setDS(dataSource);\n\n    }\n\n    @After(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void afterSwitchDS(JoinPoint point) {\n        DataSourceContextHolder.clearDS();\n    }\n}\n</code></pre><hr>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface DSInject {\n    String value() default &quot;&quot;;\n}\n</code></pre><h2 id=\"5-配置jpa\"><a href=\"#5-配置jpa\" class=\"headerlink\" title=\"5. 配置jpa\"></a>5. 配置jpa</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\nimport net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport service.basic.user.common.Constants;\n\nimport javax.persistence.EntityManager;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactorySpcsUserDB&quot;, transactionManagerRef = &quot;transactionManagerSpcsUserDB&quot;, basePackages = {\n        Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\npublic class SpcsUserDBConfig {\n\n    @Autowired\n    Environment ev;\n\n    @Autowired\n    @Qualifier(&quot;dataSource&quot;)\n    private DataSource dataSource; // 数据源\n\n    @Primary\n    @Bean(name = &quot;entityManagerSpcsUser&quot;)\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = &quot;entityManagerFactorySpcsUserDB&quot;)\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n        if (ev.acceptsProfiles(&quot;dev&quot;) || ev.acceptsProfiles(&quot;test&quot;)\n                || ev.acceptsProfiles(&quot;update&quot;)) {\n            dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n        }\n        return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                .persistenceUnit(&quot;spcsUserUnit&quot;).build(); //实体管理器别名,多数据元要设置。\n    }\n\n    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {\n        JpaProperties jpaProperties = new JpaProperties();\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    /**\n     * 开启事务。\n     *\n     * @param builder\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;transactionManagerSpcsUserDB&quot;)\n    public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>: 注入的数据源为上面配置的动态数据源。<br>@Autowired<br>@Qualifier(“dataSource”)<br>private DataSource dataSource; // 数据源    </p>\n</blockquote>\n<h2 id=\"6-配置spring-jdbcTemplate\"><a href=\"#6-配置spring-jdbcTemplate\" class=\"headerlink\" title=\"6. 配置spring jdbcTemplate\"></a>6. 配置spring jdbcTemplate</h2><pre><code>package service.basic.user.config.ds;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@AutoConfigureAfter(DataSourceConfig.class)\npublic class JdbcTemplateConfig {\n\n    @Autowired\n    @Qualifier(value = &quot;dataSource&quot;)\n    private DataSource dataSource;\n\n    /**\n     * spring jdbc。\n     *\n     * @return\n     */\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    @Qualifier(&quot;jdbcTemplate&quot;)\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource);\n    }\n}\n</code></pre><h2 id=\"7-使用\"><a href=\"#7-使用\" class=\"headerlink\" title=\"7. 使用\"></a>7. 使用</h2><ul>\n<li>方式一：<br>可在service层，也可在dao层做。<br>在开始操作数据库前调用：</li>\n</ul>\n<pre><code>DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n\n//查询数据\n\nDataSourceContextHolder.clearDS();\n</code></pre><ul>\n<li>方式二：<br>通过注解，可在service层，也可在dao层做。</li>\n</ul>\n<pre><code>@DSInject(value = Constants.SPCS_USER_SLAVE)\n@Override\npublic User getUserByMobile(String mobile) {\n    return userDao.findUserByMobile(mobile);\n}    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。</p>\n<h2 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h2><p>采用阿里druid数据源配置连接池。</p>\n<p>具体配置如下：</p>\n<pre><code>package service.basic.user.config.ds;\n\nimport com.alibaba.druid.filter.Filter;\nimport com.alibaba.druid.filter.logging.Log4j2Filter;\nimport com.alibaba.druid.filter.stat.StatFilter;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.wall.WallConfig;\nimport com.alibaba.druid.wall.WallFilter;\nimport com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.*;\nimport org.springframework.core.env.Environment;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * 配置数据源\n */\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * druid监控filter配置。\n     * @return\n     */\n    @Bean\n    public StatFilter statFilter() {\n        StatFilter statFilter = new StatFilter();\n        statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n        statFilter.setLogSlowSql(true); //日志记录慢sql\n        statFilter.setMergeSql(true); //相同sql合并\n        return statFilter;\n    }\n\n    //----------- sql注入攻击防御配置 start ---------//\n\n    @Bean\n    public WallConfig wallConfig() {\n        WallConfig wallConfig = new WallConfig();\n        wallConfig.setDir(&quot;classpath:druid/wall/mysql&quot;); //sql过滤规则装载位置。\n        return wallConfig;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n        WallFilter wallFilter = new WallFilter();\n        wallFilter.setDbType(&quot;mysql&quot;); //指定数据库类型。\n        wallFilter.setConfig(wallConfig());\n        return wallFilter;\n    }\n\n    //----------- sql注入攻击防御配置 end ---------//\n\n\n    /**\n     * 打印sql语句。\n     * @return\n     */\n    @Bean(name = &quot;log4j2Filter&quot;)\n    public Log4j2Filter log4j2Filter() {\n        Log4j2Filter log4j2Filter = new Log4j2Filter();\n        log4j2Filter.setConnectionLogEnabled(false);\n        log4j2Filter.setResultSetLogEnabled(true); //显示sql\n        log4j2Filter.setDataSourceLogEnabled(false);\n        log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n        log4j2Filter.setStatementLogEnabled(false);\n        return log4j2Filter;\n    }\n\n\n\n    //-------------- 数据源配置 start ---------------//\n\n    /**\n     * 会员主库（spcs_user）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceWrite&quot;)\n    @Qualifier(&quot;spcsUserDataSourceWrite&quot;)\n    public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n    /**\n     * 会员从库（spcs_user_slave）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceRead_0&quot;)\n    @Qualifier(&quot;spcsUserDataSourceRead_0&quot;)\n    public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;spcsUserDataSourceWrite&quot;,&quot;spcsUserDataSourceRead_0&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;spcsUserDataSourceWrite&quot;) DataSource spcsUserDataSource,\n                                          @Qualifier(&quot;spcsUserDataSourceRead_0&quot;) DataSource spcsUserSlaveDataSource) {\n        // 配置多数据源\n        Map&lt;Object, Object&gt; dsMap = new HashMap&lt;&gt;(5);\n        dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n        dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        // 默认数据源\n        dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n        dynamicDataSource.setTargetDataSources(dsMap);\n        return dynamicDataSource;\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。</p>\n</blockquote>\n<h2 id=\"2-实现自己的数据源路由（关键）\"><a href=\"#2-实现自己的数据源路由（关键）\" class=\"headerlink\" title=\"2. 实现自己的数据源路由（关键）\"></a>2. 实现自己的数据源路由（关键）</h2><p>相当于多数据源的路由功能。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.debug(&quot;数据源为{}&quot;, DataSourceContextHolder.getDS());\n        //可以做一个简单的负载均衡策略\n        return DataSourceContextHolder.getDS();\n    }\n\n}\n</code></pre><h2 id=\"3-持有数据源\"><a href=\"#3-持有数据源\" class=\"headerlink\" title=\"3. 持有数据源\"></a>3. 持有数据源</h2><pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class DataSourceContextHolder {\n\n    private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n\n    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();\n\n    /**\n     * 设置数据源名。\n     * @param dbType\n     */\n    public static void setDS(String dbType) {\n        if (dbType == null) {\n            throw new NullPointerException(&quot;数据源不能null&quot;);\n        }\n        LOGGER.debug(&quot;切换到{}数据源&quot;, dbType);\n        contextHolder.set(dbType);\n    }\n\n    /**\n     * 获取数据源名。\n     * @return\n     */\n    public static String getDS() {\n        return (contextHolder.get());\n    }\n\n    /**\n     * 清除数据源名。\n     */\n    public static void clearDS() {\n        contextHolder.remove();\n    }\n}\n</code></pre><h2 id=\"4-通过aop，注解方式持有数据源\"><a href=\"#4-通过aop，注解方式持有数据源\" class=\"headerlink\" title=\"4. 通过aop，注解方式持有数据源\"></a>4. 通过aop，注解方式持有数据源</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.ds.DSInject;\nimport com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n *  解析注入的数据源。\n */\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    @Before(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void beforeSwitchDS(JoinPoint point) {\n\n        // 获得当前访问的class\n        Class&lt;?&gt; className = point.getTarget().getClass();\n\n        // 获得访问的方法名\n        String methodName = point.getSignature().getName();\n        // 得到方法的参数的类型\n        Class[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n        String dataSource = DSType.SPCS_USER.name(); //默认主库\n        try {\n            // 得到访问的方法对象\n            Method method = className.getMethod(methodName, argClass);\n\n            // 判断是否存在@DBInject注解\n            if (method.isAnnotationPresent(DSInject.class)) {\n                DSInject annotation = method.getAnnotation(DSInject.class);\n                // 取出注解中的数据源名\n                dataSource = annotation.value();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 切换数据源\n        DataSourceContextHolder.setDS(dataSource);\n\n    }\n\n    @After(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void afterSwitchDS(JoinPoint point) {\n        DataSourceContextHolder.clearDS();\n    }\n}\n</code></pre><hr>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface DSInject {\n    String value() default &quot;&quot;;\n}\n</code></pre><h2 id=\"5-配置jpa\"><a href=\"#5-配置jpa\" class=\"headerlink\" title=\"5. 配置jpa\"></a>5. 配置jpa</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\nimport net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport service.basic.user.common.Constants;\n\nimport javax.persistence.EntityManager;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactorySpcsUserDB&quot;, transactionManagerRef = &quot;transactionManagerSpcsUserDB&quot;, basePackages = {\n        Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\npublic class SpcsUserDBConfig {\n\n    @Autowired\n    Environment ev;\n\n    @Autowired\n    @Qualifier(&quot;dataSource&quot;)\n    private DataSource dataSource; // 数据源\n\n    @Primary\n    @Bean(name = &quot;entityManagerSpcsUser&quot;)\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = &quot;entityManagerFactorySpcsUserDB&quot;)\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n        if (ev.acceptsProfiles(&quot;dev&quot;) || ev.acceptsProfiles(&quot;test&quot;)\n                || ev.acceptsProfiles(&quot;update&quot;)) {\n            dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n        }\n        return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                .persistenceUnit(&quot;spcsUserUnit&quot;).build(); //实体管理器别名,多数据元要设置。\n    }\n\n    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {\n        JpaProperties jpaProperties = new JpaProperties();\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    /**\n     * 开启事务。\n     *\n     * @param builder\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;transactionManagerSpcsUserDB&quot;)\n    public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>: 注入的数据源为上面配置的动态数据源。<br>@Autowired<br>@Qualifier(“dataSource”)<br>private DataSource dataSource; // 数据源    </p>\n</blockquote>\n<h2 id=\"6-配置spring-jdbcTemplate\"><a href=\"#6-配置spring-jdbcTemplate\" class=\"headerlink\" title=\"6. 配置spring jdbcTemplate\"></a>6. 配置spring jdbcTemplate</h2><pre><code>package service.basic.user.config.ds;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@AutoConfigureAfter(DataSourceConfig.class)\npublic class JdbcTemplateConfig {\n\n    @Autowired\n    @Qualifier(value = &quot;dataSource&quot;)\n    private DataSource dataSource;\n\n    /**\n     * spring jdbc。\n     *\n     * @return\n     */\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    @Qualifier(&quot;jdbcTemplate&quot;)\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource);\n    }\n}\n</code></pre><h2 id=\"7-使用\"><a href=\"#7-使用\" class=\"headerlink\" title=\"7. 使用\"></a>7. 使用</h2><ul>\n<li>方式一：<br>可在service层，也可在dao层做。<br>在开始操作数据库前调用：</li>\n</ul>\n<pre><code>DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n\n//查询数据\n\nDataSourceContextHolder.clearDS();\n</code></pre><ul>\n<li>方式二：<br>通过注解，可在service层，也可在dao层做。</li>\n</ul>\n<pre><code>@DSInject(value = Constants.SPCS_USER_SLAVE)\n@Override\npublic User getUserByMobile(String mobile) {\n    return userDao.findUserByMobile(mobile);\n}    \n</code></pre>"},{"title":"shiro安全框架入门","date":"2018-05-14T03:22:37.000Z","_content":"\nApache Shiro([官网](http://shiro.apache.org))是个java的安全框架，轻便、api简单、功能全面的特性获得 许多开发者的青睐。其提供了认证、授权、加密以及会话管理等功能……\n\n### 一.介绍\n\n#### 1.功能特性\nShiro 包含 10 个内容，如下图：\n\n{%asset_img shiro-01.png%}\n\n- Authentication: 身份认证，拥有合法身份才能登录系统并使用。\n- Authorization： 授权验证。即认证某个已经得到身份认证的用户是否拥有对某个功能或者某种资源的使用权限。\n- Session Manager： 会话管理。用户登录后，没退出之前，为一次会话，所有的信息都在会话中。会话可以是javase环境，也可以是java web环境。\n- Cryptography： 加密，保护数据的安全性。\n- Web Support： web支持，把shiro容易的集成到web环境中。\n- Caching： 缓存，用户登陆后，用户的信息、拥有的角色权限不必每次查，缓存起来。\n- Concurrency： shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。\n- Testing：提供测试支持。\n- Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。\n- Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。\n\n#### 2.运行原理\n1.原理图1（应用程序角度）：\n{%asset_img shiro-02.png%}\n\n- Subject：主体，代表当前“用户”，这里的用户指的不仅仅是登录用户，指的是任何与该系统交互的主体。所有的Subject都和SecurityManager绑定，与Subject的任何交互都委托给SecurityManager来处理。\n- SecurityManager： 安全管理器，是shiro的核心功能。它负责所有的安全操作管理，管理这所有的Subject。类似于SpringMvc中的DispatcherServlet控制器。\n- Realm： 域。所有的安全数据保存，获取都要通过Realm。SecurityManager和它交互，获取相关数据。Realm就类似于数据源DataSource。\n\n2.原理图2（内部架构）：\n{%asset_img shiro-03.png%}\n\n- Subject：主体。\n- SecurityManager：安全管理器。\n- Authenticator： 认证器，负责对主体的身份认证。可以自定义，重新设定认证策略，即什么情况下才算认证通过。\n- Authrizer： 授权器，或者访问控制器。决定主体是否有权限进行相应操作。\n- Realm： 可以一个或者多个。可以是jdbc，redis，内存等实现。\n- SessionManager： 会话管理器。\n- SessionDAO： 数据访问对象，用于会话的CRUD。可以自定义，控制session存储的位置，关系数据库，redis等。另外，可以使用缓存，提高性能。\n- CacheManager： 缓存管理器。\n- Cryptography： 密码模块。提供了一些加解密算法。\n\n#### 3.过滤器\n应用到web系统中时，Shiro会默认创建一些过滤器对客户端请求进行过滤。常用过滤器有：\n\n|  过滤器简称   | 对应的 Java 类 |\n| :------| :------|\n| anon | org.apache.shiro.web.filter.authc.AnonymousFilter |\n| authc | org.apache.shiro.web.filter.authc.FormAuthenticationFilter |\n| authcBasic | org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter |\n| perms | org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter |\n| port | org.apache.shiro.web.filter.authz.PortFilter |\n| rest | org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter |\n| roles | org.apache.shiro.web.filter.authz.RolesAuthorizationFilter |\n| ssl | org.apache.shiro.web.filter.authz.SslFilter |\n| user | org.apache.shiro.web.filter.authc.UserFilter |\n|  logout | org.apache.shiro.web.filter.authc.LogoutFilter |\n| noSessionCreation | org.apache.shiro.web.filter.session.NoSessionCreationFilter |\n\n说明：\n\n    /admins/**=anon               # 表示该 uri 可以匿名访问\n    /admins/**=auth               # 表示该 uri 需要认证才能访问\n    /admins/**=authcBasic         # 表示该 uri 需要 httpBasic 认证\n    /admins/**=perms[user:add:*]  # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问\n    /admins/**=port[8081]         # 表示该 uri 需要使用 8081 端口\n    /admins/**=rest[user]         # 相当于 /admins/**=perms[user:method]，其中，method 表示  get、post、delete 等\n    /admins/**=roles[admin]       # 表示该 uri 需要认证用户拥有 admin 角色才能访问\n    /admins/**=ssl                # 表示该 uri 需要使用 https 协议\n    /admins/**=user               # 表示该 uri 需要认证或通过记住我认证才能访问\n    /logout=logout                # 表示注销,可以当作固定配置\n    \n _注意_\n anon，authcBasic，auchc，user 是认证过滤器。\n perms，roles，ssl，rest，port 是授权过滤器。   \n\n### 二.认证\n\n1.认证路程图：\n{%asset_img shiro-04.png%} \n\n2.使用代码示例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.SimpleAccountRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class AuthenticationTest {\n\n    SimpleAccountRealm simpleAccoutRealm = new SimpleAccountRealm();\n\n    @Before\n    public void addUser() {\n        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");\n//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");\n    }\n\n    @Test\n    public void  testAuthentication() {\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(simpleAccoutRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.logout();//退出登录\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证\n\n    }\n}\n\n```\n\n### 三.授权\n\n1.流程图：\n{%asset_img shiro-05.png%}\n\n2。代码示例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.SimpleAccountRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class AuthenticationTest {\n\n    SimpleAccountRealm simpleAccoutRealm = new SimpleAccountRealm();\n\n    @Before\n    public void addUser() {\n//        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");\n//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");\n\n        simpleAccoutRealm.addAccount(\"zmt\",\"123456\",\"admin\",\"user\"); //添加角色\n    }\n\n    @Test\n    public void  testAuthentication() {\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(simpleAccoutRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user1\"); //拥有该两个角色\n\n//        subject.logout();//退出登录\n//        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证\n\n    }\n\n\n}\n\n```\n\n\n\n### 四.Shiro自定义Realm\n\n#### 1.IniRealm讲解\n\n代码样例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.text.IniRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class IniRealmTest {\n\n    @Test\n    public void  test1() {\n\n        IniRealm iniRealm = new IniRealm(\"classpath:user.ini\");\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(iniRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:delete\");\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //报错，没有update权限\n    }\n\n\n}\n\n```\n\n```text\n编辑：user.ini\n\n[users]\nzmt=123456,admin,user\n[roles]\nadmin=user:delete,user:update\n```\n#### 2.JdbcRealm讲解\n\n用户、角色、权限数据都在数据库里面。而不是在配置文件里面。 \n两种方式，一种是使用默认查询语句；另外一种是自己设计表，写sql语句，不必遵守默认的。   \n\n##### 2.1.默认方式\n\n- 首先，创建相关默认数据表：   \n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50718\nSource Host           : localhost:3307\nSource Database       : shiro-test\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50718\nFile Encoding         : 65001\n\nDate: 2018-10-15 17:09:45\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for roles_permissions\n-- ----------------------------\nDROP TABLE IF EXISTS `roles_permissions`;\nCREATE TABLE `roles_permissions` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(255) NOT NULL,\n  `permission` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `role_name` (`role_name`),\n  CONSTRAINT `roles_permissions_ibfk_1` FOREIGN KEY (`role_name`) REFERENCES `user_roles` (`role_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of roles_permissions\n-- ----------------------------\nINSERT INTO `roles_permissions` VALUES ('1', 'admin', 'user:select');\n\n-- ----------------------------\n-- Table structure for user_roles\n-- ----------------------------\nDROP TABLE IF EXISTS `user_roles`;\nCREATE TABLE `user_roles` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`username`),\n  KEY `role_name` (`role_name`),\n  CONSTRAINT `user_roles_ibfk_1` FOREIGN KEY (`username`) REFERENCES `users` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of user_roles\n-- ----------------------------\nINSERT INTO `user_roles` VALUES ('1', 'zmt', 'admin');\n\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  `password_salt` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'zmt', '123456', 'abcd');\nSET FOREIGN_KEY_CHECKS=1;\n\n```\n- 代码样例：\n```java\npackage com.example.springboot2shirostart;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.jdbc.JdbcRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class JdbcRealmTest {\n\n    DruidDataSource dataSource = new DruidDataSource();\n\n    {\n        dataSource.setUrl(\"jdbc:mysql://localhost:3307/shiro-test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n    }\n\n    /**\n     * 查询默认的数据表做相关操作。\n     */\n    @Test\n    public void  test1() {\n\n        JdbcRealm jdbcRealm = new JdbcRealm();\n        jdbcRealm.setDataSource(dataSource); //设置数据源\n        jdbcRealm.setPermissionsLookupEnabled(true); //是否可以查看权限。默认为false。不打开，则无法查看权限\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(jdbcRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n//        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n//        subject.checkPermission(\"user:update\"); //报错，没有update权限\n    }\n\n\n}\n\n```\n\n##### 2.2.自己设计表写查询语句\n\n- 创建数据表 \n不必遵循默认规范，表名、字段名都可以自定义。  \n\n脚本： \n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50718\nSource Host           : localhost:3307\nSource Database       : shiro-test\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50718\nFile Encoding         : 65001\n\nDate: 2018-10-17 11:42:25\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for test_role_permissions\n-- ----------------------------\nDROP TABLE IF EXISTS `test_role_permissions`;\nCREATE TABLE `test_role_permissions` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(255) NOT NULL,\n  `permission` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_role_permissions\n-- ----------------------------\nINSERT INTO `test_role_permissions` VALUES ('1', 'caiwu', 'user:update');\n\n-- ----------------------------\n-- Table structure for test_user\n-- ----------------------------\nDROP TABLE IF EXISTS `test_user`;\nCREATE TABLE `test_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_name` varchar(255) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`user_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_user\n-- ----------------------------\nINSERT INTO `test_user` VALUES ('1', 'xr', '123456');\n\n-- ----------------------------\n-- Table structure for test_user_role\n-- ----------------------------\nDROP TABLE IF EXISTS `test_user_role`;\nCREATE TABLE `test_user_role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `test_user_name` varchar(255) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_user_role\n-- ----------------------------\nINSERT INTO `test_user_role` VALUES ('1', 'xr', 'caiwu');\nSET FOREIGN_KEY_CHECKS=1;\n```\n- 代码样例：\n```java\npackage com.example.springboot2shirostart;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.jdbc.JdbcRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class JdbcRealmTest {\n\n    DruidDataSource dataSource = new DruidDataSource();\n\n    {\n        dataSource.setUrl(\"jdbc:mysql://localhost:3307/shiro-test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n    }\n\n    @Test\n    public void  test2() {\n\n        JdbcRealm jdbcRealm = new JdbcRealm();\n        jdbcRealm.setDataSource(dataSource); //设置数据源\n        jdbcRealm.setPermissionsLookupEnabled(true); //是否可以查看权限。默认为false。不打开，则无法查看权限\n\n        //创建sql语句，使用自己的表、sql来验证\n        String sql_auth = \"SELECT `password` FROM test_user WHERE user_name = ?\";\n        jdbcRealm.setAuthenticationQuery(sql_auth);\n        String sql_role = \"SELECT role_name FROM test_user_role WHERE test_user_name = ?\";\n        jdbcRealm.setUserRolesQuery(sql_role);\n        String sql_permisstion = \"SELECT permission FROM test_role_permissions WHERE role_name = ?\";\n        jdbcRealm.setPermissionsQuery(sql_permisstion);\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(jdbcRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"xr\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"caiwu\");\n\n        //权限\n        subject.checkPermission(\"user:update\");//jdbcRealm.setPermissionsLookupEnabled(true);\n    }\n\n\n}\n\n```\n\n#### 3.自定义Realm\n\n- 创建类CustomRealm\n\n自定义Realm需要继承`AuthorizingRealm`。\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CustomRealm extends AuthorizingRealm {\n\n    final String realmName = this.getClass().getSimpleName(); //自定义realm名称\n\n    Map<String,String> userMap = new HashMap<>(16);\n\n    {\n        userMap.put(\"zmt\",\"123456\");\n        userMap.put(\"xr\",\"654321\");\n\n        super.setName(realmName); //设置名称\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = (String) principals.getPrimaryPrincipal();\n        //从数据库或者缓存中获取角色数据。\n        Set<String> roles = getRolesByUsername(username);\n        Set<String> permissions = getPermissionByUsername(username);\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.setStringPermissions(permissions); //设置权限\n        authorizationInfo.setRoles(roles); //设置角色\n\n        return authorizationInfo;\n    }\n\n    /**\n     * 模拟通过用户名获取权限。\n     * @param username\n     * @return\n     */\n    private Set<String> getPermissionByUsername(String username) {\n        Set<String> permissions = new HashSet<>();\n        permissions.add(\"admin:delete\");\n        permissions.add(\"user:select\");\n        permissions.add(\"user:update\");\n        return permissions;\n    }\n\n    /**\n     * 模拟获取角色。根据用户名获取角色。\n     * @param username\n     * @return\n     */\n    private Set<String> getRolesByUsername(String username) {\n        Set<String> roles = new HashSet<>();\n        roles.add(\"admin\");\n        roles.add(\"user\");\n        return roles;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        //从主体传过来认证信息,获得用户名\n        String username = (String) token.getPrincipal();\n        System.out.println(\"username:\" + username);\n\n        //通过用户名到数据库中获取凭证\n        String pwd = getPwdByUsername(username);\n        if (pwd == null) {\n            return null;\n        }\n\n        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,pwd,realmName);\n\n        return authenticationInfo;\n    }\n\n    /**\n     * 模拟获取数据库数据。根据用户名获取用户密码\n     * @param username 用户名。\n     * @return\n     */\n    private String getPwdByUsername(String username) {\n        return userMap.get(username);\n    }\n\n}\n\n```\n\n- 测试：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class CustomRealmTest {\n\n\n    @Test\n    public void  test1() {\n\n        CustomRealm customRealm = new CustomRealm();//自定义Realm\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(customRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n//        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //有update权限\n    }\n}\n\n```\n\n### 五.Shiro加密\n\n前面介绍的密码都是明文的，实际的密码在数据库中是加密的。    \n\n下面在自定义的Realm中使用加密。  \n\n- 代码：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CustomRealm extends AuthorizingRealm {\n\n    final String realmName = this.getClass().getSimpleName(); //自定义realm名称\n\n    Map<String,String> userMap = new HashMap<>(16);\n\n    {\n//        userMap.put(\"zmt\",\"123456\");\n//        userMap.put(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\"); //数据库的密码是密文，不加盐\n        userMap.put(\"zmt\",\"640a19b710290a9ff4d72e70cdd21913\"); //md5加盐密码\n        userMap.put(\"xr\",\"654321\");\n\n        super.setName(realmName); //设置名称\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = (String) principals.getPrimaryPrincipal();\n        //从数据库或者缓存中获取角色数据。\n        Set<String> roles = getRolesByUsername(username);\n        Set<String> permissions = getPermissionByUsername(username);\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.setStringPermissions(permissions); //设置权限\n        authorizationInfo.setRoles(roles); //设置角色\n\n        return authorizationInfo;\n    }\n\n    /**\n     * 模拟通过用户名获取权限。\n     * @param username\n     * @return\n     */\n    private Set<String> getPermissionByUsername(String username) {\n        Set<String> permissions = new HashSet<>();\n        permissions.add(\"admin:delete\");\n        permissions.add(\"user:select\");\n        permissions.add(\"user:update\");\n        return permissions;\n    }\n\n    /**\n     * 模拟获取角色。根据用户名获取角色。\n     * @param username\n     * @return\n     */\n    private Set<String> getRolesByUsername(String username) {\n        Set<String> roles = new HashSet<>();\n        roles.add(\"admin\");\n        roles.add(\"user\");\n        return roles;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        //从主体传过来认证信息,获得用户名\n        String username = (String) token.getPrincipal();\n        System.out.println(\"username:\" + username);\n\n        //通过用户名到数据库中获取凭证\n        String pwd = getPwdByUsername(username);\n        if (pwd == null) {\n            return null;\n        }\n\n        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,pwd,realmName);\n        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(\"aaa\")); //密码加盐后，这里要加上这句\n\n        return authenticationInfo;\n    }\n\n    /**\n     * 模拟获取数据库数据。根据用户名获取用户密码\n     * @param username 用户名。\n     * @return\n     */\n    private String getPwdByUsername(String username) {\n        return userMap.get(username);\n    }\n\n\n}\n\n```\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.crypto.hash.Md5Hash;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class CustomRealmTest {\n\n\n    @Test\n    public void  test1() {\n\n        CustomRealm customRealm = new CustomRealm();//自定义Realm\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(customRealm);\n\n        //设置散列加密\n        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();\n        matcher.setHashAlgorithmName(\"md5\");//设置加密方式\n        matcher.setHashIterations(1); //设置加密次数\n        customRealm.setCredentialsMatcher(matcher); //设置加密对象\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\");//用户,密码MD5加密。明文：123456\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n//        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //有update权限\n    }\n\n    @Test\n    public void genPwd() {\n//        Md5Hash md5Hash = new Md5Hash(\"123456\"); //md5加密密码，不加盐\n//        System.out.println(\"md5加密：\" + md5Hash);\n\n        Md5Hash md5Hash = new Md5Hash(\"e10adc3949ba59abbe56e057f20f883e\",\"aaa\"); //md5加密密码，加盐，密码更加难以识破，盐一般用随机数，这里写死\n        System.out.println(\"md5加盐加密：\" + md5Hash);\n    }\n}\n\n```\n\n\n\n","source":"_posts/shiro-start.md","raw":"---\ntitle: shiro安全框架入门\ndate: 2018-05-14 11:22:37\ncategories: shiro\ntags: shiro入门\n---\n\nApache Shiro([官网](http://shiro.apache.org))是个java的安全框架，轻便、api简单、功能全面的特性获得 许多开发者的青睐。其提供了认证、授权、加密以及会话管理等功能……\n\n### 一.介绍\n\n#### 1.功能特性\nShiro 包含 10 个内容，如下图：\n\n{%asset_img shiro-01.png%}\n\n- Authentication: 身份认证，拥有合法身份才能登录系统并使用。\n- Authorization： 授权验证。即认证某个已经得到身份认证的用户是否拥有对某个功能或者某种资源的使用权限。\n- Session Manager： 会话管理。用户登录后，没退出之前，为一次会话，所有的信息都在会话中。会话可以是javase环境，也可以是java web环境。\n- Cryptography： 加密，保护数据的安全性。\n- Web Support： web支持，把shiro容易的集成到web环境中。\n- Caching： 缓存，用户登陆后，用户的信息、拥有的角色权限不必每次查，缓存起来。\n- Concurrency： shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。\n- Testing：提供测试支持。\n- Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。\n- Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。\n\n#### 2.运行原理\n1.原理图1（应用程序角度）：\n{%asset_img shiro-02.png%}\n\n- Subject：主体，代表当前“用户”，这里的用户指的不仅仅是登录用户，指的是任何与该系统交互的主体。所有的Subject都和SecurityManager绑定，与Subject的任何交互都委托给SecurityManager来处理。\n- SecurityManager： 安全管理器，是shiro的核心功能。它负责所有的安全操作管理，管理这所有的Subject。类似于SpringMvc中的DispatcherServlet控制器。\n- Realm： 域。所有的安全数据保存，获取都要通过Realm。SecurityManager和它交互，获取相关数据。Realm就类似于数据源DataSource。\n\n2.原理图2（内部架构）：\n{%asset_img shiro-03.png%}\n\n- Subject：主体。\n- SecurityManager：安全管理器。\n- Authenticator： 认证器，负责对主体的身份认证。可以自定义，重新设定认证策略，即什么情况下才算认证通过。\n- Authrizer： 授权器，或者访问控制器。决定主体是否有权限进行相应操作。\n- Realm： 可以一个或者多个。可以是jdbc，redis，内存等实现。\n- SessionManager： 会话管理器。\n- SessionDAO： 数据访问对象，用于会话的CRUD。可以自定义，控制session存储的位置，关系数据库，redis等。另外，可以使用缓存，提高性能。\n- CacheManager： 缓存管理器。\n- Cryptography： 密码模块。提供了一些加解密算法。\n\n#### 3.过滤器\n应用到web系统中时，Shiro会默认创建一些过滤器对客户端请求进行过滤。常用过滤器有：\n\n|  过滤器简称   | 对应的 Java 类 |\n| :------| :------|\n| anon | org.apache.shiro.web.filter.authc.AnonymousFilter |\n| authc | org.apache.shiro.web.filter.authc.FormAuthenticationFilter |\n| authcBasic | org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter |\n| perms | org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter |\n| port | org.apache.shiro.web.filter.authz.PortFilter |\n| rest | org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter |\n| roles | org.apache.shiro.web.filter.authz.RolesAuthorizationFilter |\n| ssl | org.apache.shiro.web.filter.authz.SslFilter |\n| user | org.apache.shiro.web.filter.authc.UserFilter |\n|  logout | org.apache.shiro.web.filter.authc.LogoutFilter |\n| noSessionCreation | org.apache.shiro.web.filter.session.NoSessionCreationFilter |\n\n说明：\n\n    /admins/**=anon               # 表示该 uri 可以匿名访问\n    /admins/**=auth               # 表示该 uri 需要认证才能访问\n    /admins/**=authcBasic         # 表示该 uri 需要 httpBasic 认证\n    /admins/**=perms[user:add:*]  # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问\n    /admins/**=port[8081]         # 表示该 uri 需要使用 8081 端口\n    /admins/**=rest[user]         # 相当于 /admins/**=perms[user:method]，其中，method 表示  get、post、delete 等\n    /admins/**=roles[admin]       # 表示该 uri 需要认证用户拥有 admin 角色才能访问\n    /admins/**=ssl                # 表示该 uri 需要使用 https 协议\n    /admins/**=user               # 表示该 uri 需要认证或通过记住我认证才能访问\n    /logout=logout                # 表示注销,可以当作固定配置\n    \n _注意_\n anon，authcBasic，auchc，user 是认证过滤器。\n perms，roles，ssl，rest，port 是授权过滤器。   \n\n### 二.认证\n\n1.认证路程图：\n{%asset_img shiro-04.png%} \n\n2.使用代码示例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.SimpleAccountRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class AuthenticationTest {\n\n    SimpleAccountRealm simpleAccoutRealm = new SimpleAccountRealm();\n\n    @Before\n    public void addUser() {\n        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");\n//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");\n    }\n\n    @Test\n    public void  testAuthentication() {\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(simpleAccoutRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.logout();//退出登录\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证\n\n    }\n}\n\n```\n\n### 三.授权\n\n1.流程图：\n{%asset_img shiro-05.png%}\n\n2。代码示例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.SimpleAccountRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Before;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class AuthenticationTest {\n\n    SimpleAccountRealm simpleAccoutRealm = new SimpleAccountRealm();\n\n    @Before\n    public void addUser() {\n//        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");\n//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");\n\n        simpleAccoutRealm.addAccount(\"zmt\",\"123456\",\"admin\",\"user\"); //添加角色\n    }\n\n    @Test\n    public void  testAuthentication() {\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(simpleAccoutRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user1\"); //拥有该两个角色\n\n//        subject.logout();//退出登录\n//        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证\n\n    }\n\n\n}\n\n```\n\n\n\n### 四.Shiro自定义Realm\n\n#### 1.IniRealm讲解\n\n代码样例：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.text.IniRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class IniRealmTest {\n\n    @Test\n    public void  test1() {\n\n        IniRealm iniRealm = new IniRealm(\"classpath:user.ini\");\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(iniRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:delete\");\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //报错，没有update权限\n    }\n\n\n}\n\n```\n\n```text\n编辑：user.ini\n\n[users]\nzmt=123456,admin,user\n[roles]\nadmin=user:delete,user:update\n```\n#### 2.JdbcRealm讲解\n\n用户、角色、权限数据都在数据库里面。而不是在配置文件里面。 \n两种方式，一种是使用默认查询语句；另外一种是自己设计表，写sql语句，不必遵守默认的。   \n\n##### 2.1.默认方式\n\n- 首先，创建相关默认数据表：   \n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50718\nSource Host           : localhost:3307\nSource Database       : shiro-test\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50718\nFile Encoding         : 65001\n\nDate: 2018-10-15 17:09:45\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for roles_permissions\n-- ----------------------------\nDROP TABLE IF EXISTS `roles_permissions`;\nCREATE TABLE `roles_permissions` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(255) NOT NULL,\n  `permission` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `role_name` (`role_name`),\n  CONSTRAINT `roles_permissions_ibfk_1` FOREIGN KEY (`role_name`) REFERENCES `user_roles` (`role_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of roles_permissions\n-- ----------------------------\nINSERT INTO `roles_permissions` VALUES ('1', 'admin', 'user:select');\n\n-- ----------------------------\n-- Table structure for user_roles\n-- ----------------------------\nDROP TABLE IF EXISTS `user_roles`;\nCREATE TABLE `user_roles` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`username`),\n  KEY `role_name` (`role_name`),\n  CONSTRAINT `user_roles_ibfk_1` FOREIGN KEY (`username`) REFERENCES `users` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of user_roles\n-- ----------------------------\nINSERT INTO `user_roles` VALUES ('1', 'zmt', 'admin');\n\n-- ----------------------------\n-- Table structure for users\n-- ----------------------------\nDROP TABLE IF EXISTS `users`;\nCREATE TABLE `users` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `username` varchar(255) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  `password_salt` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`username`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of users\n-- ----------------------------\nINSERT INTO `users` VALUES ('1', 'zmt', '123456', 'abcd');\nSET FOREIGN_KEY_CHECKS=1;\n\n```\n- 代码样例：\n```java\npackage com.example.springboot2shirostart;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.jdbc.JdbcRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class JdbcRealmTest {\n\n    DruidDataSource dataSource = new DruidDataSource();\n\n    {\n        dataSource.setUrl(\"jdbc:mysql://localhost:3307/shiro-test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n    }\n\n    /**\n     * 查询默认的数据表做相关操作。\n     */\n    @Test\n    public void  test1() {\n\n        JdbcRealm jdbcRealm = new JdbcRealm();\n        jdbcRealm.setDataSource(dataSource); //设置数据源\n        jdbcRealm.setPermissionsLookupEnabled(true); //是否可以查看权限。默认为false。不打开，则无法查看权限\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(jdbcRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"admin\"); //admin通过，admin1报错\n//        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n//        subject.checkPermission(\"user:update\"); //报错，没有update权限\n    }\n\n\n}\n\n```\n\n##### 2.2.自己设计表写查询语句\n\n- 创建数据表 \n不必遵循默认规范，表名、字段名都可以自定义。  \n\n脚本： \n```sql\n/*\nNavicat MySQL Data Transfer\n\nSource Server         : localhost\nSource Server Version : 50718\nSource Host           : localhost:3307\nSource Database       : shiro-test\n\nTarget Server Type    : MYSQL\nTarget Server Version : 50718\nFile Encoding         : 65001\n\nDate: 2018-10-17 11:42:25\n*/\n\nSET FOREIGN_KEY_CHECKS=0;\n\n-- ----------------------------\n-- Table structure for test_role_permissions\n-- ----------------------------\nDROP TABLE IF EXISTS `test_role_permissions`;\nCREATE TABLE `test_role_permissions` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `role_name` varchar(255) NOT NULL,\n  `permission` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_role_permissions\n-- ----------------------------\nINSERT INTO `test_role_permissions` VALUES ('1', 'caiwu', 'user:update');\n\n-- ----------------------------\n-- Table structure for test_user\n-- ----------------------------\nDROP TABLE IF EXISTS `test_user`;\nCREATE TABLE `test_user` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `user_name` varchar(255) NOT NULL,\n  `password` varchar(255) NOT NULL,\n  PRIMARY KEY (`id`),\n  KEY `username` (`user_name`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_user\n-- ----------------------------\nINSERT INTO `test_user` VALUES ('1', 'xr', '123456');\n\n-- ----------------------------\n-- Table structure for test_user_role\n-- ----------------------------\nDROP TABLE IF EXISTS `test_user_role`;\nCREATE TABLE `test_user_role` (\n  `id` int(11) NOT NULL AUTO_INCREMENT,\n  `test_user_name` varchar(255) NOT NULL,\n  `role_name` varchar(255) DEFAULT NULL,\n  PRIMARY KEY (`id`)\n) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8mb4;\n\n-- ----------------------------\n-- Records of test_user_role\n-- ----------------------------\nINSERT INTO `test_user_role` VALUES ('1', 'xr', 'caiwu');\nSET FOREIGN_KEY_CHECKS=1;\n```\n- 代码样例：\n```java\npackage com.example.springboot2shirostart;\n\nimport com.alibaba.druid.pool.DruidDataSource;\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.realm.jdbc.JdbcRealm;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class JdbcRealmTest {\n\n    DruidDataSource dataSource = new DruidDataSource();\n\n    {\n        dataSource.setUrl(\"jdbc:mysql://localhost:3307/shiro-test\");\n        dataSource.setUsername(\"root\");\n        dataSource.setPassword(\"root\");\n    }\n\n    @Test\n    public void  test2() {\n\n        JdbcRealm jdbcRealm = new JdbcRealm();\n        jdbcRealm.setDataSource(dataSource); //设置数据源\n        jdbcRealm.setPermissionsLookupEnabled(true); //是否可以查看权限。默认为false。不打开，则无法查看权限\n\n        //创建sql语句，使用自己的表、sql来验证\n        String sql_auth = \"SELECT `password` FROM test_user WHERE user_name = ?\";\n        jdbcRealm.setAuthenticationQuery(sql_auth);\n        String sql_role = \"SELECT role_name FROM test_user_role WHERE test_user_name = ?\";\n        jdbcRealm.setUserRolesQuery(sql_role);\n        String sql_permisstion = \"SELECT permission FROM test_role_permissions WHERE role_name = ?\";\n        jdbcRealm.setPermissionsQuery(sql_permisstion);\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(jdbcRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"xr\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n        subject.checkRole(\"caiwu\");\n\n        //权限\n        subject.checkPermission(\"user:update\");//jdbcRealm.setPermissionsLookupEnabled(true);\n    }\n\n\n}\n\n```\n\n#### 3.自定义Realm\n\n- 创建类CustomRealm\n\n自定义Realm需要继承`AuthorizingRealm`。\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CustomRealm extends AuthorizingRealm {\n\n    final String realmName = this.getClass().getSimpleName(); //自定义realm名称\n\n    Map<String,String> userMap = new HashMap<>(16);\n\n    {\n        userMap.put(\"zmt\",\"123456\");\n        userMap.put(\"xr\",\"654321\");\n\n        super.setName(realmName); //设置名称\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = (String) principals.getPrimaryPrincipal();\n        //从数据库或者缓存中获取角色数据。\n        Set<String> roles = getRolesByUsername(username);\n        Set<String> permissions = getPermissionByUsername(username);\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.setStringPermissions(permissions); //设置权限\n        authorizationInfo.setRoles(roles); //设置角色\n\n        return authorizationInfo;\n    }\n\n    /**\n     * 模拟通过用户名获取权限。\n     * @param username\n     * @return\n     */\n    private Set<String> getPermissionByUsername(String username) {\n        Set<String> permissions = new HashSet<>();\n        permissions.add(\"admin:delete\");\n        permissions.add(\"user:select\");\n        permissions.add(\"user:update\");\n        return permissions;\n    }\n\n    /**\n     * 模拟获取角色。根据用户名获取角色。\n     * @param username\n     * @return\n     */\n    private Set<String> getRolesByUsername(String username) {\n        Set<String> roles = new HashSet<>();\n        roles.add(\"admin\");\n        roles.add(\"user\");\n        return roles;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        //从主体传过来认证信息,获得用户名\n        String username = (String) token.getPrincipal();\n        System.out.println(\"username:\" + username);\n\n        //通过用户名到数据库中获取凭证\n        String pwd = getPwdByUsername(username);\n        if (pwd == null) {\n            return null;\n        }\n\n        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,pwd,realmName);\n\n        return authenticationInfo;\n    }\n\n    /**\n     * 模拟获取数据库数据。根据用户名获取用户密码\n     * @param username 用户名。\n     * @return\n     */\n    private String getPwdByUsername(String username) {\n        return userMap.get(username);\n    }\n\n}\n\n```\n\n- 测试：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class CustomRealmTest {\n\n\n    @Test\n    public void  test1() {\n\n        CustomRealm customRealm = new CustomRealm();//自定义Realm\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(customRealm);\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"123456\");//用户\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n//        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //有update权限\n    }\n}\n\n```\n\n### 五.Shiro加密\n\n前面介绍的密码都是明文的，实际的密码在数据库中是加密的。    \n\n下面在自定义的Realm中使用加密。  \n\n- 代码：\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.authc.AuthenticationException;\nimport org.apache.shiro.authc.AuthenticationInfo;\nimport org.apache.shiro.authc.AuthenticationToken;\nimport org.apache.shiro.authc.SimpleAuthenticationInfo;\nimport org.apache.shiro.authz.AuthorizationInfo;\nimport org.apache.shiro.authz.SimpleAuthorizationInfo;\nimport org.apache.shiro.realm.AuthorizingRealm;\nimport org.apache.shiro.subject.PrincipalCollection;\nimport org.apache.shiro.util.ByteSource;\n\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.Map;\nimport java.util.Set;\n\npublic class CustomRealm extends AuthorizingRealm {\n\n    final String realmName = this.getClass().getSimpleName(); //自定义realm名称\n\n    Map<String,String> userMap = new HashMap<>(16);\n\n    {\n//        userMap.put(\"zmt\",\"123456\");\n//        userMap.put(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\"); //数据库的密码是密文，不加盐\n        userMap.put(\"zmt\",\"640a19b710290a9ff4d72e70cdd21913\"); //md5加盐密码\n        userMap.put(\"xr\",\"654321\");\n\n        super.setName(realmName); //设置名称\n    }\n\n\n    @Override\n    protected AuthorizationInfo doGetAuthorizationInfo(PrincipalCollection principals) {\n        String username = (String) principals.getPrimaryPrincipal();\n        //从数据库或者缓存中获取角色数据。\n        Set<String> roles = getRolesByUsername(username);\n        Set<String> permissions = getPermissionByUsername(username);\n\n        SimpleAuthorizationInfo authorizationInfo = new SimpleAuthorizationInfo();\n        authorizationInfo.setStringPermissions(permissions); //设置权限\n        authorizationInfo.setRoles(roles); //设置角色\n\n        return authorizationInfo;\n    }\n\n    /**\n     * 模拟通过用户名获取权限。\n     * @param username\n     * @return\n     */\n    private Set<String> getPermissionByUsername(String username) {\n        Set<String> permissions = new HashSet<>();\n        permissions.add(\"admin:delete\");\n        permissions.add(\"user:select\");\n        permissions.add(\"user:update\");\n        return permissions;\n    }\n\n    /**\n     * 模拟获取角色。根据用户名获取角色。\n     * @param username\n     * @return\n     */\n    private Set<String> getRolesByUsername(String username) {\n        Set<String> roles = new HashSet<>();\n        roles.add(\"admin\");\n        roles.add(\"user\");\n        return roles;\n    }\n\n    @Override\n    protected AuthenticationInfo doGetAuthenticationInfo(AuthenticationToken token) throws AuthenticationException {\n\n        //从主体传过来认证信息,获得用户名\n        String username = (String) token.getPrincipal();\n        System.out.println(\"username:\" + username);\n\n        //通过用户名到数据库中获取凭证\n        String pwd = getPwdByUsername(username);\n        if (pwd == null) {\n            return null;\n        }\n\n        SimpleAuthenticationInfo authenticationInfo = new SimpleAuthenticationInfo(username,pwd,realmName);\n        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(\"aaa\")); //密码加盐后，这里要加上这句\n\n        return authenticationInfo;\n    }\n\n    /**\n     * 模拟获取数据库数据。根据用户名获取用户密码\n     * @param username 用户名。\n     * @return\n     */\n    private String getPwdByUsername(String username) {\n        return userMap.get(username);\n    }\n\n\n}\n\n```\n\n```java\npackage com.example.springboot2shirostart;\n\nimport org.apache.shiro.SecurityUtils;\nimport org.apache.shiro.authc.UsernamePasswordToken;\nimport org.apache.shiro.authc.credential.HashedCredentialsMatcher;\nimport org.apache.shiro.crypto.hash.Md5Hash;\nimport org.apache.shiro.mgt.DefaultSecurityManager;\nimport org.apache.shiro.subject.Subject;\nimport org.junit.Test;\n\n/**\n * 简单认证\n */\npublic class CustomRealmTest {\n\n\n    @Test\n    public void  test1() {\n\n        CustomRealm customRealm = new CustomRealm();//自定义Realm\n\n        //1.创建securityManager环境\n        DefaultSecurityManager defaultSecurityManager = new DefaultSecurityManager();\n        defaultSecurityManager.setRealm(customRealm);\n\n        //设置散列加密\n        HashedCredentialsMatcher matcher = new HashedCredentialsMatcher();\n        matcher.setHashAlgorithmName(\"md5\");//设置加密方式\n        matcher.setHashIterations(1); //设置加密次数\n        customRealm.setCredentialsMatcher(matcher); //设置加密对象\n\n        //2.主体提交认证请求\n        SecurityUtils.setSecurityManager(defaultSecurityManager);\n        Subject subject = SecurityUtils.getSubject();\n\n        UsernamePasswordToken token = new UsernamePasswordToken(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\");//用户,密码MD5加密。明文：123456\n        subject.login(token);\n        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//已认证\n\n//        subject.checkRole(\"admin\"); //admin通过，admin1报错\n        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色\n\n        //权限\n        subject.checkPermission(\"user:select\");//jdbcRealm.setPermissionsLookupEnabled(true);\n//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限\n        subject.checkPermission(\"user:update\"); //有update权限\n    }\n\n    @Test\n    public void genPwd() {\n//        Md5Hash md5Hash = new Md5Hash(\"123456\"); //md5加密密码，不加盐\n//        System.out.println(\"md5加密：\" + md5Hash);\n\n        Md5Hash md5Hash = new Md5Hash(\"e10adc3949ba59abbe56e057f20f883e\",\"aaa\"); //md5加密密码，加盐，密码更加难以识破，盐一般用随机数，这里写死\n        System.out.println(\"md5加盐加密：\" + md5Hash);\n    }\n}\n\n```\n\n\n\n","slug":"shiro-start","published":1,"updated":"2018-11-09T01:20:30.888Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38sw00duqcrgfi0lwzps","content":"<p>Apache Shiro(<a href=\"http://shiro.apache.org\" target=\"_blank\" rel=\"noopener\">官网</a>)是个java的安全框架，轻便、api简单、功能全面的特性获得 许多开发者的青睐。其提供了认证、授权、加密以及会话管理等功能……</p>\n<h3 id=\"一-介绍\"><a href=\"#一-介绍\" class=\"headerlink\" title=\"一.介绍\"></a>一.介绍</h3><h4 id=\"1-功能特性\"><a href=\"#1-功能特性\" class=\"headerlink\" title=\"1.功能特性\"></a>1.功能特性</h4><p>Shiro 包含 10 个内容，如下图：</p>\n<img src=\"/2018/05/14/shiro-start/shiro-01.png\">\n<ul>\n<li>Authentication: 身份认证，拥有合法身份才能登录系统并使用。</li>\n<li>Authorization： 授权验证。即认证某个已经得到身份认证的用户是否拥有对某个功能或者某种资源的使用权限。</li>\n<li>Session Manager： 会话管理。用户登录后，没退出之前，为一次会话，所有的信息都在会话中。会话可以是javase环境，也可以是java web环境。</li>\n<li>Cryptography： 加密，保护数据的安全性。</li>\n<li>Web Support： web支持，把shiro容易的集成到web环境中。</li>\n<li>Caching： 缓存，用户登陆后，用户的信息、拥有的角色权限不必每次查，缓存起来。</li>\n<li>Concurrency： shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。</li>\n<li>Testing：提供测试支持。</li>\n<li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</li>\n<li>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>\n</ul>\n<h4 id=\"2-运行原理\"><a href=\"#2-运行原理\" class=\"headerlink\" title=\"2.运行原理\"></a>2.运行原理</h4><p>1.原理图1（应用程序角度）：<br><img src=\"/2018/05/14/shiro-start/shiro-02.png\"></p>\n<ul>\n<li>Subject：主体，代表当前“用户”，这里的用户指的不仅仅是登录用户，指的是任何与该系统交互的主体。所有的Subject都和SecurityManager绑定，与Subject的任何交互都委托给SecurityManager来处理。</li>\n<li>SecurityManager： 安全管理器，是shiro的核心功能。它负责所有的安全操作管理，管理这所有的Subject。类似于SpringMvc中的DispatcherServlet控制器。</li>\n<li>Realm： 域。所有的安全数据保存，获取都要通过Realm。SecurityManager和它交互，获取相关数据。Realm就类似于数据源DataSource。</li>\n</ul>\n<p>2.原理图2（内部架构）：<br><img src=\"/2018/05/14/shiro-start/shiro-03.png\"></p>\n<ul>\n<li>Subject：主体。</li>\n<li>SecurityManager：安全管理器。</li>\n<li>Authenticator： 认证器，负责对主体的身份认证。可以自定义，重新设定认证策略，即什么情况下才算认证通过。</li>\n<li>Authrizer： 授权器，或者访问控制器。决定主体是否有权限进行相应操作。</li>\n<li>Realm： 可以一个或者多个。可以是jdbc，redis，内存等实现。</li>\n<li>SessionManager： 会话管理器。</li>\n<li>SessionDAO： 数据访问对象，用于会话的CRUD。可以自定义，控制session存储的位置，关系数据库，redis等。另外，可以使用缓存，提高性能。</li>\n<li>CacheManager： 缓存管理器。</li>\n<li>Cryptography： 密码模块。提供了一些加解密算法。</li>\n</ul>\n<h4 id=\"3-过滤器\"><a href=\"#3-过滤器\" class=\"headerlink\" title=\"3.过滤器\"></a>3.过滤器</h4><p>应用到web系统中时，Shiro会默认创建一些过滤器对客户端请求进行过滤。常用过滤器有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">过滤器简称</th>\n<th style=\"text-align:left\">对应的 Java 类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">anon</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.AnonymousFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">authc</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">authcBasic</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">perms</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">port</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.PortFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rest</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">roles</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ssl</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.SslFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">user</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.UserFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">logout</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.LogoutFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">noSessionCreation</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.session.NoSessionCreationFilter</td>\n</tr>\n</tbody>\n</table>\n<p>说明：</p>\n<pre><code>/admins/**=anon               # 表示该 uri 可以匿名访问\n/admins/**=auth               # 表示该 uri 需要认证才能访问\n/admins/**=authcBasic         # 表示该 uri 需要 httpBasic 认证\n/admins/**=perms[user:add:*]  # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问\n/admins/**=port[8081]         # 表示该 uri 需要使用 8081 端口\n/admins/**=rest[user]         # 相当于 /admins/**=perms[user:method]，其中，method 表示  get、post、delete 等\n/admins/**=roles[admin]       # 表示该 uri 需要认证用户拥有 admin 角色才能访问\n/admins/**=ssl                # 表示该 uri 需要使用 https 协议\n/admins/**=user               # 表示该 uri 需要认证或通过记住我认证才能访问\n/logout=logout                # 表示注销,可以当作固定配置\n</code></pre><p> _注意_<br> anon，authcBasic，auchc，user 是认证过滤器。<br> perms，roles，ssl，rest，port 是授权过滤器。   </p>\n<h3 id=\"二-认证\"><a href=\"#二-认证\" class=\"headerlink\" title=\"二.认证\"></a>二.认证</h3><p>1.认证路程图：<br><img src=\"/2018/05/14/shiro-start/shiro-04.png\"> </p>\n<p>2.使用代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthenticationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleAccountRealm simpleAccoutRealm = <span class=\"keyword\">new</span> SimpleAccountRealm();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        simpleAccoutRealm.addAccount(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">testAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(simpleAccoutRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.logout();<span class=\"comment\">//退出登录</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//未认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-授权\"><a href=\"#三-授权\" class=\"headerlink\" title=\"三.授权\"></a>三.授权</h3><p>1.流程图：<br><img src=\"/2018/05/14/shiro-start/shiro-05.png\"></p>\n<p>2。代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthenticationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleAccountRealm simpleAccoutRealm = <span class=\"keyword\">new</span> SimpleAccountRealm();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");</span></span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">        simpleAccoutRealm.addAccount(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>,<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//添加角色</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">testAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(simpleAccoutRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user1\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.logout();//退出登录</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-Shiro自定义Realm\"><a href=\"#四-Shiro自定义Realm\" class=\"headerlink\" title=\"四.Shiro自定义Realm\"></a>四.Shiro自定义Realm</h3><h4 id=\"1-IniRealm讲解\"><a href=\"#1-IniRealm讲解\" class=\"headerlink\" title=\"1.IniRealm讲解\"></a>1.IniRealm讲解</h4><p>代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.text.IniRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IniRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IniRealm iniRealm = <span class=\"keyword\">new</span> IniRealm(<span class=\"string\">\"classpath:user.ini\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(iniRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:delete\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//报错，没有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编辑：user.ini</span><br><span class=\"line\"></span><br><span class=\"line\">[users]</span><br><span class=\"line\">zmt=123456,admin,user</span><br><span class=\"line\">[roles]</span><br><span class=\"line\">admin=user:delete,user:update</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-JdbcRealm讲解\"><a href=\"#2-JdbcRealm讲解\" class=\"headerlink\" title=\"2.JdbcRealm讲解\"></a>2.JdbcRealm讲解</h4><p>用户、角色、权限数据都在数据库里面。而不是在配置文件里面。<br>两种方式，一种是使用默认查询语句；另外一种是自己设计表，写sql语句，不必遵守默认的。   </p>\n<h5 id=\"2-1-默认方式\"><a href=\"#2-1-默认方式\" class=\"headerlink\" title=\"2.1.默认方式\"></a>2.1.默认方式</h5><ul>\n<li><p>首先，创建相关默认数据表：   </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Navicat MySQL Data Transfer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Source Server         : localhost</span></span><br><span class=\"line\"><span class=\"comment\">Source Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">Source Host           : localhost:3307</span></span><br><span class=\"line\"><span class=\"comment\">Source Database       : shiro-test</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Target Server Type    : MYSQL</span></span><br><span class=\"line\"><span class=\"comment\">Target Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">File Encoding         : 65001</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Date: 2018-10-15 17:09:45</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for roles_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`roles_permissions`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`roles_permissions`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`permission`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`role_name`</span> (<span class=\"string\">`role_name`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> <span class=\"string\">`roles_permissions_ibfk_1`</span> <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (<span class=\"string\">`role_name`</span>) <span class=\"keyword\">REFERENCES</span> <span class=\"string\">`user_roles`</span> (<span class=\"string\">`role_name`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of roles_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`roles_permissions`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'admin'</span>, <span class=\"string\">'user:select'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for user_roles</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`user_roles`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`user_roles`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`username`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`role_name`</span> (<span class=\"string\">`role_name`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> <span class=\"string\">`user_roles_ibfk_1`</span> <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (<span class=\"string\">`username`</span>) <span class=\"keyword\">REFERENCES</span> <span class=\"string\">`users`</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of user_roles</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`user_roles`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'zmt'</span>, <span class=\"string\">'admin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for users</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`users`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`users`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password_salt`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of users</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`users`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'zmt'</span>, <span class=\"string\">'123456'</span>, <span class=\"string\">'abcd'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3307/shiro-test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 查询默认的数据表做相关操作。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JdbcRealm jdbcRealm = <span class=\"keyword\">new</span> JdbcRealm();</span><br><span class=\"line\">        jdbcRealm.setDataSource(dataSource); <span class=\"comment\">//设置数据源</span></span><br><span class=\"line\">        jdbcRealm.setPermissionsLookupEnabled(<span class=\"keyword\">true</span>); <span class=\"comment\">//是否可以查看权限。默认为false。不打开，则无法查看权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(jdbcRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:update\"); //报错，没有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"2-2-自己设计表写查询语句\"><a href=\"#2-2-自己设计表写查询语句\" class=\"headerlink\" title=\"2.2.自己设计表写查询语句\"></a>2.2.自己设计表写查询语句</h5><ul>\n<li>创建数据表<br>不必遵循默认规范，表名、字段名都可以自定义。  </li>\n</ul>\n<p>脚本：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Navicat MySQL Data Transfer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Source Server         : localhost</span></span><br><span class=\"line\"><span class=\"comment\">Source Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">Source Host           : localhost:3307</span></span><br><span class=\"line\"><span class=\"comment\">Source Database       : shiro-test</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Target Server Type    : MYSQL</span></span><br><span class=\"line\"><span class=\"comment\">Target Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">File Encoding         : 65001</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Date: 2018-10-17 11:42:25</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_role_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_role_permissions`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_role_permissions`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`permission`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_role_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_role_permissions`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'caiwu'</span>, <span class=\"string\">'user:update'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_user</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_user`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_user`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`user_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`user_name`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_user</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_user`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'xr'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_user_role</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_user_role`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_user_role`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`test_user_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_user_role</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_user_role`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'xr'</span>, <span class=\"string\">'caiwu'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>代码样例：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3307/shiro-test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JdbcRealm jdbcRealm = <span class=\"keyword\">new</span> JdbcRealm();</span><br><span class=\"line\">        jdbcRealm.setDataSource(dataSource); <span class=\"comment\">//设置数据源</span></span><br><span class=\"line\">        jdbcRealm.setPermissionsLookupEnabled(<span class=\"keyword\">true</span>); <span class=\"comment\">//是否可以查看权限。默认为false。不打开，则无法查看权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建sql语句，使用自己的表、sql来验证</span></span><br><span class=\"line\">        String sql_auth = <span class=\"string\">\"SELECT `password` FROM test_user WHERE user_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setAuthenticationQuery(sql_auth);</span><br><span class=\"line\">        String sql_role = <span class=\"string\">\"SELECT role_name FROM test_user_role WHERE test_user_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setUserRolesQuery(sql_role);</span><br><span class=\"line\">        String sql_permisstion = <span class=\"string\">\"SELECT permission FROM test_role_permissions WHERE role_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setPermissionsQuery(sql_permisstion);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(jdbcRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"caiwu\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-自定义Realm\"><a href=\"#3-自定义Realm\" class=\"headerlink\" title=\"3.自定义Realm\"></a>3.自定义Realm</h4><ul>\n<li>创建类CustomRealm</li>\n</ul>\n<p>自定义Realm需要继承<code>AuthorizingRealm</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String realmName = <span class=\"keyword\">this</span>.getClass().getSimpleName(); <span class=\"comment\">//自定义realm名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; userMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"654321\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(realmName); <span class=\"comment\">//设置名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">        String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"comment\">//从数据库或者缓存中获取角色数据。</span></span><br><span class=\"line\">        Set&lt;String&gt; roles = getRolesByUsername(username);</span><br><span class=\"line\">        Set&lt;String&gt; permissions = getPermissionByUsername(username);</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(permissions); <span class=\"comment\">//设置权限</span></span><br><span class=\"line\">        authorizationInfo.setRoles(roles); <span class=\"comment\">//设置角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟通过用户名获取权限。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getPermissionByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"admin:delete\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:select\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:update\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> permissions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取角色。根据用户名获取角色。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getRolesByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"admin\"</span>);</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从主体传过来认证信息,获得用户名</span></span><br><span class=\"line\">        String username = (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过用户名到数据库中获取凭证</span></span><br><span class=\"line\">        String pwd = getPwdByUsername(username);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pwd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,pwd,realmName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取数据库数据。根据用户名获取用户密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getPwdByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userMap.get(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CustomRealm customRealm = <span class=\"keyword\">new</span> CustomRealm();<span class=\"comment\">//自定义Realm</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(customRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRole(\"admin\"); //admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"五-Shiro加密\"><a href=\"#五-Shiro加密\" class=\"headerlink\" title=\"五.Shiro加密\"></a>五.Shiro加密</h3><p>前面介绍的密码都是明文的，实际的密码在数据库中是加密的。    </p>\n<p>下面在自定义的Realm中使用加密。  </p>\n<ul>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.util.ByteSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String realmName = <span class=\"keyword\">this</span>.getClass().getSimpleName(); <span class=\"comment\">//自定义realm名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; userMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"><span class=\"comment\">//        userMap.put(\"zmt\",\"123456\");</span></span><br><span class=\"line\"><span class=\"comment\">//        userMap.put(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\"); //数据库的密码是密文，不加盐</span></span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"640a19b710290a9ff4d72e70cdd21913\"</span>); <span class=\"comment\">//md5加盐密码</span></span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"654321\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(realmName); <span class=\"comment\">//设置名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">        String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"comment\">//从数据库或者缓存中获取角色数据。</span></span><br><span class=\"line\">        Set&lt;String&gt; roles = getRolesByUsername(username);</span><br><span class=\"line\">        Set&lt;String&gt; permissions = getPermissionByUsername(username);</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(permissions); <span class=\"comment\">//设置权限</span></span><br><span class=\"line\">        authorizationInfo.setRoles(roles); <span class=\"comment\">//设置角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟通过用户名获取权限。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getPermissionByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"admin:delete\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:select\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:update\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> permissions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取角色。根据用户名获取角色。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getRolesByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"admin\"</span>);</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从主体传过来认证信息,获得用户名</span></span><br><span class=\"line\">        String username = (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过用户名到数据库中获取凭证</span></span><br><span class=\"line\">        String pwd = getPwdByUsername(username);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pwd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,pwd,realmName);</span><br><span class=\"line\">        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(<span class=\"string\">\"aaa\"</span>)); <span class=\"comment\">//密码加盐后，这里要加上这句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取数据库数据。根据用户名获取用户密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getPwdByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userMap.get(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.crypto.hash.Md5Hash;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CustomRealm customRealm = <span class=\"keyword\">new</span> CustomRealm();<span class=\"comment\">//自定义Realm</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(customRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置散列加密</span></span><br><span class=\"line\">        HashedCredentialsMatcher matcher = <span class=\"keyword\">new</span> HashedCredentialsMatcher();</span><br><span class=\"line\">        matcher.setHashAlgorithmName(<span class=\"string\">\"md5\"</span>);<span class=\"comment\">//设置加密方式</span></span><br><span class=\"line\">        matcher.setHashIterations(<span class=\"number\">1</span>); <span class=\"comment\">//设置加密次数</span></span><br><span class=\"line\">        customRealm.setCredentialsMatcher(matcher); <span class=\"comment\">//设置加密对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"e10adc3949ba59abbe56e057f20f883e\"</span>);<span class=\"comment\">//用户,密码MD5加密。明文：123456</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRole(\"admin\"); //admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">genPwd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        Md5Hash md5Hash = new Md5Hash(\"123456\"); //md5加密密码，不加盐</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"md5加密：\" + md5Hash);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Md5Hash md5Hash = <span class=\"keyword\">new</span> Md5Hash(<span class=\"string\">\"e10adc3949ba59abbe56e057f20f883e\"</span>,<span class=\"string\">\"aaa\"</span>); <span class=\"comment\">//md5加密密码，加盐，密码更加难以识破，盐一般用随机数，这里写死</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"md5加盐加密：\"</span> + md5Hash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>Apache Shiro(<a href=\"http://shiro.apache.org\" target=\"_blank\" rel=\"noopener\">官网</a>)是个java的安全框架，轻便、api简单、功能全面的特性获得 许多开发者的青睐。其提供了认证、授权、加密以及会话管理等功能……</p>\n<h3 id=\"一-介绍\"><a href=\"#一-介绍\" class=\"headerlink\" title=\"一.介绍\"></a>一.介绍</h3><h4 id=\"1-功能特性\"><a href=\"#1-功能特性\" class=\"headerlink\" title=\"1.功能特性\"></a>1.功能特性</h4><p>Shiro 包含 10 个内容，如下图：</p>\n<img src=\"/2018/05/14/shiro-start/shiro-01.png\">\n<ul>\n<li>Authentication: 身份认证，拥有合法身份才能登录系统并使用。</li>\n<li>Authorization： 授权验证。即认证某个已经得到身份认证的用户是否拥有对某个功能或者某种资源的使用权限。</li>\n<li>Session Manager： 会话管理。用户登录后，没退出之前，为一次会话，所有的信息都在会话中。会话可以是javase环境，也可以是java web环境。</li>\n<li>Cryptography： 加密，保护数据的安全性。</li>\n<li>Web Support： web支持，把shiro容易的集成到web环境中。</li>\n<li>Caching： 缓存，用户登陆后，用户的信息、拥有的角色权限不必每次查，缓存起来。</li>\n<li>Concurrency： shiro 支持多线程应用的并发验证，即如在一个线程中开启另一个线程，能把权限自动传播过去。</li>\n<li>Testing：提供测试支持。</li>\n<li>Run As：允许一个用户假装为另一个用户（如果他们允许）的身份进行访问。</li>\n<li>Remember Me：记住我，这个是非常常见的功能，即一次登录后，下次再来的话不用登录了。</li>\n</ul>\n<h4 id=\"2-运行原理\"><a href=\"#2-运行原理\" class=\"headerlink\" title=\"2.运行原理\"></a>2.运行原理</h4><p>1.原理图1（应用程序角度）：<br><img src=\"/2018/05/14/shiro-start/shiro-02.png\"></p>\n<ul>\n<li>Subject：主体，代表当前“用户”，这里的用户指的不仅仅是登录用户，指的是任何与该系统交互的主体。所有的Subject都和SecurityManager绑定，与Subject的任何交互都委托给SecurityManager来处理。</li>\n<li>SecurityManager： 安全管理器，是shiro的核心功能。它负责所有的安全操作管理，管理这所有的Subject。类似于SpringMvc中的DispatcherServlet控制器。</li>\n<li>Realm： 域。所有的安全数据保存，获取都要通过Realm。SecurityManager和它交互，获取相关数据。Realm就类似于数据源DataSource。</li>\n</ul>\n<p>2.原理图2（内部架构）：<br><img src=\"/2018/05/14/shiro-start/shiro-03.png\"></p>\n<ul>\n<li>Subject：主体。</li>\n<li>SecurityManager：安全管理器。</li>\n<li>Authenticator： 认证器，负责对主体的身份认证。可以自定义，重新设定认证策略，即什么情况下才算认证通过。</li>\n<li>Authrizer： 授权器，或者访问控制器。决定主体是否有权限进行相应操作。</li>\n<li>Realm： 可以一个或者多个。可以是jdbc，redis，内存等实现。</li>\n<li>SessionManager： 会话管理器。</li>\n<li>SessionDAO： 数据访问对象，用于会话的CRUD。可以自定义，控制session存储的位置，关系数据库，redis等。另外，可以使用缓存，提高性能。</li>\n<li>CacheManager： 缓存管理器。</li>\n<li>Cryptography： 密码模块。提供了一些加解密算法。</li>\n</ul>\n<h4 id=\"3-过滤器\"><a href=\"#3-过滤器\" class=\"headerlink\" title=\"3.过滤器\"></a>3.过滤器</h4><p>应用到web系统中时，Shiro会默认创建一些过滤器对客户端请求进行过滤。常用过滤器有：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">过滤器简称</th>\n<th style=\"text-align:left\">对应的 Java 类</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">anon</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.AnonymousFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">authc</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.FormAuthenticationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">authcBasic</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.BasicHttpAuthenticationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">perms</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.PermissionsAuthorizationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">port</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.PortFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">rest</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.HttpMethodPermissionFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">roles</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.RolesAuthorizationFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">ssl</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authz.SslFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">user</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.UserFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">logout</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.authc.LogoutFilter</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">noSessionCreation</td>\n<td style=\"text-align:left\">org.apache.shiro.web.filter.session.NoSessionCreationFilter</td>\n</tr>\n</tbody>\n</table>\n<p>说明：</p>\n<pre><code>/admins/**=anon               # 表示该 uri 可以匿名访问\n/admins/**=auth               # 表示该 uri 需要认证才能访问\n/admins/**=authcBasic         # 表示该 uri 需要 httpBasic 认证\n/admins/**=perms[user:add:*]  # 表示该 uri 需要认证用户拥有 user:add:* 权限才能访问\n/admins/**=port[8081]         # 表示该 uri 需要使用 8081 端口\n/admins/**=rest[user]         # 相当于 /admins/**=perms[user:method]，其中，method 表示  get、post、delete 等\n/admins/**=roles[admin]       # 表示该 uri 需要认证用户拥有 admin 角色才能访问\n/admins/**=ssl                # 表示该 uri 需要使用 https 协议\n/admins/**=user               # 表示该 uri 需要认证或通过记住我认证才能访问\n/logout=logout                # 表示注销,可以当作固定配置\n</code></pre><p> _注意_<br> anon，authcBasic，auchc，user 是认证过滤器。<br> perms，roles，ssl，rest，port 是授权过滤器。   </p>\n<h3 id=\"二-认证\"><a href=\"#二-认证\" class=\"headerlink\" title=\"二.认证\"></a>二.认证</h3><p>1.认证路程图：<br><img src=\"/2018/05/14/shiro-start/shiro-04.png\"> </p>\n<p>2.使用代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthenticationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleAccountRealm simpleAccoutRealm = <span class=\"keyword\">new</span> SimpleAccountRealm();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        simpleAccoutRealm.addAccount(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">testAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(simpleAccoutRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.logout();<span class=\"comment\">//退出登录</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//未认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"三-授权\"><a href=\"#三-授权\" class=\"headerlink\" title=\"三.授权\"></a>三.授权</h3><p>1.流程图：<br><img src=\"/2018/05/14/shiro-start/shiro-05.png\"></p>\n<p>2。代码示例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.SimpleAccountRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Before;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AuthenticationTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    SimpleAccountRealm simpleAccoutRealm = <span class=\"keyword\">new</span> SimpleAccountRealm();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">addUser</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt\",\"123456\");</span></span><br><span class=\"line\"><span class=\"comment\">//        simpleAccoutRealm.addAccount(\"zmt1\",\"123456\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">        simpleAccoutRealm.addAccount(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>,<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//添加角色</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">testAuthentication</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(simpleAccoutRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user1\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.logout();//退出登录</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"isAuthenticated:\" + subject.isAuthenticated());//未认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"四-Shiro自定义Realm\"><a href=\"#四-Shiro自定义Realm\" class=\"headerlink\" title=\"四.Shiro自定义Realm\"></a>四.Shiro自定义Realm</h3><h4 id=\"1-IniRealm讲解\"><a href=\"#1-IniRealm讲解\" class=\"headerlink\" title=\"1.IniRealm讲解\"></a>1.IniRealm讲解</h4><p>代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.text.IniRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">IniRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        IniRealm iniRealm = <span class=\"keyword\">new</span> IniRealm(<span class=\"string\">\"classpath:user.ini\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(iniRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:delete\"</span>);</span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//报错，没有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">编辑：user.ini</span><br><span class=\"line\"></span><br><span class=\"line\">[users]</span><br><span class=\"line\">zmt=123456,admin,user</span><br><span class=\"line\">[roles]</span><br><span class=\"line\">admin=user:delete,user:update</span><br></pre></td></tr></table></figure>\n<h4 id=\"2-JdbcRealm讲解\"><a href=\"#2-JdbcRealm讲解\" class=\"headerlink\" title=\"2.JdbcRealm讲解\"></a>2.JdbcRealm讲解</h4><p>用户、角色、权限数据都在数据库里面。而不是在配置文件里面。<br>两种方式，一种是使用默认查询语句；另外一种是自己设计表，写sql语句，不必遵守默认的。   </p>\n<h5 id=\"2-1-默认方式\"><a href=\"#2-1-默认方式\" class=\"headerlink\" title=\"2.1.默认方式\"></a>2.1.默认方式</h5><ul>\n<li><p>首先，创建相关默认数据表：   </p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Navicat MySQL Data Transfer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Source Server         : localhost</span></span><br><span class=\"line\"><span class=\"comment\">Source Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">Source Host           : localhost:3307</span></span><br><span class=\"line\"><span class=\"comment\">Source Database       : shiro-test</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Target Server Type    : MYSQL</span></span><br><span class=\"line\"><span class=\"comment\">Target Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">File Encoding         : 65001</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Date: 2018-10-15 17:09:45</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for roles_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`roles_permissions`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`roles_permissions`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`permission`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`role_name`</span> (<span class=\"string\">`role_name`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> <span class=\"string\">`roles_permissions_ibfk_1`</span> <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (<span class=\"string\">`role_name`</span>) <span class=\"keyword\">REFERENCES</span> <span class=\"string\">`user_roles`</span> (<span class=\"string\">`role_name`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of roles_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`roles_permissions`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'admin'</span>, <span class=\"string\">'user:select'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for user_roles</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`user_roles`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`user_roles`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`username`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`role_name`</span> (<span class=\"string\">`role_name`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">CONSTRAINT</span> <span class=\"string\">`user_roles_ibfk_1`</span> <span class=\"keyword\">FOREIGN</span> <span class=\"keyword\">KEY</span> (<span class=\"string\">`username`</span>) <span class=\"keyword\">REFERENCES</span> <span class=\"string\">`users`</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of user_roles</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`user_roles`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'zmt'</span>, <span class=\"string\">'admin'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for users</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`users`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`users`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`username`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password_salt`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`username`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of users</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`users`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'zmt'</span>, <span class=\"string\">'123456'</span>, <span class=\"string\">'abcd'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>代码样例：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3307/shiro-test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 查询默认的数据表做相关操作。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JdbcRealm jdbcRealm = <span class=\"keyword\">new</span> JdbcRealm();</span><br><span class=\"line\">        jdbcRealm.setDataSource(dataSource); <span class=\"comment\">//设置数据源</span></span><br><span class=\"line\">        jdbcRealm.setPermissionsLookupEnabled(<span class=\"keyword\">true</span>); <span class=\"comment\">//是否可以查看权限。默认为false。不打开，则无法查看权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(jdbcRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"admin\"</span>); <span class=\"comment\">//admin通过，admin1报错</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRoles(\"admin\",\"user\"); //拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:update\"); //报错，没有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h5 id=\"2-2-自己设计表写查询语句\"><a href=\"#2-2-自己设计表写查询语句\" class=\"headerlink\" title=\"2.2.自己设计表写查询语句\"></a>2.2.自己设计表写查询语句</h5><ul>\n<li>创建数据表<br>不必遵循默认规范，表名、字段名都可以自定义。  </li>\n</ul>\n<p>脚本：<br><figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/*</span></span><br><span class=\"line\"><span class=\"comment\">Navicat MySQL Data Transfer</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Source Server         : localhost</span></span><br><span class=\"line\"><span class=\"comment\">Source Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">Source Host           : localhost:3307</span></span><br><span class=\"line\"><span class=\"comment\">Source Database       : shiro-test</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Target Server Type    : MYSQL</span></span><br><span class=\"line\"><span class=\"comment\">Target Server Version : 50718</span></span><br><span class=\"line\"><span class=\"comment\">File Encoding         : 65001</span></span><br><span class=\"line\"><span class=\"comment\"></span></span><br><span class=\"line\"><span class=\"comment\">Date: 2018-10-17 11:42:25</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">0</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_role_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_role_permissions`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_role_permissions`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`permission`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_role_permissions</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_role_permissions`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'caiwu'</span>, <span class=\"string\">'user:update'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_user</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_user`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_user`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`user_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`password`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>),</span><br><span class=\"line\">  <span class=\"keyword\">KEY</span> <span class=\"string\">`username`</span> (<span class=\"string\">`user_name`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_user</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_user`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'xr'</span>, <span class=\"string\">'123456'</span>);</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Table structure for test_user_role</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">DROP</span> <span class=\"keyword\">TABLE</span> <span class=\"keyword\">IF</span> <span class=\"keyword\">EXISTS</span> <span class=\"string\">`test_user_role`</span>;</span><br><span class=\"line\"><span class=\"keyword\">CREATE</span> <span class=\"keyword\">TABLE</span> <span class=\"string\">`test_user_role`</span> (</span><br><span class=\"line\">  <span class=\"string\">`id`</span> <span class=\"built_in\">int</span>(<span class=\"number\">11</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span> AUTO_INCREMENT,</span><br><span class=\"line\">  <span class=\"string\">`test_user_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">NOT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  <span class=\"string\">`role_name`</span> <span class=\"built_in\">varchar</span>(<span class=\"number\">255</span>) <span class=\"keyword\">DEFAULT</span> <span class=\"literal\">NULL</span>,</span><br><span class=\"line\">  PRIMARY <span class=\"keyword\">KEY</span> (<span class=\"string\">`id`</span>)</span><br><span class=\"line\">) <span class=\"keyword\">ENGINE</span>=<span class=\"keyword\">InnoDB</span> AUTO_INCREMENT=<span class=\"number\">2</span> <span class=\"keyword\">DEFAULT</span> <span class=\"keyword\">CHARSET</span>=utf8mb4;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"comment\">-- Records of test_user_role</span></span><br><span class=\"line\"><span class=\"comment\">-- ----------------------------</span></span><br><span class=\"line\"><span class=\"keyword\">INSERT</span> <span class=\"keyword\">INTO</span> <span class=\"string\">`test_user_role`</span> <span class=\"keyword\">VALUES</span> (<span class=\"string\">'1'</span>, <span class=\"string\">'xr'</span>, <span class=\"string\">'caiwu'</span>);</span><br><span class=\"line\"><span class=\"keyword\">SET</span> FOREIGN_KEY_CHECKS=<span class=\"number\">1</span>;</span><br></pre></td></tr></table></figure></p>\n<ul>\n<li>代码样例：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.alibaba.druid.pool.DruidDataSource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.jdbc.JdbcRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JdbcRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    DruidDataSource dataSource = <span class=\"keyword\">new</span> DruidDataSource();</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        dataSource.setUrl(<span class=\"string\">\"jdbc:mysql://localhost:3307/shiro-test\"</span>);</span><br><span class=\"line\">        dataSource.setUsername(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">        dataSource.setPassword(<span class=\"string\">\"root\"</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test2</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        JdbcRealm jdbcRealm = <span class=\"keyword\">new</span> JdbcRealm();</span><br><span class=\"line\">        jdbcRealm.setDataSource(dataSource); <span class=\"comment\">//设置数据源</span></span><br><span class=\"line\">        jdbcRealm.setPermissionsLookupEnabled(<span class=\"keyword\">true</span>); <span class=\"comment\">//是否可以查看权限。默认为false。不打开，则无法查看权限</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//创建sql语句，使用自己的表、sql来验证</span></span><br><span class=\"line\">        String sql_auth = <span class=\"string\">\"SELECT `password` FROM test_user WHERE user_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setAuthenticationQuery(sql_auth);</span><br><span class=\"line\">        String sql_role = <span class=\"string\">\"SELECT role_name FROM test_user_role WHERE test_user_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setUserRolesQuery(sql_role);</span><br><span class=\"line\">        String sql_permisstion = <span class=\"string\">\"SELECT permission FROM test_role_permissions WHERE role_name = ?\"</span>;</span><br><span class=\"line\">        jdbcRealm.setPermissionsQuery(sql_permisstion);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(jdbcRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\">        subject.checkRole(<span class=\"string\">\"caiwu\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n</ul>\n<h4 id=\"3-自定义Realm\"><a href=\"#3-自定义Realm\" class=\"headerlink\" title=\"3.自定义Realm\"></a>3.自定义Realm</h4><ul>\n<li>创建类CustomRealm</li>\n</ul>\n<p>自定义Realm需要继承<code>AuthorizingRealm</code>。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String realmName = <span class=\"keyword\">this</span>.getClass().getSimpleName(); <span class=\"comment\">//自定义realm名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; userMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);</span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"654321\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(realmName); <span class=\"comment\">//设置名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">        String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"comment\">//从数据库或者缓存中获取角色数据。</span></span><br><span class=\"line\">        Set&lt;String&gt; roles = getRolesByUsername(username);</span><br><span class=\"line\">        Set&lt;String&gt; permissions = getPermissionByUsername(username);</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(permissions); <span class=\"comment\">//设置权限</span></span><br><span class=\"line\">        authorizationInfo.setRoles(roles); <span class=\"comment\">//设置角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟通过用户名获取权限。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getPermissionByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"admin:delete\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:select\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:update\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> permissions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取角色。根据用户名获取角色。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getRolesByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"admin\"</span>);</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从主体传过来认证信息,获得用户名</span></span><br><span class=\"line\">        String username = (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过用户名到数据库中获取凭证</span></span><br><span class=\"line\">        String pwd = getPwdByUsername(username);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pwd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,pwd,realmName);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取数据库数据。根据用户名获取用户密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getPwdByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userMap.get(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<ul>\n<li>测试：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CustomRealm customRealm = <span class=\"keyword\">new</span> CustomRealm();<span class=\"comment\">//自定义Realm</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(customRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"123456\"</span>);<span class=\"comment\">//用户</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRole(\"admin\"); //admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<h3 id=\"五-Shiro加密\"><a href=\"#五-Shiro加密\" class=\"headerlink\" title=\"五.Shiro加密\"></a>五.Shiro加密</h3><p>前面介绍的密码都是明文的，实际的密码在数据库中是加密的。    </p>\n<p>下面在自定义的Realm中使用加密。  </p>\n<ul>\n<li>代码：</li>\n</ul>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.AuthenticationToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.SimpleAuthenticationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.AuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authz.SimpleAuthorizationInfo;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.realm.AuthorizingRealm;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.PrincipalCollection;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.util.ByteSource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashSet;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Set;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealm</span> <span class=\"keyword\">extends</span> <span class=\"title\">AuthorizingRealm</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> String realmName = <span class=\"keyword\">this</span>.getClass().getSimpleName(); <span class=\"comment\">//自定义realm名称</span></span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; userMap = <span class=\"keyword\">new</span> HashMap&lt;&gt;(<span class=\"number\">16</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    &#123;</span><br><span class=\"line\"><span class=\"comment\">//        userMap.put(\"zmt\",\"123456\");</span></span><br><span class=\"line\"><span class=\"comment\">//        userMap.put(\"zmt\",\"e10adc3949ba59abbe56e057f20f883e\"); //数据库的密码是密文，不加盐</span></span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"640a19b710290a9ff4d72e70cdd21913\"</span>); <span class=\"comment\">//md5加盐密码</span></span><br><span class=\"line\">        userMap.put(<span class=\"string\">\"xr\"</span>,<span class=\"string\">\"654321\"</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">super</span>.setName(realmName); <span class=\"comment\">//设置名称</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthorizationInfo <span class=\"title\">doGetAuthorizationInfo</span><span class=\"params\">(PrincipalCollection principals)</span> </span>&#123;</span><br><span class=\"line\">        String username = (String) principals.getPrimaryPrincipal();</span><br><span class=\"line\">        <span class=\"comment\">//从数据库或者缓存中获取角色数据。</span></span><br><span class=\"line\">        Set&lt;String&gt; roles = getRolesByUsername(username);</span><br><span class=\"line\">        Set&lt;String&gt; permissions = getPermissionByUsername(username);</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthorizationInfo authorizationInfo = <span class=\"keyword\">new</span> SimpleAuthorizationInfo();</span><br><span class=\"line\">        authorizationInfo.setStringPermissions(permissions); <span class=\"comment\">//设置权限</span></span><br><span class=\"line\">        authorizationInfo.setRoles(roles); <span class=\"comment\">//设置角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authorizationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟通过用户名获取权限。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getPermissionByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; permissions = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"admin:delete\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:select\"</span>);</span><br><span class=\"line\">        permissions.add(<span class=\"string\">\"user:update\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> permissions;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取角色。根据用户名获取角色。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> Set&lt;String&gt; <span class=\"title\">getRolesByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        Set&lt;String&gt; roles = <span class=\"keyword\">new</span> HashSet&lt;&gt;();</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"admin\"</span>);</span><br><span class=\"line\">        roles.add(<span class=\"string\">\"user\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> roles;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> AuthenticationInfo <span class=\"title\">doGetAuthenticationInfo</span><span class=\"params\">(AuthenticationToken token)</span> <span class=\"keyword\">throws</span> AuthenticationException </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//从主体传过来认证信息,获得用户名</span></span><br><span class=\"line\">        String username = (String) token.getPrincipal();</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"username:\"</span> + username);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//通过用户名到数据库中获取凭证</span></span><br><span class=\"line\">        String pwd = getPwdByUsername(username);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (pwd == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        SimpleAuthenticationInfo authenticationInfo = <span class=\"keyword\">new</span> SimpleAuthenticationInfo(username,pwd,realmName);</span><br><span class=\"line\">        authenticationInfo.setCredentialsSalt(ByteSource.Util.bytes(<span class=\"string\">\"aaa\"</span>)); <span class=\"comment\">//密码加盐后，这里要加上这句</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">return</span> authenticationInfo;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * 模拟获取数据库数据。根据用户名获取用户密码</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@param</span> username 用户名。</span></span><br><span class=\"line\"><span class=\"comment\">     * <span class=\"doctag\">@return</span></span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">getPwdByUsername</span><span class=\"params\">(String username)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> userMap.get(username);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.example.springboot2shirostart;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.SecurityUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.UsernamePasswordToken;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.authc.credential.HashedCredentialsMatcher;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.crypto.hash.Md5Hash;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.mgt.DefaultSecurityManager;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.apache.shiro.subject.Subject;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.junit.Test;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 简单认证</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CustomRealmTest</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span>  <span class=\"title\">test1</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">        CustomRealm customRealm = <span class=\"keyword\">new</span> CustomRealm();<span class=\"comment\">//自定义Realm</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//1.创建securityManager环境</span></span><br><span class=\"line\">        DefaultSecurityManager defaultSecurityManager = <span class=\"keyword\">new</span> DefaultSecurityManager();</span><br><span class=\"line\">        defaultSecurityManager.setRealm(customRealm);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//设置散列加密</span></span><br><span class=\"line\">        HashedCredentialsMatcher matcher = <span class=\"keyword\">new</span> HashedCredentialsMatcher();</span><br><span class=\"line\">        matcher.setHashAlgorithmName(<span class=\"string\">\"md5\"</span>);<span class=\"comment\">//设置加密方式</span></span><br><span class=\"line\">        matcher.setHashIterations(<span class=\"number\">1</span>); <span class=\"comment\">//设置加密次数</span></span><br><span class=\"line\">        customRealm.setCredentialsMatcher(matcher); <span class=\"comment\">//设置加密对象</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//2.主体提交认证请求</span></span><br><span class=\"line\">        SecurityUtils.setSecurityManager(defaultSecurityManager);</span><br><span class=\"line\">        Subject subject = SecurityUtils.getSubject();</span><br><span class=\"line\"></span><br><span class=\"line\">        UsernamePasswordToken token = <span class=\"keyword\">new</span> UsernamePasswordToken(<span class=\"string\">\"zmt\"</span>,<span class=\"string\">\"e10adc3949ba59abbe56e057f20f883e\"</span>);<span class=\"comment\">//用户,密码MD5加密。明文：123456</span></span><br><span class=\"line\">        subject.login(token);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"isAuthenticated:\"</span> + subject.isAuthenticated());<span class=\"comment\">//已认证</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkRole(\"admin\"); //admin通过，admin1报错</span></span><br><span class=\"line\">        subject.checkRoles(<span class=\"string\">\"admin\"</span>,<span class=\"string\">\"user\"</span>); <span class=\"comment\">//拥有该两个角色</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">//权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:select\"</span>);<span class=\"comment\">//jdbcRealm.setPermissionsLookupEnabled(true);</span></span><br><span class=\"line\"><span class=\"comment\">//        subject.checkPermission(\"user:insert\"); //报错，么有insert权限</span></span><br><span class=\"line\">        subject.checkPermission(<span class=\"string\">\"user:update\"</span>); <span class=\"comment\">//有update权限</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">genPwd</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"><span class=\"comment\">//        Md5Hash md5Hash = new Md5Hash(\"123456\"); //md5加密密码，不加盐</span></span><br><span class=\"line\"><span class=\"comment\">//        System.out.println(\"md5加密：\" + md5Hash);</span></span><br><span class=\"line\"></span><br><span class=\"line\">        Md5Hash md5Hash = <span class=\"keyword\">new</span> Md5Hash(<span class=\"string\">\"e10adc3949ba59abbe56e057f20f883e\"</span>,<span class=\"string\">\"aaa\"</span>); <span class=\"comment\">//md5加密密码，加盐，密码更加难以识破，盐一般用随机数，这里写死</span></span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"md5加盐加密：\"</span> + md5Hash);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n"},{"title":"后端架构师技术图谱","date":"2018-06-19T00:51:42.000Z","_content":"\n列出了后端架构师要掌握的基本知识。少壮不努力，老大徒伤悲……\n\n本文拷贝自https://github.com/xingshaocheng/architect-awesome\n\n\n<h1>《后端架构师技术图谱》</h1>\n\n**更新于20180513**\n* [数据结构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构)\n\t* [队列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列)\n\t* [集合](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合)\n\t* [链表、数组](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组)\n\t* [字典、关联数组](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组)\n\t* [栈](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈)\n\t* [树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#树)\n\t\t* [二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉树)\n\t\t* [完全二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉树)\n\t\t* [平衡二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉树)\n\t\t* [二叉查找树（BST）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查找树bst)\n\t\t* [红黑树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#红黑树)\n\t\t* [B-，B+，B*树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb树)\n\t\t* [LSM 树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-树)\n\t* [BitSet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset)\n* [常用算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用算法)\n\t* [排序、查找算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查找算法)\n\t\t* [选择排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#选择排序)\n\t\t* [冒泡排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冒泡排序)\n\t\t* [插入排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序)\n\t\t* [快速排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序)\n\t\t* [归并排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#归并排序)\n\t\t* [希尔排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希尔排序)\n\t\t* [堆排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序)\n\t\t* [计数排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计数排序)\n\t\t* [桶排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序)\n\t\t* [基数排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基数排序)\n\t\t* [二分查找](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查找)\n\t\t* [Java 中的排序工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具)\n\t* [布隆过滤器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆过滤器)\n\t* [字符串比较](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字符串比较)\n\t\t* [KMP 算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kmp-算法)\n\t* [深度优先、广度优先](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度优先广度优先)\n\t* [贪心算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贪心算法)\n\t* [回溯算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯算法)\n\t* [剪枝算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝算法)\n\t* [动态规划](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#动态规划)\n\t* [朴素贝叶斯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#朴素贝叶斯)\n\t* [推荐算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐算法)\n\t* [最小生成树算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成树算法)\n\t* [最短路径算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路径算法)\n* [并发](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#并发)\n\t* [多线程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多线程)\n\t* [线程安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程安全)\n\t* [一致性、事务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事务)\n\t\t* [事务 ACID 特性](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务-acid-特性)\n\t\t* [事务的隔离级别](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务的隔离级别)\n\t\t* [MVCC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvcc)\n\t* [锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#锁)\n\t\t* [Java中的锁和同步类](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的锁和同步类)\n\t\t* [公平锁 &amp; 非公平锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平锁--非公平锁)\n\t\t* [悲观锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲观锁)\n\t\t* [乐观锁 &amp; CAS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#乐观锁--cas)\n\t\t* [ABA 问题](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-问题)\n\t\t* [CopyOnWrite容器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器)\n\t\t* [RingBuffer](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer)\n\t\t* [可重入锁 &amp; 不可重入锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入锁--不可重入锁)\n\t\t* [互斥锁 &amp; 共享锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥锁--共享锁)\n\t\t* [死锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死锁)\n* [操作系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#操作系统)\n\t* [计算机原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计算机原理)\n\t* [CPU](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cpu)\n\t\t* [多级缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多级缓存)\n\t* [进程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#进程)\n\t* [线程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程)\n\t* [协程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协程)\n\t* [Linux](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux)\n* [设计模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式)\n\t* [设计模式的六大原则](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式的六大原则)\n\t* [23种常见设计模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23种常见设计模式)\n\t* [应用场景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景)\n\t* [单例模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单例模式)\n\t* [责任链模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#责任链模式)\n\t* [MVC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc)\n\t* [IOC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc)\n\t* [AOP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop)\n\t* [UML](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml)\n\t* [微服务思想](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服务思想)\n\t\t* [康威定律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律)\n* [运维 &amp; 统计 &amp; 技术支持](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#运维--统计--技术支持)\n\t* [常规监控](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常规监控)\n\t* [APM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm)\n\t* [统计分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#统计分析)\n\t* [持续集成(CI/CD)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持续集成cicd)\n\t\t* [Jenkins](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins)\n\t\t* [环境分离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#环境分离)\n\t* [自动化运维](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自动化运维)\n\t\t* [Ansible](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible)\n\t\t* [puppet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet)\n\t\t* [chef](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef)\n\t* [测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#测试)\n\t\t* [TDD 理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理论)\n\t\t* [单元测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单元测试)\n\t\t* [压力测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#压力测试)\n\t\t* [全链路压测](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全链路压测)\n\t\t* [A/B 、灰度、蓝绿测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-灰度蓝绿测试)\n\t* [虚拟化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虚拟化)\n\t\t* [KVM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm)\n\t\t* [Xen](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen)\n\t\t* [OpenVZ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz)\n\t* [容器技术](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技术)\n\t\t* [Docker](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker)\n\t* [云技术](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#云技术)\n\t\t* [OpenStack](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack)\n\t* [DevOps](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops)\n\t* [文档管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文档管理)\n* [中间件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中间件)\n\t* [Web Server](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server)\n\t\t* [Nginx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx)\n\t\t* [OpenResty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty)\n\t\t* [Apache Httpd](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd)\n\t\t* [Tomcat](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat)\n\t\t\t* [架构原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构原理)\n\t\t\t* [调优方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#调优方案)\n\t\t* [Jetty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty)\n\t* [缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#缓存)\n\t\t* [本地缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地缓存)\n\t* [客户端缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客户端缓存)\n\t* [服务端缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务端缓存)\n\t\t* [Web缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web缓存)\n\t\t* [Memcached](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached)\n\t\t* [Redis](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis)\n\t\t\t* [架构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构)\n\t\t\t* [回收策略](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略)\n\t\t* [Tair](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair)\n\t* [消息队列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息队列)\n\t\t* [消息总线](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息总线)\n\t\t* [消息的顺序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息的顺序)\n\t\t* [RabbitMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq)\n\t\t* [RocketMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq)\n\t\t* [ActiveMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq)\n\t\t* [Kafka](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka)\n\t\t* [Redis 消息推送](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-消息推送)\n\t\t* [ZeroMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq)\n\t* [定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定时调度)\n\t\t* [单机定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单机定时调度)\n\t\t* [分布式定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式定时调度)\n\t* [RPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc)\n\t\t* [Dubbo](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo)\n\t\t* [Thrift](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift)\n\t\t* [gRPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc)\n\t* [数据库中间件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库中间件)\n\t\t* [Sharding Jdbc](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc)\n\t* [日志系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志系统)\n\t\t* [日志搜集](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志搜集)\n\t* [配置中心](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心)\n\t* [API 网关](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-网关)\n* [网络](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络)\n\t* [协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协议)\n\t\t* [OSI 七层协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七层协议)\n\t\t* [TCP/IP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip)\n\t\t* [HTTP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http)\n\t\t* [HTTP2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20)\n\t\t* [HTTPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https)\n\t* [网络模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络模型)\n\t\t* [Epoll](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll)\n\t\t* [Java NIO](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-nio)\n\t\t* [kqueue](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue)\n\t* [连接和短连接](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接和短连接)\n\t* [框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架)\n\t* [零拷贝（Zero-copy）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷贝zero-copy)\n\t* [序列化(二进制协议)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二进制协议)\n\t\t* [Hessian](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian)\n\t\t* [Protobuf](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf)\n* [数据库](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库)\n\t* [基础理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论)\n\t\t* [数据库设计的三大范式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库设计的三大范式)\n\t* [MySQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql)\n\t\t* [原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理)\n\t\t* [InnoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb)\n\t\t* [优化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#优化)\n\t\t* [索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引)\n\t\t\t* [聚集索引, 非聚集索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引)\n\t\t\t* [复合索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#复合索引)\n\t\t\t* [自适应哈希索引(AHI)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自适应哈希索引ahi)\n\t\t* [explain](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain)\n\t* [NoSQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql)\n\t\t* [MongoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb)\n\t\t* [Hbase](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase)\n* [搜索引擎](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎)\n\t* [搜索引擎原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎原理)\n\t* [Lucene](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene)\n\t* [Elasticsearch](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch)\n\t* [Solr](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr)\n\t* [sphinx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx)\n* [性能](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能)\n\t* [性能优化方法论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能优化方法论)\n\t* [容量评估](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量评估)\n\t* [CDN 网络](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-网络)\n\t* [连接池](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接池)\n\t* [性能调优](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能调优)\n* [大数据](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据)\n\t* [流式计算](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式计算)\n\t\t* [Storm](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm)\n\t\t* [Flink](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink)\n\t\t* [Kafka Stream](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream)\n\t\t* [应用场景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景-1)\n\t* [Hadoop](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop)\n\t\t* [HDFS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs)\n\t\t* [MapReduce](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce)\n\t\t* [Yarn](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn)\n\t* [Spark](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark)\n* [安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全)\n\t* [web 安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全)\n\t\t* [XSS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss)\n\t\t* [CSRF](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf)\n\t\t* [SQL 注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入)\n\t\t* [Hash Dos](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos)\n\t\t* [脚本注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#脚本注入)\n\t\t* [漏洞扫描工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞扫描工具)\n\t\t* [验证码](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#验证码)\n\t* [DDoS 防范](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防范)\n\t* [用户隐私信息保护](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#用户隐私信息保护)\n\t* [序列化漏洞](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化漏洞)\n\t* [加密解密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密)\n\t\t* [对称加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#对称加密)\n\t\t* [哈希算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#哈希算法)\n\t\t* [非对称加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非对称加密)\n\t* [服务器安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务器安全)\n\t* [数据安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据安全)\n\t\t* [数据备份](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据备份)\n\t* [网络隔离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络隔离)\n\t\t* [内外网分离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#内外网分离)\n\t\t* [登录跳板机](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登录跳板机)\n\t* [授权、认证](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授权认证)\n\t\t* [RBAC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac)\n\t\t* [OAuth2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20)\n\t\t* [双因素认证（2FA）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#双因素认证2fa)\n\t\t* [单点登录(SSO)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单点登录sso)\n* [常用开源框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用开源框架)\n\t* [开源协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源协议)\n\t* [日志框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志框架)\n\t\t* [Log4j、Log4j2](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2)\n\t\t* [Logback](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback)\n\t* [ORM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm)\n\t* [网络框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络框架)\n\t* [Web 框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架)\n\t\t* [Spring 家族](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族)\n\t* [工具框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架)\n* [分布式设计](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式设计)\n\t* [扩展性设计](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#扩展性设计)\n\t* [稳定性 &amp; 高可用](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#稳定性--高可用)\n\t\t* [硬件负载均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬件负载均衡)\n\t\t* [软件负载均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#软件负载均衡)\n\t\t* [限流](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流)\n\t\t* [应用层容灾](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用层容灾)\n\t\t* [跨机房容灾](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨机房容灾)\n\t\t* [容灾演练流程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容灾演练流程)\n\t\t* [平滑启动](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑启动)\n\t* [数据库扩展](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库扩展)\n\t\t* [读写分离模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#读写分离模式)\n\t\t* [分片模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式)\n\t* [服务治理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务治理)\n\t\t* [服务注册与发现](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务注册与发现)\n\t\t* [服务路由控制](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务路由控制)\n\t* [分布式一致](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致)\n\t\t* [CAP 与 BASE 理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-与-base-理论)\n\t\t* [分布式锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式锁)\n\t\t* [分布式一致性算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致性算法)\n\t\t\t* [PAXOS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos)\n\t\t\t* [Zab](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab)\n\t\t\t* [Raft](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft)\n\t\t\t* [Gossip](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip)\n\t\t\t* [两阶段提交、多阶段提交](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#两阶段提交多阶段提交)\n\t\t* [幂等](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#幂等)\n\t\t* [分布式一致方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致方案)\n\t\t* [分布式 Leader 节点选举](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式-leader-节点选举)\n\t\t* [TCC(Try/Confirm/Cancel) 柔性事务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事务)\n\t* [分布式文件系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式文件系统)\n\t* [唯一ID 生成](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成)\n\t\t* [全局唯一ID](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全局唯一id)\n\t* [一致性Hash算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash算法)\n* [设计思想 &amp; 开发模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计思想--开发模式)\n\t* [DDD(Domain-driven Design - 领域驱动设计)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---领域驱动设计)\n\t\t* [命令查询职责分离(CQRS)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查询职责分离cqrs)\n\t\t* [贫血，充血模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贫血充血模型)\n\t* [Actor 模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式)\n\t* [响应式编程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#响应式编程)\n\t\t* [Reactor](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#reactor)\n\t\t* [RxJava](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rxjava)\n\t\t* [Vert.x](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vertx)\n\t* [DODAF2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20)\n\t* [Serverless](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless)\n\t* [Service Mesh](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#service-mesh)\n* [项目管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#项目管理)\n\t* [架构评审](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构评审)\n\t* [重构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重构)\n\t* [代码规范](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码规范)\n\t* [代码 Review](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码-review)\n\t* [RUP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup)\n\t* [看板管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理)\n\t* [SCRUM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum)\n\t* [敏捷开发](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷开发)\n\t* [极限编程（XP）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#极限编程xp)\n\t* [结对编程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#结对编程)\n\t* [FMEA管理模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#fmea管理模式)\n* [通用业务术语](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用业务术语)\n* [技术趋势](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术趋势)\n* [政策、法规](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#政策法规)\n\t* [法律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#法律)\n\t\t* [严格遵守刑法253法条](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#严格遵守刑法253法条)\n* [架构师素质](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构师素质)\n* [团队管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队管理)\n\t* [招聘](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘)\n* [资讯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#资讯)\n\t* [行业资讯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业资讯)\n\t* [公众号列表](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公众号列表)\n\t* [博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#博客)\n\t\t* [团队博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队博客)\n\t\t* [个人博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#个人博客)\n\t* [综合门户、社区](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合门户社区)\n\t* [问答、讨论类社区](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#问答讨论类社区)\n\t* [行业数据分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业数据分析)\n\t* [专项网站](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#专项网站)\n\t* [其他类](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他类)\n\t* [推荐参考书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐参考书)\n\t\t* [在线电子书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线电子书)\n\t\t* [纸质书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#纸质书)\n\t\t\t* [开发方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开发方面)\n\t\t\t* [架构方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构方面)\n\t\t\t* [技术管理方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术管理方面)\n\t\t\t* [基础理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论-1)\n\t\t\t* [工具方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面)\n\t\t\t* [大数据方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据方面)\n* [技术资源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术资源)\n\t* [开源资源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源资源)\n\t* [手册、文档、教程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手册文档教程)\n\t* [在线课堂](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线课堂)\n\t* [会议、活动](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#会议活动)\n\t* [常用APP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app)\n\t* [找工作](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作)\n\t* [工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具)\n\t* [代码托管](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码托管)\n\t* [文件服务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件服务)\n\t* [综合云服务商](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合云服务商)\n\t\t* [VPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vps)\n\t\n\n**（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）**\n\n# 数据结构\n\n## 队列\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\n\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\n\n## 集合\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\n\n## 链表、数组\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\n\n## 字典、关联数组\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\n\n## 栈\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\n\t* Stack 是线程安全的。\n\t* 内部使用数组保存数据，不够时翻倍。\n\n## 树\n\n### 二叉树\n\n每个节点最多有两个叶子节点。\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\n\n### 完全二叉树\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\n\n### 平衡二叉树\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\n\n### 二叉查找树（BST）\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\n\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\n\n\n### 红黑树\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\n\n### B-，B+，B*树\nMySQL是基于B+树聚集索引组织表\n\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\n\t* B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。\n### LSM 树\n\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\n\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n\t\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\n\n## BitSet\n\n经常用于大规模数据的排重检查。\n\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\n\n# 常用算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n## 排序、查找算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n### 选择排序\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\n\n### 冒泡排序\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\n\t* 相邻元素前后交换、把最大的排到最后。\n\t* 时间复杂度 O(n²) \n\n### 插入排序\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\n\n### 快速排序\n* [《坐在马桶上看算法：快速排序》](http://developer.51cto.com/art/201403/430986.htm)\n\t* 一侧比另外一次都大或小。 \n### 归并排序\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \n\n### 希尔排序\nTODO\n\n### 堆排序\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\n\n### 计数排序\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\n\t* 和桶排序过程比较像，差别在于桶的数量。\n\n### 桶排序\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\n\t* 每个桶单独进行排序，然后再遍历每个桶。\n\n### 基数排序\n\n按照个位、十位、百位、...依次来排。\n\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n\n### 二分查找\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\n\t* 要求待查找的序列有序。\n\t* 时间复杂度 O(logN)。\n\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\n\t* while + 递归。\n### Java 中的排序工具\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)\n\t* Collections.sort算法调用的是合并排序。\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\n\n## 布隆过滤器\n\n常用于大数据的排重，比如email，url 等。\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\n优点：空间和时间效率都很高。\n缺点：随着存入的元素数量增加，误算率随之增加。\n\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\n\t* 基于 Redis 的 Bitmap 数据结构。\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\n\n## 字符串比较\n\n### KMP 算法\nKMP：Knuth-Morris-Pratt算法（简称KMP）\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n## 深度优先、广度优先\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\n\n## 贪心算法\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\n\n## 回溯算法\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\n\n## 剪枝算法\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\n\n## 动态规划\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\n\n## 朴素贝叶斯\n\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\n\t* P(B|A)=P(A|B)P(B)/P(A)\n\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\n\n\n## 推荐算法\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\n\n## 最小生成树算法\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\n\n## 最短路径算法\n\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\n\n# 并发\n\n## Java 并发\n\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\n\n## 多线程\n\n* [《40个Java多线程问题总结》](http://www.importnew.com/18459.html)\n\n## 线程安全\n\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\n\n## 一致性、事务\n\n### 事务 ACID 特性\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\n\n### 事务的隔离级别\n\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\n* 序列化：所有事物串行处理（牺牲了效率）\n\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\n\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\n\t* 幻读的例子非常清楚。\n\t* 通过 SELECT ... FOR UPDATE 解决。\n\t\n* [《一篇文章带你读懂MySQL和InnoDB》](http://database.51cto.com/art/201804/570101.htm)\n\t* 图解脏读、不可重复读、幻读问题。\n\n\n### MVCC\n\n\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\n\t* MVCC 会产生幻读问题（更新时异常。）\n\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\n\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\n\t* 每次只操作比当前版本小（或等于）的 行。\n\t\n\n\n## 锁\n\n### Java中的锁和同步类\n\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \n\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\n\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\n\t* 有数量控制\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\n\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \n\n### 公平锁 & 非公平锁\n\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\n\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\n\n### 悲观锁 \n\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\n\n* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\n\t* 乐观锁的方式：版本号+重试方式\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\n\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\n\t* 锁相同数据的不同索引条件可能会引起死锁。\n\t\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\n\n### 乐观锁 & CAS\n\n* [《乐观锁的一种实现方式——CAS》](http://www.importnew.com/20472.html)\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \n\n### ABA 问题\n\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\n\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\n\t* AtomicStampedReference 和 AtomicStampedReference。 \n\n### CopyOnWrite容器\n\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\n\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \n\t* 不用加锁，通过最终一致实现一致性。\n\t\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\n\n### RingBuffer \n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\n\n### 可重入锁 & 不可重入锁\n\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\n\t* 可重入锁可以用户避免死锁。\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\n\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\n\t* 相同加锁场景下，推荐使用 synchronized。\n\n### 互斥锁 & 共享锁\n\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\n\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\n\n### 死锁\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\n\t* 互斥、持有、不可剥夺、环形等待。\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\n\t* JConsole 可以识别死锁。\n\t\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\n\t* jstack 可以显示死锁。\n\t\n# 操作系统\n\n## 计算机原理\n\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\n\n## CPU\n\n### 多级缓存\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\n\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\n\n## 进程\n\nTODO\n\n## 线程\n\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\n\n## 协程\n\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\n\t* 与线程相比，协程减少了无谓的操作系统切换.\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\n\t\n## Linux\n\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\n\n# 设计模式\n\n## 设计模式的六大原则\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\n\n## 23种常见设计模式\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\n\n## 应用场景\n* [《细数JDK里的设计模式》](http://blog.jobbole.com/62314/)\n\t* 结构型模式：\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\n\t\t\n\t* 创建模式:\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\n\t\t* 工厂方法：就是 **一个返*** 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\n\t* 行为模式：\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\n\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\n\n## 单例模式\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\n\t* 使用枚举类型。\n\n## 责任链模式\nTODO\n\n## MVC\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\n\t* 模型(model)－视图(view)－控制器(controller) \n\n## IOC\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\n\t* 作用：用于模块解耦。\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\n\n## AOP\n\n* [《轻松理解AOP(面向切面编程)》](https://my.oschina.net/yanquan345/blog/203415)\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \n\n\n## UML\n\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\n\n## 微服务思想\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\n\n### 康威定律\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\n\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\n\n# 运维 & 统计 & 技术支持 \n\n## 常规监控\n\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\n\t监控、用户端监控\n\t* 监控的目标：全、块、准\n\t* 核心指标：请求量、成功率、耗时\n\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\n\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\n\n**命令行监控工具**\n\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\n\t* top、sar、tsar、nload\n\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\n\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\n\n## APM\n\nAPM —  Application Performance Management\n\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\n\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\n\n* 主要开源软件，按字母排序\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\n  * [CAT](https://github.com/dianping/cat)\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\n  * [Pinpoint](https://github.com/naver/pinpoint)\n  * [Zipkin](https://github.com/openzipkin/zipkin)\n\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\n\t\n\n\n## 统计分析\n\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\n\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\n\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt-mobile-analytics-practice.html)\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \n\n\n## 持续集成(CI/CD)\n\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n* [《8个流行的持续集成工具》](https://www.testwo.com/article/1170)\n\n### Jenkins\n\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\n\n### 环境分离\n\n开发、测试、生成环境分离。\n\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\n\n## 自动化运维\n\n### Ansible\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\n\n### puppet\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\n\n### chef\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\n\n## 测试\n\n### TDD 理论\n\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \n\n### 单元测试\n\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \n\n### 压力测试\n\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\n\n\n### 全链路压测\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\n\n\n### A/B 、灰度、蓝绿测试\n\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\n\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\n\n## 虚拟化\n\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\n\n### KVM\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\n\n### Xen\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\n\n### OpenVZ\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\n\n## 容器技术\n\n### Docker\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\n\n## 云技术\n\n### OpenStack\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\n\n## DevOps\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\n\n## 文档管理\n\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\n* GitLab?\n* Wiki\n\n# 中间件\n\n## Web Server\n\n### Nginx\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \n\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\n\n### OpenResty\n* [官方网站](http://openresty.org/cn/)\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\n\t* 通过 Lua 模块可以在Nginx上进行开发。 \n\n### Apache Httpd\n* [官方网站](http://httpd.apache.org/)\n\n### Tomcat\n\n#### 架构原理\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\n\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\n\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\n\n#### 调优方案\n\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \n\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\n\t* 并发高时，AJP协议优于HTTP协议。\n\n### Jetty\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \n\n\n\n## 缓存\n\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\n\n### 本地缓存\n\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\n\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\n\t* 堆内、堆外、磁盘三级缓存。\n\t* 可按照缓存空间容量进行设置。\n\t* 按照时间、次数等过期策略。\n\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\n\t* 简单轻量、无堆外、磁盘缓存。\n\n\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\n\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\n\n## 客户端缓存\n\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\n\t* 主要是利用 Cache-Control 参数。\n\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\n\n## 服务端缓存\n\n### Web缓存\n\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\n* [squid](https://github.com/squid-cache/squid) - squid cache\n\n### Memcached\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\n\t* 采用多路复用技术提高并发性。\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\n\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\n\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)\n\n### Redis\n\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\n\t* 也可以两者结合使用。\n\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\n\n#### 架构\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\n\n#### 回收策略\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\n\n### Tair\n\n* [官方网站](https://github.com/alibaba/tair)\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\n* 一致性Hash算法。\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\n\n\n几种存储引擎:\n* MDB，完全内存性，可以用来存储Session等数据。\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\n\n## 消息队列\n\n* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\n\t* Kafka 默认是拉模式。\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\n\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\n\n### 消息总线\n\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\n\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\n\n### 消息的顺序\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\n\n### RabbitMQ\n\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\n\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\n\n### RocketMQ\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)\n\n### ActiveMQ\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\n\n### Kafka\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\n\n* [官方网站](http://kafka.apache.org/)\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\n\n### Redis 消息推送\n\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\n\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\n\n### ZeroMQ\n TODO\n\n\n## 定时调度\n\n### 单机定时调度\n\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\n\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\n\t* fork 进程 + sleep 轮询\n\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\n\n\n### 分布式定时调度\n\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\n\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)\n\n\n## RPC\n\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\n\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\n\n### Dubbo\n* [官方网站](http://dubbo.apache.org/)\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\n\n** SPI **\nTODO\n\n### Thrift\n* [官方网站](http://thrift.apache.org/)\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\n\t* 支持多语言，通过中间语言定义接口。\n\n### gRPC\n\n服务端可以认证加密，在外网环境下，可以保证数据安全。\n\n* [官方网站](https://grpc.io/)\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\n\n\n## 数据库中间件\n\n### Sharding Jdbc\n\n* [官网](http://shardingjdbc.io/)\n\n## 日志系统\n\n### 日志搜集\n\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\n\n## 配置中心\n\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\n\t* Spring Boot 和 Spring Cloud\n\t* 支持推、拉模式更新配置\n\t* 支持多种语言 \n\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\n\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\n\nservlet 3.0 异步特性可用于配置中心的客户端\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\n\n## API 网关\n\n主要职责：请求转发、安全认证、协议转换、容灾。\n\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\n\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\n\n# 网络\n\n\n## 协议\n\n### OSI 七层协议\n\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\n\n### TCP/IP\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\n\n### HTTP\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\n\n### HTTP2.0\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\n\t* 利用二进制帧负责传输。\n\t* 多路复用。\n\n### HTTPS\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\n\t* 使用非对称加密协商加密算法\n\t* 使用对称加密方式传输数据\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\n\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\n\n## 网络模型\n\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\n\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\n\t\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\n\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\n\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\n\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\n\n### Epoll\n\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\n\n### Java NIO\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\n\n### kqueue\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\n\n## 连接和短连接\n\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\n\n## 框架\n\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\n\t* Reactor 模式介绍。\n\t* Netty 是 Reactor 模式的一种实现。\n\n## 零拷贝（Zero-copy）\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\n\n## 序列化(二进制协议)\n\n### Hessian\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\nBinary-RPC;不仅仅是序列化\n\n### Protobuf\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\n  \t* 关于协议的解释；缺点：可读性差;\n\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\n\n# 数据库\n## 基础理论\n### 数据库设计的三大范式\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\n\n## MySQL\n\n### 原理\n* [《MySQL的InnoDB索引原理详解》](http://www.admin10000.com/document/5372.html)\n\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\n\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\n\n### InnoDB\n\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\n\n### 优化\n\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\n\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\n* [《 MYSQL分页limit速度太慢优化方法》](https://blog.csdn.net/zy_281870667/article/details/51604540)\n\t* 原则上就是缩小扫描范围。\n\n\n### 索引\n\n#### 聚集索引, 非聚集索引\n\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\n\nMyISAM 是非聚集，InnoDB 是聚集\n\n#### 复合索引\n\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\n\n#### 自适应哈希索引(AHI)\n\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\n\n\n### explain\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\n\n## NoSQL\n\n### MongoDB\n\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\n\n### Hbase\n\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\n\n\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\n\t* 空数据不存储，节省空间，且适用于并发。\n\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\n\t* rowkey 按照字典顺序排列，便于批量扫描。\n\t* 通过散列可以避免热点。\n\n# 搜索引擎\n\n## 搜索引擎原理\n\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\n\n## Lucene\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\n\n## Elasticsearch\n\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\n\n## Solr\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\n\n## sphinx \n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\n\n# 性能\n\n## 性能优化方法论\n\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\n\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\n\n## 容量评估\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\n\n## CDN 网络\n\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\n\n## 连接池\n\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\n\n## 性能调优\n\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\n\n\n# 大数据\n\n## 流式计算\n\n### Storm\n* [官方网站](http://storm.apache.org/)\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\n\n### Flink\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\n\n### Kafka Stream\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\n\n### 应用场景\n\n例如：\n\n* 广告相关实时统计；\n* 推荐系统用户画像标签实时更新；\n* 线上服务健康状况实时监测；\n* 实时榜单；\n* 实时数据统计。\n\n## Hadoop\n\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\n\n### HDFS\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\n\n### MapReduce\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\n\n### Yarn\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\n\n## Spark\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\n\n\n# 安全\n\n## web 安全\n\n### XSS\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\n### CSRF\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\n\n### SQL 注入\n\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\n\n### Hash Dos\n\n\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\n\t* 利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\n* [《一种高级的DoS攻击-Hash碰撞攻击》](https://yq.aliyun.com/articles/92194?t=t1)\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\n\n### 脚本注入\n\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\n\n### 漏洞扫描工具\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\n\n### 验证码\n\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\n\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\n\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\n\n## DDoS 防范\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\n\n## 用户隐私信息保护\n\n1. 用户密码非明文保存，加动态salt。\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\n3. 联系方式在的显示与否由用户自己控制。\n4. TODO\n\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\n\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\n\n## 序列化漏洞\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\n\n## 加密解密\n\n### 对称加密\n\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\n\t* DES、3DES、Blowfish、AES\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\n\t\n### 哈希算法\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\n\t* 目前 SHA-256 是比较安全的。\n\t\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\n\n### 非对称加密\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\n\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)\t\n\n\n## 服务器安全\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\n\n## 数据安全\n\n### 数据备份\n\nTODO\n\n## 网络隔离\n\n### 内外网分离\n\nTODO\n\n### 登录跳板机\n在内外环境中通过跳板机登录到线上主机。\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\n\n## 授权、认证\n### RBAC \n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\n\n### OAuth2.0\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\n\n### 双因素认证（2FA）\n\n2FA - Two-factor authentication，用于加强登录验证\n\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\n\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\n\n### 单点登录(SSO)\n\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\n\n* [CAS单点登录框架](https://github.com/apereo/cas)\n\n# 常用开源框架\n\n## 开源协议\n\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\n\n* [如何选择一个开源软件协议](http://choosealicense.online/)\n\n## 日志框架\n\n### Log4j、Log4j2\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\n\t* Log4J 异步日志性能优异。 \n\n### Logback\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\n\n## ORM\n\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\n\t* 主要目的是为了提高开发效率。 \n\n**MyBatis：**\n\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \n\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\n\n## 网络框架\n\nTODO\n\n## Web 框架\n\n### Spring 家族\n**Spring**\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\n\n**Spring Boot**\n* [官方网站](http://projects.spring.io/spring-boot/)\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n**Spring Cloud**\n\n* [Spring Boot 中文索引站](http://springboot.fun/)\n* [Spring Cloud 中文文档](https://springcloud.cc/)\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n## 工具框架\n\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\n\n\n# 分布式设计\n\n## 扩展性设计\n\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \n\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\n\t* 水平切分+垂直切分\n\t* 利用中间件进行分片如，MySQL Proxy。\n\t* 利用分片策略进行切分，如按照ID取模。 \n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\n\t* 分布式服务+消息队列。\n\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\n\n## 稳定性 & 高可用\n\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\n\n\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \n\n### 硬件负载均衡\n\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\n\t* 主要是和F5对比。\n\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\n\n### 软件负载均衡\n\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\n\t轮寻、权重、负载、最少连接、QoS\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\n\t* 配置简单，更新速度慢。 \n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\n\t* 简单轻量、学习成本低；主要适用于web应用。\n\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\n\t* 配置比较负载、只支持到4层，性能较高。\n\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\n\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\n\t* 主要是用户读请求的负载均衡。\n\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\n\n### 限流\n\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\n\n### 应用层容灾\n\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\n\t* Hystrix设计原则：\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \n\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\n\n### 跨机房容灾\n\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\n\t* 通过自研中间件进行数据同步。 \n\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\n\t* 异地多活监控部署、测试也要跟上。\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\n\t* 控制跨机房消息体大小，越小越好。\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\n\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\n\n\n### 容灾演练流程\n\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)\n\t* 常见故障画像\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\n\n### 平滑启动\n\n* 平滑重启应用思路\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\n\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\nJava、Srping、Dubbo 优雅关闭方式。\n\n## 数据库扩展\n\n### 读写分离模式\n\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\n\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\n\t* DRDB 进行磁盘复制，避免单点问题。\n\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\n\n### 分片模式\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\n\t* 分库策略：数值范围；取模；日期等。\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \n\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\n\n## 服务治理\n###  服务注册与发现\n\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\n\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \n\n### 服务路由控制\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\n\t* 原则：透明化路由\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\n\t* 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\n\t* 配置方式：统一注册表；本地配置；动态下发。\n\n## 分布式一致\n\n### CAP 与 BASE 理论\n\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 分布式锁\n\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\n\t* 清楚的原理描述 + Java 代码示例。 \n\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\n\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\n\n### 分布式一致性算法\n\n#### PAXOS\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\n* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\n\n#### Zab\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\n\n#### Raft\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\n\t* 通过随机等待的方式发出投票，得票多的获胜。\n\n#### Gossip\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\n\n#### 两阶段提交、多阶段提交\n\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\n\n### 幂等\n\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \n\n### 分布式一致方案\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\n\n### 分布式 Leader 节点选举\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\n\n### TCC(Try/Confirm/Cancel) 柔性事务\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\n\n## 分布式文件系统\n\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\n  * FastDFS：轻量级、适合小文件。\n\n## 唯一ID 生成\n\n### 全局唯一ID\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\n\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\n\n## 一致性Hash算法\n\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\n\n# 设计思想 & 开发模式\n\n## DDD(Domain-driven Design - 领域驱动设计)\n\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\n  \n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\n  * 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\n  * 使用的模式：\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\n\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\n\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\n\n\n### 命令查询职责分离(CQRS)\n\nCQRS — Command Query Responsibility Seperation\n\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\n\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\n\t\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\n\t* 一个实现 CQRS 的抽象案例。\n\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\n\t* CQRS 模式分析 + 12306 抢票案例\n\n### 贫血，充血模型\n\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\n\t* 作者主张使用贫血模式。\n\t\n## Actor 模式\n\nTODO\n\n## 响应式编程\n\n### Reactor\nTODO\n### RxJava\nTODO\n### Vert.x\nTODO\n\n## DODAF2.0\n\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\n\n## Serverless\n\n无需过多关系服务器的服务架构理念。\n\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\n\t* Serverless 不代表某个具体的框架。\n\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\n\n\n\n## Service Mesh\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n\n# 项目管理\n\n## 架构评审\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\n\n## 重构\n\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\n\n## 代码规范\n\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\n\n## 代码 Review\n\n\n制度还是制度!\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\n\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\n\t* 代码 review 做的好，在于制度建设。\n\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\n\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\n\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\n\n## RUP\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\n\n## 看板管理\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\n\n## SCRUM\n\nSCRUM - 争球\n\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\n* 五个价值观：专注、勇气、公开、承诺、尊重。\n\n\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\n\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\n\n## 敏捷开发\n\nTODO\n\n## 极限编程（XP）\n\nXP - eXtreme Programming\n\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\n\t* 是一种指导开发人员的方法论。\n\t* 4大价值：\n\t\t* 沟通：鼓励口头沟通，提高效率。\n\t\t* 简单：够用就好。\n\t\t* 反馈：及时反馈、通知相关人。\n\t\t* 勇气：提倡拥抱变化，敢于重构。\n\t\t\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\n\n## 结对编程\n\n边写码，边review。能够增强代码质量、减少bug。\n\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\n\n## PDCA 循环质量管理\n\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\n\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\n\n## FMEA管理模式\n\nTODO\n\n# 通用业务术语\n\nTODO\n\n# 技术趋势\n\nTODO\n\n# 政策、法规\n\nTODO\n## 法律\n\n### 严格遵守刑法253法条\n\n我国刑法第253条之一规定：\n\n> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\n> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \n> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\n\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\n\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\n\n\n# 架构师素质\n\n* [《架构师画像》](http://hellojava.info/?p=430)\n\t* 业务理解和抽象能力\n\t* NB的代码能力\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \n\t* 全局：是否考虑到了对上下游的系统的影响。\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\n\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\n\t* 基础设施、配置、测试、开发、运维综合考虑。\n\t* 考虑人、团队、和组织的影响。 \n\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \n\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \n\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\n\t* 第一层的架构师看到的只是产品本身\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\n\t* 第三层的架构师看到的是商业价值 \n\n# 团队管理\n\nTODO\n\n## 招聘\n\n# 资讯\n\n## 行业资讯\n\n* [36kr](http://36kr.com/)\n* [Techweb](http://www.techweb.com.cn/)\n\n## 公众号列表\n\nTODO\n\n## 博客\n\n### 团队博客\n* [阿里中间件博客](http://jm.taobao.org/)\n* [美团点评技术团队博客](https://tech.meituan.com)\n\n### 个人博客\n\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\n* [hellojava-阿里毕玄](http://hellojava.info/)\n* [Cm's Blog](http://cmsblogs.com/)\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\n\n## 综合门户、社区\n\n**国内：**\n\n* [CSDN](http://csdn.net)\n\t 老牌技术社区、不必解释。\n* [51cto.com](http://www.51cto.com/)\n* [ITeye](http://www.iteye.com/)\n\t* 偏 Java 方向 \n* [博客园](https://www.cnblogs.com)\n* [ChinaUnix](http://www.tom.net/)\n\t* 偏 Linux 方向 \n* [开源中国社区](https://www.oschina.net/)\n* [深度开源](http://www.open-open.com/)\n* [伯乐在线](http://www.jobbole.com/)\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\n\n* [ITPUB](http://www.itpub.net/)\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\n* [开发者头条](https://toutiao.io/)\n* [LinkedKeeper](http://www.linkedkeeper.com)\n\n**国外：**\n\n* [DZone](https://dzone.com)\n* [Reddit](https://www.reddit.com)\n\n## 问答、讨论类社区\n\n* [segmentfault](https://segmentfault.com)\n\t* 问答+专栏 \n* [知乎](https://www.zhihu.com/)\n* [stackoverflow](https://stackoverflow.com/)\n\n## 行业数据分析\n\n* [艾瑞网](http://report.iresearch.cn/)\n* [QUEST MOBILE](https://www.questmobile.com.cn)\n\n* [国家数据](http://data.stats.gov.cn/)\n\n* [TalkingData](http://www.talkingdata.com/)\n\n## 专项网站\n\n* 测试:\n\t* [领测国际](http://www.ltesting.net/) \n\t* [测试窝](https://www.testwo.com/)\n\t* [TesterHome](https://testerhome.com)\n\n* 运维:\n  \t* [运维派](http://www.yunweipai.com/) \n  \t* [Abcdocker](https://www.abcdocker.com/)\n  \n* Java:\n\t* [ImportNew](http://www.importnew.com/)\n\t\t* 专注于 Java 技术分享\n\t* [HowToDoInJava](https://howtodoinjava.com/)\n\t\t* 英文博客\n\t\n* 安全\n\t* [红黑联盟](https://www.2cto.com/) \n\t* [FreeBuf](http://www.freebuf.com/)\n\n* 大数据\n\t* [中国大数据](http://www.thebigdata.cn/) \n\n* 其他专题网站：\n\t* [DockerInfo](http://www.dockerinfo.net/)\n\t\t* 专注于 Docker 应用及咨询、教程的网站。\n\t* [Linux公社](https://www.linuxidc.com/)\n\t\t* Linux 主题社区\n\n## 其他类\n\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\n\n## 推荐参考书\n\n\n### 在线电子书\n\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\n\n\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\n\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\n\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\n\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\n\n### 纸质书\n\n#### 开发方面\n\n* 《阿里巴巴Java开发手册》[京东](https://union-click.jd.com/jdc?d=bVKwZQ) [淘宝](https://s.taobao.com/search?q=阿里巴巴Java开发手册)\n\n#### 架构方面\n* 《软件架构师的12项修炼：技术技能篇》[京东](https://union-click.jd.com/jdc?d=gXvRd8) [淘宝](https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇)\n* 《架构之美》[京东](https://union-click.jd.com/jdc?d=xJit5I) [淘宝](https://s.taobao.com/search?q=架构之美)\n* 《分布式服务架构》[京东](https://union-click.jd.com/jdc?d=JS5Od9) [淘宝](https://s.taobao.com/search?q=分布式服务架构)\n* 《聊聊架构》 [京东](https://union-click.jd.com/jdc?d=FHooH4) [淘宝](https://s.taobao.com/search?q=聊聊架构)\n* 《云原生应用架构实践》[京东](https://union-click.jd.com/jdc?d=orkJSj) [淘宝](https://s.taobao.com/search?q=云原生应用架构实践)\n* 《亿级流量网站架构核心技术》[京东](https://union-click.jd.com/jdc?d=RnOSP5) [淘宝](https://s.taobao.com/search?q=亿级流量网站架构核心技术)\n* 《淘宝技术这十年》[京东](https://union-click.jd.com/jdc?d=LwrDfD) [淘宝](https://s.taobao.com/search?q=淘宝技术这十年)\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [京东](https://union-click.jd.com/jdc?d=89pAEm) [淘宝](https://s.taobao.com/search?q=企业IT架构转型之道)\n\n* 《高可用架构（第1卷）》[京东](https://item.jd.com/12195481.html) [淘宝](https://s.taobao.com/search?q=高可用架构)\n\n#### 技术管理方面\n* 《CTO说》[京东](https://union-click.jd.com/jdc?d=zhTZyr) [淘宝](https://s.taobao.com/search?q=CTO说)\n* 《技术管理之巅》[京东](https://union-click.jd.com/jdc?d=LgRBUW) [淘宝](https://s.taobao.com/search?q=技术管理之巅)\n* 《网易一千零一夜：互联网产品项目管理实战》[京东](https://union-click.jd.com/jdc?d=jcRz2r) [淘宝](https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战)\n\n#### 基础理论\n* 《数学之美》[京东](https://union-click.jd.com/jdc?d=ghIES2) [淘宝](https://s.taobao.com/search?q=数学之美)\n* 《编程珠玑》[京东](https://union-click.jd.com/jdc?d=YmhdEu) [淘宝](https://s.taobao.com/search?q=编程珠玑)\n\n#### 工具方面\nTODO\n\n#### 大数据方面\n\n# 技术资源\n\n## 开源资源\n* [github](https://github.com)\n\n* [Apache 软件基金会](https://www.apache.org/index.html)\n\n## 手册、文档、教程\n\n**国内：**\n* [W3Cschool](http://w3cschool.cn) \n* [Runoob.com](http://www.runoob.com/)\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\n\n* [Love2.io](https://love2.io/)\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\n* [gitbook.cn](http://gitbook.cn/)\n\t* 付费电子书。 \n* [ApacheCN](http://www.apachecn.org/)\n\t* AI、大数据方面系列中文文档。\n\n**国外：**\n\n* [Quick Code](http://www.quickcode.co/)\n\t* 免费在线技术教程。\n* [gitbook.com](http://gitbook.com)\n\t* 有部分中文电子书。\n* [Cheatography](https://www.cheatography.com/)\n\t* Cheat Sheets 大全，单页文档网站。\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\n\n\n## 在线课堂\n\n* [学徒无忧](http://www.xuetuwuyou.com/)\n* [极客时间](https://time.geekbang.org/)\n* [segmentfault](https://segmentfault.com/lives)\n* [斯达克学院](https://new.stuq.org/course/explore)\n* [牛客网](http://nowcoder.com)\n* [极客学院](https://www.jikexueyuan.com/)\n* [51CTO学院](http://edu.51cto.com/)\n\n## 会议、活动\n\n* [QCon](http://www.infoq.com/cn/qcon/)\n* [ArchSummit](https://archsummit.com)\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\n\n**活动发布平台:** \n* [活动行](http://www.huodongxing.com/)\n\n## 常用APP\n\n* [极客时间](https://time.geekbang.org)\n* [得到](https://www.igetget.com)\n\n## 找工作\n* [Boss直聘](https://www.zhipin.com)\n* [拉勾网](https://www.lagou.com)\n* [猎聘](https://www.liepin.com)\n* [100Offer](https://cn.100offer.com/)\n\n## 工具\n\n* [极客搜索](https://s.geekbang.org/)\n\t* 技术文章搜索引擎。\n\n## 代码托管\n\n* [Coding](https://coding.net)\n* [码云](https://gitee.com/)\n\n## 文件服务\n* 七牛\n* 又拍云\n\n## 综合云服务商\n* 阿里云\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)\n* 百度云\n* 新浪云\n* 金山云\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\n* [微软云](https://azure.microsoft.com/zh-cn/)\n\n### VPS\n* [Linode](http://linode.com)\n\n","source":"_posts/architect-awesome.md","raw":"---\ntitle: 后端架构师技术图谱\ndate: 2018-06-19 08:51:42\ncategories: 架构\ntags: 后端架构师技术图谱\n---\n\n列出了后端架构师要掌握的基本知识。少壮不努力，老大徒伤悲……\n\n本文拷贝自https://github.com/xingshaocheng/architect-awesome\n\n\n<h1>《后端架构师技术图谱》</h1>\n\n**更新于20180513**\n* [数据结构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构)\n\t* [队列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列)\n\t* [集合](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合)\n\t* [链表、数组](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组)\n\t* [字典、关联数组](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组)\n\t* [栈](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈)\n\t* [树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#树)\n\t\t* [二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉树)\n\t\t* [完全二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉树)\n\t\t* [平衡二叉树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉树)\n\t\t* [二叉查找树（BST）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查找树bst)\n\t\t* [红黑树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#红黑树)\n\t\t* [B-，B+，B*树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb树)\n\t\t* [LSM 树](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-树)\n\t* [BitSet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset)\n* [常用算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用算法)\n\t* [排序、查找算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查找算法)\n\t\t* [选择排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#选择排序)\n\t\t* [冒泡排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冒泡排序)\n\t\t* [插入排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序)\n\t\t* [快速排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序)\n\t\t* [归并排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#归并排序)\n\t\t* [希尔排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希尔排序)\n\t\t* [堆排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序)\n\t\t* [计数排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计数排序)\n\t\t* [桶排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序)\n\t\t* [基数排序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基数排序)\n\t\t* [二分查找](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查找)\n\t\t* [Java 中的排序工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具)\n\t* [布隆过滤器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆过滤器)\n\t* [字符串比较](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字符串比较)\n\t\t* [KMP 算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kmp-算法)\n\t* [深度优先、广度优先](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度优先广度优先)\n\t* [贪心算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贪心算法)\n\t* [回溯算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯算法)\n\t* [剪枝算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝算法)\n\t* [动态规划](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#动态规划)\n\t* [朴素贝叶斯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#朴素贝叶斯)\n\t* [推荐算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐算法)\n\t* [最小生成树算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成树算法)\n\t* [最短路径算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路径算法)\n* [并发](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#并发)\n\t* [多线程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多线程)\n\t* [线程安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程安全)\n\t* [一致性、事务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事务)\n\t\t* [事务 ACID 特性](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务-acid-特性)\n\t\t* [事务的隔离级别](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务的隔离级别)\n\t\t* [MVCC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvcc)\n\t* [锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#锁)\n\t\t* [Java中的锁和同步类](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的锁和同步类)\n\t\t* [公平锁 &amp; 非公平锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平锁--非公平锁)\n\t\t* [悲观锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲观锁)\n\t\t* [乐观锁 &amp; CAS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#乐观锁--cas)\n\t\t* [ABA 问题](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-问题)\n\t\t* [CopyOnWrite容器](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器)\n\t\t* [RingBuffer](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer)\n\t\t* [可重入锁 &amp; 不可重入锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入锁--不可重入锁)\n\t\t* [互斥锁 &amp; 共享锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥锁--共享锁)\n\t\t* [死锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死锁)\n* [操作系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#操作系统)\n\t* [计算机原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计算机原理)\n\t* [CPU](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cpu)\n\t\t* [多级缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多级缓存)\n\t* [进程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#进程)\n\t* [线程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程)\n\t* [协程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协程)\n\t* [Linux](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux)\n* [设计模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式)\n\t* [设计模式的六大原则](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式的六大原则)\n\t* [23种常见设计模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23种常见设计模式)\n\t* [应用场景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景)\n\t* [单例模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单例模式)\n\t* [责任链模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#责任链模式)\n\t* [MVC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc)\n\t* [IOC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc)\n\t* [AOP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop)\n\t* [UML](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml)\n\t* [微服务思想](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服务思想)\n\t\t* [康威定律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律)\n* [运维 &amp; 统计 &amp; 技术支持](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#运维--统计--技术支持)\n\t* [常规监控](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常规监控)\n\t* [APM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm)\n\t* [统计分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#统计分析)\n\t* [持续集成(CI/CD)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持续集成cicd)\n\t\t* [Jenkins](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins)\n\t\t* [环境分离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#环境分离)\n\t* [自动化运维](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自动化运维)\n\t\t* [Ansible](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible)\n\t\t* [puppet](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet)\n\t\t* [chef](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef)\n\t* [测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#测试)\n\t\t* [TDD 理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理论)\n\t\t* [单元测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单元测试)\n\t\t* [压力测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#压力测试)\n\t\t* [全链路压测](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全链路压测)\n\t\t* [A/B 、灰度、蓝绿测试](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-灰度蓝绿测试)\n\t* [虚拟化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虚拟化)\n\t\t* [KVM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm)\n\t\t* [Xen](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen)\n\t\t* [OpenVZ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz)\n\t* [容器技术](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技术)\n\t\t* [Docker](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker)\n\t* [云技术](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#云技术)\n\t\t* [OpenStack](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack)\n\t* [DevOps](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops)\n\t* [文档管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文档管理)\n* [中间件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中间件)\n\t* [Web Server](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server)\n\t\t* [Nginx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx)\n\t\t* [OpenResty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty)\n\t\t* [Apache Httpd](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd)\n\t\t* [Tomcat](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat)\n\t\t\t* [架构原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构原理)\n\t\t\t* [调优方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#调优方案)\n\t\t* [Jetty](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty)\n\t* [缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#缓存)\n\t\t* [本地缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地缓存)\n\t* [客户端缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客户端缓存)\n\t* [服务端缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务端缓存)\n\t\t* [Web缓存](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web缓存)\n\t\t* [Memcached](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached)\n\t\t* [Redis](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis)\n\t\t\t* [架构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构)\n\t\t\t* [回收策略](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略)\n\t\t* [Tair](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair)\n\t* [消息队列](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息队列)\n\t\t* [消息总线](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息总线)\n\t\t* [消息的顺序](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息的顺序)\n\t\t* [RabbitMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq)\n\t\t* [RocketMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq)\n\t\t* [ActiveMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq)\n\t\t* [Kafka](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka)\n\t\t* [Redis 消息推送](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-消息推送)\n\t\t* [ZeroMQ](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq)\n\t* [定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定时调度)\n\t\t* [单机定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单机定时调度)\n\t\t* [分布式定时调度](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式定时调度)\n\t* [RPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc)\n\t\t* [Dubbo](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo)\n\t\t* [Thrift](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift)\n\t\t* [gRPC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc)\n\t* [数据库中间件](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库中间件)\n\t\t* [Sharding Jdbc](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc)\n\t* [日志系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志系统)\n\t\t* [日志搜集](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志搜集)\n\t* [配置中心](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心)\n\t* [API 网关](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-网关)\n* [网络](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络)\n\t* [协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协议)\n\t\t* [OSI 七层协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七层协议)\n\t\t* [TCP/IP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip)\n\t\t* [HTTP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http)\n\t\t* [HTTP2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20)\n\t\t* [HTTPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https)\n\t* [网络模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络模型)\n\t\t* [Epoll](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll)\n\t\t* [Java NIO](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-nio)\n\t\t* [kqueue](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue)\n\t* [连接和短连接](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接和短连接)\n\t* [框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架)\n\t* [零拷贝（Zero-copy）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷贝zero-copy)\n\t* [序列化(二进制协议)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二进制协议)\n\t\t* [Hessian](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian)\n\t\t* [Protobuf](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf)\n* [数据库](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库)\n\t* [基础理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论)\n\t\t* [数据库设计的三大范式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库设计的三大范式)\n\t* [MySQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql)\n\t\t* [原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理)\n\t\t* [InnoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb)\n\t\t* [优化](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#优化)\n\t\t* [索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引)\n\t\t\t* [聚集索引, 非聚集索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引)\n\t\t\t* [复合索引](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#复合索引)\n\t\t\t* [自适应哈希索引(AHI)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自适应哈希索引ahi)\n\t\t* [explain](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain)\n\t* [NoSQL](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql)\n\t\t* [MongoDB](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb)\n\t\t* [Hbase](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase)\n* [搜索引擎](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎)\n\t* [搜索引擎原理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎原理)\n\t* [Lucene](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene)\n\t* [Elasticsearch](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch)\n\t* [Solr](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr)\n\t* [sphinx](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx)\n* [性能](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能)\n\t* [性能优化方法论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能优化方法论)\n\t* [容量评估](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量评估)\n\t* [CDN 网络](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-网络)\n\t* [连接池](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接池)\n\t* [性能调优](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能调优)\n* [大数据](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据)\n\t* [流式计算](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式计算)\n\t\t* [Storm](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm)\n\t\t* [Flink](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink)\n\t\t* [Kafka Stream](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream)\n\t\t* [应用场景](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景-1)\n\t* [Hadoop](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop)\n\t\t* [HDFS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs)\n\t\t* [MapReduce](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce)\n\t\t* [Yarn](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn)\n\t* [Spark](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark)\n* [安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全)\n\t* [web 安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全)\n\t\t* [XSS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss)\n\t\t* [CSRF](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf)\n\t\t* [SQL 注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入)\n\t\t* [Hash Dos](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos)\n\t\t* [脚本注入](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#脚本注入)\n\t\t* [漏洞扫描工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞扫描工具)\n\t\t* [验证码](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#验证码)\n\t* [DDoS 防范](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防范)\n\t* [用户隐私信息保护](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#用户隐私信息保护)\n\t* [序列化漏洞](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化漏洞)\n\t* [加密解密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密)\n\t\t* [对称加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#对称加密)\n\t\t* [哈希算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#哈希算法)\n\t\t* [非对称加密](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非对称加密)\n\t* [服务器安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务器安全)\n\t* [数据安全](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据安全)\n\t\t* [数据备份](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据备份)\n\t* [网络隔离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络隔离)\n\t\t* [内外网分离](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#内外网分离)\n\t\t* [登录跳板机](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登录跳板机)\n\t* [授权、认证](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授权认证)\n\t\t* [RBAC](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac)\n\t\t* [OAuth2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20)\n\t\t* [双因素认证（2FA）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#双因素认证2fa)\n\t\t* [单点登录(SSO)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单点登录sso)\n* [常用开源框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用开源框架)\n\t* [开源协议](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源协议)\n\t* [日志框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志框架)\n\t\t* [Log4j、Log4j2](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2)\n\t\t* [Logback](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback)\n\t* [ORM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm)\n\t* [网络框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络框架)\n\t* [Web 框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架)\n\t\t* [Spring 家族](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族)\n\t* [工具框架](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架)\n* [分布式设计](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式设计)\n\t* [扩展性设计](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#扩展性设计)\n\t* [稳定性 &amp; 高可用](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#稳定性--高可用)\n\t\t* [硬件负载均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬件负载均衡)\n\t\t* [软件负载均衡](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#软件负载均衡)\n\t\t* [限流](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流)\n\t\t* [应用层容灾](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用层容灾)\n\t\t* [跨机房容灾](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨机房容灾)\n\t\t* [容灾演练流程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容灾演练流程)\n\t\t* [平滑启动](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑启动)\n\t* [数据库扩展](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库扩展)\n\t\t* [读写分离模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#读写分离模式)\n\t\t* [分片模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式)\n\t* [服务治理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务治理)\n\t\t* [服务注册与发现](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务注册与发现)\n\t\t* [服务路由控制](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务路由控制)\n\t* [分布式一致](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致)\n\t\t* [CAP 与 BASE 理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-与-base-理论)\n\t\t* [分布式锁](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式锁)\n\t\t* [分布式一致性算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致性算法)\n\t\t\t* [PAXOS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos)\n\t\t\t* [Zab](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab)\n\t\t\t* [Raft](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft)\n\t\t\t* [Gossip](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip)\n\t\t\t* [两阶段提交、多阶段提交](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#两阶段提交多阶段提交)\n\t\t* [幂等](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#幂等)\n\t\t* [分布式一致方案](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致方案)\n\t\t* [分布式 Leader 节点选举](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式-leader-节点选举)\n\t\t* [TCC(Try/Confirm/Cancel) 柔性事务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事务)\n\t* [分布式文件系统](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式文件系统)\n\t* [唯一ID 生成](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成)\n\t\t* [全局唯一ID](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全局唯一id)\n\t* [一致性Hash算法](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash算法)\n* [设计思想 &amp; 开发模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计思想--开发模式)\n\t* [DDD(Domain-driven Design - 领域驱动设计)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---领域驱动设计)\n\t\t* [命令查询职责分离(CQRS)](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查询职责分离cqrs)\n\t\t* [贫血，充血模型](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贫血充血模型)\n\t* [Actor 模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式)\n\t* [响应式编程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#响应式编程)\n\t\t* [Reactor](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#reactor)\n\t\t* [RxJava](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rxjava)\n\t\t* [Vert.x](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vertx)\n\t* [DODAF2.0](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20)\n\t* [Serverless](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless)\n\t* [Service Mesh](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#service-mesh)\n* [项目管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#项目管理)\n\t* [架构评审](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构评审)\n\t* [重构](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重构)\n\t* [代码规范](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码规范)\n\t* [代码 Review](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码-review)\n\t* [RUP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup)\n\t* [看板管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理)\n\t* [SCRUM](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum)\n\t* [敏捷开发](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷开发)\n\t* [极限编程（XP）](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#极限编程xp)\n\t* [结对编程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#结对编程)\n\t* [FMEA管理模式](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#fmea管理模式)\n* [通用业务术语](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用业务术语)\n* [技术趋势](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术趋势)\n* [政策、法规](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#政策法规)\n\t* [法律](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#法律)\n\t\t* [严格遵守刑法253法条](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#严格遵守刑法253法条)\n* [架构师素质](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构师素质)\n* [团队管理](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队管理)\n\t* [招聘](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘)\n* [资讯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#资讯)\n\t* [行业资讯](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业资讯)\n\t* [公众号列表](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公众号列表)\n\t* [博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#博客)\n\t\t* [团队博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队博客)\n\t\t* [个人博客](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#个人博客)\n\t* [综合门户、社区](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合门户社区)\n\t* [问答、讨论类社区](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#问答讨论类社区)\n\t* [行业数据分析](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业数据分析)\n\t* [专项网站](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#专项网站)\n\t* [其他类](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他类)\n\t* [推荐参考书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐参考书)\n\t\t* [在线电子书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线电子书)\n\t\t* [纸质书](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#纸质书)\n\t\t\t* [开发方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开发方面)\n\t\t\t* [架构方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构方面)\n\t\t\t* [技术管理方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术管理方面)\n\t\t\t* [基础理论](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论-1)\n\t\t\t* [工具方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面)\n\t\t\t* [大数据方面](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据方面)\n* [技术资源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术资源)\n\t* [开源资源](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源资源)\n\t* [手册、文档、教程](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手册文档教程)\n\t* [在线课堂](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线课堂)\n\t* [会议、活动](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#会议活动)\n\t* [常用APP](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app)\n\t* [找工作](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作)\n\t* [工具](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具)\n\t* [代码托管](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码托管)\n\t* [文件服务](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件服务)\n\t* [综合云服务商](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合云服务商)\n\t\t* [VPS](https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vps)\n\t\n\n**（Toc generated by [simple-php-github-toc](https://github.com/xingshaocheng/simple-php-github-toc) ）**\n\n# 数据结构\n\n## 队列\n* [《java队列——queue详细分析》](https://www.cnblogs.com/lemon-flm/p/7877898.html)\n\t* 非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。\n\t* 阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。\n\n* [《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》](https://www.cnblogs.com/mantu/p/5802393.html)\n\n## 集合\n* [《Java Set集合的详解》](https://blog.csdn.net/qq_33642117/article/details/52040345)\n\n## 链表、数组\n* [《Java集合详解--什么是List》](https://blog.csdn.net/wz249863091/article/details/52853360)\n\n## 字典、关联数组\n* [《Java map 详解 - 用法、遍历、排序、常用API等》](https://baike.xsoftlab.net/view/250.html)\n\n## 栈\n* [《java数据结构与算法之栈（Stack）设计与实现》](https://blog.csdn.net/javazejian/article/details/53362993)\n* [《Java Stack 类》](http://www.runoob.com/java/java-stack-class.html)\n* [《java stack的详细实现分析》](https://blog.csdn.net/f2006116/article/details/51375225)\n\t* Stack 是线程安全的。\n\t* 内部使用数组保存数据，不够时翻倍。\n\n## 树\n\n### 二叉树\n\n每个节点最多有两个叶子节点。\n*  [《二叉树》](https://blog.csdn.net/cai2016/article/details/52589952)\n\n### 完全二叉树\n* [《完全二叉树》](https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin)\n\t* 叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。\n\n### 平衡二叉树\n左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。\n* [《浅谈数据结构-平衡二叉树》](http://www.cnblogs.com/polly333/p/4798944.html)\n* [《浅谈算法和数据结构: 八 平衡查找树之2-3树》](http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html)\n\n### 二叉查找树（BST）\n二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。\n\n* [《浅谈算法和数据结构: 七 二叉查找树》](http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html)\n\n\n### 红黑树\n* [《最容易懂得红黑树》](https://blog.csdn.net/sun_tttt/article/details/65445754)\n\t* 添加阶段后，左旋或者右旋从而再次达到平衡。 \n* [《浅谈算法和数据结构: 九 平衡查找树之红黑树》](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)\n\n### B-，B+，B*树\nMySQL是基于B+树聚集索引组织表\n\n* [《B-树，B+树，B\\*树详解》](https://blog.csdn.net/aqzwss/article/details/53074186)\n* [《B-树，B+树与B\\*树的优缺点比较》](https://blog.csdn.net/bigtree_3721/article/details/73632405)\n\t* B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。\n### LSM 树\n\nLSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。\nHbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。\n\n* [《LSM树 VS B+树》](https://blog.csdn.net/dbanote/article/details/8897599)\n\t* B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。\n\t* LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。\n\t\n* [《LSM树（Log-Structured Merge Tree）存储引擎》](https://blog.csdn.net/u014774781/article/details/52105708)\n\t* 极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。\n\t* 优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。\n\t* Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。\n\n## BitSet\n\n经常用于大规模数据的排重检查。\n\n* [《Java Bitset类》](http://www.runoob.com/java/java-bitset-class.html)\n* [《Java BitSet（位集）》](https://blog.csdn.net/caiandyong/article/details/51581160)\n\n# 常用算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n## 排序、查找算法\n\n* [《常见排序算法及对应的时间复杂度和空间复杂度》](https://blog.csdn.net/gane_cheng/article/details/52652705)\n\n### 选择排序\n* [《Java中的经典算法之选择排序（SelectionSort）》](https://www.cnblogs.com/shen-hua/p/5424059.html)\n\t* 每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。\n\n### 冒泡排序\n* [《冒泡排序的2种写法》](https://blog.csdn.net/shuaizai88/article/details/73250615)\n\t* 相邻元素前后交换、把最大的排到最后。\n\t* 时间复杂度 O(n²) \n\n### 插入排序\n* [《排序算法总结之插入排序》](https://www.cnblogs.com/hapjin/p/5517667.html)\n\n### 快速排序\n* [《坐在马桶上看算法：快速排序》](http://developer.51cto.com/art/201403/430986.htm)\n\t* 一侧比另外一次都大或小。 \n### 归并排序\n* [《图解排序算法(四)之归并排序》](http://www.cnblogs.com/chengxiao/p/6194356.html)\n\t* 分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 \n\n### 希尔排序\nTODO\n\n### 堆排序\n* [《图解排序算法(三)之堆排序》](https://www.cnblogs.com/chengxiao/p/6129630.html)\n\t* 排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。\n\n### 计数排序\n* [《计数排序和桶排序》](https://www.cnblogs.com/suvllian/p/5495780.html)\n\t* 和桶排序过程比较像，差别在于桶的数量。\n\n### 桶排序\n* [《【啊哈！算法】最快最简单的排序——桶排序》](http://blog.51cto.com/ahalei/1362789)\n* [《排序算法（三）：计数排序与桶排序》](https://blog.csdn.net/sunjinshengli/article/details/70738527)\n\t* 桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。\n\t* 每个桶单独进行排序，然后再遍历每个桶。\n\n### 基数排序\n\n按照个位、十位、百位、...依次来排。\n\n* [《排序算法系列：基数排序》](https://blog.csdn.net/lemon_tree12138/article/details/51695211)\n* [《基数排序》](https://www.cnblogs.com/skywang12345/p/3603669.html)\n\n\n### 二分查找\n* [《二分查找(java实现)》](https://www.cnblogs.com/coderising/p/5708632.html)\n\t* 要求待查找的序列有序。\n\t* 时间复杂度 O(logN)。\n\n* [《java实现二分查找-两种方式》](https://blog.csdn.net/maoyuanming0806/article/details/78176957)\n\t* while + 递归。\n### Java 中的排序工具\n* [《Arrays.sort和Collections.sort实现原理解析》](https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&fps=1)\n\t* Collections.sort算法调用的是合并排序。\n\t* Arrays.sort() 采用了2种排序算法 -- 基本类型数据使用快速排序法，对象数组使用归并排序。\n\n## 布隆过滤器\n\n常用于大数据的排重，比如email，url 等。\n核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。\n优点：空间和时间效率都很高。\n缺点：随着存入的元素数量增加，误算率随之增加。\n\n* [《布隆过滤器 -- 空间效率很高的数据结构》](https://segmentfault.com/a/1190000002729689)\n* [《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》](https://blog.csdn.net/zdxiq000/article/details/57626464)\n* [《基于Redis的布隆过滤器的实现》](https://blog.csdn.net/qq_30242609/article/details/71024458)\n\t* 基于 Redis 的 Bitmap 数据结构。\n* [《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》](https://blog.csdn.net/lemon_tree12138/article/details/47973715)\n\t* 使用Java中的 BitSet 类 和 加权和hash算法。\n\n## 字符串比较\n\n### KMP 算法\nKMP：Knuth-Morris-Pratt算法（简称KMP）\n核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。\n* [《字符串匹配的KMP算法》](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html)\n\n## 深度优先、广度优先\n* [《广度优先搜索BFS和深度优先搜索DFS》](https://www.cnblogs.com/0kk470/p/7555033.html)\n\n## 贪心算法\n* [《算法：贪婪算法基础》](https://www.cnblogs.com/MrSaver/p/8641971.html)\n* [《常见算法及问题场景——贪心算法》](https://blog.csdn.net/a345017062/article/details/52443781)\n\n## 回溯算法\n* [《 五大常用算法之四：回溯法》](https://blog.csdn.net/qfikh/article/details/51960331)\n\n## 剪枝算法\n* [《α-β剪枝算法》](https://blog.csdn.net/luningcsdn/article/details/50930276)\n\n## 动态规划\n* [《详解动态规划——邹博讲动态规划》](https://www.cnblogs.com/little-YTMM/p/5372680.html)\n* [《动态规划算法的个人理解》](https://blog.csdn.net/yao_zi_jie/article/details/54580283)\n\n## 朴素贝叶斯\n\n* [《带你搞懂朴素贝叶斯分类算法》](https://blog.csdn.net/amds123/article/details/70173402)\n\t* P(B|A)=P(A|B)P(B)/P(A)\n\n* [《贝叶斯推断及其互联网应用1》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html)\n* [《贝叶斯推断及其互联网应用2》](http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html)\n\n\n## 推荐算法\n* [《推荐算法综述》](http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01)\n* [《TOP 10 开源的推荐系统简介》](https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems)\n\n## 最小生成树算法\n* [《算法导论--最小生成树（Kruskal和Prim算法）》](https://blog.csdn.net/luoshixian099/article/details/51908175)\n\n## 最短路径算法\n\n* [《Dijkstra算法详解》](https://blog.csdn.net/qq_35644234/article/details/60870719)\n\n# 并发\n\n## Java 并发\n\n* [Java 并发知识合集](https://github.com/CL0610/Java-concurrency)\n* [JAVA并发知识图谱](https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png)\n\n## 多线程\n\n* [《40个Java多线程问题总结》](http://www.importnew.com/18459.html)\n\n## 线程安全\n\n* [《Java并发编程——线程安全及解决机制简介》](https://www.cnblogs.com/zhanht/p/5450325.html)\n\n## 一致性、事务\n\n### 事务 ACID 特性\n* [《数据库事务ACID特性》](https://blog.csdn.net/u012440687/article/details/52116108)\n\n### 事务的隔离级别\n\n* 未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。\n* 读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。\n* 可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。\n* 序列化：所有事物串行处理（牺牲了效率）\n\n* [《理解事务的4种隔离级别》](https://blog.csdn.net/qq_33290787/article/details/51924963)\n* [数据库事务的四大特性及事务隔离级别](https://www.cnblogs.com/z-sm/p/7245981.html)\n\n* [《MySQL的InnoDB的幻读问题 》](http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html)\n\t* 幻读的例子非常清楚。\n\t* 通过 SELECT ... FOR UPDATE 解决。\n\t\n* [《一篇文章带你读懂MySQL和InnoDB》](http://database.51cto.com/art/201804/570101.htm)\n\t* 图解脏读、不可重复读、幻读问题。\n\n\n### MVCC\n\n\n* [《【mysql】关于innodb中MVCC的一些理解》](https://www.cnblogs.com/chenpingzhao/p/5065316.html)\n\t* innodb 中 MVCC 用在 Repeatable-Read 隔离级别。\n\t* MVCC 会产生幻读问题（更新时异常。）\n\n* [《轻松理解MYSQL MVCC 实现机制》](https://blog.csdn.net/whoamiyang/article/details/51901888)\n\n\t* 通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间\n\t* 每次只操作比当前版本小（或等于）的 行。\n\t\n\n\n## 锁\n\n### Java中的锁和同步类\n\n* [《Java中的锁分类》](https://www.cnblogs.com/qifengshi/p/6831055.html)\n\t* 主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 \n\n* [《Java并发之AQS详解》](https://www.cnblogs.com/waterystone/p/4920797.html)\n\n* [《Java中信号量 Semaphore》](http://cuisuqiang.iteye.com/blog/2020146)\n\t* 有数量控制\n\t* 申请用 acquire，申请不要则阻塞；释放用 release。\n\n* [《java开发中的Mutex vs Semaphore》](https://www.cnblogs.com/davidwang456/p/6094947.html)\n\t* 简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。\t \n\n### 公平锁 & 非公平锁\n\n公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。\n\n* [《公平锁与非公平锁》](https://blog.csdn.net/EthanWhite/article/details/55508357)\n\t* 默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。\n\n### 悲观锁 \n\n悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。\n\n* [《【MySQL】悲观锁&乐观锁》](https://www.cnblogs.com/zhiqian-ali/p/6200874.html)\n\t* 乐观锁的方式：版本号+重试方式\n\t* 悲观锁：通过 select ... for update 进行行锁(不可读、不可写，share 锁可读不可写)。\n\n* [《Mysql查询语句使用select.. for update导致的数据库死锁分析》](https://www.cnblogs.com/Lawson/p/5008741.html)\n\t* mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。\n\t* 锁相同数据的不同索引条件可能会引起死锁。\n\t\n* [《Mysql并发时经典常见的死锁原因及解决方法》](https://www.cnblogs.com/zejin2008/p/5262751.html)\n\n### 乐观锁 & CAS\n\n* [《乐观锁的一种实现方式——CAS》](http://www.importnew.com/20472.html)\n\t* 和MySQL乐观锁方式相似，只不过是通过和原值进行比较。\t \n\n### ABA 问题\n\n由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。\n\n* [《Java CAS 和ABA问题》](https://www.cnblogs.com/549294286/p/3766717.html)\n* [《Java 中 ABA问题及避免》](https://blog.csdn.net/li954644351/article/details/50511879)\n\t* AtomicStampedReference 和 AtomicStampedReference。 \n\n### CopyOnWrite容器\n\n可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。\n\n* [《JAVA中写时复制(Copy-On-Write)Map实现》](https://www.cnblogs.com/hapjin/p/4840107.html)\n\t* 实现读写分离，读取发生在原始数据上，写入发生在副本上。  \n\t* 不用加锁，通过最终一致实现一致性。\n\t\n* [《聊聊并发-Java中的Copy-On-Write容器》](https://blog.csdn.net/a494303877/article/details/53404623)\n\n### RingBuffer \n* [《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》](http://www.cnblogs.com/l00l/p/4115001.html)\n\n### 可重入锁 & 不可重入锁\n\n* [《可重入锁和不可重入锁》](https://www.cnblogs.com/dj3839/p/6580765.html)\n\t* 通过简单代码举例说明可重入锁和不可重入锁。\n\t* 可重入锁指同一个线程可以再次获得之前已经获得的锁。\n\t* 可重入锁可以用户避免死锁。\n\t* Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock\n\n* [《ReenTrantLock可重入锁（和synchronized的区别）总结》](https://www.cnblogs.com/baizhanshi/p/7211802.html)\n\t* synchronized 使用方便，编译器来加锁，是非公平锁。\n\t* ReenTrantLock 使用灵活，锁的公平性可以定制。\n\t* 相同加锁场景下，推荐使用 synchronized。\n\n### 互斥锁 & 共享锁\n\n互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。\n共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。\n\n* [《ReadWriteLock场景应用》](https://www.cnblogs.com/liang1101/p/6475555.html)\n\n### 死锁\n* [《“死锁”四个必要条件的合理解释》](https://blog.csdn.net/yunfenglw/article/details/45950305)\n\t* 互斥、持有、不可剥夺、环形等待。\n* [Java如何查看死锁？](https://blog.csdn.net/u014039577/article/details/52351626)\n\t* JConsole 可以识别死锁。\n\t\n* [java多线程系列：死锁及检测](https://blog.csdn.net/bohu83/article/details/51135061)\n\t* jstack 可以显示死锁。\n\t\n# 操作系统\n\n## 计算机原理\n\n* [《操作系统基础知识——操作系统的原理，类型和结构》](https://segmentfault.com/a/1190000003692840)\n\n## CPU\n\n### 多级缓存\n典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。\n\n* [《从Java视角理解CPU缓存和伪共享》](https://blog.csdn.net/zero__007/article/details/54089730)\n\n## 进程\n\nTODO\n\n## 线程\n\n* [《线程的生命周期及状态转换详解》](https://blog.csdn.net/asdf_1024/article/details/78978437)\n\n## 协程\n\n* [《终结python协程----从yield到actor模型的实现》](https://www.thinksaas.cn/group/topic/839375/)\n\t* 线程的调度是由操作系统负责，协程调度是程序自行负责\n\t* 与线程相比，协程减少了无谓的操作系统切换.\n\t* 实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.\n\t\n## Linux\n\n* [《Linux 命令大全》](http://www.runoob.com/linux/linux-command-manual.html)\n\n# 设计模式\n\n## 设计模式的六大原则\n* [《设计模式的六大原则》](https://blog.csdn.net/q291611265/article/details/48465113)\n\t* 开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。\n\t* 里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。\n\t* 依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。\n\t* 接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。\n\t* 迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。\n\t* 合成复用原则：尽量使用合成/聚合,而不是使用继承。\n\n## 23种常见设计模式\n* [《设计模式》](http://www.runoob.com/design-pattern/design-pattern-tutorial.html)\n* [《23种设计模式全解析》](https://www.cnblogs.com/susanws/p/5510229.html)\n\n## 应用场景\n* [《细数JDK里的设计模式》](http://blog.jobbole.com/62314/)\n\t* 结构型模式：\n\t\t* 适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。\n\t\t* 桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；\n\t\t* 组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。\n\t\t* 装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。\n\t\t* 享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。\n\t\t* 代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy\n\t\t\n\t* 创建模式:\n\t\t* 抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。\n\t\t* 建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。\n\t\t* 工厂方法：就是 **一个返*** 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。\n\t\t* 原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。\n\t\t* 单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。\n\t* 行为模式：\n\t\t* 责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。\n\t\t* 命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。\n\t\t* 解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。\n\t\t* 迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。\n\t\t* 中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。\n\t\t* 空对象模式：如 java.util.Collections#emptyList()。\n\t\t* 观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。\n\t\t* 模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。\n\n* [《Spring-涉及到的设计模式汇总》](https://www.cnblogs.com/hwaggLee/p/4510687.html)\n* [《Mybatis使用的设计模式》](https://blog.csdn.net/u012387062/article/details/54719114)\n\n## 单例模式\n* [《单例模式的三种实现 以及各自的优缺点》](https://blog.csdn.net/YECrazy/article/details/79481964)\n* [《单例模式－－反射－－防止序列化破坏单例模式》](https://www.cnblogs.com/ttylinux/p/6498822.html)\n\t* 使用枚举类型。\n\n## 责任链模式\nTODO\n\n## MVC\n* [《MVC 模式》](http://www.runoob.com/design-pattern/mvc-pattern.html)\n\t* 模型(model)－视图(view)－控制器(controller) \n\n## IOC\n* [《理解 IOC》](https://www.zhihu.com/question/23277575)\n* [《IOC 的理解与解释》](https://www.cnblogs.com/NancyStartOnce/p/6813162.html)\n\t* 正向控制：传统通过new的方式。反向控制，通过容器注入对象。\n\t* 作用：用于模块解耦。\n\t* DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。\n\n## AOP\n\n* [《轻松理解AOP(面向切面编程)》](https://my.oschina.net/yanquan345/blog/203415)\n* [《Spring AOP详解》](https://www.cnblogs.com/hongwz/p/5764917.html)\n* [《Spring AOP的实现原理》](http://www.importnew.com/24305.html)\n\t* Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。\n* [《Spring AOP 实现原理与 CGLIB 应用》](https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/)\n\t* Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 \n\n\n## UML\n\n* [《UML教程》](https://www.w3cschool.cn/uml_tutorial/)\n\n## 微服务思想\n* [《微服务架构设计》](https://www.cnblogs.com/wintersun/p/6219259.html)\n* [《微服务架构技术栈选型手册》](http://www.infoq.com/cn/articles/micro-service-technology-stack)\n\n### 康威定律\n* [《微服务架构的理论基础 - 康威定律》](https://yq.aliyun.com/articles/8611)\n\t* 定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。\n\t* 定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。\n\t* 定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。\n\t* 定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。\n\n* [《微服务架构核⼼20讲》](https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf)\n\n# 运维 & 统计 & 技术支持 \n\n## 常规监控\n\n* [《腾讯业务系统监控的修炼之路》](https://blog.csdn.net/enweitech/article/details/77849205)\n\t* 监控的方式：主动、被动、旁路(比如舆情监控)\n\t* 监控类型： 基础监控、服务端监控、客户端监控、\n\t监控、用户端监控\n\t* 监控的目标：全、块、准\n\t* 核心指标：请求量、成功率、耗时\n\n* [《开源还是商用？十大云运维监控工具横评》](https://www.oschina.net/news/67525/monitoring-tools)\n\t* Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。\n\n* [《监控报警系统搭建及二次开发经验》](http://developer.51cto.com/art/201612/525373.htm)\n\n**命令行监控工具**\n\n* [《常用命令行监控工具》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html)\n\t* top、sar、tsar、nload\n\n* [《20个命令行工具监控 Linux 系统性能》](http://blog.jobbole.com/96846/)\n\n* [《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》](https://my.oschina.net/feichexia/blog/196575)\n\n## APM\n\nAPM —  Application Performance Management\n\n* [《Dapper，大规模分布式系统的跟踪系统》](http://bigbully.github.io/Dapper-translation/)\n\n* [CNCF OpenTracing](http://opentracing.io)，[中文版](https://github.com/opentracing-contrib/opentracing-specification-zh)\n\n* 主要开源软件，按字母排序\n  * [Apache SkyWalking](https://github.com/apache/incubator-skywalking)\n  * [CAT](https://github.com/dianping/cat)\n  * [CNCF jaeger](https://github.com/jaegertracing/jaeger)\n  * [Pinpoint](https://github.com/naver/pinpoint)\n  * [Zipkin](https://github.com/openzipkin/zipkin)\n\n* [《开源APM技术选型与实战》](http://www.infoq.com/cn/articles/apm-Pinpoint-practice)\n\t* 主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。\n\t\n\n\n## 统计分析\n\n* [《流量统计的基础：埋点》](https://zhuanlan.zhihu.com/p/25195217)\n\t* 常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度\n\n* [《APP埋点常用的统计工具、埋点目标和埋点内容》](http://www.25xt.com/company/17066.html)\n\t* 第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。\n\n* [《美团点评前端无痕埋点实践》](https://tech.meituan.com/mt-mobile-analytics-practice.html)\n\t* 所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 \n\n\n## 持续集成(CI/CD)\n\n* [《持续集成是什么？》](http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html)\n* [《8个流行的持续集成工具》](https://www.testwo.com/article/1170)\n\n### Jenkins\n\n* [《使用Jenkins进行持续集成》](https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000)\n\n### 环境分离\n\n开发、测试、生成环境分离。\n\n* [《开发环境、生产环境、测试环境的基本理解和区》](https://my.oschina.net/sancuo/blog/214904)\n\n## 自动化运维\n\n### Ansible\n* [《Ansible中文权威指南》](http://www.ansible.com.cn/)\n* [《Ansible基础配置和企业级项目实用案例》](https://www.cnblogs.com/heiye123/articles/7855890.html)\n\n### puppet\n* [《自动化运维工具——puppet详解》](https://www.cnblogs.com/keerya/p/8040071.html)\n\n### chef\n* [《Chef 的安装与使用》](https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/)\n\n## 测试\n\n### TDD 理论\n\n* [《深度解读 - TDD（测试驱动开发）》](https://www.jianshu.com/p/62f16cd4fef3)\n\t* 基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.\n\t* 好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； \n\n### 单元测试\n\n* [《Java单元测试之JUnit篇》](https://www.cnblogs.com/happyzm/p/6482886.html)\n* [《JUnit 4 与 TestNG 对比》](https://blog.csdn.net/hotdust/article/details/53406086)\n\t* TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 \n* [《单元测试主要的测试功能点》](https://blog.csdn.net/wqetfg/article/details/50900512)\n\t* 模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 \n\n### 压力测试\n\n* [《Apache ab 测试使用指南》](https://blog.csdn.net/blueheart20/article/details/52170790)\n* [《大型网站压力测试及优化方案》](https://www.cnblogs.com/binyue/p/6141088.html)\n* [《10大主流压力/负载/性能测试工具推荐》](http://news.chinabyte.com/466/14126966.shtml)\n* [《真实流量压测工具 tcpcopy应用浅析》](http://quentinxxz.iteye.com/blog/2249799)\n* [《nGrinder 简易使用教程》](https://www.cnblogs.com/jwentest/p/7136727.html)\n\n\n### 全链路压测\n* [《京东618：升级全链路压测方案，打造军演机器人ForceBot》](http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot)\n* [《饿了么全链路压测的探索与实践》](https://zhuanlan.zhihu.com/p/30306892)\n* [《四大语言，八大框架｜滴滴全链路压测解决之道》](https://zhuanlan.zhihu.com/p/28355759)\n* [《全链路压测经验》](https://www.jianshu.com/p/27060fd61f72)\n\n\n### A/B 、灰度、蓝绿测试\n\n* [《技术干货 | AB 测试和灰度发布探索及实践》](https://testerhome.com/topics/11165)\n* [《nginx 根据IP 进行灰度发布》](http://blog.51cto.com/purplegrape/1403123)\n\n* [《蓝绿部署、A/B 测试以及灰度发布》](https://www.v2ex.com/t/344341)\n\n## 虚拟化\n\n* [《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》](https://blog.csdn.net/enweitech/article/details/52910082)\n\n### KVM\n* [《KVM详解，太详细太深入了，经典》](http://blog.chinaunix.net/uid-20201831-id-5775661.html)\n* [《【图文】KVM 虚拟机安装详解》](https://www.coderxing.com/kvm-install.html)\n\n### Xen\n* [《Xen虚拟化基本原理详解》](https://www.cnblogs.com/sddai/p/5931201.html)\n\n### OpenVZ\n* [《开源Linux容器 OpenVZ 快速上手指南》](https://blog.csdn.net/longerzone/article/details/44829255)\n\n## 容器技术\n\n### Docker\n* [《几张图帮你理解 docker 基本原理及快速入门》](https://www.cnblogs.com/SzeCheng/p/6822905.html)\n* [《Docker 核心技术与实现原理》](https://draveness.me/docker)\n* [《Docker 教程》](http://www.runoob.com/docker/docker-tutorial.html)\n\n## 云技术\n\n### OpenStack\n* [《OpenStack构架知识梳理》](https://www.cnblogs.com/klb561/p/8660264.html)\n\n## DevOps\n* [《一分钟告诉你究竟DevOps是什么鬼？》](https://www.cnblogs.com/jetzhang/p/6068773.html)\n* [《DevOps详解》](http://www.infoq.com/cn/articles/detail-analysis-of-devops)\n\n## 文档管理\n\n* [Confluence-收费文档管理系统](http://www.confluence.cn/)\n* GitLab?\n* Wiki\n\n# 中间件\n\n## Web Server\n\n### Nginx\n* [《Ngnix的基本学习-多进程和Apache的比较》](https://blog.csdn.net/qq_25797077/article/details/52200722)\n\t* Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。\n\t* 事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  \n\n* [《nginx与Apache的对比以及优缺点》](https://www.cnblogs.com/cunkouzh/p/5410154.html)\n\t* nginx只适合静态和反向代理，不适合处理动态请求。\n\n### OpenResty\n* [官方网站](http://openresty.org/cn/)\n* [《浅谈 OpenResty》](http://www.linkedkeeper.com/detail/blog.action?bid=1034)\n\t* 通过 Lua 模块可以在Nginx上进行开发。 \n\n### Apache Httpd\n* [官方网站](http://httpd.apache.org/)\n\n### Tomcat\n\n#### 架构原理\n* [《TOMCAT原理详解及请求过程》](https://www.cnblogs.com/hggen/p/6264475.html)\n* [《Tomcat服务器原理详解》](https://www.cnblogs.com/crazylqy/p/4706223.html)\n* [《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》](https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/)\n\n* [《四张图带你了解Tomcat系统架构》](https://blog.csdn.net/xlgen157387/article/details/79006434)\n\n* [《JBoss vs. Tomcat: Choosing A Java Application Server》](https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/)\n\t* Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。\n\t* Jboss 实现全部了JEE特性，软件开源免费、文档收费。\n\n#### 调优方案\n\n* [《Tomcat 调优方案》](https://www.cnblogs.com/sunfenqing/p/7339058.html)\n\t* 启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； \n\n* [《tomcat http协议与ajp协议》](http://blog.chinaunix.net/uid-20662363-id-3012760.html)\n* [《AJP与HTTP比较和分析》](http://dmouse.iteye.com/blog/1354527)\n\t* AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。\n\t* 并发高时，AJP协议优于HTTP协议。\n\n### Jetty\n* [《Jetty 的工作原理以及与 Tomcat 的比较》](https://www.ibm.com/developerworks/cn/java/j-lo-jetty/)\n* [《jetty和tomcat优势比较》](https://blog.csdn.net/doutao6677/article/details/51957288)\n\t* 架构比较:Jetty的架构比Tomcat的更为简单。\n\t* 性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。\n\t* 其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 \n\n\n\n## 缓存\n\n* [《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》](https://blog.csdn.net/clementad/article/details/48229243)\n\n### 本地缓存\n\n* [《HashMap本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html)\n\n* [《EhCache本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html)\n\t* 堆内、堆外、磁盘三级缓存。\n\t* 可按照缓存空间容量进行设置。\n\t* 按照时间、次数等过期策略。\n\n* [《Guava Cache》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html)\n\t* 简单轻量、无堆外、磁盘缓存。\n\n\n* [《Nginx本地缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html)\n\n* [《Pagespeed—懒人工具，服务器端加速》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html)\n\n## 客户端缓存\n\n* [《浏览器端缓存》](https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html)\n\t* 主要是利用 Cache-Control 参数。\n\n* [《H5 和移动端 WebView 缓存机制解析与实战》](https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w)\n\n## 服务端缓存\n\n### Web缓存\n\n* [nuster](https://github.com/jiangwenyuan/nuster) - nuster cache\n* [varnish](https://github.com/varnishcache/varnish-cache) - varnish cache\n* [squid](https://github.com/squid-cache/squid) - squid cache\n\n### Memcached\n* [《Memcached 教程》](http://www.runoob.com/Memcached/Memcached-tutorial.html)\n* [《深入理解Memcached原理》](https://blog.csdn.net/chenleixing/article/details/47035453)\n\t* 采用多路复用技术提高并发性。\n\t* slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。\n* [《Memcached软件工作原理》](https://www.jianshu.com/p/36e5cd400580)\n* [《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》](http://zhihuzeye.com/archives/2361)\n\n* [《memcache 中 add 、 set 、replace 的区别》](https://blog.csdn.net/liu251890347/article/details/37690045)\n\t* 区别在于当key存在还是不存在时，返回值是true和false的。\n\n* [**《memcached全面剖析》**](https://pan.baidu.com/s/1qX00Lti?errno=0&errmsg=Auth%20Login%20Sucess&&bduss=&ssnerror=0&traceid=)\n\n### Redis\n\n* [《Redis 教程》](http://www.runoob.com/redis/redis-tutorial.html)\n* [《redis底层原理》](https://blog.csdn.net/wcf373722432/article/details/78678504)\n\t* 使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。\n\t* 使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。\n* [《Redis持久化方式》](http://doc.redisfans.com/topic/persistence.html)\n\t* RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。\n\t* AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。\n\t* 也可以两者结合使用。\n\n* [《分布式缓存--序列3--原子操作与CAS乐观锁》](https://blog.csdn.net/chunlongyu/article/details/53346436)\n\n#### 架构\n* [《Redis单线程架构》](https://blog.csdn.net/sunhuiliang85/article/details/73656830)\n\n#### 回收策略\n* [《redis的回收策略》](https://blog.csdn.net/qq_29108585/article/details/63251491)\n\n### Tair\n\n* [官方网站](https://github.com/alibaba/tair)\n* [《Tair和Redis的对比》](http://blog.csdn.net/farphone/article/details/53522383)\n* 特点：可以配置备份节点数目，通过异步同步到备份节点\n* 一致性Hash算法。\n* 架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。\n\n\n几种存储引擎:\n* MDB，完全内存性，可以用来存储Session等数据。\n* Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作\n* LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。\n* Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。\n\n## 消息队列\n\n* [《消息队列-推/拉模式学习 & ActiveMQ及JMS学习》](https://www.cnblogs.com/charlesblc/p/6045238.html)\n\t* RabbitMQ 消费者默认是推模式（也支持拉模式）。\n\t* Kafka 默认是拉模式。\n\t* Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。\n\t* Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。\n\n* [《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》](https://blog.csdn.net/yunfeng482/article/details/72856762)\n\n### 消息总线\n\n消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。\n\n* [《消息总线VS消息队列》](https://blog.csdn.net/yanghua_kobe/article/details/43877281)\n\n### 消息的顺序\n* [《如何保证消费者接收消息的顺序》](https://www.cnblogs.com/cjsblog/p/8267892.html)\n\n### RabbitMQ\n\n支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。\n\n* [《RabbitMQ的应用场景以及基本原理介绍》](https://blog.csdn.net/whoamiyang/article/details/54954780)\n* [《消息队列之 RabbitMQ》](https://www.jianshu.com/p/79ca08116d57) \n* [《RabbitMQ之消息确认机制（事务+Confirm）》](https://blog.csdn.net/u013256816/article/details/55515234)\n\n### RocketMQ\nJava实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。\n* [《RocketMQ 实战之快速入门》](https://www.jianshu.com/p/824066d70da8)\n* [《RocketMQ 源码解析》](http://www.iocoder.cn/categories/RocketMQ/?vip&architect-awesome)\n\n### ActiveMQ\n纯Java实现，兼容JMS，可以内嵌于Java应用中。\n* [《ActiveMQ消息队列介绍》](https://www.cnblogs.com/wintersun/p/3962302.html)\n\n### Kafka\n高吞吐量、采用拉模式。适合高IO场景，比如日志同步。\n\n* [官方网站](http://kafka.apache.org/)\n* [《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》](https://blog.csdn.net/allthesametome/article/details/47362451)\n* [《Kafka分区机制介绍与示例》](http://lxw1234.com/archives/2015/10/538.htm)\n\n### Redis 消息推送\n\n生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。\n\n* [《Redis学习笔记之十：Redis用作消息队列》](https://blog.csdn.net/qq_34212276/article/details/78455004)\n\n### ZeroMQ\n TODO\n\n\n## 定时调度\n\n### 单机定时调度\n\n* [《linux定时任务cron配置》](https://www.cnblogs.com/shuaiqing/p/7742382.html)\n\n* [《Linux cron运行原理》](https://my.oschina.net/daquan/blog/483305)\n\t* fork 进程 + sleep 轮询\n\n* [《Quartz使用总结》](https://www.cnblogs.com/drift-ice/p/3817269.html)\n* [《Quartz源码解析 ---- 触发器按时启动原理》](https://blog.csdn.net/wenniuwuren/article/details/42082981/)\n* [《quartz原理揭秘和源码解读》](https://www.jianshu.com/p/bab8e4e32952)\n\t* 定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。\n\n\n### 分布式定时调度\n\n* [《这些优秀的国产分布式任务调度系统，你用过几个？》](https://blog.csdn.net/qq_16216221/article/details/70314337)\n\t* opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares\n\n* [《Quartz任务调度的基本实现原理》](https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html)\n\t* Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 \n* [《Elastic-Job-Lite 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&architect-awesome)\n* [《Elastic-Job-Cloud 源码解析》](http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&architect-awesome)\n\n\n## RPC\n\n* [《从零开始实现RPC框架 - RPC原理及实现》](https://blog.csdn.net/top_code/article/details/54615853)\n\t* 核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。\n\n* [《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》](https://blog.csdn.net/testcs_dn/article/details/78050590)\n\n### Dubbo\n* [官方网站](http://dubbo.apache.org/)\n* [dubbo实现原理简单介绍](https://www.cnblogs.com/steven520213/p/7606598.html)\n\n** SPI **\nTODO\n\n### Thrift\n* [官方网站](http://thrift.apache.org/)\n* [《Thrift RPC详解》](https://blog.csdn.net/kesonyk/article/details/50924489)\n\t* 支持多语言，通过中间语言定义接口。\n\n### gRPC\n\n服务端可以认证加密，在外网环境下，可以保证数据安全。\n\n* [官方网站](https://grpc.io/)\n* [《你应该知道的RPC原理》](https://www.cnblogs.com/LBSer/p/4853234.html)\n\n\n## 数据库中间件\n\n### Sharding Jdbc\n\n* [官网](http://shardingjdbc.io/)\n\n## 日志系统\n\n### 日志搜集\n\n* [《从零开始搭建一个ELKB日志收集系统》](http://cjting.me/misc/build-log-system-with-elkb/)\n* [《用ELK搭建简单的日志收集分析系统》](https://blog.csdn.net/lzw_2006/article/details/51280058)\n* [《日志收集系统-探究》](https://www.cnblogs.com/beginmind/p/6058194.html)\n\n## 配置中心\n\n* [Apollo - 携程开源的配置中心应用](https://github.com/ctripcorp/apollo)\n\t* Spring Boot 和 Spring Cloud\n\t* 支持推、拉模式更新配置\n\t* 支持多种语言 \n\n* [《基于zookeeper实现统一配置管理》](https://blog.csdn.net/u011320740/article/details/78742625)\n\n* [《 Spring Cloud Config 分布式配置中心使用教程》](https://www.cnblogs.com/shamo89/p/8016908.html)\n\nservlet 3.0 异步特性可用于配置中心的客户端\n* [《servlet3.0 新特性——异步处理》](https://www.cnblogs.com/dogdogwang/p/7151866.html)\n\n## API 网关\n\n主要职责：请求转发、安全认证、协议转换、容灾。\n\n* [《API网关那些儿》](http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/)\n* [《谈API网关的背景、架构以及落地方案》](http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo)\n\n* [《使用Zuul构建API Gateway》](https://blog.csdn.net/zhanglh046/article/details/78651993)\n* [《Spring Cloud Gateway 源码解析》](http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&architect-awesome)\n* [《HTTP API网关选择之一Kong介绍》](https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A)\n\n# 网络\n\n\n## 协议\n\n### OSI 七层协议\n\n* [《OSI七层协议模型、TCP/IP四层模型学习笔记》](https://www.cnblogs.com/Robin-YB/p/6668762.html)\n\n### TCP/IP\n* [《深入浅出 TCP/IP 协议》](https://www.cnblogs.com/onepixel/p/7092302.html)\n* [《TCP协议中的三次握手和四次挥手》](https://blog.csdn.net/whuslei/article/details/6667471/)\n\n### HTTP\n* [《http协议详解(超详细)》](https://www.cnblogs.com/wangning528/p/6388464.html)\n\n### HTTP2.0\n* [《HTTP 2.0 原理详细分析》](https://blog.csdn.net/zhuyiquan/article/details/69257126)\n* [《HTTP2.0的基本单位为二进制帧》](https://blog.csdn.net/u012657197/article/details/77877840)\n\t* 利用二进制帧负责传输。\n\t* 多路复用。\n\n### HTTPS\n* [《https原理通俗了解》](https://www.cnblogs.com/zhangshitong/p/6478721.html)\n\t* 使用非对称加密协商加密算法\n\t* 使用对称加密方式传输数据\n\t* 使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。\n\n* [《八大免费SSL证书-给你的网站免费添加Https安全加密》](https://blog.csdn.net/enweitech/article/details/53213862)\n\n## 网络模型\n\n* [《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》](http://blog.51cto.com/litaotao/1289790)\n\t* 五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。\n\t* 三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。\n\n* [《select、poll、epoll之间的区别总结》](http://www.cnblogs.com/Anker/p/3265058.html)\n\t* select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。\n\t* select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。\n\t* select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。\n\t* poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。\n\t\n* [《select，poll，epoll比较  》](http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/)\n\t* 在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。\n\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n\t* NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务\n\n* [《BIO与NIO、AIO的区别》](https://blog.csdn.net/skiof007/article/details/52873421)\n\n* [《两种高效的服务器设计模型：Reactor和Proactor模型》](https://blog.csdn.net/u013074465/article/details/46276967)\n\n### Epoll\n\n* [《epoll使用详解（精髓）》](https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html)\n\n### Java NIO\n* [《深入理解Java NIO》](https://www.cnblogs.com/geason/p/5774096.html)\n* [《Java NIO编写Socket服务器的一个例子》](https://blog.csdn.net/xidianliuy/article/details/51612676)\n\n### kqueue\n* [《kqueue用法简介》](http://www.cnblogs.com/luminocean/p/5631336.html)\n\n## 连接和短连接\n\n* [《TCP/IP系列——长连接与短连接的区别》](https://www.cnblogs.com/pangguoping/p/5571422.html)\n\n## 框架\n\n* [《Netty原理剖析》](https://blog.csdn.net/excellentyuxiao/article/details/53390408)\n\t* Reactor 模式介绍。\n\t* Netty 是 Reactor 模式的一种实现。\n\n## 零拷贝（Zero-copy）\n* [《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》](https://www.cnblogs.com/xys1228/p/6088805.html)\n\t* 多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。\n\n## 序列化(二进制协议)\n\n### Hessian\n* [《Hessian原理分析》](https://www.cnblogs.com/happyday56/p/4268249.html)\nBinary-RPC;不仅仅是序列化\n\n### Protobuf\n* [《Protobuf协议的Java应用例子》](https://blog.csdn.net/antgan/article/details/52103966)\nGoolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。\n* [《Protocol Buffers序列化协议及应用》](https://worktile.com/tech/share/prototol-buffers)\n  \t* 关于协议的解释；缺点：可读性差;\n\n* [《简单的使用 protobuf 和 protostuff》](https://blog.csdn.net/eric520zenobia/article/details/53766571)\n\t* protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。\n\n# 数据库\n## 基础理论\n### 数据库设计的三大范式\n* [《数据库的三大范式以及五大约束》](https://www.cnblogs.com/waj6511988/p/7027127.html)\n\t* 第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；\n\t* 第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；\n\t* 第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；\n\n## MySQL\n\n### 原理\n* [《MySQL的InnoDB索引原理详解》](http://www.admin10000.com/document/5372.html)\n\n* [《MySQL存储引擎－－MyISAM与InnoDB区别》](https://blog.csdn.net/xifeijian/article/details/20316775)\n\t* 两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁\n\n* [《myisam和innodb索引实现的不同》](https://www.2cto.com/database/201211/172380.html)\n\n### InnoDB\n\n* [《一篇文章带你读懂Mysql和InnoDB》](https://my.oschina.net/kailuncen/blog/1504217)\n\n### 优化\n\n* [《MySQL36条军规》](http://vdisk.weibo.com/s/muWOT)\n\n* [《MYSQL性能优化的最佳20+条经验》](https://www.cnblogs.com/zhouyusheng/p/8038224.html)\n* [《SQL优化之道》](https://blog.csdn.net/when_less_is_more/article/details/70187459)\n* [《mysql数据库死锁的产生原因及解决办法》](https://www.cnblogs.com/sivkun/p/7518540.html)\n* [《导致索引失效的可能情况》](https://blog.csdn.net/monkey_d_feilong/article/details/52291556)\n* [《 MYSQL分页limit速度太慢优化方法》](https://blog.csdn.net/zy_281870667/article/details/51604540)\n\t* 原则上就是缩小扫描范围。\n\n\n### 索引\n\n#### 聚集索引, 非聚集索引\n\n* [《MySQL 聚集索引/非聚集索引简述》](https://blog.csdn.net/no_endless/article/details/77073549)\n* [《MyISAM和InnoDB的索引实现》](https://www.cnblogs.com/zlcxbb/p/5757245.html)\n\nMyISAM 是非聚集，InnoDB 是聚集\n\n#### 复合索引\n\n* [《复合索引的优点和注意事项》](https://www.cnblogs.com/summer0space/p/7247778.html)\n\n#### 自适应哈希索引(AHI)\n\n* [《InnoDB存储引擎——自适应哈希索引》](https://blog.csdn.net/Linux_ever/article/details/62043708)\n\n\n### explain\n* [《MySQL 性能优化神器 Explain 使用分析》](https://segmentfault.com/a/1190000008131735)\n\n## NoSQL\n\n### MongoDB\n\n* [MongoDB 教程](http://www.runoob.com/mongodb/mongodb-tutorial.html)\n* [《Mongodb相对于关系型数据库的优缺点》](http://mxdxm.iteye.com/blog/2093603)\n\t* 优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；\n\t* 缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；\n\n### Hbase\n\n* [《简明 HBase 入门教程（开篇）》](http://www.thebigdata.cn/HBase/35831.html)\n* [《深入学习HBase架构原理》](https://www.cnblogs.com/qiaoyihang/p/6246424.html)\n* [《传统的行存储和（HBase）列存储的区别》](https://blog.csdn.net/youzhouliu/article/details/67632882)\n\n\n* [《Hbase与传统数据库的区别》](https://blog.csdn.net/lifuxiangcaohui/article/details/39891099)\n\t* 空数据不存储，节省空间，且适用于并发。\n\n* [《HBase Rowkey设计》](https://blog.csdn.net/u014091123/article/details/73163088)\n\t* rowkey 按照字典顺序排列，便于批量扫描。\n\t* 通过散列可以避免热点。\n\n# 搜索引擎\n\n## 搜索引擎原理\n\n* [《倒排索引--搜索引擎入门》](https://www.jianshu.com/p/0193dc44135b)\n\n## Lucene\n* [《Lucene入门简介》](https://www.cnblogs.com/rodge-run/p/6551152.html)\n\n## Elasticsearch\n\n* [《Elasticsearch学习，请先看这一篇！》](https://blog.csdn.net/laoyang360/article/details/52244917)\n* [《Elasticsearch索引原理》](https://blog.csdn.net/cyony/article/details/65437708)\n\n## Solr\n* [《 Apache Solr入门教程》](https://blog.csdn.net/u011936655/article/details/51960005)\n* [《elasticsearch与solr比较》](https://blog.csdn.net/convict_eva/article/details/53537837)\n\n## sphinx \n* [《Sphinx 的介绍和原理探索》](http://blog.jobbole.com/101672/)\n\n# 性能\n\n## 性能优化方法论\n\n* [《15天的性能优化工作，5方面的调优经验》](https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread)\n\t* 代码层面、业务层面、数据库层面、服务器层面、前端优化。\n\n* [《系统性能优化的几个方面》](https://blog.csdn.net/tenglizhe/article/details/44563135)\n\n## 容量评估\n* [《联网性能与容量评估的方法论和典型案例》](https://blog.csdn.net/u012528360/article/details/70054156)\n* [《互联网架构，如何进行容量设计？》](https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&mid=2651959542&idx=1&sn=2494bbea9a855e0e1c3ccd6d2562a600&scene=21#wechat_redirect)\n\t* 评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS\n\n## CDN 网络\n\n* [《CDN加速原理》](https://www.cnblogs.com/wxiaona/p/5867685.html)\n* [《国内有哪些比较好的 CDN？》](https://www.zhihu.com/question/20536932)\n\n## 连接池\n\n* [《主流Java数据库连接池比较与开发配置实战》](https://blog.csdn.net/fysuccess/article/details/66972554)\n\n## 性能调优\n\n* [《九大Java性能调试工具，必备至少一款》](https://blog.csdn.net/yethyeth/article/details/73266455)\n\n\n# 大数据\n\n## 流式计算\n\n### Storm\n* [官方网站](http://storm.apache.org/)\n* [《最详细的Storm入门教程》](https://blog.csdn.net/uisoul/article/details/77989927)\n\n### Flink\n* [《Flink之一 Flink基本原理介绍》](https://blog.csdn.net/lisi1129/article/details/54844919)\n\n### Kafka Stream\n* [《Kafka Stream调研：一种轻量级流计算模式》](https://yq.aliyun.com/articles/58382)\n\n### 应用场景\n\n例如：\n\n* 广告相关实时统计；\n* 推荐系统用户画像标签实时更新；\n* 线上服务健康状况实时监测；\n* 实时榜单；\n* 实时数据统计。\n\n## Hadoop\n\n* [《用通俗易懂的话说下hadoop是什么,能做什么》](https://blog.csdn.net/houbin0912/article/details/72967178)\n* [《史上最详细的Hadoop环境搭建》](http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html)\n\n### HDFS\n* [《【Hadoop学习】HDFS基本原理》](https://segmentfault.com/a/1190000011575458)\n\n### MapReduce\n* [《用通俗易懂的大白话讲解Map/Reduce原理》](https://blog.csdn.net/oppo62258801/article/details/72884633)\n* [《 简单的map-reduce的java例子》](https://blog.csdn.net/foye12/article/details/78358292)\n\n### Yarn\n* [《初步掌握Yarn的架构及原理》](http://www.cnblogs.com/codeOfLife/p/5492740.html)\n\n## Spark\n* [《Spark(一): 基本架构及原理》](http://www.cnblogs.com/tgzhu/p/5818374.html)\n\n\n# 安全\n\n## web 安全\n\n### XSS\n* [《xss攻击原理与解决方法》](https://blog.csdn.net/qq_21956483/article/details/54377947)\n### CSRF\n* [《CSRF原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html)\n\n### SQL 注入\n\n* [《SQL注入》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html)\n\n### Hash Dos\n\n\n* [《邪恶的JAVA HASH DOS攻击》](http://www.freebuf.com/articles/web/14199.html)\n\t* 利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。\n* [《一种高级的DoS攻击-Hash碰撞攻击》](https://yq.aliyun.com/articles/92194?t=t1)\n* [《关于Hash Collision DoS漏洞：解析与解决方案》](http://www.iteye.com/news/23939/)\n\n### 脚本注入\n\n* [《上传文件漏洞原理及防范》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html)\n\n### 漏洞扫描工具\n* [《DVWA》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html)\n* [W3af](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html)\n* [OpenVAS详解](https://blog.csdn.net/xygg0801/article/details/53610640)\n\n### 验证码\n\n* [《验证码原理分析及实现》](https://blog.csdn.net/niaonao/article/details/51112686)\n\n* [《详解滑动验证码的实现原理》](https://my.oschina.net/jiangbianwanghai/blog/1031031)\n\t* 滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。\n\n* [《淘宝滑动验证码研究》](https://www.cnblogs.com/xcj26/p/5242758.html)\n\n## DDoS 防范\n* [《学习手册：DDoS的攻击方式及防御手段》](http://netsecurity.51cto.com/art/201601/503799.htm)\n* [《免费DDoS攻击测试工具大合集》](http://netsecurity.51cto.com/art/201406/442756.htm)\n\n## 用户隐私信息保护\n\n1. 用户密码非明文保存，加动态salt。\n2. 身份证号，手机号如果要显示，用 “\\*” 替代部分字符。\n3. 联系方式在的显示与否由用户自己控制。\n4. TODO\n\n* [《个人隐私包括哪些》](https://zhidao.baidu.com/question/1988017976673661587.html)\n* [《在互联网上，隐私的范围包括哪些？》](https://www.zhihu.com/question/20137108)\n\n* [《用户密码保存》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html)\n\n## 序列化漏洞\n* [《Lib之过？Java反序列化漏洞通用利用分析》](https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/)\n\n## 加密解密\n\n### 对称加密\n\n* [《常见对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html)\n\t* DES、3DES、Blowfish、AES\n\t* DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。\n\t* DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。\n\t\n### 哈希算法\n* [《常用的哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html)\n\t* MD5 和 SHA-1 已经不再安全，已被弃用。\n\t* 目前 SHA-256 是比较安全的。\n\t\n* [《基于Hash摘要签名的公网URL签名验证设计方案》](https://blog.csdn.net/zhangruhong168/article/details/78033202)\n\n### 非对称加密\n* [《常见非对称加密算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html)\n\t* RSA、DSA、ECDSA(螺旋曲线加密算法)\n\t* 和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。\n\t* 256位的ECC秘钥的安全性等同于3072位的RSA秘钥。\n\n\t\t[《区块链的加密技术》](http://baijiahao.baidu.com/s?id=1578348858092033763&wfr=spider&for=pc)\t\n\n\n## 服务器安全\n* [《Linux强化论：15步打造一个安全的Linux服务器》](http://www.freebuf.com/articles/system/121540.html)\n\n## 数据安全\n\n### 数据备份\n\nTODO\n\n## 网络隔离\n\n### 内外网分离\n\nTODO\n\n### 登录跳板机\n在内外环境中通过跳板机登录到线上主机。\n* [《搭建简易堡垒机》](http://blog.51cto.com/zero01/2062618)\n\n## 授权、认证\n### RBAC \n* [《基于组织角色的权限设计》](https://www.cnblogs.com/zq8024/p/5003050.html)\n* [《权限系统与RBAC模型概述》](https://www.cnblogs.com/shijiaqi1066/p/3793894.html)\n* [《Spring整合Shiro做权限控制模块详细案例分析》](https://blog.csdn.net/he90227/article/details/38663553)\n\n### OAuth2.0\n* [《理解OAuth 2.0》](http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html)\n* [《一张图搞定OAuth2.0》](https://www.cnblogs.com/flashsun/p/7424071.html)\n\n### 双因素认证（2FA）\n\n2FA - Two-factor authentication，用于加强登录验证\n\n常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）\n\n* 【《双因素认证（2FA）教程》】(http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html)\n\n### 单点登录(SSO)\n\n* [《单点登录原理与简单实现》](https://www.cnblogs.com/ywlaker/p/6113927.html)\n\n* [CAS单点登录框架](https://github.com/apereo/cas)\n\n# 常用开源框架\n\n## 开源协议\n\n* [《开源协议的选择》](https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html)\n\n* [如何选择一个开源软件协议](http://choosealicense.online/)\n\n## 日志框架\n\n### Log4j、Log4j2\n* [《log4j 详细讲解》](https://blog.csdn.net/u012422446/article/details/51199724)\n* [《log4j2 实际使用详解》](https://blog.csdn.net/vbirdbest/article/details/71751835)\n* [《Log4j1,Logback以及Log4j2性能测试对比》](https://my.oschina.net/OutOfMemory/blog/789267)\n\t* Log4J 异步日志性能优异。 \n\n### Logback\n* [《最全LogBack 详解、含java案例和配置说明》](https://blog.csdn.net/rulon147/article/details/52620541)\n\n## ORM\n\n* [《ORM框架使用优缺点》](https://blog.csdn.net/sinat_34093604/article/details/53082000)\n\t* 主要目的是为了提高开发效率。 \n\n**MyBatis：**\n\n* [《mybatis缓存机制详解》](https://www.cnblogs.com/winclpt/articles/7511672.html)\n\t* 一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效\n\t* 二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  \n\n* [《MyBatis学习之代码生成器Generator》](https://blog.csdn.net/baidu_32877851/article/details/53959268)\n\n## 网络框架\n\nTODO\n\n## Web 框架\n\n### Spring 家族\n**Spring**\n* [Spring 简明教程](https://www.w3cschool.cn/wkspring/)\n\n**Spring Boot**\n* [官方网站](http://projects.spring.io/spring-boot/)\n* [《Spring Boot基础教程》](http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n**Spring Cloud**\n\n* [Spring Boot 中文索引站](http://springboot.fun/)\n* [Spring Cloud 中文文档](https://springcloud.cc/)\n* [《Spring Cloud基础教程》](http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/)\n\n## 工具框架\n\n* [《Apache Commons 工具类介绍及简单使用》](https://www.cnblogs.com/crazylqy/p/4872236.html)\n* [《Google guava 中文教程》](http://ifeve.com/google-guava/)\n\n\n# 分布式设计\n\n## 扩展性设计\n\n* [《架构师不可不知的十大可扩展架构》](https://blog.csdn.net/hemin1003/article/details/53633926)\n\t* 总结下来，通用的套路就是分布、缓存及异步处理。 \n\n* [《可扩展性设计之数据切分》](https://yq.aliyun.com/articles/38119)\n\t* 水平切分+垂直切分\n\t* 利用中间件进行分片如，MySQL Proxy。\n\t* 利用分片策略进行切分，如按照ID取模。 \n* [《说说如何实现可扩展性的大型网站架构》](https://blog.csdn.net/deniro_li/article/details/78458306)\n\t* 分布式服务+消息队列。\n\n* [《大型网站技术架构（七）--网站的可扩展性架构》](https://blog.csdn.net/chaofanwei/article/details/29191073)\n\n## 稳定性 & 高可用\n\n* [《系统设计：关于高可用系统的一些技术方案》](https://blog.csdn.net/hustspy1990/article/details/78008324)\n\t* 可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。\n\t* 隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。\n\t* 解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。\n\t* 限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。\n\t* 降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。\n\t* 熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。\n\t* 自动化测试：通过完善的测试，减少发布引起的故障。\n\t* 灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。\n\n\n* [《关于高可用的系统》](https://coolshell.cn/articles/17459.html)\n\t* 设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。\t \n\n### 硬件负载均衡\n\n* [《转！！负载均衡器技术Nginx和F5的优缺点对比》](https://www.cnblogs.com/wuyun-blog/p/6186198.html)\n\t* 主要是和F5对比。\n\n* [《软/硬件负载均衡产品 你知多少？》](https://www.cnblogs.com/lcword/p/5773296.html)\n\n### 软件负载均衡\n\n* [《几种负载均衡算法》](https://www.cnblogs.com/tianzhiliang/articles/2317808.html)\n\t轮寻、权重、负载、最少连接、QoS\n* [《DNS负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html)\n\t* 配置简单，更新速度慢。 \n* [《Nginx负载均衡》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html)\n\t* 简单轻量、学习成本低；主要适用于web应用。\n\n*  [《借助LVS+Keepalived实现负载均衡 》](https://www.cnblogs.com/edisonchou/p/4281978.html)\n\t* 配置比较负载、只支持到4层，性能较高。\n\n* [《HAProxy用法详解 全网最详细中文文档》](http://www.ttlsa.com/linux/haproxy-study-tutorial/)\n\t* 支持到七层（比如HTTP）、功能比较全面，性能也不错。\n\n* [《Haproxy+Keepalived+MySQL实现读均衡负载》](http://blog.itpub.net/25704976/viewspace-1319781/)\n\t* 主要是用户读请求的负载均衡。\n\n* [《rabbitmq+haproxy+keepalived实现高可用集群搭建》](https://www.cnblogs.com/lylife/p/5584019.html)\n\n### 限流\n\n* [《谈谈高并发系统的限流》](https://www.cnblogs.com/haoxinyue/p/6792309.html)\n\t* 计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。\n\t* 漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。\n\t* 令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。\n\t* Nginx 限流：通过 `limit_req` 等模块限制并发连接数。\n\n### 应用层容灾\n\n* [《防雪崩利器：熔断器 Hystrix 的原理与使用》](https://segmentfault.com/a/1190000005988895)\n\t* 雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 \n\t* 雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。\n\t* Hystrix设计原则：\n\t\t* 资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。\n\t\t* 熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。\n\t\t* 命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 \n\n* [《缓存穿透，缓存击穿，缓存雪崩解决方案分析》](https://blog.csdn.net/zeb_perfect/article/details/54135506)\n* [《缓存击穿、失效以及热点key问题》](https://blog.csdn.net/zeb_perfect/article/details/54135506) \n\t* 主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；\n\t* 热点数据：热点数据单独存储；使用本地缓存；分成多个子key；\n\n### 跨机房容灾\n\n* [《“异地多活”多机房部署经验谈》](http://dc.idcquan.com/ywgl/71559.shtml)\n\t* 通过自研中间件进行数据同步。 \n\n* [《异地多活（异地双活）实践经验》](https://blog.csdn.net/jeffreynicole/article/details/48135093)\n\t* 注意延迟问题，多次跨机房调用会将延时放大数倍。\n\t* 建房间专线很大概率会出现问题，做好运维和程序层面的容错。\n\t* 不能依赖于程序端数据双写，要有自动同步方案。 \n\t* 数据永不在高延迟和较差网络质量下，考虑同步质量问题。\n\t* 核心业务和次要业务分而治之，甚至只考虑核心业务。\n\t* 异地多活监控部署、测试也要跟上。\n\t* 业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。\n\t* 控制跨机房消息体大小，越小越好。\n\t* 考虑使用docker容器虚拟化技术，提高动态调度能力。\n\n* [容灾技术及建设经验介绍](https://blog.csdn.net/yoara/article/details/38013751)\n\n\n### 容灾演练流程\n\n* [《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》](https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&mid=2650996320&idx=1&sn=0ed3be190bbee4a9277886ef88cbb2e5)\n\t* 常见故障画像\n\t* 案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。\n\n### 平滑启动\n\n* 平滑重启应用思路\n1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用\n\n* [《JVM安全退出（如何优雅的关闭java服务）》](https://blog.csdn.net/u011001084/article/details/73480432)\n推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。\n* [《常见Java应用如何优雅关闭》](http://ju.outofmemory.cn/entry/337235)\nJava、Srping、Dubbo 优雅关闭方式。\n\n## 数据库扩展\n\n### 读写分离模式\n\n* [《Mysql主从方案的实现》](https://www.cnblogs.com/houdj/p/6563771.html)\n* [《搭建MySQL主从复制经典架构》](https://www.cnblogs.com/edisonchou/p/4133148.html)\n* [《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》](https://blog.csdn.net/nimasike/article/details/48048341)\n\n* [《DRBD+Heartbeat+Mysql高可用读写分离架构》](https://www.cnblogs.com/zhangsubai/p/6801764.html)\n\t* DRDB 进行磁盘复制，避免单点问题。\n\n* [《MySQL Cluster 方式》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html)\n\n### 分片模式\n* [《分库分表需要考虑的问题及方案》](https://www.jianshu.com/p/32b3e91aa22c)\n\t* 中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。\n\t* 问题：事务、Join、迁移、扩容、ID、分页等。\n\t* 事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。\n\t* 分库策略：数值范围；取模；日期等。\n\t* 分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 \n\n* [《MySql分表和表分区详解》](https://www.2cto.com/database/201503/380348.html)\n\t* 分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。\n\t* 分表：物理上创建不同的表、客户端需要管理分表路由。\n\n## 服务治理\n###  服务注册与发现\n\n* [《永不失联！如何实现微服务架构中的服务发现？》](https://blog.csdn.net/jiaolongdy/article/details/51188798)\n  * 客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。\n  * 服务器端服务发现模式：客户端通过负载均衡查询服务实例。\n* [《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》](https://blog.csdn.net/u010963948/article/details/71730165)\n  * CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）\n  * 作者认为目前 Consul 对 Spring cloud 的支持比较好。\n\n* [《基于Zookeeper的服务注册与发现》](http://mobile.51cto.com/news-502394.htm)\n\t* 优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 \n\n### 服务路由控制\n* [《分布式服务框架学习笔记4 服务路由》](https://blog.csdn.net/xundh/article/details/59492750)\n\t* 原则：透明化路由\n\t* 负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接\n\t* 本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。\n\t* 配置方式：统一注册表；本地配置；动态下发。\n\n## 分布式一致\n\n### CAP 与 BASE 理论\n\n* [《从分布式一致性谈到CAP理论、BASE理论》](http://www.cnblogs.com/szlbm/p/5588543.html)\n\t* 一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)\n\t* CAP：一致性、可用性、分区容错性(网络故障引起)\n\t* BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）\n\t* BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。\n\n### 分布式锁\n\n* [《分布式锁的几种实现方式》](http://www.hollischuang.com/archives/1716)\n\t* 基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；\n\t* 基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。\n\t* Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。\n* [《基于Zookeeper的分布式锁》](https://www.tuicool.com/articles/VZJr6fY)\n\t* 清楚的原理描述 + Java 代码示例。 \n\n* [《jedisLock—redis分布式锁实现》](https://www.cnblogs.com/0201zcr/p/5942748.html)\n\t* 基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。\n\n* [《Memcached 和 Redis 分布式锁方案》](https://blog.csdn.net/albertfly/article/details/77412333)\n\t* 利用 memcached 的 add（有别于set）操作，当key存在时，返回false。\n\n### 分布式一致性算法\n\n#### PAXOS\n* [《分布式系列文章——Paxos算法原理与推导》](https://www.cnblogs.com/linbingdong/p/6253479.html)\n* [《Paxos-->Fast Paxos-->Zookeeper分析》](https://blog.csdn.net/u010039929/article/details/70171672)\n* [《【分布式】Zookeeper与Paxos》](https://www.cnblogs.com/leesf456/p/6012777.html)\n\n#### Zab\n* [《Zab：Zookeeper 中的分布式一致性协议介绍》](https://www.jianshu.com/p/fb527a64deee)\n\n#### Raft\n* [《Raft 为什么是更易理解的分布式一致性算法》](http://www.cnblogs.com/mindwind/p/5231986.html)\n\t* 三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）\n\t* 通过随机等待的方式发出投票，得票多的获胜。\n\n#### Gossip\n* [《Gossip算法》](http://blog.51cto.com/tianya23/530743)\n\n#### 两阶段提交、多阶段提交\n\n* [《关于分布式事务、两阶段提交协议、三阶提交协议》](http://blog.jobbole.com/95632/)\n\n### 幂等\n\n* [《分布式系统---幂等性设计》](https://www.cnblogs.com/wxgblogs/p/6639272.html)\n\t* 幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。\n\t* 常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 \n\n### 分布式一致方案\n* [《分布式系统事务一致性解决方案》](http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency)\n* [《保证分布式系统数据一致性的6种方案》](https://weibo.com/ttarticle/p/show?id=2309403965965003062676)\n\n### 分布式 Leader 节点选举\n* [《利用zookeeper实现分布式leader节点选举》](https://blog.csdn.net/johnson_moon/article/details/78809995)\n\n### TCC(Try/Confirm/Cancel) 柔性事务\n* [《传统事务与柔性事务》](https://www.jianshu.com/p/ab1a1c6b08a1)\n\t* 基于BASE理论：基本可用、柔性状态、最终一致。\n\t* 解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。\n\n## 分布式文件系统\n\n* [说说分布式文件存储系统-基本架构](https://zhuanlan.zhihu.com/p/27666295) ？\n* [《各种分布式文件系统的比较》](https://blog.csdn.net/gatieme/article/details/44982961) ？\n  * HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。\n  * FastDFS：轻量级、适合小文件。\n\n## 唯一ID 生成\n\n### 全局唯一ID\n* [《高并发分布式系统中生成全局唯一Id汇总》](https://www.cnblogs.com/baiwa/p/5318432.html)\n\t* Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)\n\t* Flicker 方案：MySQL自增ID + \"REPLACE INTO XXX:SELECT LAST_INSERT_ID();\" \n\t* UUID：缺点，无序，字符串过长，占用空间，影响检索性能。\n\t* MongoDB 方案：利用 ObjectId。缺点：不能自增。\n\n* [《TDDL 在分布式下的SEQUENCE原理》](https://blog.csdn.net/hdu09075340/article/details/79103851)\n\t* 在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。\n\t* 每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。\n\t* 客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。\n\n## 一致性Hash算法\n\n* [《一致性哈希算法》](https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html)\n\n# 设计思想 & 开发模式\n\n## DDD(Domain-driven Design - 领域驱动设计)\n\n* [《浅谈我对DDD领域驱动设计的理解》](https://www.cnblogs.com/netfocus/p/5548025.html)\n  * 概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。\n  * 过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。\n  * 设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。\n  \n* [《领域驱动设计的基础知识总结》](https://www.cnblogs.com/butterfly100/p/7827870.html)\n  * 领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。\n  * 界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。\n  * 领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；\n  * 领域通用语言：领域专家、开发设计人员都能立即的语言或工具。\n  * 经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。\n  * 使用的模式：\n    * 关联尽量少，尽量单项，尽量降低整体复杂度。\n    * 实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。\n    * 值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。\n    * 领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。\n    * 聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；\n    * 工厂（Factory）：类似于设计模式中的工厂模式。\n    * 仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。\n\n* [《领域驱动设计(DDD)实现之路》](http://www.cnblogs.com/Leo_wl/p/3866629.html)\n\t* 聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。\n\n* [《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》](http://www.hollischuang.com/archives/553)\n\n\n### 命令查询职责分离(CQRS)\n\nCQRS — Command Query Responsibility Seperation\n\n* [《领域驱动设计系列 (六)：CQRS》](https://www.cnblogs.com/cnblogsfans/p/4551990.html)\n\t* 核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。\n\n* [《DDD CQRS架构和传统架构的优缺点比较》](http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml)\n\t* 最终一致的设计理念；依赖于高可用消息中间件。\n\t\n* [《CQRS架构简介》](http://www.cnblogs.com/netfocus/p/4055346.html)\n\t* 一个实现 CQRS 的抽象案例。\n\n* [《深度长文：我对CQRS/EventSourcing架构的思考》](http://www.uml.org.cn/zjjs/201609221.asp)\n\t* CQRS 模式分析 + 12306 抢票案例\n\n### 贫血，充血模型\n\n* [《贫血，充血模型的解释以及一些经验》](https://kb.cnblogs.com/page/520743/)\n\t* 失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。\n\t* 贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；\n\t* 充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。\n\t* 肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。\n\t* 作者主张使用贫血模式。\n\t\n## Actor 模式\n\nTODO\n\n## 响应式编程\n\n### Reactor\nTODO\n### RxJava\nTODO\n### Vert.x\nTODO\n\n## DODAF2.0\n\n* [《DODAF2.0方法论》](http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml)\n* [《DODAF2.0之能力视角如何落地》](http://blog.51cto.com/xiaoyong/1553164)\n\n## Serverless\n\n无需过多关系服务器的服务架构理念。\n\n* [《什么是Serverless无服务器架构？》](http://www.jdon.com/soa/serverless.html)\n\t* Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。\n\t* Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。\n\t* Serverless 不代表某个具体的框架。\n\n* [《如何理解Serverless？》](http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless)\n\t* 依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）\n\n\n\n## Service Mesh\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n* [《初识 Service Mesh》](https://www.jianshu.com/p/e23e3e74538e)\n\n* [《什么是Service Mesh？》](https://time.geekbang.org/article/2355)\n\n# 项目管理\n\n## 架构评审\n* [《架构设计之如何评审架构设计说明书》](http://developer.51cto.com/art/201506/478486.htm)\n* [《人人都是架构师：非功能性需求》](https://blog.csdn.net/wireless_com/article/details/45935591)\n\n## 重构\n\n* [《架构之重构的12条军规》](http://www.infoq.com/cn/articles/architect-12-rules-complete/)\n\n## 代码规范\n\n* [《阿里巴巴Java开发手册》](https://github.com/alibaba/p3c)\n\n## 代码 Review\n\n\n制度还是制度!\n另外，每个公司需要根据自己的需求和目标制定自己的 check list\n\n* [《为什么你做不好 Code Review？》](http://www.sohu.com/a/229745352_181657)\n\t* 代码 review 做的好，在于制度建设。\n\n* [《从零开始Code Review》](https://blog.csdn.net/uxyheaven/article/details/49773619)\n\n* [《Code Review Checklist》](https://www.cnblogs.com/zuoping/p/5477047.html)\n* [《Java Code Review Checklist》](https://dzone.com/articles/java-code-review-checklist)\n\n* [《如何用 gitlab 做 code review》](https://blog.csdn.net/legend0011/article/details/45585575)\n\n## RUP\n* [《运用RUP 4+1视图方法进行软件架构设计》](https://blog.csdn.net/apanious/article/details/51011946)\n\n## 看板管理\n* [《说说看板在项目中的应用》](https://blog.csdn.net/tkchen/article/details/51637643)\n\n## SCRUM\n\nSCRUM - 争球\n\n* 3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。\n* 3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；\n* 五个价值观：专注、勇气、公开、承诺、尊重。\n\n\n* [《敏捷项目管理流程-Scrum框架最全总结！》](https://blog.csdn.net/inny100_100/article/details/54633757)\n\n* [《敏捷其实很简单3---敏捷方法之scrum》](https://blog.csdn.net/superkunkun/article/details/52951142)\n\n## 敏捷开发\n\nTODO\n\n## 极限编程（XP）\n\nXP - eXtreme Programming\n\n* [《主流敏捷开发方法：极限编程XP》](http://www.woshipm.com/pmd/406917.html)\n\t* 是一种指导开发人员的方法论。\n\t* 4大价值：\n\t\t* 沟通：鼓励口头沟通，提高效率。\n\t\t* 简单：够用就好。\n\t\t* 反馈：及时反馈、通知相关人。\n\t\t* 勇气：提倡拥抱变化，敢于重构。\n\t\t\n\t* 5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。\n\t* 5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。\n\n## 结对编程\n\n边写码，边review。能够增强代码质量、减少bug。\n\n* [《结对编程》](http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B)\n\n## PDCA 循环质量管理\n\nP——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进\n\n* [《PDCA》](http://www.baike.com/wiki/PDCA)\n\n## FMEA管理模式\n\nTODO\n\n# 通用业务术语\n\nTODO\n\n# 技术趋势\n\nTODO\n\n# 政策、法规\n\nTODO\n## 法律\n\n### 严格遵守刑法253法条\n\n我国刑法第253条之一规定：\n\n> * 国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。\n> * 窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 \n> * 单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。\n\n最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”\n\n* [《非法获取公民个人信息罪》](https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA)\n\n\n# 架构师素质\n\n* [《架构师画像》](http://hellojava.info/?p=430)\n\t* 业务理解和抽象能力\n\t* NB的代码能力\n\t* 全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； \n\t* 全局：是否考虑到了对上下游的系统的影响。\n\t* 权衡：权衡投入产出比；优先级和节奏控制；\n\n* [《关于架构优化和设计，架构师必须知道的事情》](http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know)\n\t* 要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。\n\t* 基础设施、配置、测试、开发、运维综合考虑。\n\t* 考虑人、团队、和组织的影响。 \n\n* [《如何才能真正的提高自己，成为一名出色的架构师？》](https://www.zhihu.com/question/19841397) \n\n* [《架构师的必备素质和成长途径》](https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129)\n\t* 素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。\n\t* 成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 \n\n* [《架构设计师—你在哪层楼？》](http://blog.51cto.com/frankfan/1248401)\n\t* 第一层的架构师看到的只是产品本身\n\t* 第二层的架构师不仅看到自己的产品，还看到了整体的方案\n\t* 第三层的架构师看到的是商业价值 \n\n# 团队管理\n\nTODO\n\n## 招聘\n\n# 资讯\n\n## 行业资讯\n\n* [36kr](http://36kr.com/)\n* [Techweb](http://www.techweb.com.cn/)\n\n## 公众号列表\n\nTODO\n\n## 博客\n\n### 团队博客\n* [阿里中间件博客](http://jm.taobao.org/)\n* [美团点评技术团队博客](https://tech.meituan.com)\n\n### 个人博客\n\n* [阮一峰的网络日志](http://www.ruanyifeng.com/)\n* [酷壳 - COOLSHELL-陈皓](https://coolshell.cn/)\n* [hellojava-阿里毕玄](http://hellojava.info/)\n* [Cm's Blog](http://cmsblogs.com/)\n* [程序猿DD-翟永超-《Spring Cloud微服务实战》作者](http://blog.didispace.com/)\n\n## 综合门户、社区\n\n**国内：**\n\n* [CSDN](http://csdn.net)\n\t 老牌技术社区、不必解释。\n* [51cto.com](http://www.51cto.com/)\n* [ITeye](http://www.iteye.com/)\n\t* 偏 Java 方向 \n* [博客园](https://www.cnblogs.com)\n* [ChinaUnix](http://www.tom.net/)\n\t* 偏 Linux 方向 \n* [开源中国社区](https://www.oschina.net/)\n* [深度开源](http://www.open-open.com/)\n* [伯乐在线](http://www.jobbole.com/)\n\t* 涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。\n\n* [ITPUB](http://www.itpub.net/)\n* [腾讯云— 云+社区](https://cloud.tencent.com/developer/column)\n* [阿里云— 云栖社区](https://yq.aliyun.com/)\n* [IBM DeveloperWorks](https://www.ibm.com/developerworks/cn/)\n* [开发者头条](https://toutiao.io/)\n* [LinkedKeeper](http://www.linkedkeeper.com)\n\n**国外：**\n\n* [DZone](https://dzone.com)\n* [Reddit](https://www.reddit.com)\n\n## 问答、讨论类社区\n\n* [segmentfault](https://segmentfault.com)\n\t* 问答+专栏 \n* [知乎](https://www.zhihu.com/)\n* [stackoverflow](https://stackoverflow.com/)\n\n## 行业数据分析\n\n* [艾瑞网](http://report.iresearch.cn/)\n* [QUEST MOBILE](https://www.questmobile.com.cn)\n\n* [国家数据](http://data.stats.gov.cn/)\n\n* [TalkingData](http://www.talkingdata.com/)\n\n## 专项网站\n\n* 测试:\n\t* [领测国际](http://www.ltesting.net/) \n\t* [测试窝](https://www.testwo.com/)\n\t* [TesterHome](https://testerhome.com)\n\n* 运维:\n  \t* [运维派](http://www.yunweipai.com/) \n  \t* [Abcdocker](https://www.abcdocker.com/)\n  \n* Java:\n\t* [ImportNew](http://www.importnew.com/)\n\t\t* 专注于 Java 技术分享\n\t* [HowToDoInJava](https://howtodoinjava.com/)\n\t\t* 英文博客\n\t\n* 安全\n\t* [红黑联盟](https://www.2cto.com/) \n\t* [FreeBuf](http://www.freebuf.com/)\n\n* 大数据\n\t* [中国大数据](http://www.thebigdata.cn/) \n\n* 其他专题网站：\n\t* [DockerInfo](http://www.dockerinfo.net/)\n\t\t* 专注于 Docker 应用及咨询、教程的网站。\n\t* [Linux公社](https://www.linuxidc.com/)\n\t\t* Linux 主题社区\n\n## 其他类\n\n* [程序员技能图谱](https://github.com/TeamStuQ/skill-map)\n\n## 推荐参考书\n\n\n### 在线电子书\n\n* [《深入理解Spring Cloud与微服务构建》](https://github.com/forezp/SpringCloudLearning)\n\n\n* [《阿里技术参考图册-研发篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf)\n* [《阿里技术参考图册-算法篇》](http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf)\n\n* [《2018美团点评技术年货（合辑）》70M](http://dpurl.cn/n/1lqcX)\n\n* [InfoQ《架构师》月刊](http://www.infoq.com/cn/architect/)\n\n* [《架构师之路》](https://www.w3cschool.cn/architectroad/)\n\n### 纸质书\n\n#### 开发方面\n\n* 《阿里巴巴Java开发手册》[京东](https://union-click.jd.com/jdc?d=bVKwZQ) [淘宝](https://s.taobao.com/search?q=阿里巴巴Java开发手册)\n\n#### 架构方面\n* 《软件架构师的12项修炼：技术技能篇》[京东](https://union-click.jd.com/jdc?d=gXvRd8) [淘宝](https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇)\n* 《架构之美》[京东](https://union-click.jd.com/jdc?d=xJit5I) [淘宝](https://s.taobao.com/search?q=架构之美)\n* 《分布式服务架构》[京东](https://union-click.jd.com/jdc?d=JS5Od9) [淘宝](https://s.taobao.com/search?q=分布式服务架构)\n* 《聊聊架构》 [京东](https://union-click.jd.com/jdc?d=FHooH4) [淘宝](https://s.taobao.com/search?q=聊聊架构)\n* 《云原生应用架构实践》[京东](https://union-click.jd.com/jdc?d=orkJSj) [淘宝](https://s.taobao.com/search?q=云原生应用架构实践)\n* 《亿级流量网站架构核心技术》[京东](https://union-click.jd.com/jdc?d=RnOSP5) [淘宝](https://s.taobao.com/search?q=亿级流量网站架构核心技术)\n* 《淘宝技术这十年》[京东](https://union-click.jd.com/jdc?d=LwrDfD) [淘宝](https://s.taobao.com/search?q=淘宝技术这十年)\n* 《企业IT架构转型之道-中台战略思想与架构实战》 [京东](https://union-click.jd.com/jdc?d=89pAEm) [淘宝](https://s.taobao.com/search?q=企业IT架构转型之道)\n\n* 《高可用架构（第1卷）》[京东](https://item.jd.com/12195481.html) [淘宝](https://s.taobao.com/search?q=高可用架构)\n\n#### 技术管理方面\n* 《CTO说》[京东](https://union-click.jd.com/jdc?d=zhTZyr) [淘宝](https://s.taobao.com/search?q=CTO说)\n* 《技术管理之巅》[京东](https://union-click.jd.com/jdc?d=LgRBUW) [淘宝](https://s.taobao.com/search?q=技术管理之巅)\n* 《网易一千零一夜：互联网产品项目管理实战》[京东](https://union-click.jd.com/jdc?d=jcRz2r) [淘宝](https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战)\n\n#### 基础理论\n* 《数学之美》[京东](https://union-click.jd.com/jdc?d=ghIES2) [淘宝](https://s.taobao.com/search?q=数学之美)\n* 《编程珠玑》[京东](https://union-click.jd.com/jdc?d=YmhdEu) [淘宝](https://s.taobao.com/search?q=编程珠玑)\n\n#### 工具方面\nTODO\n\n#### 大数据方面\n\n# 技术资源\n\n## 开源资源\n* [github](https://github.com)\n\n* [Apache 软件基金会](https://www.apache.org/index.html)\n\n## 手册、文档、教程\n\n**国内：**\n* [W3Cschool](http://w3cschool.cn) \n* [Runoob.com](http://www.runoob.com/)\n\t* HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。\n\n* [Love2.io](https://love2.io/)\n\t* 很多很多中文在线电子书，是一个全新的开源技术文档分享平台。\n* [gitbook.cn](http://gitbook.cn/)\n\t* 付费电子书。 \n* [ApacheCN](http://www.apachecn.org/)\n\t* AI、大数据方面系列中文文档。\n\n**国外：**\n\n* [Quick Code](http://www.quickcode.co/)\n\t* 免费在线技术教程。\n* [gitbook.com](http://gitbook.com)\n\t* 有部分中文电子书。\n* [Cheatography](https://www.cheatography.com/)\n\t* Cheat Sheets 大全，单页文档网站。\n* [Tutorialspoint](https://www.tutorialspoint.com/index.htm)\n\t* 知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。\n\n\n## 在线课堂\n\n* [学徒无忧](http://www.xuetuwuyou.com/)\n* [极客时间](https://time.geekbang.org/)\n* [segmentfault](https://segmentfault.com/lives)\n* [斯达克学院](https://new.stuq.org/course/explore)\n* [牛客网](http://nowcoder.com)\n* [极客学院](https://www.jikexueyuan.com/)\n* [51CTO学院](http://edu.51cto.com/)\n\n## 会议、活动\n\n* [QCon](http://www.infoq.com/cn/qcon/)\n* [ArchSummit](https://archsummit.com)\n* [GITC全球互联网技术大会](http://www.thegitc.com/)\n\n**活动发布平台:** \n* [活动行](http://www.huodongxing.com/)\n\n## 常用APP\n\n* [极客时间](https://time.geekbang.org)\n* [得到](https://www.igetget.com)\n\n## 找工作\n* [Boss直聘](https://www.zhipin.com)\n* [拉勾网](https://www.lagou.com)\n* [猎聘](https://www.liepin.com)\n* [100Offer](https://cn.100offer.com/)\n\n## 工具\n\n* [极客搜索](https://s.geekbang.org/)\n\t* 技术文章搜索引擎。\n\n## 代码托管\n\n* [Coding](https://coding.net)\n* [码云](https://gitee.com/)\n\n## 文件服务\n* 七牛\n* 又拍云\n\n## 综合云服务商\n* 阿里云\n* [腾讯云](https://cloud.tencent.com/redirect.php?redirect=1012&cps_key=c2665015d90871c0cb20fef91b7afc3c)\n* 百度云\n* 新浪云\n* 金山云\n* [亚马逊云(AWS)](https://amazonaws-china.com/cn/)\n* [谷歌云](https://cloud.google.com/?hl=zh-cn)\n* [微软云](https://azure.microsoft.com/zh-cn/)\n\n### VPS\n* [Linode](http://linode.com)\n\n","slug":"architect-awesome","published":1,"updated":"2018-11-09T01:20:29.999Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjp0m38zk00dzqcrguy5x6lwb","content":"<p>列出了后端架构师要掌握的基本知识。少壮不努力，老大徒伤悲……</p>\n<p>本文拷贝自<a href=\"https://github.com/xingshaocheng/architect-awesome\" target=\"_blank\" rel=\"noopener\">https://github.com/xingshaocheng/architect-awesome</a></p>\n<h1>《后端架构师技术图谱》</h1>\n\n<p><strong>更新于20180513</strong></p>\n<ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构\" target=\"_blank\" rel=\"noopener\">数据结构</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列\" target=\"_blank\" rel=\"noopener\">队列</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合\" target=\"_blank\" rel=\"noopener\">集合</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组\" target=\"_blank\" rel=\"noopener\">链表、数组</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组\" target=\"_blank\" rel=\"noopener\">字典、关联数组</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈\" target=\"_blank\" rel=\"noopener\">栈</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#树\" target=\"_blank\" rel=\"noopener\">树</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉树\" target=\"_blank\" rel=\"noopener\">二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉树\" target=\"_blank\" rel=\"noopener\">完全二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉树\" target=\"_blank\" rel=\"noopener\">平衡二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查找树bst\" target=\"_blank\" rel=\"noopener\">二叉查找树（BST）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#红黑树\" target=\"_blank\" rel=\"noopener\">红黑树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb树\" target=\"_blank\" rel=\"noopener\">B-，B+，B*树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-树\" target=\"_blank\" rel=\"noopener\">LSM 树</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset\" target=\"_blank\" rel=\"noopener\">BitSet</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用算法\" target=\"_blank\" rel=\"noopener\">常用算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查找算法\" target=\"_blank\" rel=\"noopener\">排序、查找算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#选择排序\" target=\"_blank\" rel=\"noopener\">选择排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冒泡排序\" target=\"_blank\" rel=\"noopener\">冒泡排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序\" target=\"_blank\" rel=\"noopener\">插入排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序\" target=\"_blank\" rel=\"noopener\">快速排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#归并排序\" target=\"_blank\" rel=\"noopener\">归并排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希尔排序\" target=\"_blank\" rel=\"noopener\">希尔排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序\" target=\"_blank\" rel=\"noopener\">堆排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计数排序\" target=\"_blank\" rel=\"noopener\">计数排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序\" target=\"_blank\" rel=\"noopener\">桶排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基数排序\" target=\"_blank\" rel=\"noopener\">基数排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查找\" target=\"_blank\" rel=\"noopener\">二分查找</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具\" target=\"_blank\" rel=\"noopener\">Java 中的排序工具</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆过滤器\" target=\"_blank\" rel=\"noopener\">布隆过滤器</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字符串比较\" target=\"_blank\" rel=\"noopener\">字符串比较</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kmp-算法\" target=\"_blank\" rel=\"noopener\">KMP 算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度优先广度优先\" target=\"_blank\" rel=\"noopener\">深度优先、广度优先</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贪心算法\" target=\"_blank\" rel=\"noopener\">贪心算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯算法\" target=\"_blank\" rel=\"noopener\">回溯算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝算法\" target=\"_blank\" rel=\"noopener\">剪枝算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#动态规划\" target=\"_blank\" rel=\"noopener\">动态规划</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#朴素贝叶斯\" target=\"_blank\" rel=\"noopener\">朴素贝叶斯</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐算法\" target=\"_blank\" rel=\"noopener\">推荐算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成树算法\" target=\"_blank\" rel=\"noopener\">最小生成树算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路径算法\" target=\"_blank\" rel=\"noopener\">最短路径算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#并发\" target=\"_blank\" rel=\"noopener\">并发</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多线程\" target=\"_blank\" rel=\"noopener\">多线程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程安全\" target=\"_blank\" rel=\"noopener\">线程安全</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事务\" target=\"_blank\" rel=\"noopener\">一致性、事务</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务-acid-特性\" target=\"_blank\" rel=\"noopener\">事务 ACID 特性</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务的隔离级别\" target=\"_blank\" rel=\"noopener\">事务的隔离级别</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvcc\" target=\"_blank\" rel=\"noopener\">MVCC</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#锁\" target=\"_blank\" rel=\"noopener\">锁</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的锁和同步类\" target=\"_blank\" rel=\"noopener\">Java中的锁和同步类</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平锁--非公平锁\" target=\"_blank\" rel=\"noopener\">公平锁 &amp; 非公平锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲观锁\" target=\"_blank\" rel=\"noopener\">悲观锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#乐观锁--cas\" target=\"_blank\" rel=\"noopener\">乐观锁 &amp; CAS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-问题\" target=\"_blank\" rel=\"noopener\">ABA 问题</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器\" target=\"_blank\" rel=\"noopener\">CopyOnWrite容器</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer\" target=\"_blank\" rel=\"noopener\">RingBuffer</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入锁--不可重入锁\" target=\"_blank\" rel=\"noopener\">可重入锁 &amp; 不可重入锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥锁--共享锁\" target=\"_blank\" rel=\"noopener\">互斥锁 &amp; 共享锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死锁\" target=\"_blank\" rel=\"noopener\">死锁</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#操作系统\" target=\"_blank\" rel=\"noopener\">操作系统</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计算机原理\" target=\"_blank\" rel=\"noopener\">计算机原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cpu\" target=\"_blank\" rel=\"noopener\">CPU</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多级缓存\" target=\"_blank\" rel=\"noopener\">多级缓存</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#进程\" target=\"_blank\" rel=\"noopener\">进程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程\" target=\"_blank\" rel=\"noopener\">线程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协程\" target=\"_blank\" rel=\"noopener\">协程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux\" target=\"_blank\" rel=\"noopener\">Linux</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式\" target=\"_blank\" rel=\"noopener\">设计模式</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式的六大原则\" target=\"_blank\" rel=\"noopener\">设计模式的六大原则</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23种常见设计模式\" target=\"_blank\" rel=\"noopener\">23种常见设计模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景\" target=\"_blank\" rel=\"noopener\">应用场景</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单例模式\" target=\"_blank\" rel=\"noopener\">单例模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#责任链模式\" target=\"_blank\" rel=\"noopener\">责任链模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc\" target=\"_blank\" rel=\"noopener\">MVC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc\" target=\"_blank\" rel=\"noopener\">IOC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop\" target=\"_blank\" rel=\"noopener\">AOP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml\" target=\"_blank\" rel=\"noopener\">UML</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服务思想\" target=\"_blank\" rel=\"noopener\">微服务思想</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律\" target=\"_blank\" rel=\"noopener\">康威定律</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#运维--统计--技术支持\" target=\"_blank\" rel=\"noopener\">运维 &amp; 统计 &amp; 技术支持</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常规监控\" target=\"_blank\" rel=\"noopener\">常规监控</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm\" target=\"_blank\" rel=\"noopener\">APM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#统计分析\" target=\"_blank\" rel=\"noopener\">统计分析</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持续集成cicd\" target=\"_blank\" rel=\"noopener\">持续集成(CI/CD)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins\" target=\"_blank\" rel=\"noopener\">Jenkins</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#环境分离\" target=\"_blank\" rel=\"noopener\">环境分离</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自动化运维\" target=\"_blank\" rel=\"noopener\">自动化运维</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible\" target=\"_blank\" rel=\"noopener\">Ansible</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet\" target=\"_blank\" rel=\"noopener\">puppet</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef\" target=\"_blank\" rel=\"noopener\">chef</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#测试\" target=\"_blank\" rel=\"noopener\">测试</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理论\" target=\"_blank\" rel=\"noopener\">TDD 理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单元测试\" target=\"_blank\" rel=\"noopener\">单元测试</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#压力测试\" target=\"_blank\" rel=\"noopener\">压力测试</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全链路压测\" target=\"_blank\" rel=\"noopener\">全链路压测</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-灰度蓝绿测试\" target=\"_blank\" rel=\"noopener\">A/B 、灰度、蓝绿测试</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虚拟化\" target=\"_blank\" rel=\"noopener\">虚拟化</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm\" target=\"_blank\" rel=\"noopener\">KVM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen\" target=\"_blank\" rel=\"noopener\">Xen</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz\" target=\"_blank\" rel=\"noopener\">OpenVZ</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技术\" target=\"_blank\" rel=\"noopener\">容器技术</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker\" target=\"_blank\" rel=\"noopener\">Docker</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#云技术\" target=\"_blank\" rel=\"noopener\">云技术</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack\" target=\"_blank\" rel=\"noopener\">OpenStack</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops\" target=\"_blank\" rel=\"noopener\">DevOps</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文档管理\" target=\"_blank\" rel=\"noopener\">文档管理</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中间件\" target=\"_blank\" rel=\"noopener\">中间件</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server\" target=\"_blank\" rel=\"noopener\">Web Server</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx\" target=\"_blank\" rel=\"noopener\">Nginx</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty\" target=\"_blank\" rel=\"noopener\">OpenResty</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd\" target=\"_blank\" rel=\"noopener\">Apache Httpd</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat\" target=\"_blank\" rel=\"noopener\">Tomcat</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构原理\" target=\"_blank\" rel=\"noopener\">架构原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#调优方案\" target=\"_blank\" rel=\"noopener\">调优方案</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty\" target=\"_blank\" rel=\"noopener\">Jetty</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#缓存\" target=\"_blank\" rel=\"noopener\">缓存</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地缓存\" target=\"_blank\" rel=\"noopener\">本地缓存</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客户端缓存\" target=\"_blank\" rel=\"noopener\">客户端缓存</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务端缓存\" target=\"_blank\" rel=\"noopener\">服务端缓存</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web缓存\" target=\"_blank\" rel=\"noopener\">Web缓存</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached\" target=\"_blank\" rel=\"noopener\">Memcached</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis\" target=\"_blank\" rel=\"noopener\">Redis</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构\" target=\"_blank\" rel=\"noopener\">架构</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略\" target=\"_blank\" rel=\"noopener\">回收策略</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair\" target=\"_blank\" rel=\"noopener\">Tair</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息队列\" target=\"_blank\" rel=\"noopener\">消息队列</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息总线\" target=\"_blank\" rel=\"noopener\">消息总线</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息的顺序\" target=\"_blank\" rel=\"noopener\">消息的顺序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq\" target=\"_blank\" rel=\"noopener\">RabbitMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq\" target=\"_blank\" rel=\"noopener\">RocketMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq\" target=\"_blank\" rel=\"noopener\">ActiveMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka\" target=\"_blank\" rel=\"noopener\">Kafka</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-消息推送\" target=\"_blank\" rel=\"noopener\">Redis 消息推送</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq\" target=\"_blank\" rel=\"noopener\">ZeroMQ</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定时调度\" target=\"_blank\" rel=\"noopener\">定时调度</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单机定时调度\" target=\"_blank\" rel=\"noopener\">单机定时调度</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式定时调度\" target=\"_blank\" rel=\"noopener\">分布式定时调度</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc\" target=\"_blank\" rel=\"noopener\">RPC</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo\" target=\"_blank\" rel=\"noopener\">Dubbo</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift\" target=\"_blank\" rel=\"noopener\">Thrift</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc\" target=\"_blank\" rel=\"noopener\">gRPC</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库中间件\" target=\"_blank\" rel=\"noopener\">数据库中间件</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc\" target=\"_blank\" rel=\"noopener\">Sharding Jdbc</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志系统\" target=\"_blank\" rel=\"noopener\">日志系统</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志搜集\" target=\"_blank\" rel=\"noopener\">日志搜集</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心\" target=\"_blank\" rel=\"noopener\">配置中心</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-网关\" target=\"_blank\" rel=\"noopener\">API 网关</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络\" target=\"_blank\" rel=\"noopener\">网络</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协议\" target=\"_blank\" rel=\"noopener\">协议</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七层协议\" target=\"_blank\" rel=\"noopener\">OSI 七层协议</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip\" target=\"_blank\" rel=\"noopener\">TCP/IP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http\" target=\"_blank\" rel=\"noopener\">HTTP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20\" target=\"_blank\" rel=\"noopener\">HTTP2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https\" target=\"_blank\" rel=\"noopener\">HTTPS</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络模型\" target=\"_blank\" rel=\"noopener\">网络模型</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-nio\" target=\"_blank\" rel=\"noopener\">Java NIO</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue\" target=\"_blank\" rel=\"noopener\">kqueue</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接和短连接\" target=\"_blank\" rel=\"noopener\">连接和短连接</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架\" target=\"_blank\" rel=\"noopener\">框架</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷贝zero-copy\" target=\"_blank\" rel=\"noopener\">零拷贝（Zero-copy）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二进制协议\" target=\"_blank\" rel=\"noopener\">序列化(二进制协议)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian\" target=\"_blank\" rel=\"noopener\">Hessian</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf\" target=\"_blank\" rel=\"noopener\">Protobuf</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库\" target=\"_blank\" rel=\"noopener\">数据库</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论\" target=\"_blank\" rel=\"noopener\">基础理论</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库设计的三大范式\" target=\"_blank\" rel=\"noopener\">数据库设计的三大范式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql\" target=\"_blank\" rel=\"noopener\">MySQL</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理\" target=\"_blank\" rel=\"noopener\">原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb\" target=\"_blank\" rel=\"noopener\">InnoDB</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#优化\" target=\"_blank\" rel=\"noopener\">优化</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引\" target=\"_blank\" rel=\"noopener\">索引</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引\" target=\"_blank\" rel=\"noopener\">聚集索引, 非聚集索引</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#复合索引\" target=\"_blank\" rel=\"noopener\">复合索引</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自适应哈希索引ahi\" target=\"_blank\" rel=\"noopener\">自适应哈希索引(AHI)</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain\" target=\"_blank\" rel=\"noopener\">explain</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql\" target=\"_blank\" rel=\"noopener\">NoSQL</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb\" target=\"_blank\" rel=\"noopener\">MongoDB</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase\" target=\"_blank\" rel=\"noopener\">Hbase</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎\" target=\"_blank\" rel=\"noopener\">搜索引擎</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎原理\" target=\"_blank\" rel=\"noopener\">搜索引擎原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene\" target=\"_blank\" rel=\"noopener\">Lucene</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch\" target=\"_blank\" rel=\"noopener\">Elasticsearch</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr\" target=\"_blank\" rel=\"noopener\">Solr</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx\" target=\"_blank\" rel=\"noopener\">sphinx</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能\" target=\"_blank\" rel=\"noopener\">性能</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能优化方法论\" target=\"_blank\" rel=\"noopener\">性能优化方法论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量评估\" target=\"_blank\" rel=\"noopener\">容量评估</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-网络\" target=\"_blank\" rel=\"noopener\">CDN 网络</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接池\" target=\"_blank\" rel=\"noopener\">连接池</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能调优\" target=\"_blank\" rel=\"noopener\">性能调优</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据\" target=\"_blank\" rel=\"noopener\">大数据</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式计算\" target=\"_blank\" rel=\"noopener\">流式计算</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm\" target=\"_blank\" rel=\"noopener\">Storm</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink\" target=\"_blank\" rel=\"noopener\">Flink</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream\" target=\"_blank\" rel=\"noopener\">Kafka Stream</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景-1\" target=\"_blank\" rel=\"noopener\">应用场景</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop\" target=\"_blank\" rel=\"noopener\">Hadoop</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs\" target=\"_blank\" rel=\"noopener\">HDFS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce\" target=\"_blank\" rel=\"noopener\">MapReduce</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn\" target=\"_blank\" rel=\"noopener\">Yarn</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark\" target=\"_blank\" rel=\"noopener\">Spark</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全\" target=\"_blank\" rel=\"noopener\">安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全\" target=\"_blank\" rel=\"noopener\">web 安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss\" target=\"_blank\" rel=\"noopener\">XSS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf\" target=\"_blank\" rel=\"noopener\">CSRF</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入\" target=\"_blank\" rel=\"noopener\">SQL 注入</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos\" target=\"_blank\" rel=\"noopener\">Hash Dos</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#脚本注入\" target=\"_blank\" rel=\"noopener\">脚本注入</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞扫描工具\" target=\"_blank\" rel=\"noopener\">漏洞扫描工具</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#验证码\" target=\"_blank\" rel=\"noopener\">验证码</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防范\" target=\"_blank\" rel=\"noopener\">DDoS 防范</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#用户隐私信息保护\" target=\"_blank\" rel=\"noopener\">用户隐私信息保护</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化漏洞\" target=\"_blank\" rel=\"noopener\">序列化漏洞</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密\" target=\"_blank\" rel=\"noopener\">加密解密</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#对称加密\" target=\"_blank\" rel=\"noopener\">对称加密</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#哈希算法\" target=\"_blank\" rel=\"noopener\">哈希算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非对称加密\" target=\"_blank\" rel=\"noopener\">非对称加密</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务器安全\" target=\"_blank\" rel=\"noopener\">服务器安全</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据安全\" target=\"_blank\" rel=\"noopener\">数据安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据备份\" target=\"_blank\" rel=\"noopener\">数据备份</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络隔离\" target=\"_blank\" rel=\"noopener\">网络隔离</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#内外网分离\" target=\"_blank\" rel=\"noopener\">内外网分离</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登录跳板机\" target=\"_blank\" rel=\"noopener\">登录跳板机</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授权认证\" target=\"_blank\" rel=\"noopener\">授权、认证</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac\" target=\"_blank\" rel=\"noopener\">RBAC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20\" target=\"_blank\" rel=\"noopener\">OAuth2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#双因素认证2fa\" target=\"_blank\" rel=\"noopener\">双因素认证（2FA）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单点登录sso\" target=\"_blank\" rel=\"noopener\">单点登录(SSO)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用开源框架\" target=\"_blank\" rel=\"noopener\">常用开源框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源协议\" target=\"_blank\" rel=\"noopener\">开源协议</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志框架\" target=\"_blank\" rel=\"noopener\">日志框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2\" target=\"_blank\" rel=\"noopener\">Log4j、Log4j2</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback\" target=\"_blank\" rel=\"noopener\">Logback</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm\" target=\"_blank\" rel=\"noopener\">ORM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络框架\" target=\"_blank\" rel=\"noopener\">网络框架</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架\" target=\"_blank\" rel=\"noopener\">Web 框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族\" target=\"_blank\" rel=\"noopener\">Spring 家族</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架\" target=\"_blank\" rel=\"noopener\">工具框架</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式设计\" target=\"_blank\" rel=\"noopener\">分布式设计</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#扩展性设计\" target=\"_blank\" rel=\"noopener\">扩展性设计</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#稳定性--高可用\" target=\"_blank\" rel=\"noopener\">稳定性 &amp; 高可用</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬件负载均衡\" target=\"_blank\" rel=\"noopener\">硬件负载均衡</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#软件负载均衡\" target=\"_blank\" rel=\"noopener\">软件负载均衡</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流\" target=\"_blank\" rel=\"noopener\">限流</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用层容灾\" target=\"_blank\" rel=\"noopener\">应用层容灾</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨机房容灾\" target=\"_blank\" rel=\"noopener\">跨机房容灾</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容灾演练流程\" target=\"_blank\" rel=\"noopener\">容灾演练流程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑启动\" target=\"_blank\" rel=\"noopener\">平滑启动</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库扩展\" target=\"_blank\" rel=\"noopener\">数据库扩展</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#读写分离模式\" target=\"_blank\" rel=\"noopener\">读写分离模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式\" target=\"_blank\" rel=\"noopener\">分片模式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务治理\" target=\"_blank\" rel=\"noopener\">服务治理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务注册与发现\" target=\"_blank\" rel=\"noopener\">服务注册与发现</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务路由控制\" target=\"_blank\" rel=\"noopener\">服务路由控制</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致\" target=\"_blank\" rel=\"noopener\">分布式一致</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-与-base-理论\" target=\"_blank\" rel=\"noopener\">CAP 与 BASE 理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式锁\" target=\"_blank\" rel=\"noopener\">分布式锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致性算法\" target=\"_blank\" rel=\"noopener\">分布式一致性算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos\" target=\"_blank\" rel=\"noopener\">PAXOS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab\" target=\"_blank\" rel=\"noopener\">Zab</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft\" target=\"_blank\" rel=\"noopener\">Raft</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip\" target=\"_blank\" rel=\"noopener\">Gossip</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#两阶段提交多阶段提交\" target=\"_blank\" rel=\"noopener\">两阶段提交、多阶段提交</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#幂等\" target=\"_blank\" rel=\"noopener\">幂等</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致方案\" target=\"_blank\" rel=\"noopener\">分布式一致方案</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式-leader-节点选举\" target=\"_blank\" rel=\"noopener\">分布式 Leader 节点选举</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事务\" target=\"_blank\" rel=\"noopener\">TCC(Try/Confirm/Cancel) 柔性事务</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式文件系统\" target=\"_blank\" rel=\"noopener\">分布式文件系统</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成\" target=\"_blank\" rel=\"noopener\">唯一ID 生成</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全局唯一id\" target=\"_blank\" rel=\"noopener\">全局唯一ID</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash算法\" target=\"_blank\" rel=\"noopener\">一致性Hash算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计思想--开发模式\" target=\"_blank\" rel=\"noopener\">设计思想 &amp; 开发模式</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---领域驱动设计\" target=\"_blank\" rel=\"noopener\">DDD(Domain-driven Design - 领域驱动设计)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查询职责分离cqrs\" target=\"_blank\" rel=\"noopener\">命令查询职责分离(CQRS)</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贫血充血模型\" target=\"_blank\" rel=\"noopener\">贫血，充血模型</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式\" target=\"_blank\" rel=\"noopener\">Actor 模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#响应式编程\" target=\"_blank\" rel=\"noopener\">响应式编程</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#reactor\" target=\"_blank\" rel=\"noopener\">Reactor</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rxjava\" target=\"_blank\" rel=\"noopener\">RxJava</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vertx\" target=\"_blank\" rel=\"noopener\">Vert.x</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20\" target=\"_blank\" rel=\"noopener\">DODAF2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless\" target=\"_blank\" rel=\"noopener\">Serverless</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#service-mesh\" target=\"_blank\" rel=\"noopener\">Service Mesh</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#项目管理\" target=\"_blank\" rel=\"noopener\">项目管理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构评审\" target=\"_blank\" rel=\"noopener\">架构评审</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重构\" target=\"_blank\" rel=\"noopener\">重构</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码规范\" target=\"_blank\" rel=\"noopener\">代码规范</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码-review\" target=\"_blank\" rel=\"noopener\">代码 Review</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup\" target=\"_blank\" rel=\"noopener\">RUP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理\" target=\"_blank\" rel=\"noopener\">看板管理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum\" target=\"_blank\" rel=\"noopener\">SCRUM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷开发\" target=\"_blank\" rel=\"noopener\">敏捷开发</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#极限编程xp\" target=\"_blank\" rel=\"noopener\">极限编程（XP）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#结对编程\" target=\"_blank\" rel=\"noopener\">结对编程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#fmea管理模式\" target=\"_blank\" rel=\"noopener\">FMEA管理模式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用业务术语\" target=\"_blank\" rel=\"noopener\">通用业务术语</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术趋势\" target=\"_blank\" rel=\"noopener\">技术趋势</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#政策法规\" target=\"_blank\" rel=\"noopener\">政策、法规</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#法律\" target=\"_blank\" rel=\"noopener\">法律</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#严格遵守刑法253法条\" target=\"_blank\" rel=\"noopener\">严格遵守刑法253法条</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构师素质\" target=\"_blank\" rel=\"noopener\">架构师素质</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队管理\" target=\"_blank\" rel=\"noopener\">团队管理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘\" target=\"_blank\" rel=\"noopener\">招聘</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#资讯\" target=\"_blank\" rel=\"noopener\">资讯</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业资讯\" target=\"_blank\" rel=\"noopener\">行业资讯</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公众号列表\" target=\"_blank\" rel=\"noopener\">公众号列表</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#博客\" target=\"_blank\" rel=\"noopener\">博客</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队博客\" target=\"_blank\" rel=\"noopener\">团队博客</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#个人博客\" target=\"_blank\" rel=\"noopener\">个人博客</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合门户社区\" target=\"_blank\" rel=\"noopener\">综合门户、社区</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#问答讨论类社区\" target=\"_blank\" rel=\"noopener\">问答、讨论类社区</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业数据分析\" target=\"_blank\" rel=\"noopener\">行业数据分析</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#专项网站\" target=\"_blank\" rel=\"noopener\">专项网站</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他类\" target=\"_blank\" rel=\"noopener\">其他类</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐参考书\" target=\"_blank\" rel=\"noopener\">推荐参考书</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线电子书\" target=\"_blank\" rel=\"noopener\">在线电子书</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#纸质书\" target=\"_blank\" rel=\"noopener\">纸质书</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开发方面\" target=\"_blank\" rel=\"noopener\">开发方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构方面\" target=\"_blank\" rel=\"noopener\">架构方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术管理方面\" target=\"_blank\" rel=\"noopener\">技术管理方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论-1\" target=\"_blank\" rel=\"noopener\">基础理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面\" target=\"_blank\" rel=\"noopener\">工具方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据方面\" target=\"_blank\" rel=\"noopener\">大数据方面</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术资源\" target=\"_blank\" rel=\"noopener\">技术资源</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源资源\" target=\"_blank\" rel=\"noopener\">开源资源</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手册文档教程\" target=\"_blank\" rel=\"noopener\">手册、文档、教程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线课堂\" target=\"_blank\" rel=\"noopener\">在线课堂</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#会议活动\" target=\"_blank\" rel=\"noopener\">会议、活动</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app\" target=\"_blank\" rel=\"noopener\">常用APP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作\" target=\"_blank\" rel=\"noopener\">找工作</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具\" target=\"_blank\" rel=\"noopener\">工具</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码托管\" target=\"_blank\" rel=\"noopener\">代码托管</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件服务\" target=\"_blank\" rel=\"noopener\">文件服务</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合云服务商\" target=\"_blank\" rel=\"noopener\">综合云服务商</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vps\" target=\"_blank\" rel=\"noopener\">VPS</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>（Toc generated by <a href=\"https://github.com/xingshaocheng/simple-php-github-toc\" target=\"_blank\" rel=\"noopener\">simple-php-github-toc</a> ）</strong></p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/lemon-flm/p/7877898.html\" target=\"_blank\" rel=\"noopener\">《java队列——queue详细分析》</a></p>\n<ul>\n<li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li>\n<li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/mantu/p/5802393.html\" target=\"_blank\" rel=\"noopener\">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></p>\n</li>\n</ul>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_33642117/article/details/52040345\" target=\"_blank\" rel=\"noopener\">《Java Set集合的详解》</a></li>\n</ul>\n<h2 id=\"链表、数组\"><a href=\"#链表、数组\" class=\"headerlink\" title=\"链表、数组\"></a>链表、数组</h2><ul>\n<li><a href=\"https://blog.csdn.net/wz249863091/article/details/52853360\" target=\"_blank\" rel=\"noopener\">《Java集合详解–什么是List》</a></li>\n</ul>\n<h2 id=\"字典、关联数组\"><a href=\"#字典、关联数组\" class=\"headerlink\" title=\"字典、关联数组\"></a>字典、关联数组</h2><ul>\n<li><a href=\"https://baike.xsoftlab.net/view/250.html\" target=\"_blank\" rel=\"noopener\">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><a href=\"https://blog.csdn.net/javazejian/article/details/53362993\" target=\"_blank\" rel=\"noopener\">《java数据结构与算法之栈（Stack）设计与实现》</a></li>\n<li><a href=\"http://www.runoob.com/java/java-stack-class.html\" target=\"_blank\" rel=\"noopener\">《Java Stack 类》</a></li>\n<li><a href=\"https://blog.csdn.net/f2006116/article/details/51375225\" target=\"_blank\" rel=\"noopener\">《java stack的详细实现分析》</a><ul>\n<li>Stack 是线程安全的。</li>\n<li>内部使用数组保存数据，不够时翻倍。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/cai2016/article/details/52589952\" target=\"_blank\" rel=\"noopener\">《二叉树》</a></li>\n</ul>\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\" target=\"_blank\" rel=\"noopener\">《完全二叉树》</a><ul>\n<li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/polly333/p/4798944.html\" target=\"_blank\" rel=\"noopener\">《浅谈数据结构-平衡二叉树》</a></li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li>\n</ul>\n<h3 id=\"二叉查找树（BST）\"><a href=\"#二叉查找树（BST）\" class=\"headerlink\" title=\"二叉查找树（BST）\"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 七 二叉查找树》</a></li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ul>\n<li><a href=\"https://blog.csdn.net/sun_tttt/article/details/65445754\" target=\"_blank\" rel=\"noopener\">《最容易懂得红黑树》</a><ul>\n<li>添加阶段后，左旋或者右旋从而再次达到平衡。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li>\n</ul>\n<h3 id=\"B-，B-，B-树\"><a href=\"#B-，B-，B-树\" class=\"headerlink\" title=\"B-，B+，B*树\"></a>B-，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/aqzwss/article/details/53074186\" target=\"_blank\" rel=\"noopener\">《B-树，B+树，B*树详解》</a></li>\n<li><a href=\"https://blog.csdn.net/bigtree_3721/article/details/73632405\" target=\"_blank\" rel=\"noopener\">《B-树，B+树与B*树的优缺点比较》</a><ul>\n<li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。<h3 id=\"LSM-树\"><a href=\"#LSM-树\" class=\"headerlink\" title=\"LSM 树\"></a>LSM 树</h3></li>\n</ul>\n</li>\n</ul>\n<p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。<br>Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/dbanote/article/details/8897599\" target=\"_blank\" rel=\"noopener\">《LSM树 VS B+树》</a></p>\n<ul>\n<li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。</li>\n<li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014774781/article/details/52105708\" target=\"_blank\" rel=\"noopener\">《LSM树（Log-Structured Merge Tree）存储引擎》</a></p>\n<ul>\n<li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li>\n<li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li>\n<li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"BitSet\"><a href=\"#BitSet\" class=\"headerlink\" title=\"BitSet\"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p>\n<ul>\n<li><a href=\"http://www.runoob.com/java/java-bitset-class.html\" target=\"_blank\" rel=\"noopener\">《Java Bitset类》</a></li>\n<li><a href=\"https://blog.csdn.net/caiandyong/article/details/51581160\" target=\"_blank\" rel=\"noopener\">《Java BitSet（位集）》</a></li>\n</ul>\n<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\" target=\"_blank\" rel=\"noopener\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h2 id=\"排序、查找算法\"><a href=\"#排序、查找算法\" class=\"headerlink\" title=\"排序、查找算法\"></a>排序、查找算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\" target=\"_blank\" rel=\"noopener\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/shen-hua/p/5424059.html\" target=\"_blank\" rel=\"noopener\">《Java中的经典算法之选择排序（SelectionSort）》</a><ul>\n<li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li><a href=\"https://blog.csdn.net/shuaizai88/article/details/73250615\" target=\"_blank\" rel=\"noopener\">《冒泡排序的2种写法》</a><ul>\n<li>相邻元素前后交换、把最大的排到最后。</li>\n<li>时间复杂度 O(n²) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/hapjin/p/5517667.html\" target=\"_blank\" rel=\"noopener\">《排序算法总结之插入排序》</a></li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li><a href=\"http://developer.51cto.com/art/201403/430986.htm\" target=\"_blank\" rel=\"noopener\">《坐在马桶上看算法：快速排序》</a><ul>\n<li>一侧比另外一次都大或小。 <h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3></li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/chengxiao/p/6194356.html\" target=\"_blank\" rel=\"noopener\">《图解排序算法(四)之归并排序》</a><ul>\n<li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>TODO</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/chengxiao/p/6129630.html\" target=\"_blank\" rel=\"noopener\">《图解排序算法(三)之堆排序》</a><ul>\n<li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/suvllian/p/5495780.html\" target=\"_blank\" rel=\"noopener\">《计数排序和桶排序》</a><ul>\n<li>和桶排序过程比较像，差别在于桶的数量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li><a href=\"http://blog.51cto.com/ahalei/1362789\" target=\"_blank\" rel=\"noopener\">《【啊哈！算法】最快最简单的排序——桶排序》</a></li>\n<li><a href=\"https://blog.csdn.net/sunjinshengli/article/details/70738527\" target=\"_blank\" rel=\"noopener\">《排序算法（三）：计数排序与桶排序》</a><ul>\n<li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li>\n<li>每个桶单独进行排序，然后再遍历每个桶。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/51695211\" target=\"_blank\" rel=\"noopener\">《排序算法系列：基数排序》</a></li>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/3603669.html\" target=\"_blank\" rel=\"noopener\">《基数排序》</a></li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/coderising/p/5708632.html\" target=\"_blank\" rel=\"noopener\">《二分查找(java实现)》</a></p>\n<ul>\n<li>要求待查找的序列有序。</li>\n<li>时间复杂度 O(logN)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/maoyuanming0806/article/details/78176957\" target=\"_blank\" rel=\"noopener\">《java实现二分查找-两种方式》</a></p>\n<ul>\n<li>while + 递归。<h3 id=\"Java-中的排序工具\"><a href=\"#Java-中的排序工具\" class=\"headerlink\" title=\"Java 中的排序工具\"></a>Java 中的排序工具</h3></li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&amp;fps=1\" target=\"_blank\" rel=\"noopener\">《Arrays.sort和Collections.sort实现原理解析》</a><ul>\n<li>Collections.sort算法调用的是合并排序。</li>\n<li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。<br>核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。<br>优点：空间和时间效率都很高。<br>缺点：随着存入的元素数量增加，误算率随之增加。</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000002729689\" target=\"_blank\" rel=\"noopener\">《布隆过滤器 – 空间效率很高的数据结构》</a></li>\n<li><a href=\"https://blog.csdn.net/zdxiq000/article/details/57626464\" target=\"_blank\" rel=\"noopener\">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li>\n<li><a href=\"https://blog.csdn.net/qq_30242609/article/details/71024458\" target=\"_blank\" rel=\"noopener\">《基于Redis的布隆过滤器的实现》</a><ul>\n<li>基于 Redis 的 Bitmap 数据结构。</li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/47973715\" target=\"_blank\" rel=\"noopener\">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul>\n<li>使用Java中的 BitSet 类 和 加权和hash算法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h2><h3 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP）<br>核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\" target=\"_blank\" rel=\"noopener\">《字符串匹配的KMP算法》</a></li>\n</ul>\n<h2 id=\"深度优先、广度优先\"><a href=\"#深度优先、广度优先\" class=\"headerlink\" title=\"深度优先、广度优先\"></a>深度优先、广度优先</h2><ul>\n<li><a href=\"https://www.cnblogs.com/0kk470/p/7555033.html\" target=\"_blank\" rel=\"noopener\">《广度优先搜索BFS和深度优先搜索DFS》</a></li>\n</ul>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><ul>\n<li><a href=\"https://www.cnblogs.com/MrSaver/p/8641971.html\" target=\"_blank\" rel=\"noopener\">《算法：贪婪算法基础》</a></li>\n<li><a href=\"https://blog.csdn.net/a345017062/article/details/52443781\" target=\"_blank\" rel=\"noopener\">《常见算法及问题场景——贪心算法》</a></li>\n</ul>\n<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qfikh/article/details/51960331\" target=\"_blank\" rel=\"noopener\">《 五大常用算法之四：回溯法》</a></li>\n</ul>\n<h2 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luningcsdn/article/details/50930276\" target=\"_blank\" rel=\"noopener\">《α-β剪枝算法》</a></li>\n</ul>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ul>\n<li><a href=\"https://www.cnblogs.com/little-YTMM/p/5372680.html\" target=\"_blank\" rel=\"noopener\">《详解动态规划——邹博讲动态规划》</a></li>\n<li><a href=\"https://blog.csdn.net/yao_zi_jie/article/details/54580283\" target=\"_blank\" rel=\"noopener\">《动态规划算法的个人理解》</a></li>\n</ul>\n<h2 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/amds123/article/details/70173402\" target=\"_blank\" rel=\"noopener\">《带你搞懂朴素贝叶斯分类算法》</a></p>\n<ul>\n<li>P(B|A)=P(A|B)P(B)/P(A)</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html\" target=\"_blank\" rel=\"noopener\">《贝叶斯推断及其互联网应用1》</a></p>\n</li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html\" target=\"_blank\" rel=\"noopener\">《贝叶斯推断及其互联网应用2》</a></li>\n</ul>\n<h2 id=\"推荐算法\"><a href=\"#推荐算法\" class=\"headerlink\" title=\"推荐算法\"></a>推荐算法</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01\" target=\"_blank\" rel=\"noopener\">《推荐算法综述》</a></li>\n<li><a href=\"https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems\" target=\"_blank\" rel=\"noopener\">《TOP 10 开源的推荐系统简介》</a></li>\n</ul>\n<h2 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luoshixian099/article/details/51908175\" target=\"_blank\" rel=\"noopener\">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li>\n</ul>\n<h2 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_35644234/article/details/60870719\" target=\"_blank\" rel=\"noopener\">《Dijkstra算法详解》</a></li>\n</ul>\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h1><h2 id=\"Java-并发\"><a href=\"#Java-并发\" class=\"headerlink\" title=\"Java 并发\"></a>Java 并发</h2><ul>\n<li><a href=\"https://github.com/CL0610/Java-concurrency\" target=\"_blank\" rel=\"noopener\">Java 并发知识合集</a></li>\n<li><a href=\"https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png\" target=\"_blank\" rel=\"noopener\">JAVA并发知识图谱</a></li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><ul>\n<li><a href=\"http://www.importnew.com/18459.html\" target=\"_blank\" rel=\"noopener\">《40个Java多线程问题总结》</a></li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><ul>\n<li><a href=\"https://www.cnblogs.com/zhanht/p/5450325.html\" target=\"_blank\" rel=\"noopener\">《Java并发编程——线程安全及解决机制简介》</a></li>\n</ul>\n<h2 id=\"一致性、事务\"><a href=\"#一致性、事务\" class=\"headerlink\" title=\"一致性、事务\"></a>一致性、事务</h2><h3 id=\"事务-ACID-特性\"><a href=\"#事务-ACID-特性\" class=\"headerlink\" title=\"事务 ACID 特性\"></a>事务 ACID 特性</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012440687/article/details/52116108\" target=\"_blank\" rel=\"noopener\">《数据库事务ACID特性》</a></li>\n</ul>\n<h3 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h3><ul>\n<li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li>\n<li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li>\n<li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li>\n<li><p>序列化：所有事物串行处理（牺牲了效率）</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_33290787/article/details/51924963\" target=\"_blank\" rel=\"noopener\">《理解事务的4种隔离级别》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/z-sm/p/7245981.html\" target=\"_blank\" rel=\"noopener\">数据库事务的四大特性及事务隔离级别</a></p>\n</li>\n<li><p><a href=\"http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html\" target=\"_blank\" rel=\"noopener\">《MySQL的InnoDB的幻读问题 》</a></p>\n<ul>\n<li>幻读的例子非常清楚。</li>\n<li>通过 SELECT … FOR UPDATE 解决。</li>\n</ul>\n</li>\n<li><p><a href=\"http://database.51cto.com/art/201804/570101.htm\" target=\"_blank\" rel=\"noopener\">《一篇文章带你读懂MySQL和InnoDB》</a></p>\n<ul>\n<li>图解脏读、不可重复读、幻读问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/chenpingzhao/p/5065316.html\" target=\"_blank\" rel=\"noopener\">《【mysql】关于innodb中MVCC的一些理解》</a></p>\n<ul>\n<li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li>\n<li>MVCC 会产生幻读问题（更新时异常。）</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/whoamiyang/article/details/51901888\" target=\"_blank\" rel=\"noopener\">《轻松理解MYSQL MVCC 实现机制》</a></p>\n<ul>\n<li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li>\n<li>每次只操作比当前版本小（或等于）的 行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"Java中的锁和同步类\"><a href=\"#Java中的锁和同步类\" class=\"headerlink\" title=\"Java中的锁和同步类\"></a>Java中的锁和同步类</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/qifengshi/p/6831055.html\" target=\"_blank\" rel=\"noopener\">《Java中的锁分类》</a></p>\n<ul>\n<li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener\">《Java并发之AQS详解》</a></p>\n</li>\n<li><p><a href=\"http://cuisuqiang.iteye.com/blog/2020146\" target=\"_blank\" rel=\"noopener\">《Java中信号量 Semaphore》</a></p>\n<ul>\n<li>有数量控制</li>\n<li>申请用 acquire，申请不要则阻塞；释放用 release。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/davidwang456/p/6094947.html\" target=\"_blank\" rel=\"noopener\">《java开发中的Mutex vs Semaphore》</a></p>\n<ul>\n<li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"公平锁-amp-非公平锁\"><a href=\"#公平锁-amp-非公平锁\" class=\"headerlink\" title=\"公平锁 &amp; 非公平锁\"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/EthanWhite/article/details/55508357\" target=\"_blank\" rel=\"noopener\">《公平锁与非公平锁》</a><ul>\n<li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/zhiqian-ali/p/6200874.html\" target=\"_blank\" rel=\"noopener\">《【MySQL】悲观锁&amp;乐观锁》</a></p>\n<ul>\n<li>乐观锁的方式：版本号+重试方式</li>\n<li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/Lawson/p/5008741.html\" target=\"_blank\" rel=\"noopener\">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a></p>\n<ul>\n<li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li>\n<li>锁相同数据的不同索引条件可能会引起死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zejin2008/p/5262751.html\" target=\"_blank\" rel=\"noopener\">《Mysql并发时经典常见的死锁原因及解决方法》</a></p>\n</li>\n</ul>\n<h3 id=\"乐观锁-amp-CAS\"><a href=\"#乐观锁-amp-CAS\" class=\"headerlink\" title=\"乐观锁 &amp; CAS\"></a>乐观锁 &amp; CAS</h3><ul>\n<li><a href=\"http://www.importnew.com/20472.html\" target=\"_blank\" rel=\"noopener\">《乐观锁的一种实现方式——CAS》</a><ul>\n<li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ABA-问题\"><a href=\"#ABA-问题\" class=\"headerlink\" title=\"ABA 问题\"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/549294286/p/3766717.html\" target=\"_blank\" rel=\"noopener\">《Java CAS 和ABA问题》</a></li>\n<li><a href=\"https://blog.csdn.net/li954644351/article/details/50511879\" target=\"_blank\" rel=\"noopener\">《Java 中 ABA问题及避免》</a><ul>\n<li>AtomicStampedReference 和 AtomicStampedReference。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CopyOnWrite容器\"><a href=\"#CopyOnWrite容器\" class=\"headerlink\" title=\"CopyOnWrite容器\"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/hapjin/p/4840107.html\" target=\"_blank\" rel=\"noopener\">《JAVA中写时复制(Copy-On-Write)Map实现》</a></p>\n<ul>\n<li>实现读写分离，读取发生在原始数据上，写入发生在副本上。  </li>\n<li>不用加锁，通过最终一致实现一致性。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/a494303877/article/details/53404623\" target=\"_blank\" rel=\"noopener\">《聊聊并发-Java中的Copy-On-Write容器》</a></p>\n</li>\n</ul>\n<h3 id=\"RingBuffer\"><a href=\"#RingBuffer\" class=\"headerlink\" title=\"RingBuffer\"></a>RingBuffer</h3><ul>\n<li><a href=\"http://www.cnblogs.com/l00l/p/4115001.html\" target=\"_blank\" rel=\"noopener\">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li>\n</ul>\n<h3 id=\"可重入锁-amp-不可重入锁\"><a href=\"#可重入锁-amp-不可重入锁\" class=\"headerlink\" title=\"可重入锁 &amp; 不可重入锁\"></a>可重入锁 &amp; 不可重入锁</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/dj3839/p/6580765.html\" target=\"_blank\" rel=\"noopener\">《可重入锁和不可重入锁》</a></p>\n<ul>\n<li>通过简单代码举例说明可重入锁和不可重入锁。</li>\n<li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li>\n<li>可重入锁可以用户避免死锁。</li>\n<li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/baizhanshi/p/7211802.html\" target=\"_blank\" rel=\"noopener\">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a></p>\n<ul>\n<li>synchronized 使用方便，编译器来加锁，是非公平锁。</li>\n<li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li>\n<li>相同加锁场景下，推荐使用 synchronized。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"互斥锁-amp-共享锁\"><a href=\"#互斥锁-amp-共享锁\" class=\"headerlink\" title=\"互斥锁 &amp; 共享锁\"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。<br>共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/liang1101/p/6475555.html\" target=\"_blank\" rel=\"noopener\">《ReadWriteLock场景应用》</a></li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><ul>\n<li><a href=\"https://blog.csdn.net/yunfenglw/article/details/45950305\" target=\"_blank\" rel=\"noopener\">《“死锁”四个必要条件的合理解释》</a><ul>\n<li>互斥、持有、不可剥夺、环形等待。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014039577/article/details/52351626\" target=\"_blank\" rel=\"noopener\">Java如何查看死锁？</a></p>\n<ul>\n<li>JConsole 可以识别死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/bohu83/article/details/51135061\" target=\"_blank\" rel=\"noopener\">java多线程系列：死锁及检测</a></p>\n<ul>\n<li>jstack 可以显示死锁。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h2 id=\"计算机原理\"><a href=\"#计算机原理\" class=\"headerlink\" title=\"计算机原理\"></a>计算机原理</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000003692840\" target=\"_blank\" rel=\"noopener\">《操作系统基础知识——操作系统的原理，类型和结构》</a></li>\n</ul>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><h3 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/zero__007/article/details/54089730\" target=\"_blank\" rel=\"noopener\">《从Java视角理解CPU缓存和伪共享》</a></li>\n</ul>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>TODO</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ul>\n<li><a href=\"https://blog.csdn.net/asdf_1024/article/details/78978437\" target=\"_blank\" rel=\"noopener\">《线程的生命周期及状态转换详解》</a></li>\n</ul>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><ul>\n<li><a href=\"https://www.thinksaas.cn/group/topic/839375/\" target=\"_blank\" rel=\"noopener\">《终结python协程—-从yield到actor模型的实现》</a><ul>\n<li>线程的调度是由操作系统负责，协程调度是程序自行负责</li>\n<li>与线程相比，协程减少了无谓的操作系统切换.</li>\n<li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><ul>\n<li><a href=\"http://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\">《Linux 命令大全》</a></li>\n</ul>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"设计模式的六大原则\"><a href=\"#设计模式的六大原则\" class=\"headerlink\" title=\"设计模式的六大原则\"></a>设计模式的六大原则</h2><ul>\n<li><a href=\"https://blog.csdn.net/q291611265/article/details/48465113\" target=\"_blank\" rel=\"noopener\">《设计模式的六大原则》</a><ul>\n<li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li>\n<li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li>\n<li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li>\n<li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li>\n<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li>\n<li>合成复用原则：尽量使用合成/聚合,而不是使用继承。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"23种常见设计模式\"><a href=\"#23种常见设计模式\" class=\"headerlink\" title=\"23种常见设计模式\"></a>23种常见设计模式</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/design-pattern-tutorial.html\" target=\"_blank\" rel=\"noopener\">《设计模式》</a></li>\n<li><a href=\"https://www.cnblogs.com/susanws/p/5510229.html\" target=\"_blank\" rel=\"noopener\">《23种设计模式全解析》</a></li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li><p><a href=\"http://blog.jobbole.com/62314/\" target=\"_blank\" rel=\"noopener\">《细数JDK里的设计模式》</a></p>\n<ul>\n<li><p>结构型模式：</p>\n<ul>\n<li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li>\n<li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li>\n<li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li>\n<li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li>\n<li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li>\n<li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li>\n</ul>\n</li>\n<li><p>创建模式:</p>\n<ul>\n<li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li>\n<li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li>\n<li>工厂方法：就是 <strong>一个返*</strong> 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li>\n<li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li>\n<li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li>\n</ul>\n</li>\n<li>行为模式：<ul>\n<li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li>\n<li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li>\n<li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li>\n<li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li>\n<li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li>\n<li>空对象模式：如 java.util.Collections#emptyList()。</li>\n<li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li>\n<li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/hwaggLee/p/4510687.html\" target=\"_blank\" rel=\"noopener\">《Spring-涉及到的设计模式汇总》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/u012387062/article/details/54719114\" target=\"_blank\" rel=\"noopener\">《Mybatis使用的设计模式》</a></li>\n</ul>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><ul>\n<li><a href=\"https://blog.csdn.net/YECrazy/article/details/79481964\" target=\"_blank\" rel=\"noopener\">《单例模式的三种实现 以及各自的优缺点》</a></li>\n<li><a href=\"https://www.cnblogs.com/ttylinux/p/6498822.html\" target=\"_blank\" rel=\"noopener\">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul>\n<li>使用枚举类型。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>TODO</p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/mvc-pattern.html\" target=\"_blank\" rel=\"noopener\">《MVC 模式》</a><ul>\n<li>模型(model)－视图(view)－控制器(controller) </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/23277575\" target=\"_blank\" rel=\"noopener\">《理解 IOC》</a></li>\n<li><a href=\"https://www.cnblogs.com/NancyStartOnce/p/6813162.html\" target=\"_blank\" rel=\"noopener\">《IOC 的理解与解释》</a><ul>\n<li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li>\n<li>作用：用于模块解耦。</li>\n<li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><ul>\n<li><a href=\"https://my.oschina.net/yanquan345/blog/203415\" target=\"_blank\" rel=\"noopener\">《轻松理解AOP(面向切面编程)》</a></li>\n<li><a href=\"https://www.cnblogs.com/hongwz/p/5764917.html\" target=\"_blank\" rel=\"noopener\">《Spring AOP详解》</a></li>\n<li><a href=\"http://www.importnew.com/24305.html\" target=\"_blank\" rel=\"noopener\">《Spring AOP的实现原理》</a><ul>\n<li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li>\n</ul>\n</li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/\" target=\"_blank\" rel=\"noopener\">《Spring AOP 实现原理与 CGLIB 应用》</a><ul>\n<li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><ul>\n<li><a href=\"https://www.w3cschool.cn/uml_tutorial/\" target=\"_blank\" rel=\"noopener\">《UML教程》</a></li>\n</ul>\n<h2 id=\"微服务思想\"><a href=\"#微服务思想\" class=\"headerlink\" title=\"微服务思想\"></a>微服务思想</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/6219259.html\" target=\"_blank\" rel=\"noopener\">《微服务架构设计》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/micro-service-technology-stack\" target=\"_blank\" rel=\"noopener\">《微服务架构技术栈选型手册》</a></li>\n</ul>\n<h3 id=\"康威定律\"><a href=\"#康威定律\" class=\"headerlink\" title=\"康威定律\"></a>康威定律</h3><ul>\n<li><p><a href=\"https://yq.aliyun.com/articles/8611\" target=\"_blank\" rel=\"noopener\">《微服务架构的理论基础 - 康威定律》</a></p>\n<ul>\n<li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li>\n<li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li>\n<li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li>\n<li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li>\n</ul>\n</li>\n<li><p><a href=\"https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf\" target=\"_blank\" rel=\"noopener\">《微服务架构核⼼20讲》</a></p>\n</li>\n</ul>\n<h1 id=\"运维-amp-统计-amp-技术支持\"><a href=\"#运维-amp-统计-amp-技术支持\" class=\"headerlink\" title=\"运维 &amp; 统计 &amp; 技术支持\"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id=\"常规监控\"><a href=\"#常规监控\" class=\"headerlink\" title=\"常规监控\"></a>常规监控</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/77849205\" target=\"_blank\" rel=\"noopener\">《腾讯业务系统监控的修炼之路》</a></p>\n<ul>\n<li>监控的方式：主动、被动、旁路(比如舆情监控)</li>\n<li>监控类型： 基础监控、服务端监控、客户端监控、<br>监控、用户端监控</li>\n<li>监控的目标：全、块、准</li>\n<li>核心指标：请求量、成功率、耗时</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.oschina.net/news/67525/monitoring-tools\" target=\"_blank\" rel=\"noopener\">《开源还是商用？十大云运维监控工具横评》</a></p>\n<ul>\n<li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li>\n</ul>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/201612/525373.htm\" target=\"_blank\" rel=\"noopener\">《监控报警系统搭建及二次开发经验》</a></p>\n</li>\n</ul>\n<p><strong>命令行监控工具</strong></p>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html\" target=\"_blank\" rel=\"noopener\">《常用命令行监控工具》</a></p>\n<ul>\n<li>top、sar、tsar、nload</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.jobbole.com/96846/\" target=\"_blank\" rel=\"noopener\">《20个命令行工具监控 Linux 系统性能》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/feichexia/blog/196575\" target=\"_blank\" rel=\"noopener\">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></p>\n</li>\n</ul>\n<h2 id=\"APM\"><a href=\"#APM\" class=\"headerlink\" title=\"APM\"></a>APM</h2><p>APM —  Application Performance Management</p>\n<ul>\n<li><p><a href=\"http://bigbully.github.io/Dapper-translation/\" target=\"_blank\" rel=\"noopener\">《Dapper，大规模分布式系统的跟踪系统》</a></p>\n</li>\n<li><p><a href=\"http://opentracing.io\" target=\"_blank\" rel=\"noopener\">CNCF OpenTracing</a>，<a href=\"https://github.com/opentracing-contrib/opentracing-specification-zh\" target=\"_blank\" rel=\"noopener\">中文版</a></p>\n</li>\n<li><p>主要开源软件，按字母排序</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-skywalking\" target=\"_blank\" rel=\"noopener\">Apache SkyWalking</a></li>\n<li><a href=\"https://github.com/dianping/cat\" target=\"_blank\" rel=\"noopener\">CAT</a></li>\n<li><a href=\"https://github.com/jaegertracing/jaeger\" target=\"_blank\" rel=\"noopener\">CNCF jaeger</a></li>\n<li><a href=\"https://github.com/naver/pinpoint\" target=\"_blank\" rel=\"noopener\">Pinpoint</a></li>\n<li><a href=\"https://github.com/openzipkin/zipkin\" target=\"_blank\" rel=\"noopener\">Zipkin</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/apm-Pinpoint-practice\" target=\"_blank\" rel=\"noopener\">《开源APM技术选型与实战》</a></p>\n<ul>\n<li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"统计分析\"><a href=\"#统计分析\" class=\"headerlink\" title=\"统计分析\"></a>统计分析</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/25195217\" target=\"_blank\" rel=\"noopener\">《流量统计的基础：埋点》</a></p>\n<ul>\n<li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.25xt.com/company/17066.html\" target=\"_blank\" rel=\"noopener\">《APP埋点常用的统计工具、埋点目标和埋点内容》</a></p>\n<ul>\n<li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li>\n</ul>\n</li>\n<li><p><a href=\"https://tech.meituan.com/mt-mobile-analytics-practice.html\" target=\"_blank\" rel=\"noopener\">《美团点评前端无痕埋点实践》</a></p>\n<ul>\n<li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"持续集成-CI-CD\"><a href=\"#持续集成-CI-CD\" class=\"headerlink\" title=\"持续集成(CI/CD)\"></a>持续集成(CI/CD)</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">《持续集成是什么？》</a></li>\n<li><a href=\"https://www.testwo.com/article/1170\" target=\"_blank\" rel=\"noopener\">《8个流行的持续集成工具》</a></li>\n</ul>\n<h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000\" target=\"_blank\" rel=\"noopener\">《使用Jenkins进行持续集成》</a></li>\n</ul>\n<h3 id=\"环境分离\"><a href=\"#环境分离\" class=\"headerlink\" title=\"环境分离\"></a>环境分离</h3><p>开发、测试、生成环境分离。</p>\n<ul>\n<li><a href=\"https://my.oschina.net/sancuo/blog/214904\" target=\"_blank\" rel=\"noopener\">《开发环境、生产环境、测试环境的基本理解和区》</a></li>\n</ul>\n<h2 id=\"自动化运维\"><a href=\"#自动化运维\" class=\"headerlink\" title=\"自动化运维\"></a>自动化运维</h2><h3 id=\"Ansible\"><a href=\"#Ansible\" class=\"headerlink\" title=\"Ansible\"></a>Ansible</h3><ul>\n<li><a href=\"http://www.ansible.com.cn/\" target=\"_blank\" rel=\"noopener\">《Ansible中文权威指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/heiye123/articles/7855890.html\" target=\"_blank\" rel=\"noopener\">《Ansible基础配置和企业级项目实用案例》</a></li>\n</ul>\n<h3 id=\"puppet\"><a href=\"#puppet\" class=\"headerlink\" title=\"puppet\"></a>puppet</h3><ul>\n<li><a href=\"https://www.cnblogs.com/keerya/p/8040071.html\" target=\"_blank\" rel=\"noopener\">《自动化运维工具——puppet详解》</a></li>\n</ul>\n<h3 id=\"chef\"><a href=\"#chef\" class=\"headerlink\" title=\"chef\"></a>chef</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/\" target=\"_blank\" rel=\"noopener\">《Chef 的安装与使用》</a></li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"TDD-理论\"><a href=\"#TDD-理论\" class=\"headerlink\" title=\"TDD 理论\"></a>TDD 理论</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/62f16cd4fef3\" target=\"_blank\" rel=\"noopener\">《深度解读 - TDD（测试驱动开发）》</a><ul>\n<li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li>\n<li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyzm/p/6482886.html\" target=\"_blank\" rel=\"noopener\">《Java单元测试之JUnit篇》</a></li>\n<li><a href=\"https://blog.csdn.net/hotdust/article/details/53406086\" target=\"_blank\" rel=\"noopener\">《JUnit 4 与 TestNG 对比》</a><ul>\n<li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 </li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/wqetfg/article/details/50900512\" target=\"_blank\" rel=\"noopener\">《单元测试主要的测试功能点》</a><ul>\n<li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h3><ul>\n<li><a href=\"https://blog.csdn.net/blueheart20/article/details/52170790\" target=\"_blank\" rel=\"noopener\">《Apache ab 测试使用指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/binyue/p/6141088.html\" target=\"_blank\" rel=\"noopener\">《大型网站压力测试及优化方案》</a></li>\n<li><a href=\"http://news.chinabyte.com/466/14126966.shtml\" target=\"_blank\" rel=\"noopener\">《10大主流压力/负载/性能测试工具推荐》</a></li>\n<li><a href=\"http://quentinxxz.iteye.com/blog/2249799\" target=\"_blank\" rel=\"noopener\">《真实流量压测工具 tcpcopy应用浅析》</a></li>\n<li><a href=\"https://www.cnblogs.com/jwentest/p/7136727.html\" target=\"_blank\" rel=\"noopener\">《nGrinder 简易使用教程》</a></li>\n</ul>\n<h3 id=\"全链路压测\"><a href=\"#全链路压测\" class=\"headerlink\" title=\"全链路压测\"></a>全链路压测</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot\" target=\"_blank\" rel=\"noopener\">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30306892\" target=\"_blank\" rel=\"noopener\">《饿了么全链路压测的探索与实践》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28355759\" target=\"_blank\" rel=\"noopener\">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li>\n<li><a href=\"https://www.jianshu.com/p/27060fd61f72\" target=\"_blank\" rel=\"noopener\">《全链路压测经验》</a></li>\n</ul>\n<h3 id=\"A-B-、灰度、蓝绿测试\"><a href=\"#A-B-、灰度、蓝绿测试\" class=\"headerlink\" title=\"A/B 、灰度、蓝绿测试\"></a>A/B 、灰度、蓝绿测试</h3><ul>\n<li><a href=\"https://testerhome.com/topics/11165\" target=\"_blank\" rel=\"noopener\">《技术干货 | AB 测试和灰度发布探索及实践》</a></li>\n<li><p><a href=\"http://blog.51cto.com/purplegrape/1403123\" target=\"_blank\" rel=\"noopener\">《nginx 根据IP 进行灰度发布》</a></p>\n</li>\n<li><p><a href=\"https://www.v2ex.com/t/344341\" target=\"_blank\" rel=\"noopener\">《蓝绿部署、A/B 测试以及灰度发布》</a></p>\n</li>\n</ul>\n<h2 id=\"虚拟化\"><a href=\"#虚拟化\" class=\"headerlink\" title=\"虚拟化\"></a>虚拟化</h2><ul>\n<li><a href=\"https://blog.csdn.net/enweitech/article/details/52910082\" target=\"_blank\" rel=\"noopener\">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li>\n</ul>\n<h3 id=\"KVM\"><a href=\"#KVM\" class=\"headerlink\" title=\"KVM\"></a>KVM</h3><ul>\n<li><a href=\"http://blog.chinaunix.net/uid-20201831-id-5775661.html\" target=\"_blank\" rel=\"noopener\">《KVM详解，太详细太深入了，经典》</a></li>\n<li><a href=\"https://www.coderxing.com/kvm-install.html\" target=\"_blank\" rel=\"noopener\">《【图文】KVM 虚拟机安装详解》</a></li>\n</ul>\n<h3 id=\"Xen\"><a href=\"#Xen\" class=\"headerlink\" title=\"Xen\"></a>Xen</h3><ul>\n<li><a href=\"https://www.cnblogs.com/sddai/p/5931201.html\" target=\"_blank\" rel=\"noopener\">《Xen虚拟化基本原理详解》</a></li>\n</ul>\n<h3 id=\"OpenVZ\"><a href=\"#OpenVZ\" class=\"headerlink\" title=\"OpenVZ\"></a>OpenVZ</h3><ul>\n<li><a href=\"https://blog.csdn.net/longerzone/article/details/44829255\" target=\"_blank\" rel=\"noopener\">《开源Linux容器 OpenVZ 快速上手指南》</a></li>\n</ul>\n<h2 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h2><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ul>\n<li><a href=\"https://www.cnblogs.com/SzeCheng/p/6822905.html\" target=\"_blank\" rel=\"noopener\">《几张图帮你理解 docker 基本原理及快速入门》</a></li>\n<li><a href=\"https://draveness.me/docker\" target=\"_blank\" rel=\"noopener\">《Docker 核心技术与实现原理》</a></li>\n<li><a href=\"http://www.runoob.com/docker/docker-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Docker 教程》</a></li>\n</ul>\n<h2 id=\"云技术\"><a href=\"#云技术\" class=\"headerlink\" title=\"云技术\"></a>云技术</h2><h3 id=\"OpenStack\"><a href=\"#OpenStack\" class=\"headerlink\" title=\"OpenStack\"></a>OpenStack</h3><ul>\n<li><a href=\"https://www.cnblogs.com/klb561/p/8660264.html\" target=\"_blank\" rel=\"noopener\">《OpenStack构架知识梳理》</a></li>\n</ul>\n<h2 id=\"DevOps\"><a href=\"#DevOps\" class=\"headerlink\" title=\"DevOps\"></a>DevOps</h2><ul>\n<li><a href=\"https://www.cnblogs.com/jetzhang/p/6068773.html\" target=\"_blank\" rel=\"noopener\">《一分钟告诉你究竟DevOps是什么鬼？》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/detail-analysis-of-devops\" target=\"_blank\" rel=\"noopener\">《DevOps详解》</a></li>\n</ul>\n<h2 id=\"文档管理\"><a href=\"#文档管理\" class=\"headerlink\" title=\"文档管理\"></a>文档管理</h2><ul>\n<li><a href=\"http://www.confluence.cn/\" target=\"_blank\" rel=\"noopener\">Confluence-收费文档管理系统</a></li>\n<li>GitLab?</li>\n<li>Wiki</li>\n</ul>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><h2 id=\"Web-Server\"><a href=\"#Web-Server\" class=\"headerlink\" title=\"Web Server\"></a>Web Server</h2><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_25797077/article/details/52200722\" target=\"_blank\" rel=\"noopener\">《Ngnix的基本学习-多进程和Apache的比较》</a></p>\n<ul>\n<li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li>\n<li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/cunkouzh/p/5410154.html\" target=\"_blank\" rel=\"noopener\">《nginx与Apache的对比以及优缺点》</a></p>\n<ul>\n<li>nginx只适合静态和反向代理，不适合处理动态请求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"OpenResty\"><a href=\"#OpenResty\" class=\"headerlink\" title=\"OpenResty\"></a>OpenResty</h3><ul>\n<li><a href=\"http://openresty.org/cn/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://www.linkedkeeper.com/detail/blog.action?bid=1034\" target=\"_blank\" rel=\"noopener\">《浅谈 OpenResty》</a><ul>\n<li>通过 Lua 模块可以在Nginx上进行开发。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Apache-Httpd\"><a href=\"#Apache-Httpd\" class=\"headerlink\" title=\"Apache Httpd\"></a>Apache Httpd</h3><ul>\n<li><a href=\"http://httpd.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n</ul>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><h4 id=\"架构原理\"><a href=\"#架构原理\" class=\"headerlink\" title=\"架构原理\"></a>架构原理</h4><ul>\n<li><a href=\"https://www.cnblogs.com/hggen/p/6264475.html\" target=\"_blank\" rel=\"noopener\">《TOMCAT原理详解及请求过程》</a></li>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4706223.html\" target=\"_blank\" rel=\"noopener\">《Tomcat服务器原理详解》</a></li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/\" target=\"_blank\" rel=\"noopener\">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xlgen157387/article/details/79006434\" target=\"_blank\" rel=\"noopener\">《四张图带你了解Tomcat系统架构》</a></p>\n</li>\n<li><p><a href=\"https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/\" target=\"_blank\" rel=\"noopener\">《JBoss vs. Tomcat: Choosing A Java Application Server》</a></p>\n<ul>\n<li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li>\n<li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"调优方案\"><a href=\"#调优方案\" class=\"headerlink\" title=\"调优方案\"></a>调优方案</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/sunfenqing/p/7339058.html\" target=\"_blank\" rel=\"noopener\">《Tomcat 调优方案》</a></p>\n<ul>\n<li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.chinaunix.net/uid-20662363-id-3012760.html\" target=\"_blank\" rel=\"noopener\">《tomcat http协议与ajp协议》</a></p>\n</li>\n<li><a href=\"http://dmouse.iteye.com/blog/1354527\" target=\"_blank\" rel=\"noopener\">《AJP与HTTP比较和分析》</a><ul>\n<li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li>\n<li>并发高时，AJP协议优于HTTP协议。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Jetty\"><a href=\"#Jetty\" class=\"headerlink\" title=\"Jetty\"></a>Jetty</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jetty/\" target=\"_blank\" rel=\"noopener\">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li>\n<li><a href=\"https://blog.csdn.net/doutao6677/article/details/51957288\" target=\"_blank\" rel=\"noopener\">《jetty和tomcat优势比较》</a><ul>\n<li>架构比较:Jetty的架构比Tomcat的更为简单。</li>\n<li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li>\n<li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ul>\n<li><a href=\"https://blog.csdn.net/clementad/article/details/48229243\" target=\"_blank\" rel=\"noopener\">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li>\n</ul>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html\" target=\"_blank\" rel=\"noopener\">《HashMap本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html\" target=\"_blank\" rel=\"noopener\">《EhCache本地缓存》</a></p>\n<ul>\n<li>堆内、堆外、磁盘三级缓存。</li>\n<li>可按照缓存空间容量进行设置。</li>\n<li>按照时间、次数等过期策略。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html\" target=\"_blank\" rel=\"noopener\">《Guava Cache》</a></p>\n<ul>\n<li>简单轻量、无堆外、磁盘缓存。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html\" target=\"_blank\" rel=\"noopener\">《Nginx本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html\" target=\"_blank\" rel=\"noopener\">《Pagespeed—懒人工具，服务器端加速》</a></p>\n</li>\n</ul>\n<h2 id=\"客户端缓存\"><a href=\"#客户端缓存\" class=\"headerlink\" title=\"客户端缓存\"></a>客户端缓存</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html\" target=\"_blank\" rel=\"noopener\">《浏览器端缓存》</a></p>\n<ul>\n<li>主要是利用 Cache-Control 参数。</li>\n</ul>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w\" target=\"_blank\" rel=\"noopener\">《H5 和移动端 WebView 缓存机制解析与实战》</a></p>\n</li>\n</ul>\n<h2 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a>服务端缓存</h2><h3 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h3><ul>\n<li><a href=\"https://github.com/jiangwenyuan/nuster\" target=\"_blank\" rel=\"noopener\">nuster</a> - nuster cache</li>\n<li><a href=\"https://github.com/varnishcache/varnish-cache\" target=\"_blank\" rel=\"noopener\">varnish</a> - varnish cache</li>\n<li><a href=\"https://github.com/squid-cache/squid\" target=\"_blank\" rel=\"noopener\">squid</a> - squid cache</li>\n</ul>\n<h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><ul>\n<li><a href=\"http://www.runoob.com/Memcached/Memcached-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Memcached 教程》</a></li>\n<li><a href=\"https://blog.csdn.net/chenleixing/article/details/47035453\" target=\"_blank\" rel=\"noopener\">《深入理解Memcached原理》</a><ul>\n<li>采用多路复用技术提高并发性。</li>\n<li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li>\n</ul>\n</li>\n<li><a href=\"https://www.jianshu.com/p/36e5cd400580\" target=\"_blank\" rel=\"noopener\">《Memcached软件工作原理》</a></li>\n<li><p><a href=\"http://zhihuzeye.com/archives/2361\" target=\"_blank\" rel=\"noopener\">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/liu251890347/article/details/37690045\" target=\"_blank\" rel=\"noopener\">《memcache 中 add 、 set 、replace 的区别》</a></p>\n<ul>\n<li>区别在于当key存在还是不存在时，返回值是true和false的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=\" target=\"_blank\" rel=\"noopener\"><strong>《memcached全面剖析》</strong></a></p>\n</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li><a href=\"http://www.runoob.com/redis/redis-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Redis 教程》</a></li>\n<li><a href=\"https://blog.csdn.net/wcf373722432/article/details/78678504\" target=\"_blank\" rel=\"noopener\">《redis底层原理》</a><ul>\n<li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li>\n<li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://doc.redisfans.com/topic/persistence.html\" target=\"_blank\" rel=\"noopener\">《Redis持久化方式》</a></p>\n<ul>\n<li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li>\n<li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li>\n<li>也可以两者结合使用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chunlongyu/article/details/53346436\" target=\"_blank\" rel=\"noopener\">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><a href=\"https://blog.csdn.net/sunhuiliang85/article/details/73656830\" target=\"_blank\" rel=\"noopener\">《Redis单线程架构》</a></li>\n</ul>\n<h4 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h4><ul>\n<li><a href=\"https://blog.csdn.net/qq_29108585/article/details/63251491\" target=\"_blank\" rel=\"noopener\">《redis的回收策略》</a></li>\n</ul>\n<h3 id=\"Tair\"><a href=\"#Tair\" class=\"headerlink\" title=\"Tair\"></a>Tair</h3><ul>\n<li><a href=\"https://github.com/alibaba/tair\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://blog.csdn.net/farphone/article/details/53522383\" target=\"_blank\" rel=\"noopener\">《Tair和Redis的对比》</a></li>\n<li>特点：可以配置备份节点数目，通过异步同步到备份节点</li>\n<li>一致性Hash算法。</li>\n<li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li>\n</ul>\n<p>几种存储引擎:</p>\n<ul>\n<li>MDB，完全内存性，可以用来存储Session等数据。</li>\n<li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li>\n<li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li>\n<li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li>\n</ul>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/charlesblc/p/6045238.html\" target=\"_blank\" rel=\"noopener\">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a></p>\n<ul>\n<li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li>\n<li>Kafka 默认是拉模式。</li>\n<li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li>\n<li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yunfeng482/article/details/72856762\" target=\"_blank\" rel=\"noopener\">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></p>\n</li>\n</ul>\n<h3 id=\"消息总线\"><a href=\"#消息总线\" class=\"headerlink\" title=\"消息总线\"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanghua_kobe/article/details/43877281\" target=\"_blank\" rel=\"noopener\">《消息总线VS消息队列》</a></li>\n</ul>\n<h3 id=\"消息的顺序\"><a href=\"#消息的顺序\" class=\"headerlink\" title=\"消息的顺序\"></a>消息的顺序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/cjsblog/p/8267892.html\" target=\"_blank\" rel=\"noopener\">《如何保证消费者接收消息的顺序》</a></li>\n</ul>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/whoamiyang/article/details/54954780\" target=\"_blank\" rel=\"noopener\">《RabbitMQ的应用场景以及基本原理介绍》</a></li>\n<li><a href=\"https://www.jianshu.com/p/79ca08116d57\" target=\"_blank\" rel=\"noopener\">《消息队列之 RabbitMQ》</a> </li>\n<li><a href=\"https://blog.csdn.net/u013256816/article/details/55515234\" target=\"_blank\" rel=\"noopener\">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li>\n</ul>\n<h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/824066d70da8\" target=\"_blank\" rel=\"noopener\">《RocketMQ 实战之快速入门》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/RocketMQ/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《RocketMQ 源码解析》</a></li>\n</ul>\n<h3 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/3962302.html\" target=\"_blank\" rel=\"noopener\">《ActiveMQ消息队列介绍》</a></li>\n</ul>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p>\n<ul>\n<li><a href=\"http://kafka.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/allthesametome/article/details/47362451\" target=\"_blank\" rel=\"noopener\">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li>\n<li><a href=\"http://lxw1234.com/archives/2015/10/538.htm\" target=\"_blank\" rel=\"noopener\">《Kafka分区机制介绍与示例》</a></li>\n</ul>\n<h3 id=\"Redis-消息推送\"><a href=\"#Redis-消息推送\" class=\"headerlink\" title=\"Redis 消息推送\"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_34212276/article/details/78455004\" target=\"_blank\" rel=\"noopener\">《Redis学习笔记之十：Redis用作消息队列》</a></li>\n</ul>\n<h3 id=\"ZeroMQ\"><a href=\"#ZeroMQ\" class=\"headerlink\" title=\"ZeroMQ\"></a>ZeroMQ</h3><p> TODO</p>\n<h2 id=\"定时调度\"><a href=\"#定时调度\" class=\"headerlink\" title=\"定时调度\"></a>定时调度</h2><h3 id=\"单机定时调度\"><a href=\"#单机定时调度\" class=\"headerlink\" title=\"单机定时调度\"></a>单机定时调度</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/shuaiqing/p/7742382.html\" target=\"_blank\" rel=\"noopener\">《linux定时任务cron配置》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/daquan/blog/483305\" target=\"_blank\" rel=\"noopener\">《Linux cron运行原理》</a></p>\n<ul>\n<li>fork 进程 + sleep 轮询</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/drift-ice/p/3817269.html\" target=\"_blank\" rel=\"noopener\">《Quartz使用总结》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/wenniuwuren/article/details/42082981/\" target=\"_blank\" rel=\"noopener\">《Quartz源码解析 —- 触发器按时启动原理》</a></li>\n<li><a href=\"https://www.jianshu.com/p/bab8e4e32952\" target=\"_blank\" rel=\"noopener\">《quartz原理揭秘和源码解读》</a><ul>\n<li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式定时调度\"><a href=\"#分布式定时调度\" class=\"headerlink\" title=\"分布式定时调度\"></a>分布式定时调度</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_16216221/article/details/70314337\" target=\"_blank\" rel=\"noopener\">《这些优秀的国产分布式任务调度系统，你用过几个？》</a></p>\n<ul>\n<li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html\" target=\"_blank\" rel=\"noopener\">《Quartz任务调度的基本实现原理》</a></p>\n<ul>\n<li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 </li>\n</ul>\n</li>\n<li><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Elastic-Job-Lite 源码解析》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Elastic-Job-Cloud 源码解析》</a></li>\n</ul>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/top_code/article/details/54615853\" target=\"_blank\" rel=\"noopener\">《从零开始实现RPC框架 - RPC原理及实现》</a></p>\n<ul>\n<li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/testcs_dn/article/details/78050590\" target=\"_blank\" rel=\"noopener\">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></p>\n</li>\n</ul>\n<h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li><a href=\"http://dubbo.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/steven520213/p/7606598.html\" target=\"_blank\" rel=\"noopener\">dubbo实现原理简单介绍</a></li>\n</ul>\n<p><strong> SPI </strong><br>TODO</p>\n<h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><ul>\n<li><a href=\"http://thrift.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/kesonyk/article/details/50924489\" target=\"_blank\" rel=\"noopener\">《Thrift RPC详解》</a><ul>\n<li>支持多语言，通过中间语言定义接口。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p>\n<ul>\n<li><a href=\"https://grpc.io/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/LBSer/p/4853234.html\" target=\"_blank\" rel=\"noopener\">《你应该知道的RPC原理》</a></li>\n</ul>\n<h2 id=\"数据库中间件\"><a href=\"#数据库中间件\" class=\"headerlink\" title=\"数据库中间件\"></a>数据库中间件</h2><h3 id=\"Sharding-Jdbc\"><a href=\"#Sharding-Jdbc\" class=\"headerlink\" title=\"Sharding Jdbc\"></a>Sharding Jdbc</h3><ul>\n<li><a href=\"http://shardingjdbc.io/\" target=\"_blank\" rel=\"noopener\">官网</a></li>\n</ul>\n<h2 id=\"日志系统\"><a href=\"#日志系统\" class=\"headerlink\" title=\"日志系统\"></a>日志系统</h2><h3 id=\"日志搜集\"><a href=\"#日志搜集\" class=\"headerlink\" title=\"日志搜集\"></a>日志搜集</h3><ul>\n<li><a href=\"http://cjting.me/misc/build-log-system-with-elkb/\" target=\"_blank\" rel=\"noopener\">《从零开始搭建一个ELKB日志收集系统》</a></li>\n<li><a href=\"https://blog.csdn.net/lzw_2006/article/details/51280058\" target=\"_blank\" rel=\"noopener\">《用ELK搭建简单的日志收集分析系统》</a></li>\n<li><a href=\"https://www.cnblogs.com/beginmind/p/6058194.html\" target=\"_blank\" rel=\"noopener\">《日志收集系统-探究》</a></li>\n</ul>\n<h2 id=\"配置中心\"><a href=\"#配置中心\" class=\"headerlink\" title=\"配置中心\"></a>配置中心</h2><ul>\n<li><p><a href=\"https://github.com/ctripcorp/apollo\" target=\"_blank\" rel=\"noopener\">Apollo - 携程开源的配置中心应用</a></p>\n<ul>\n<li>Spring Boot 和 Spring Cloud</li>\n<li>支持推、拉模式更新配置</li>\n<li>支持多种语言 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011320740/article/details/78742625\" target=\"_blank\" rel=\"noopener\">《基于zookeeper实现统一配置管理》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/shamo89/p/8016908.html\" target=\"_blank\" rel=\"noopener\">《 Spring Cloud Config 分布式配置中心使用教程》</a></p>\n</li>\n</ul>\n<p>servlet 3.0 异步特性可用于配置中心的客户端</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/dogdogwang/p/7151866.html\" target=\"_blank\" rel=\"noopener\">《servlet3.0 新特性——异步处理》</a></li>\n</ul>\n<h2 id=\"API-网关\"><a href=\"#API-网关\" class=\"headerlink\" title=\"API 网关\"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p>\n<ul>\n<li><a href=\"http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/\" target=\"_blank\" rel=\"noopener\">《API网关那些儿》</a></li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo\" target=\"_blank\" rel=\"noopener\">《谈API网关的背景、架构以及落地方案》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhanglh046/article/details/78651993\" target=\"_blank\" rel=\"noopener\">《使用Zuul构建API Gateway》</a></p>\n</li>\n<li><a href=\"http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Spring Cloud Gateway 源码解析》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A\" target=\"_blank\" rel=\"noopener\">《HTTP API网关选择之一Kong介绍》</a></li>\n</ul>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><h3 id=\"OSI-七层协议\"><a href=\"#OSI-七层协议\" class=\"headerlink\" title=\"OSI 七层协议\"></a>OSI 七层协议</h3><ul>\n<li><a href=\"https://www.cnblogs.com/Robin-YB/p/6668762.html\" target=\"_blank\" rel=\"noopener\">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li>\n</ul>\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/onepixel/p/7092302.html\" target=\"_blank\" rel=\"noopener\">《深入浅出 TCP/IP 协议》</a></li>\n<li><a href=\"https://blog.csdn.net/whuslei/article/details/6667471/\" target=\"_blank\" rel=\"noopener\">《TCP协议中的三次握手和四次挥手》</a></li>\n</ul>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wangning528/p/6388464.html\" target=\"_blank\" rel=\"noopener\">《http协议详解(超详细)》</a></li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li><a href=\"https://blog.csdn.net/zhuyiquan/article/details/69257126\" target=\"_blank\" rel=\"noopener\">《HTTP 2.0 原理详细分析》</a></li>\n<li><a href=\"https://blog.csdn.net/u012657197/article/details/77877840\" target=\"_blank\" rel=\"noopener\">《HTTP2.0的基本单位为二进制帧》</a><ul>\n<li>利用二进制帧负责传输。</li>\n<li>多路复用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/zhangshitong/p/6478721.html\" target=\"_blank\" rel=\"noopener\">《https原理通俗了解》</a></p>\n<ul>\n<li>使用非对称加密协商加密算法</li>\n<li>使用对称加密方式传输数据</li>\n<li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/53213862\" target=\"_blank\" rel=\"noopener\">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></p>\n</li>\n</ul>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><ul>\n<li><p><a href=\"http://blog.51cto.com/litaotao/1289790\" target=\"_blank\" rel=\"noopener\">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a></p>\n<ul>\n<li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li>\n<li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Anker/p/3265058.html\" target=\"_blank\" rel=\"noopener\">《select、poll、epoll之间的区别总结》</a></p>\n<ul>\n<li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li>\n<li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li>\n<li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li>\n<li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li>\n</ul>\n</li>\n<li><p><a href=\"http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/\" target=\"_blank\" rel=\"noopener\">《select，poll，epoll比较  》</a></p>\n<ul>\n<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/geason/p/5774096.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java NIO》</a></p>\n<ul>\n<li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/skiof007/article/details/52873421\" target=\"_blank\" rel=\"noopener\">《BIO与NIO、AIO的区别》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u013074465/article/details/46276967\" target=\"_blank\" rel=\"noopener\">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></p>\n</li>\n</ul>\n<h3 id=\"Epoll\"><a href=\"#Epoll\" class=\"headerlink\" title=\"Epoll\"></a>Epoll</h3><ul>\n<li><a href=\"https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html\" target=\"_blank\" rel=\"noopener\">《epoll使用详解（精髓）》</a></li>\n</ul>\n<h3 id=\"Java-NIO\"><a href=\"#Java-NIO\" class=\"headerlink\" title=\"Java NIO\"></a>Java NIO</h3><ul>\n<li><a href=\"https://www.cnblogs.com/geason/p/5774096.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java NIO》</a></li>\n<li><a href=\"https://blog.csdn.net/xidianliuy/article/details/51612676\" target=\"_blank\" rel=\"noopener\">《Java NIO编写Socket服务器的一个例子》</a></li>\n</ul>\n<h3 id=\"kqueue\"><a href=\"#kqueue\" class=\"headerlink\" title=\"kqueue\"></a>kqueue</h3><ul>\n<li><a href=\"http://www.cnblogs.com/luminocean/p/5631336.html\" target=\"_blank\" rel=\"noopener\">《kqueue用法简介》</a></li>\n</ul>\n<h2 id=\"连接和短连接\"><a href=\"#连接和短连接\" class=\"headerlink\" title=\"连接和短连接\"></a>连接和短连接</h2><ul>\n<li><a href=\"https://www.cnblogs.com/pangguoping/p/5571422.html\" target=\"_blank\" rel=\"noopener\">《TCP/IP系列——长连接与短连接的区别》</a></li>\n</ul>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><ul>\n<li><a href=\"https://blog.csdn.net/excellentyuxiao/article/details/53390408\" target=\"_blank\" rel=\"noopener\">《Netty原理剖析》</a><ul>\n<li>Reactor 模式介绍。</li>\n<li>Netty 是 Reactor 模式的一种实现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"零拷贝（Zero-copy）\"><a href=\"#零拷贝（Zero-copy）\" class=\"headerlink\" title=\"零拷贝（Zero-copy）\"></a>零拷贝（Zero-copy）</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\" target=\"_blank\" rel=\"noopener\">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul>\n<li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"序列化-二进制协议\"><a href=\"#序列化-二进制协议\" class=\"headerlink\" title=\"序列化(二进制协议)\"></a>序列化(二进制协议)</h2><h3 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyday56/p/4268249.html\" target=\"_blank\" rel=\"noopener\">《Hessian原理分析》</a><br>Binary-RPC;不仅仅是序列化</li>\n</ul>\n<h3 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h3><ul>\n<li><a href=\"https://blog.csdn.net/antgan/article/details/52103966\" target=\"_blank\" rel=\"noopener\">《Protobuf协议的Java应用例子》</a><br>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。</li>\n<li><p><a href=\"https://worktile.com/tech/share/prototol-buffers\" target=\"_blank\" rel=\"noopener\">《Protocol Buffers序列化协议及应用》</a></p>\n<pre><code>* 关于协议的解释；缺点：可读性差;\n</code></pre></li>\n<li><p><a href=\"https://blog.csdn.net/eric520zenobia/article/details/53766571\" target=\"_blank\" rel=\"noopener\">《简单的使用 protobuf 和 protostuff》</a></p>\n<ul>\n<li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"基础理论\"><a href=\"#基础理论\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h2><h3 id=\"数据库设计的三大范式\"><a href=\"#数据库设计的三大范式\" class=\"headerlink\" title=\"数据库设计的三大范式\"></a>数据库设计的三大范式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/waj6511988/p/7027127.html\" target=\"_blank\" rel=\"noopener\">《数据库的三大范式以及五大约束》</a><ul>\n<li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li>\n<li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>\n<li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li><p><a href=\"http://www.admin10000.com/document/5372.html\" target=\"_blank\" rel=\"noopener\">《MySQL的InnoDB索引原理详解》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xifeijian/article/details/20316775\" target=\"_blank\" rel=\"noopener\">《MySQL存储引擎－－MyISAM与InnoDB区别》</a></p>\n<ul>\n<li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201211/172380.html\" target=\"_blank\" rel=\"noopener\">《myisam和innodb索引实现的不同》</a></p>\n</li>\n</ul>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><ul>\n<li><a href=\"https://my.oschina.net/kailuncen/blog/1504217\" target=\"_blank\" rel=\"noopener\">《一篇文章带你读懂Mysql和InnoDB》</a></li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ul>\n<li><p><a href=\"http://vdisk.weibo.com/s/muWOT\" target=\"_blank\" rel=\"noopener\">《MySQL36条军规》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhouyusheng/p/8038224.html\" target=\"_blank\" rel=\"noopener\">《MYSQL性能优化的最佳20+条经验》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/when_less_is_more/article/details/70187459\" target=\"_blank\" rel=\"noopener\">《SQL优化之道》</a></li>\n<li><a href=\"https://www.cnblogs.com/sivkun/p/7518540.html\" target=\"_blank\" rel=\"noopener\">《mysql数据库死锁的产生原因及解决办法》</a></li>\n<li><a href=\"https://blog.csdn.net/monkey_d_feilong/article/details/52291556\" target=\"_blank\" rel=\"noopener\">《导致索引失效的可能情况》</a></li>\n<li><a href=\"https://blog.csdn.net/zy_281870667/article/details/51604540\" target=\"_blank\" rel=\"noopener\">《 MYSQL分页limit速度太慢优化方法》</a><ul>\n<li>原则上就是缩小扫描范围。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"聚集索引-非聚集索引\"><a href=\"#聚集索引-非聚集索引\" class=\"headerlink\" title=\"聚集索引, 非聚集索引\"></a>聚集索引, 非聚集索引</h4><ul>\n<li><a href=\"https://blog.csdn.net/no_endless/article/details/77073549\" target=\"_blank\" rel=\"noopener\">《MySQL 聚集索引/非聚集索引简述》</a></li>\n<li><a href=\"https://www.cnblogs.com/zlcxbb/p/5757245.html\" target=\"_blank\" rel=\"noopener\">《MyISAM和InnoDB的索引实现》</a></li>\n</ul>\n<p>MyISAM 是非聚集，InnoDB 是聚集</p>\n<h4 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h4><ul>\n<li><a href=\"https://www.cnblogs.com/summer0space/p/7247778.html\" target=\"_blank\" rel=\"noopener\">《复合索引的优点和注意事项》</a></li>\n</ul>\n<h4 id=\"自适应哈希索引-AHI\"><a href=\"#自适应哈希索引-AHI\" class=\"headerlink\" title=\"自适应哈希索引(AHI)\"></a>自适应哈希索引(AHI)</h4><ul>\n<li><a href=\"https://blog.csdn.net/Linux_ever/article/details/62043708\" target=\"_blank\" rel=\"noopener\">《InnoDB存储引擎——自适应哈希索引》</a></li>\n</ul>\n<h3 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008131735\" target=\"_blank\" rel=\"noopener\">《MySQL 性能优化神器 Explain 使用分析》</a></li>\n</ul>\n<h2 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h2><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><ul>\n<li><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\" target=\"_blank\" rel=\"noopener\">MongoDB 教程</a></li>\n<li><a href=\"http://mxdxm.iteye.com/blog/2093603\" target=\"_blank\" rel=\"noopener\">《Mongodb相对于关系型数据库的优缺点》</a><ul>\n<li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li>\n<li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hbase\"><a href=\"#Hbase\" class=\"headerlink\" title=\"Hbase\"></a>Hbase</h3><ul>\n<li><a href=\"http://www.thebigdata.cn/HBase/35831.html\" target=\"_blank\" rel=\"noopener\">《简明 HBase 入门教程（开篇）》</a></li>\n<li><a href=\"https://www.cnblogs.com/qiaoyihang/p/6246424.html\" target=\"_blank\" rel=\"noopener\">《深入学习HBase架构原理》</a></li>\n<li><a href=\"https://blog.csdn.net/youzhouliu/article/details/67632882\" target=\"_blank\" rel=\"noopener\">《传统的行存储和（HBase）列存储的区别》</a></li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/lifuxiangcaohui/article/details/39891099\" target=\"_blank\" rel=\"noopener\">《Hbase与传统数据库的区别》</a></p>\n<ul>\n<li>空数据不存储，节省空间，且适用于并发。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014091123/article/details/73163088\" target=\"_blank\" rel=\"noopener\">《HBase Rowkey设计》</a></p>\n<ul>\n<li>rowkey 按照字典顺序排列，便于批量扫描。</li>\n<li>通过散列可以避免热点。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h1><h2 id=\"搜索引擎原理\"><a href=\"#搜索引擎原理\" class=\"headerlink\" title=\"搜索引擎原理\"></a>搜索引擎原理</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/0193dc44135b\" target=\"_blank\" rel=\"noopener\">《倒排索引–搜索引擎入门》</a></li>\n</ul>\n<h2 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h2><ul>\n<li><a href=\"https://www.cnblogs.com/rodge-run/p/6551152.html\" target=\"_blank\" rel=\"noopener\">《Lucene入门简介》</a></li>\n</ul>\n<h2 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h2><ul>\n<li><a href=\"https://blog.csdn.net/laoyang360/article/details/52244917\" target=\"_blank\" rel=\"noopener\">《Elasticsearch学习，请先看这一篇！》</a></li>\n<li><a href=\"https://blog.csdn.net/cyony/article/details/65437708\" target=\"_blank\" rel=\"noopener\">《Elasticsearch索引原理》</a></li>\n</ul>\n<h2 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h2><ul>\n<li><a href=\"https://blog.csdn.net/u011936655/article/details/51960005\" target=\"_blank\" rel=\"noopener\">《 Apache Solr入门教程》</a></li>\n<li><a href=\"https://blog.csdn.net/convict_eva/article/details/53537837\" target=\"_blank\" rel=\"noopener\">《elasticsearch与solr比较》</a></li>\n</ul>\n<h2 id=\"sphinx\"><a href=\"#sphinx\" class=\"headerlink\" title=\"sphinx\"></a>sphinx</h2><ul>\n<li><a href=\"http://blog.jobbole.com/101672/\" target=\"_blank\" rel=\"noopener\">《Sphinx 的介绍和原理探索》</a></li>\n</ul>\n<h1 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h1><h2 id=\"性能优化方法论\"><a href=\"#性能优化方法论\" class=\"headerlink\" title=\"性能优化方法论\"></a>性能优化方法论</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread\" target=\"_blank\" rel=\"noopener\">《15天的性能优化工作，5方面的调优经验》</a></p>\n<ul>\n<li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/tenglizhe/article/details/44563135\" target=\"_blank\" rel=\"noopener\">《系统性能优化的几个方面》</a></p>\n</li>\n</ul>\n<h2 id=\"容量评估\"><a href=\"#容量评估\" class=\"headerlink\" title=\"容量评估\"></a>容量评估</h2><ul>\n<li><a href=\"https://blog.csdn.net/u012528360/article/details/70054156\" target=\"_blank\" rel=\"noopener\">《联网性能与容量评估的方法论和典型案例》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959542&amp;idx=1&amp;sn=2494bbea9a855e0e1c3ccd6d2562a600&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">《互联网架构，如何进行容量设计？》</a><ul>\n<li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CDN-网络\"><a href=\"#CDN-网络\" class=\"headerlink\" title=\"CDN 网络\"></a>CDN 网络</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wxiaona/p/5867685.html\" target=\"_blank\" rel=\"noopener\">《CDN加速原理》</a></li>\n<li><a href=\"https://www.zhihu.com/question/20536932\" target=\"_blank\" rel=\"noopener\">《国内有哪些比较好的 CDN？》</a></li>\n</ul>\n<h2 id=\"连接池\"><a href=\"#连接池\" class=\"headerlink\" title=\"连接池\"></a>连接池</h2><ul>\n<li><a href=\"https://blog.csdn.net/fysuccess/article/details/66972554\" target=\"_blank\" rel=\"noopener\">《主流Java数据库连接池比较与开发配置实战》</a></li>\n</ul>\n<h2 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h2><ul>\n<li><a href=\"https://blog.csdn.net/yethyeth/article/details/73266455\" target=\"_blank\" rel=\"noopener\">《九大Java性能调试工具，必备至少一款》</a></li>\n</ul>\n<h1 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h1><h2 id=\"流式计算\"><a href=\"#流式计算\" class=\"headerlink\" title=\"流式计算\"></a>流式计算</h2><h3 id=\"Storm\"><a href=\"#Storm\" class=\"headerlink\" title=\"Storm\"></a>Storm</h3><ul>\n<li><a href=\"http://storm.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/uisoul/article/details/77989927\" target=\"_blank\" rel=\"noopener\">《最详细的Storm入门教程》</a></li>\n</ul>\n<h3 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h3><ul>\n<li><a href=\"https://blog.csdn.net/lisi1129/article/details/54844919\" target=\"_blank\" rel=\"noopener\">《Flink之一 Flink基本原理介绍》</a></li>\n</ul>\n<h3 id=\"Kafka-Stream\"><a href=\"#Kafka-Stream\" class=\"headerlink\" title=\"Kafka Stream\"></a>Kafka Stream</h3><ul>\n<li><a href=\"https://yq.aliyun.com/articles/58382\" target=\"_blank\" rel=\"noopener\">《Kafka Stream调研：一种轻量级流计算模式》</a></li>\n</ul>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>例如：</p>\n<ul>\n<li>广告相关实时统计；</li>\n<li>推荐系统用户画像标签实时更新；</li>\n<li>线上服务健康状况实时监测；</li>\n<li>实时榜单；</li>\n<li>实时数据统计。</li>\n</ul>\n<h2 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h2><ul>\n<li><a href=\"https://blog.csdn.net/houbin0912/article/details/72967178\" target=\"_blank\" rel=\"noopener\">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li>\n<li><a href=\"http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html\" target=\"_blank\" rel=\"noopener\">《史上最详细的Hadoop环境搭建》</a></li>\n</ul>\n<h3 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000011575458\" target=\"_blank\" rel=\"noopener\">《【Hadoop学习】HDFS基本原理》</a></li>\n</ul>\n<h3 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h3><ul>\n<li><a href=\"https://blog.csdn.net/oppo62258801/article/details/72884633\" target=\"_blank\" rel=\"noopener\">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li>\n<li><a href=\"https://blog.csdn.net/foye12/article/details/78358292\" target=\"_blank\" rel=\"noopener\">《 简单的map-reduce的java例子》</a></li>\n</ul>\n<h3 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h3><ul>\n<li><a href=\"http://www.cnblogs.com/codeOfLife/p/5492740.html\" target=\"_blank\" rel=\"noopener\">《初步掌握Yarn的架构及原理》</a></li>\n</ul>\n<h2 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h2><ul>\n<li><a href=\"http://www.cnblogs.com/tgzhu/p/5818374.html\" target=\"_blank\" rel=\"noopener\">《Spark(一): 基本架构及原理》</a></li>\n</ul>\n<h1 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h1><h2 id=\"web-安全\"><a href=\"#web-安全\" class=\"headerlink\" title=\"web 安全\"></a>web 安全</h2><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><ul>\n<li><a href=\"https://blog.csdn.net/qq_21956483/article/details/54377947\" target=\"_blank\" rel=\"noopener\">《xss攻击原理与解决方法》</a><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html\" target=\"_blank\" rel=\"noopener\">《CSRF原理及防范》</a></li>\n</ul>\n<h3 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html\" target=\"_blank\" rel=\"noopener\">《SQL注入》</a></li>\n</ul>\n<h3 id=\"Hash-Dos\"><a href=\"#Hash-Dos\" class=\"headerlink\" title=\"Hash Dos\"></a>Hash Dos</h3><ul>\n<li><a href=\"http://www.freebuf.com/articles/web/14199.html\" target=\"_blank\" rel=\"noopener\">《邪恶的JAVA HASH DOS攻击》</a><ul>\n<li>利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li>\n</ul>\n</li>\n<li><a href=\"https://yq.aliyun.com/articles/92194?t=t1\" target=\"_blank\" rel=\"noopener\">《一种高级的DoS攻击-Hash碰撞攻击》</a></li>\n<li><a href=\"http://www.iteye.com/news/23939/\" target=\"_blank\" rel=\"noopener\">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li>\n</ul>\n<h3 id=\"脚本注入\"><a href=\"#脚本注入\" class=\"headerlink\" title=\"脚本注入\"></a>脚本注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html\" target=\"_blank\" rel=\"noopener\">《上传文件漏洞原理及防范》</a></li>\n</ul>\n<h3 id=\"漏洞扫描工具\"><a href=\"#漏洞扫描工具\" class=\"headerlink\" title=\"漏洞扫描工具\"></a>漏洞扫描工具</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html\" target=\"_blank\" rel=\"noopener\">《DVWA》</a></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html\" target=\"_blank\" rel=\"noopener\">W3af</a></li>\n<li><a href=\"https://blog.csdn.net/xygg0801/article/details/53610640\" target=\"_blank\" rel=\"noopener\">OpenVAS详解</a></li>\n</ul>\n<h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/niaonao/article/details/51112686\" target=\"_blank\" rel=\"noopener\">《验证码原理分析及实现》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/jiangbianwanghai/blog/1031031\" target=\"_blank\" rel=\"noopener\">《详解滑动验证码的实现原理》</a></p>\n<ul>\n<li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/xcj26/p/5242758.html\" target=\"_blank\" rel=\"noopener\">《淘宝滑动验证码研究》</a></p>\n</li>\n</ul>\n<h2 id=\"DDoS-防范\"><a href=\"#DDoS-防范\" class=\"headerlink\" title=\"DDoS 防范\"></a>DDoS 防范</h2><ul>\n<li><a href=\"http://netsecurity.51cto.com/art/201601/503799.htm\" target=\"_blank\" rel=\"noopener\">《学习手册：DDoS的攻击方式及防御手段》</a></li>\n<li><a href=\"http://netsecurity.51cto.com/art/201406/442756.htm\" target=\"_blank\" rel=\"noopener\">《免费DDoS攻击测试工具大合集》</a></li>\n</ul>\n<h2 id=\"用户隐私信息保护\"><a href=\"#用户隐私信息保护\" class=\"headerlink\" title=\"用户隐私信息保护\"></a>用户隐私信息保护</h2><ol>\n<li>用户密码非明文保存，加动态salt。</li>\n<li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li>\n<li>联系方式在的显示与否由用户自己控制。</li>\n<li>TODO</li>\n</ol>\n<ul>\n<li><a href=\"https://zhidao.baidu.com/question/1988017976673661587.html\" target=\"_blank\" rel=\"noopener\">《个人隐私包括哪些》</a></li>\n<li><p><a href=\"https://www.zhihu.com/question/20137108\" target=\"_blank\" rel=\"noopener\">《在互联网上，隐私的范围包括哪些？》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html\" target=\"_blank\" rel=\"noopener\">《用户密码保存》</a></p>\n</li>\n</ul>\n<h2 id=\"序列化漏洞\"><a href=\"#序列化漏洞\" class=\"headerlink\" title=\"序列化漏洞\"></a>序列化漏洞</h2><ul>\n<li><a href=\"https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/\" target=\"_blank\" rel=\"noopener\">《Lib之过？Java反序列化漏洞通用利用分析》</a></li>\n</ul>\n<h2 id=\"加密解密\"><a href=\"#加密解密\" class=\"headerlink\" title=\"加密解密\"></a>加密解密</h2><h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html\" target=\"_blank\" rel=\"noopener\">《常见对称加密算法》</a><ul>\n<li>DES、3DES、Blowfish、AES</li>\n<li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li>\n<li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html\" target=\"_blank\" rel=\"noopener\">《常用的哈希算法》</a></p>\n<ul>\n<li>MD5 和 SHA-1 已经不再安全，已被弃用。</li>\n<li>目前 SHA-256 是比较安全的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhangruhong168/article/details/78033202\" target=\"_blank\" rel=\"noopener\">《基于Hash摘要签名的公网URL签名验证设计方案》</a></p>\n</li>\n</ul>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html\" target=\"_blank\" rel=\"noopener\">《常见非对称加密算法》</a></p>\n<ul>\n<li>RSA、DSA、ECDSA(螺旋曲线加密算法)</li>\n<li>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li>\n<li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p>\n<p>  <a href=\"http://baijiahao.baidu.com/s?id=1578348858092033763&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">《区块链的加密技术》</a>    </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务器安全\"><a href=\"#服务器安全\" class=\"headerlink\" title=\"服务器安全\"></a>服务器安全</h2><ul>\n<li><a href=\"http://www.freebuf.com/articles/system/121540.html\" target=\"_blank\" rel=\"noopener\">《Linux强化论：15步打造一个安全的Linux服务器》</a></li>\n</ul>\n<h2 id=\"数据安全\"><a href=\"#数据安全\" class=\"headerlink\" title=\"数据安全\"></a>数据安全</h2><h3 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h3><p>TODO</p>\n<h2 id=\"网络隔离\"><a href=\"#网络隔离\" class=\"headerlink\" title=\"网络隔离\"></a>网络隔离</h2><h3 id=\"内外网分离\"><a href=\"#内外网分离\" class=\"headerlink\" title=\"内外网分离\"></a>内外网分离</h3><p>TODO</p>\n<h3 id=\"登录跳板机\"><a href=\"#登录跳板机\" class=\"headerlink\" title=\"登录跳板机\"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p>\n<ul>\n<li><a href=\"http://blog.51cto.com/zero01/2062618\" target=\"_blank\" rel=\"noopener\">《搭建简易堡垒机》</a></li>\n</ul>\n<h2 id=\"授权、认证\"><a href=\"#授权、认证\" class=\"headerlink\" title=\"授权、认证\"></a>授权、认证</h2><h3 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h3><ul>\n<li><a href=\"https://www.cnblogs.com/zq8024/p/5003050.html\" target=\"_blank\" rel=\"noopener\">《基于组织角色的权限设计》</a></li>\n<li><a href=\"https://www.cnblogs.com/shijiaqi1066/p/3793894.html\" target=\"_blank\" rel=\"noopener\">《权限系统与RBAC模型概述》</a></li>\n<li><a href=\"https://blog.csdn.net/he90227/article/details/38663553\" target=\"_blank\" rel=\"noopener\">《Spring整合Shiro做权限控制模块详细案例分析》</a></li>\n</ul>\n<h3 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">《理解OAuth 2.0》</a></li>\n<li><a href=\"https://www.cnblogs.com/flashsun/p/7424071.html\" target=\"_blank\" rel=\"noopener\">《一张图搞定OAuth2.0》</a></li>\n</ul>\n<h3 id=\"双因素认证（2FA）\"><a href=\"#双因素认证（2FA）\" class=\"headerlink\" title=\"双因素认证（2FA）\"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p>\n<p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p>\n<ul>\n<li>【《双因素认证（2FA）教程》】(<a href=\"http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li>\n</ul>\n<h3 id=\"单点登录-SSO\"><a href=\"#单点登录-SSO\" class=\"headerlink\" title=\"单点登录(SSO)\"></a>单点登录(SSO)</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/ywlaker/p/6113927.html\" target=\"_blank\" rel=\"noopener\">《单点登录原理与简单实现》</a></p>\n</li>\n<li><p><a href=\"https://github.com/apereo/cas\" target=\"_blank\" rel=\"noopener\">CAS单点登录框架</a></p>\n</li>\n</ul>\n<h1 id=\"常用开源框架\"><a href=\"#常用开源框架\" class=\"headerlink\" title=\"常用开源框架\"></a>常用开源框架</h1><h2 id=\"开源协议\"><a href=\"#开源协议\" class=\"headerlink\" title=\"开源协议\"></a>开源协议</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html\" target=\"_blank\" rel=\"noopener\">《开源协议的选择》</a></p>\n</li>\n<li><p><a href=\"http://choosealicense.online/\" target=\"_blank\" rel=\"noopener\">如何选择一个开源软件协议</a></p>\n</li>\n</ul>\n<h2 id=\"日志框架\"><a href=\"#日志框架\" class=\"headerlink\" title=\"日志框架\"></a>日志框架</h2><h3 id=\"Log4j、Log4j2\"><a href=\"#Log4j、Log4j2\" class=\"headerlink\" title=\"Log4j、Log4j2\"></a>Log4j、Log4j2</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012422446/article/details/51199724\" target=\"_blank\" rel=\"noopener\">《log4j 详细讲解》</a></li>\n<li><a href=\"https://blog.csdn.net/vbirdbest/article/details/71751835\" target=\"_blank\" rel=\"noopener\">《log4j2 实际使用详解》</a></li>\n<li><a href=\"https://my.oschina.net/OutOfMemory/blog/789267\" target=\"_blank\" rel=\"noopener\">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul>\n<li>Log4J 异步日志性能优异。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Logback\"><a href=\"#Logback\" class=\"headerlink\" title=\"Logback\"></a>Logback</h3><ul>\n<li><a href=\"https://blog.csdn.net/rulon147/article/details/52620541\" target=\"_blank\" rel=\"noopener\">《最全LogBack 详解、含java案例和配置说明》</a></li>\n</ul>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><ul>\n<li><a href=\"https://blog.csdn.net/sinat_34093604/article/details/53082000\" target=\"_blank\" rel=\"noopener\">《ORM框架使用优缺点》</a><ul>\n<li>主要目的是为了提高开发效率。 </li>\n</ul>\n</li>\n</ul>\n<p><strong>MyBatis：</strong></p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/winclpt/articles/7511672.html\" target=\"_blank\" rel=\"noopener\">《mybatis缓存机制详解》</a></p>\n<ul>\n<li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li>\n<li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/baidu_32877851/article/details/53959268\" target=\"_blank\" rel=\"noopener\">《MyBatis学习之代码生成器Generator》</a></p>\n</li>\n</ul>\n<h2 id=\"网络框架\"><a href=\"#网络框架\" class=\"headerlink\" title=\"网络框架\"></a>网络框架</h2><p>TODO</p>\n<h2 id=\"Web-框架\"><a href=\"#Web-框架\" class=\"headerlink\" title=\"Web 框架\"></a>Web 框架</h2><h3 id=\"Spring-家族\"><a href=\"#Spring-家族\" class=\"headerlink\" title=\"Spring 家族\"></a>Spring 家族</h3><p><strong>Spring</strong></p>\n<ul>\n<li><a href=\"https://www.w3cschool.cn/wkspring/\" target=\"_blank\" rel=\"noopener\">Spring 简明教程</a></li>\n</ul>\n<p><strong>Spring Boot</strong></p>\n<ul>\n<li><a href=\"http://projects.spring.io/spring-boot/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">《Spring Boot基础教程》</a></li>\n</ul>\n<p><strong>Spring Cloud</strong></p>\n<ul>\n<li><a href=\"http://springboot.fun/\" target=\"_blank\" rel=\"noopener\">Spring Boot 中文索引站</a></li>\n<li><a href=\"https://springcloud.cc/\" target=\"_blank\" rel=\"noopener\">Spring Cloud 中文文档</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">《Spring Cloud基础教程》</a></li>\n</ul>\n<h2 id=\"工具框架\"><a href=\"#工具框架\" class=\"headerlink\" title=\"工具框架\"></a>工具框架</h2><ul>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4872236.html\" target=\"_blank\" rel=\"noopener\">《Apache Commons 工具类介绍及简单使用》</a></li>\n<li><a href=\"http://ifeve.com/google-guava/\" target=\"_blank\" rel=\"noopener\">《Google guava 中文教程》</a></li>\n</ul>\n<h1 id=\"分布式设计\"><a href=\"#分布式设计\" class=\"headerlink\" title=\"分布式设计\"></a>分布式设计</h1><h2 id=\"扩展性设计\"><a href=\"#扩展性设计\" class=\"headerlink\" title=\"扩展性设计\"></a>扩展性设计</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/hemin1003/article/details/53633926\" target=\"_blank\" rel=\"noopener\">《架构师不可不知的十大可扩展架构》</a></p>\n<ul>\n<li>总结下来，通用的套路就是分布、缓存及异步处理。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://yq.aliyun.com/articles/38119\" target=\"_blank\" rel=\"noopener\">《可扩展性设计之数据切分》</a></p>\n<ul>\n<li>水平切分+垂直切分</li>\n<li>利用中间件进行分片如，MySQL Proxy。</li>\n<li>利用分片策略进行切分，如按照ID取模。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/deniro_li/article/details/78458306\" target=\"_blank\" rel=\"noopener\">《说说如何实现可扩展性的大型网站架构》</a></p>\n<ul>\n<li>分布式服务+消息队列。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chaofanwei/article/details/29191073\" target=\"_blank\" rel=\"noopener\">《大型网站技术架构（七）–网站的可扩展性架构》</a></p>\n</li>\n</ul>\n<h2 id=\"稳定性-amp-高可用\"><a href=\"#稳定性-amp-高可用\" class=\"headerlink\" title=\"稳定性 &amp; 高可用\"></a>稳定性 &amp; 高可用</h2><ul>\n<li><a href=\"https://blog.csdn.net/hustspy1990/article/details/78008324\" target=\"_blank\" rel=\"noopener\">《系统设计：关于高可用系统的一些技术方案》</a><ul>\n<li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li>\n<li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li>\n<li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li>\n<li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li>\n<li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li>\n<li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li>\n<li>自动化测试：通过完善的测试，减少发布引起的故障。</li>\n<li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><a href=\"https://coolshell.cn/articles/17459.html\" target=\"_blank\" rel=\"noopener\">《关于高可用的系统》</a><ul>\n<li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"硬件负载均衡\"><a href=\"#硬件负载均衡\" class=\"headerlink\" title=\"硬件负载均衡\"></a>硬件负载均衡</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/wuyun-blog/p/6186198.html\" target=\"_blank\" rel=\"noopener\">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a></p>\n<ul>\n<li>主要是和F5对比。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lcword/p/5773296.html\" target=\"_blank\" rel=\"noopener\">《软/硬件负载均衡产品 你知多少？》</a></p>\n</li>\n</ul>\n<h3 id=\"软件负载均衡\"><a href=\"#软件负载均衡\" class=\"headerlink\" title=\"软件负载均衡\"></a>软件负载均衡</h3><ul>\n<li><a href=\"https://www.cnblogs.com/tianzhiliang/articles/2317808.html\" target=\"_blank\" rel=\"noopener\">《几种负载均衡算法》</a><br>  轮寻、权重、负载、最少连接、QoS</li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html\" target=\"_blank\" rel=\"noopener\">《DNS负载均衡》</a><ul>\n<li>配置简单，更新速度慢。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html\" target=\"_blank\" rel=\"noopener\">《Nginx负载均衡》</a></p>\n<ul>\n<li>简单轻量、学习成本低；主要适用于web应用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/edisonchou/p/4281978.html\" target=\"_blank\" rel=\"noopener\">《借助LVS+Keepalived实现负载均衡 》</a></p>\n<ul>\n<li>配置比较负载、只支持到4层，性能较高。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ttlsa.com/linux/haproxy-study-tutorial/\" target=\"_blank\" rel=\"noopener\">《HAProxy用法详解 全网最详细中文文档》</a></p>\n<ul>\n<li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.itpub.net/25704976/viewspace-1319781/\" target=\"_blank\" rel=\"noopener\">《Haproxy+Keepalived+MySQL实现读均衡负载》</a></p>\n<ul>\n<li>主要是用户读请求的负载均衡。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lylife/p/5584019.html\" target=\"_blank\" rel=\"noopener\">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></p>\n</li>\n</ul>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><ul>\n<li><a href=\"https://www.cnblogs.com/haoxinyue/p/6792309.html\" target=\"_blank\" rel=\"noopener\">《谈谈高并发系统的限流》</a><ul>\n<li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li>\n<li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li>\n<li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li>\n<li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层容灾\"><a href=\"#应用层容灾\" class=\"headerlink\" title=\"应用层容灾\"></a>应用层容灾</h3><ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000005988895\" target=\"_blank\" rel=\"noopener\">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p>\n<ul>\n<li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 </li>\n<li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li>\n<li>Hystrix设计原则：<ul>\n<li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li>\n<li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li>\n<li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\" target=\"_blank\" rel=\"noopener\">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\" target=\"_blank\" rel=\"noopener\">《缓存击穿、失效以及热点key问题》</a> <ul>\n<li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li>\n<li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"跨机房容灾\"><a href=\"#跨机房容灾\" class=\"headerlink\" title=\"跨机房容灾\"></a>跨机房容灾</h3><ul>\n<li><p><a href=\"http://dc.idcquan.com/ywgl/71559.shtml\" target=\"_blank\" rel=\"noopener\">《“异地多活”多机房部署经验谈》</a></p>\n<ul>\n<li>通过自研中间件进行数据同步。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/jeffreynicole/article/details/48135093\" target=\"_blank\" rel=\"noopener\">《异地多活（异地双活）实践经验》</a></p>\n<ul>\n<li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li>\n<li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li>\n<li>不能依赖于程序端数据双写，要有自动同步方案。 </li>\n<li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li>\n<li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li>\n<li>异地多活监控部署、测试也要跟上。</li>\n<li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li>\n<li>控制跨机房消息体大小，越小越好。</li>\n<li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yoara/article/details/38013751\" target=\"_blank\" rel=\"noopener\">容灾技术及建设经验介绍</a></p>\n</li>\n</ul>\n<h3 id=\"容灾演练流程\"><a href=\"#容灾演练流程\" class=\"headerlink\" title=\"容灾演练流程\"></a>容灾演练流程</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650996320&amp;idx=1&amp;sn=0ed3be190bbee4a9277886ef88cbb2e5\" target=\"_blank\" rel=\"noopener\">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul>\n<li>常见故障画像</li>\n<li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平滑启动\"><a href=\"#平滑启动\" class=\"headerlink\" title=\"平滑启动\"></a>平滑启动</h3><ul>\n<li><p>平滑重启应用思路<br>1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011001084/article/details/73480432\" target=\"_blank\" rel=\"noopener\">《JVM安全退出（如何优雅的关闭java服务）》</a><br>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</p>\n</li>\n<li><a href=\"http://ju.outofmemory.cn/entry/337235\" target=\"_blank\" rel=\"noopener\">《常见Java应用如何优雅关闭》</a><br>Java、Srping、Dubbo 优雅关闭方式。</li>\n</ul>\n<h2 id=\"数据库扩展\"><a href=\"#数据库扩展\" class=\"headerlink\" title=\"数据库扩展\"></a>数据库扩展</h2><h3 id=\"读写分离模式\"><a href=\"#读写分离模式\" class=\"headerlink\" title=\"读写分离模式\"></a>读写分离模式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/houdj/p/6563771.html\" target=\"_blank\" rel=\"noopener\">《Mysql主从方案的实现》</a></li>\n<li><a href=\"https://www.cnblogs.com/edisonchou/p/4133148.html\" target=\"_blank\" rel=\"noopener\">《搭建MySQL主从复制经典架构》</a></li>\n<li><p><a href=\"https://blog.csdn.net/nimasike/article/details/48048341\" target=\"_blank\" rel=\"noopener\">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhangsubai/p/6801764.html\" target=\"_blank\" rel=\"noopener\">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a></p>\n<ul>\n<li>DRDB 进行磁盘复制，避免单点问题。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html\" target=\"_blank\" rel=\"noopener\">《MySQL Cluster 方式》</a></p>\n</li>\n</ul>\n<h3 id=\"分片模式\"><a href=\"#分片模式\" class=\"headerlink\" title=\"分片模式\"></a>分片模式</h3><ul>\n<li><p><a href=\"https://www.jianshu.com/p/32b3e91aa22c\" target=\"_blank\" rel=\"noopener\">《分库分表需要考虑的问题及方案》</a></p>\n<ul>\n<li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li>\n<li>问题：事务、Join、迁移、扩容、ID、分页等。</li>\n<li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li>\n<li>分库策略：数值范围；取模；日期等。</li>\n<li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201503/380348.html\" target=\"_blank\" rel=\"noopener\">《MySql分表和表分区详解》</a></p>\n<ul>\n<li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li>\n<li>分表：物理上创建不同的表、客户端需要管理分表路由。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h2><h3 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h3><ul>\n<li><a href=\"https://blog.csdn.net/jiaolongdy/article/details/51188798\" target=\"_blank\" rel=\"noopener\">《永不失联！如何实现微服务架构中的服务发现？》</a><ul>\n<li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li>\n<li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u010963948/article/details/71730165\" target=\"_blank\" rel=\"noopener\">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a></p>\n<ul>\n<li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li>\n<li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://mobile.51cto.com/news-502394.htm\" target=\"_blank\" rel=\"noopener\">《基于Zookeeper的服务注册与发现》</a></p>\n<ul>\n<li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务路由控制\"><a href=\"#服务路由控制\" class=\"headerlink\" title=\"服务路由控制\"></a>服务路由控制</h3><ul>\n<li><a href=\"https://blog.csdn.net/xundh/article/details/59492750\" target=\"_blank\" rel=\"noopener\">《分布式服务框架学习笔记4 服务路由》</a><ul>\n<li>原则：透明化路由</li>\n<li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li>\n<li>本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li>\n<li>配置方式：统一注册表；本地配置；动态下发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式一致\"><a href=\"#分布式一致\" class=\"headerlink\" title=\"分布式一致\"></a>分布式一致</h2><h3 id=\"CAP-与-BASE-理论\"><a href=\"#CAP-与-BASE-理论\" class=\"headerlink\" title=\"CAP 与 BASE 理论\"></a>CAP 与 BASE 理论</h3><ul>\n<li><a href=\"http://www.cnblogs.com/szlbm/p/5588543.html\" target=\"_blank\" rel=\"noopener\">《从分布式一致性谈到CAP理论、BASE理论》</a><ul>\n<li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li>\n<li>CAP：一致性、可用性、分区容错性(网络故障引起)</li>\n<li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li>\n<li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><a href=\"http://www.hollischuang.com/archives/1716\" target=\"_blank\" rel=\"noopener\">《分布式锁的几种实现方式》</a><ul>\n<li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li>\n<li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li>\n<li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.tuicool.com/articles/VZJr6fY\" target=\"_blank\" rel=\"noopener\">《基于Zookeeper的分布式锁》</a></p>\n<ul>\n<li>清楚的原理描述 + Java 代码示例。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/0201zcr/p/5942748.html\" target=\"_blank\" rel=\"noopener\">《jedisLock—redis分布式锁实现》</a></p>\n<ul>\n<li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/albertfly/article/details/77412333\" target=\"_blank\" rel=\"noopener\">《Memcached 和 Redis 分布式锁方案》</a></p>\n<ul>\n<li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致性算法\"><a href=\"#分布式一致性算法\" class=\"headerlink\" title=\"分布式一致性算法\"></a>分布式一致性算法</h3><h4 id=\"PAXOS\"><a href=\"#PAXOS\" class=\"headerlink\" title=\"PAXOS\"></a>PAXOS</h4><ul>\n<li><a href=\"https://www.cnblogs.com/linbingdong/p/6253479.html\" target=\"_blank\" rel=\"noopener\">《分布式系列文章——Paxos算法原理与推导》</a></li>\n<li><a href=\"https://blog.csdn.net/u010039929/article/details/70171672\" target=\"_blank\" rel=\"noopener\">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li>\n<li><a href=\"https://www.cnblogs.com/leesf456/p/6012777.html\" target=\"_blank\" rel=\"noopener\">《【分布式】Zookeeper与Paxos》</a></li>\n</ul>\n<h4 id=\"Zab\"><a href=\"#Zab\" class=\"headerlink\" title=\"Zab\"></a>Zab</h4><ul>\n<li><a href=\"https://www.jianshu.com/p/fb527a64deee\" target=\"_blank\" rel=\"noopener\">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li>\n</ul>\n<h4 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h4><ul>\n<li><a href=\"http://www.cnblogs.com/mindwind/p/5231986.html\" target=\"_blank\" rel=\"noopener\">《Raft 为什么是更易理解的分布式一致性算法》</a><ul>\n<li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li>\n<li>通过随机等待的方式发出投票，得票多的获胜。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Gossip\"><a href=\"#Gossip\" class=\"headerlink\" title=\"Gossip\"></a>Gossip</h4><ul>\n<li><a href=\"http://blog.51cto.com/tianya23/530743\" target=\"_blank\" rel=\"noopener\">《Gossip算法》</a></li>\n</ul>\n<h4 id=\"两阶段提交、多阶段提交\"><a href=\"#两阶段提交、多阶段提交\" class=\"headerlink\" title=\"两阶段提交、多阶段提交\"></a>两阶段提交、多阶段提交</h4><ul>\n<li><a href=\"http://blog.jobbole.com/95632/\" target=\"_blank\" rel=\"noopener\">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li>\n</ul>\n<h3 id=\"幂等\"><a href=\"#幂等\" class=\"headerlink\" title=\"幂等\"></a>幂等</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wxgblogs/p/6639272.html\" target=\"_blank\" rel=\"noopener\">《分布式系统—幂等性设计》</a><ul>\n<li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li>\n<li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致方案\"><a href=\"#分布式一致方案\" class=\"headerlink\" title=\"分布式一致方案\"></a>分布式一致方案</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency\" target=\"_blank\" rel=\"noopener\">《分布式系统事务一致性解决方案》</a></li>\n<li><a href=\"https://weibo.com/ttarticle/p/show?id=2309403965965003062676\" target=\"_blank\" rel=\"noopener\">《保证分布式系统数据一致性的6种方案》</a></li>\n</ul>\n<h3 id=\"分布式-Leader-节点选举\"><a href=\"#分布式-Leader-节点选举\" class=\"headerlink\" title=\"分布式 Leader 节点选举\"></a>分布式 Leader 节点选举</h3><ul>\n<li><a href=\"https://blog.csdn.net/johnson_moon/article/details/78809995\" target=\"_blank\" rel=\"noopener\">《利用zookeeper实现分布式leader节点选举》</a></li>\n</ul>\n<h3 id=\"TCC-Try-Confirm-Cancel-柔性事务\"><a href=\"#TCC-Try-Confirm-Cancel-柔性事务\" class=\"headerlink\" title=\"TCC(Try/Confirm/Cancel) 柔性事务\"></a>TCC(Try/Confirm/Cancel) 柔性事务</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/ab1a1c6b08a1\" target=\"_blank\" rel=\"noopener\">《传统事务与柔性事务》</a><ul>\n<li>基于BASE理论：基本可用、柔性状态、最终一致。</li>\n<li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式文件系统\"><a href=\"#分布式文件系统\" class=\"headerlink\" title=\"分布式文件系统\"></a>分布式文件系统</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27666295\" target=\"_blank\" rel=\"noopener\">说说分布式文件存储系统-基本架构</a> ？</li>\n<li><a href=\"https://blog.csdn.net/gatieme/article/details/44982961\" target=\"_blank\" rel=\"noopener\">《各种分布式文件系统的比较》</a> ？<ul>\n<li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li>\n<li>FastDFS：轻量级、适合小文件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"唯一ID-生成\"><a href=\"#唯一ID-生成\" class=\"headerlink\" title=\"唯一ID 生成\"></a>唯一ID 生成</h2><h3 id=\"全局唯一ID\"><a href=\"#全局唯一ID\" class=\"headerlink\" title=\"全局唯一ID\"></a>全局唯一ID</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/baiwa/p/5318432.html\" target=\"_blank\" rel=\"noopener\">《高并发分布式系统中生成全局唯一Id汇总》</a></p>\n<ul>\n<li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li>\n<li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” </li>\n<li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li>\n<li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/hdu09075340/article/details/79103851\" target=\"_blank\" rel=\"noopener\">《TDDL 在分布式下的SEQUENCE原理》</a></p>\n<ul>\n<li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li>\n<li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li>\n<li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一致性Hash算法\"><a href=\"#一致性Hash算法\" class=\"headerlink\" title=\"一致性Hash算法\"></a>一致性Hash算法</h2><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html\" target=\"_blank\" rel=\"noopener\">《一致性哈希算法》</a></li>\n</ul>\n<h1 id=\"设计思想-amp-开发模式\"><a href=\"#设计思想-amp-开发模式\" class=\"headerlink\" title=\"设计思想 &amp; 开发模式\"></a>设计思想 &amp; 开发模式</h1><h2 id=\"DDD-Domain-driven-Design-领域驱动设计\"><a href=\"#DDD-Domain-driven-Design-领域驱动设计\" class=\"headerlink\" title=\"DDD(Domain-driven Design - 领域驱动设计)\"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/netfocus/p/5548025.html\" target=\"_blank\" rel=\"noopener\">《浅谈我对DDD领域驱动设计的理解》</a></p>\n<ul>\n<li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li>\n<li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li>\n<li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/butterfly100/p/7827870.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计的基础知识总结》</a></p>\n<ul>\n<li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li>\n<li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li>\n<li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li>\n<li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li>\n<li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li>\n<li>使用的模式：<ul>\n<li>关联尽量少，尽量单项，尽量降低整体复杂度。</li>\n<li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li>\n<li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li>\n<li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li>\n<li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li>\n<li>工厂（Factory）：类似于设计模式中的工厂模式。</li>\n<li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Leo_wl/p/3866629.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计(DDD)实现之路》</a></p>\n<ul>\n<li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.hollischuang.com/archives/553\" target=\"_blank\" rel=\"noopener\">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></p>\n</li>\n</ul>\n<h3 id=\"命令查询职责分离-CQRS\"><a href=\"#命令查询职责分离-CQRS\" class=\"headerlink\" title=\"命令查询职责分离(CQRS)\"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/cnblogsfans/p/4551990.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计系列 (六)：CQRS》</a></p>\n<ul>\n<li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml\" target=\"_blank\" rel=\"noopener\">《DDD CQRS架构和传统架构的优缺点比较》</a></p>\n<ul>\n<li>最终一致的设计理念；依赖于高可用消息中间件。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/netfocus/p/4055346.html\" target=\"_blank\" rel=\"noopener\">《CQRS架构简介》</a></p>\n<ul>\n<li>一个实现 CQRS 的抽象案例。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.uml.org.cn/zjjs/201609221.asp\" target=\"_blank\" rel=\"noopener\">《深度长文：我对CQRS/EventSourcing架构的思考》</a></p>\n<ul>\n<li>CQRS 模式分析 + 12306 抢票案例</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"贫血，充血模型\"><a href=\"#贫血，充血模型\" class=\"headerlink\" title=\"贫血，充血模型\"></a>贫血，充血模型</h3><ul>\n<li><a href=\"https://kb.cnblogs.com/page/520743/\" target=\"_blank\" rel=\"noopener\">《贫血，充血模型的解释以及一些经验》</a><ul>\n<li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li>\n<li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li>\n<li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li>\n<li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li>\n<li>作者主张使用贫血模式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Actor-模式\"><a href=\"#Actor-模式\" class=\"headerlink\" title=\"Actor 模式\"></a>Actor 模式</h2><p>TODO</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><h3 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h3><p>TODO</p>\n<h3 id=\"RxJava\"><a href=\"#RxJava\" class=\"headerlink\" title=\"RxJava\"></a>RxJava</h3><p>TODO</p>\n<h3 id=\"Vert-x\"><a href=\"#Vert-x\" class=\"headerlink\" title=\"Vert.x\"></a>Vert.x</h3><p>TODO</p>\n<h2 id=\"DODAF2-0\"><a href=\"#DODAF2-0\" class=\"headerlink\" title=\"DODAF2.0\"></a>DODAF2.0</h2><ul>\n<li><a href=\"http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml\" target=\"_blank\" rel=\"noopener\">《DODAF2.0方法论》</a></li>\n<li><a href=\"http://blog.51cto.com/xiaoyong/1553164\" target=\"_blank\" rel=\"noopener\">《DODAF2.0之能力视角如何落地》</a></li>\n</ul>\n<h2 id=\"Serverless\"><a href=\"#Serverless\" class=\"headerlink\" title=\"Serverless\"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p>\n<ul>\n<li><p><a href=\"http://www.jdon.com/soa/serverless.html\" target=\"_blank\" rel=\"noopener\">《什么是Serverless无服务器架构？》</a></p>\n<ul>\n<li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li>\n<li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li>\n<li>Serverless 不代表某个具体的框架。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless\" target=\"_blank\" rel=\"noopener\">《如何理解Serverless？》</a></p>\n<ul>\n<li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Service-Mesh\"><a href=\"#Service-Mesh\" class=\"headerlink\" title=\"Service Mesh\"></a>Service Mesh</h2><ul>\n<li><a href=\"https://time.geekbang.org/article/2355\" target=\"_blank\" rel=\"noopener\">《什么是Service Mesh？》</a></li>\n<li><p><a href=\"https://www.jianshu.com/p/e23e3e74538e\" target=\"_blank\" rel=\"noopener\">《初识 Service Mesh》</a></p>\n</li>\n<li><p><a href=\"https://time.geekbang.org/article/2355\" target=\"_blank\" rel=\"noopener\">《什么是Service Mesh？》</a></p>\n</li>\n</ul>\n<h1 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h1><h2 id=\"架构评审\"><a href=\"#架构评审\" class=\"headerlink\" title=\"架构评审\"></a>架构评审</h2><ul>\n<li><a href=\"http://developer.51cto.com/art/201506/478486.htm\" target=\"_blank\" rel=\"noopener\">《架构设计之如何评审架构设计说明书》</a></li>\n<li><a href=\"https://blog.csdn.net/wireless_com/article/details/45935591\" target=\"_blank\" rel=\"noopener\">《人人都是架构师：非功能性需求》</a></li>\n</ul>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/architect-12-rules-complete/\" target=\"_blank\" rel=\"noopener\">《架构之重构的12条军规》</a></li>\n</ul>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><ul>\n<li><a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener\">《阿里巴巴Java开发手册》</a></li>\n</ul>\n<h2 id=\"代码-Review\"><a href=\"#代码-Review\" class=\"headerlink\" title=\"代码 Review\"></a>代码 Review</h2><p>制度还是制度!<br>另外，每个公司需要根据自己的需求和目标制定自己的 check list</p>\n<ul>\n<li><p><a href=\"http://www.sohu.com/a/229745352_181657\" target=\"_blank\" rel=\"noopener\">《为什么你做不好 Code Review？》</a></p>\n<ul>\n<li>代码 review 做的好，在于制度建设。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/uxyheaven/article/details/49773619\" target=\"_blank\" rel=\"noopener\">《从零开始Code Review》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zuoping/p/5477047.html\" target=\"_blank\" rel=\"noopener\">《Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://dzone.com/articles/java-code-review-checklist\" target=\"_blank\" rel=\"noopener\">《Java Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/legend0011/article/details/45585575\" target=\"_blank\" rel=\"noopener\">《如何用 gitlab 做 code review》</a></p>\n</li>\n</ul>\n<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2><ul>\n<li><a href=\"https://blog.csdn.net/apanious/article/details/51011946\" target=\"_blank\" rel=\"noopener\">《运用RUP 4+1视图方法进行软件架构设计》</a></li>\n</ul>\n<h2 id=\"看板管理\"><a href=\"#看板管理\" class=\"headerlink\" title=\"看板管理\"></a>看板管理</h2><ul>\n<li><a href=\"https://blog.csdn.net/tkchen/article/details/51637643\" target=\"_blank\" rel=\"noopener\">《说说看板在项目中的应用》</a></li>\n</ul>\n<h2 id=\"SCRUM\"><a href=\"#SCRUM\" class=\"headerlink\" title=\"SCRUM\"></a>SCRUM</h2><p>SCRUM - 争球</p>\n<ul>\n<li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li>\n<li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li>\n<li>五个价值观：专注、勇气、公开、承诺、尊重。</li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/inny100_100/article/details/54633757\" target=\"_blank\" rel=\"noopener\">《敏捷项目管理流程-Scrum框架最全总结！》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/superkunkun/article/details/52951142\" target=\"_blank\" rel=\"noopener\">《敏捷其实很简单3—敏捷方法之scrum》</a></p>\n</li>\n</ul>\n<h2 id=\"敏捷开发\"><a href=\"#敏捷开发\" class=\"headerlink\" title=\"敏捷开发\"></a>敏捷开发</h2><p>TODO</p>\n<h2 id=\"极限编程（XP）\"><a href=\"#极限编程（XP）\" class=\"headerlink\" title=\"极限编程（XP）\"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p>\n<ul>\n<li><p><a href=\"http://www.woshipm.com/pmd/406917.html\" target=\"_blank\" rel=\"noopener\">《主流敏捷开发方法：极限编程XP》</a></p>\n<ul>\n<li>是一种指导开发人员的方法论。</li>\n<li><p>4大价值：</p>\n<ul>\n<li>沟通：鼓励口头沟通，提高效率。</li>\n<li>简单：够用就好。</li>\n<li>反馈：及时反馈、通知相关人。</li>\n<li>勇气：提倡拥抱变化，敢于重构。</li>\n</ul>\n</li>\n<li><p>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</p>\n</li>\n<li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"结对编程\"><a href=\"#结对编程\" class=\"headerlink\" title=\"结对编程\"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">《结对编程》</a></li>\n</ul>\n<h2 id=\"PDCA-循环质量管理\"><a href=\"#PDCA-循环质量管理\" class=\"headerlink\" title=\"PDCA 循环质量管理\"></a>PDCA 循环质量管理</h2><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/PDCA\" target=\"_blank\" rel=\"noopener\">《PDCA》</a></li>\n</ul>\n<h2 id=\"FMEA管理模式\"><a href=\"#FMEA管理模式\" class=\"headerlink\" title=\"FMEA管理模式\"></a>FMEA管理模式</h2><p>TODO</p>\n<h1 id=\"通用业务术语\"><a href=\"#通用业务术语\" class=\"headerlink\" title=\"通用业务术语\"></a>通用业务术语</h1><p>TODO</p>\n<h1 id=\"技术趋势\"><a href=\"#技术趋势\" class=\"headerlink\" title=\"技术趋势\"></a>技术趋势</h1><p>TODO</p>\n<h1 id=\"政策、法规\"><a href=\"#政策、法规\" class=\"headerlink\" title=\"政策、法规\"></a>政策、法规</h1><p>TODO</p>\n<h2 id=\"法律\"><a href=\"#法律\" class=\"headerlink\" title=\"法律\"></a>法律</h2><h3 id=\"严格遵守刑法253法条\"><a href=\"#严格遵守刑法253法条\" class=\"headerlink\" title=\"严格遵守刑法253法条\"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p>\n<blockquote>\n<ul>\n<li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li>\n<li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 </li>\n<li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li>\n</ul>\n</blockquote>\n<p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA\" target=\"_blank\" rel=\"noopener\">《非法获取公民个人信息罪》</a></li>\n</ul>\n<h1 id=\"架构师素质\"><a href=\"#架构师素质\" class=\"headerlink\" title=\"架构师素质\"></a>架构师素质</h1><ul>\n<li><p><a href=\"http://hellojava.info/?p=430\" target=\"_blank\" rel=\"noopener\">《架构师画像》</a></p>\n<ul>\n<li>业务理解和抽象能力</li>\n<li>NB的代码能力</li>\n<li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； </li>\n<li>全局：是否考虑到了对上下游的系统的影响。</li>\n<li>权衡：权衡投入产出比；优先级和节奏控制；</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know\" target=\"_blank\" rel=\"noopener\">《关于架构优化和设计，架构师必须知道的事情》</a></p>\n<ul>\n<li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li>\n<li>基础设施、配置、测试、开发、运维综合考虑。</li>\n<li>考虑人、团队、和组织的影响。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/19841397\" target=\"_blank\" rel=\"noopener\">《如何才能真正的提高自己，成为一名出色的架构师？》</a> </p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129\" target=\"_blank\" rel=\"noopener\">《架构师的必备素质和成长途径》</a></p>\n<ul>\n<li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li>\n<li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.51cto.com/frankfan/1248401\" target=\"_blank\" rel=\"noopener\">《架构设计师—你在哪层楼？》</a></p>\n<ul>\n<li>第一层的架构师看到的只是产品本身</li>\n<li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li>\n<li>第三层的架构师看到的是商业价值 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"团队管理\"><a href=\"#团队管理\" class=\"headerlink\" title=\"团队管理\"></a>团队管理</h1><p>TODO</p>\n<h2 id=\"招聘\"><a href=\"#招聘\" class=\"headerlink\" title=\"招聘\"></a>招聘</h2><h1 id=\"资讯\"><a href=\"#资讯\" class=\"headerlink\" title=\"资讯\"></a>资讯</h1><h2 id=\"行业资讯\"><a href=\"#行业资讯\" class=\"headerlink\" title=\"行业资讯\"></a>行业资讯</h2><ul>\n<li><a href=\"http://36kr.com/\" target=\"_blank\" rel=\"noopener\">36kr</a></li>\n<li><a href=\"http://www.techweb.com.cn/\" target=\"_blank\" rel=\"noopener\">Techweb</a></li>\n</ul>\n<h2 id=\"公众号列表\"><a href=\"#公众号列表\" class=\"headerlink\" title=\"公众号列表\"></a>公众号列表</h2><p>TODO</p>\n<h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><h3 id=\"团队博客\"><a href=\"#团队博客\" class=\"headerlink\" title=\"团队博客\"></a>团队博客</h3><ul>\n<li><a href=\"http://jm.taobao.org/\" target=\"_blank\" rel=\"noopener\">阿里中间件博客</a></li>\n<li><a href=\"https://tech.meituan.com\" target=\"_blank\" rel=\"noopener\">美团点评技术团队博客</a></li>\n</ul>\n<h3 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></li>\n<li><a href=\"https://coolshell.cn/\" target=\"_blank\" rel=\"noopener\">酷壳 - COOLSHELL-陈皓</a></li>\n<li><a href=\"http://hellojava.info/\" target=\"_blank\" rel=\"noopener\">hellojava-阿里毕玄</a></li>\n<li><a href=\"http://cmsblogs.com/\" target=\"_blank\" rel=\"noopener\">Cm’s Blog</a></li>\n<li><a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li>\n</ul>\n<h2 id=\"综合门户、社区\"><a href=\"#综合门户、社区\" class=\"headerlink\" title=\"综合门户、社区\"></a>综合门户、社区</h2><p><strong>国内：</strong></p>\n<ul>\n<li><a href=\"http://csdn.net\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>   老牌技术社区、不必解释。</li>\n<li><a href=\"http://www.51cto.com/\" target=\"_blank\" rel=\"noopener\">51cto.com</a></li>\n<li><a href=\"http://www.iteye.com/\" target=\"_blank\" rel=\"noopener\">ITeye</a><ul>\n<li>偏 Java 方向 </li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com\" target=\"_blank\" rel=\"noopener\">博客园</a></li>\n<li><a href=\"http://www.tom.net/\" target=\"_blank\" rel=\"noopener\">ChinaUnix</a><ul>\n<li>偏 Linux 方向 </li>\n</ul>\n</li>\n<li><a href=\"https://www.oschina.net/\" target=\"_blank\" rel=\"noopener\">开源中国社区</a></li>\n<li><a href=\"http://www.open-open.com/\" target=\"_blank\" rel=\"noopener\">深度开源</a></li>\n<li><p><a href=\"http://www.jobbole.com/\" target=\"_blank\" rel=\"noopener\">伯乐在线</a></p>\n<ul>\n<li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.itpub.net/\" target=\"_blank\" rel=\"noopener\">ITPUB</a></p>\n</li>\n<li><a href=\"https://cloud.tencent.com/developer/column\" target=\"_blank\" rel=\"noopener\">腾讯云— 云+社区</a></li>\n<li><a href=\"https://yq.aliyun.com/\" target=\"_blank\" rel=\"noopener\">阿里云— 云栖社区</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/\" target=\"_blank\" rel=\"noopener\">IBM DeveloperWorks</a></li>\n<li><a href=\"https://toutiao.io/\" target=\"_blank\" rel=\"noopener\">开发者头条</a></li>\n<li><a href=\"http://www.linkedkeeper.com\" target=\"_blank\" rel=\"noopener\">LinkedKeeper</a></li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"https://dzone.com\" target=\"_blank\" rel=\"noopener\">DZone</a></li>\n<li><a href=\"https://www.reddit.com\" target=\"_blank\" rel=\"noopener\">Reddit</a></li>\n</ul>\n<h2 id=\"问答、讨论类社区\"><a href=\"#问答、讨论类社区\" class=\"headerlink\" title=\"问答、讨论类社区\"></a>问答、讨论类社区</h2><ul>\n<li><a href=\"https://segmentfault.com\" target=\"_blank\" rel=\"noopener\">segmentfault</a><ul>\n<li>问答+专栏 </li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/\" target=\"_blank\" rel=\"noopener\">知乎</a></li>\n<li><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></li>\n</ul>\n<h2 id=\"行业数据分析\"><a href=\"#行业数据分析\" class=\"headerlink\" title=\"行业数据分析\"></a>行业数据分析</h2><ul>\n<li><a href=\"http://report.iresearch.cn/\" target=\"_blank\" rel=\"noopener\">艾瑞网</a></li>\n<li><p><a href=\"https://www.questmobile.com.cn\" target=\"_blank\" rel=\"noopener\">QUEST MOBILE</a></p>\n</li>\n<li><p><a href=\"http://data.stats.gov.cn/\" target=\"_blank\" rel=\"noopener\">国家数据</a></p>\n</li>\n<li><p><a href=\"http://www.talkingdata.com/\" target=\"_blank\" rel=\"noopener\">TalkingData</a></p>\n</li>\n</ul>\n<h2 id=\"专项网站\"><a href=\"#专项网站\" class=\"headerlink\" title=\"专项网站\"></a>专项网站</h2><ul>\n<li><p>测试:</p>\n<ul>\n<li><a href=\"http://www.ltesting.net/\" target=\"_blank\" rel=\"noopener\">领测国际</a> </li>\n<li><a href=\"https://www.testwo.com/\" target=\"_blank\" rel=\"noopener\">测试窝</a></li>\n<li><a href=\"https://testerhome.com\" target=\"_blank\" rel=\"noopener\">TesterHome</a></li>\n</ul>\n</li>\n<li><p>运维:</p>\n<pre><code>* [运维派](http://www.yunweipai.com/) \n* [Abcdocker](https://www.abcdocker.com/)\n</code></pre></li>\n<li><p>Java:</p>\n<ul>\n<li><a href=\"http://www.importnew.com/\" target=\"_blank\" rel=\"noopener\">ImportNew</a><ul>\n<li>专注于 Java 技术分享</li>\n</ul>\n</li>\n<li><a href=\"https://howtodoinjava.com/\" target=\"_blank\" rel=\"noopener\">HowToDoInJava</a><ul>\n<li>英文博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全</p>\n<ul>\n<li><a href=\"https://www.2cto.com/\" target=\"_blank\" rel=\"noopener\">红黑联盟</a> </li>\n<li><a href=\"http://www.freebuf.com/\" target=\"_blank\" rel=\"noopener\">FreeBuf</a></li>\n</ul>\n</li>\n<li><p>大数据</p>\n<ul>\n<li><a href=\"http://www.thebigdata.cn/\" target=\"_blank\" rel=\"noopener\">中国大数据</a> </li>\n</ul>\n</li>\n<li><p>其他专题网站：</p>\n<ul>\n<li><a href=\"http://www.dockerinfo.net/\" target=\"_blank\" rel=\"noopener\">DockerInfo</a><ul>\n<li>专注于 Docker 应用及咨询、教程的网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.linuxidc.com/\" target=\"_blank\" rel=\"noopener\">Linux公社</a><ul>\n<li>Linux 主题社区</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他类\"><a href=\"#其他类\" class=\"headerlink\" title=\"其他类\"></a>其他类</h2><ul>\n<li><a href=\"https://github.com/TeamStuQ/skill-map\" target=\"_blank\" rel=\"noopener\">程序员技能图谱</a></li>\n</ul>\n<h2 id=\"推荐参考书\"><a href=\"#推荐参考书\" class=\"headerlink\" title=\"推荐参考书\"></a>推荐参考书</h2><h3 id=\"在线电子书\"><a href=\"#在线电子书\" class=\"headerlink\" title=\"在线电子书\"></a>在线电子书</h3><ul>\n<li><a href=\"https://github.com/forezp/SpringCloudLearning\" target=\"_blank\" rel=\"noopener\">《深入理解Spring Cloud与微服务构建》</a></li>\n</ul>\n<ul>\n<li><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf\" target=\"_blank\" rel=\"noopener\">《阿里技术参考图册-研发篇》</a></li>\n<li><p><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf\" target=\"_blank\" rel=\"noopener\">《阿里技术参考图册-算法篇》</a></p>\n</li>\n<li><p><a href=\"http://dpurl.cn/n/1lqcX\" target=\"_blank\" rel=\"noopener\">《2018美团点评技术年货（合辑）》70M</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/architect/\" target=\"_blank\" rel=\"noopener\">InfoQ《架构师》月刊</a></p>\n</li>\n<li><p><a href=\"https://www.w3cschool.cn/architectroad/\" target=\"_blank\" rel=\"noopener\">《架构师之路》</a></p>\n</li>\n</ul>\n<h3 id=\"纸质书\"><a href=\"#纸质书\" class=\"headerlink\" title=\"纸质书\"></a>纸质书</h3><h4 id=\"开发方面\"><a href=\"#开发方面\" class=\"headerlink\" title=\"开发方面\"></a>开发方面</h4><ul>\n<li>《阿里巴巴Java开发手册》<a href=\"https://union-click.jd.com/jdc?d=bVKwZQ\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=阿里巴巴Java开发手册\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"架构方面\"><a href=\"#架构方面\" class=\"headerlink\" title=\"架构方面\"></a>架构方面</h4><ul>\n<li>《软件架构师的12项修炼：技术技能篇》<a href=\"https://union-click.jd.com/jdc?d=gXvRd8\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《架构之美》<a href=\"https://union-click.jd.com/jdc?d=xJit5I\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=架构之美\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《分布式服务架构》<a href=\"https://union-click.jd.com/jdc?d=JS5Od9\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=分布式服务架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《聊聊架构》 <a href=\"https://union-click.jd.com/jdc?d=FHooH4\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=聊聊架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《云原生应用架构实践》<a href=\"https://union-click.jd.com/jdc?d=orkJSj\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=云原生应用架构实践\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《亿级流量网站架构核心技术》<a href=\"https://union-click.jd.com/jdc?d=RnOSP5\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=亿级流量网站架构核心技术\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《淘宝技术这十年》<a href=\"https://union-click.jd.com/jdc?d=LwrDfD\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=淘宝技术这十年\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li><p>《企业IT架构转型之道-中台战略思想与架构实战》 <a href=\"https://union-click.jd.com/jdc?d=89pAEm\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=企业IT架构转型之道\" target=\"_blank\" rel=\"noopener\">淘宝</a></p>\n</li>\n<li><p>《高可用架构（第1卷）》<a href=\"https://item.jd.com/12195481.html\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=高可用架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></p>\n</li>\n</ul>\n<h4 id=\"技术管理方面\"><a href=\"#技术管理方面\" class=\"headerlink\" title=\"技术管理方面\"></a>技术管理方面</h4><ul>\n<li>《CTO说》<a href=\"https://union-click.jd.com/jdc?d=zhTZyr\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=CTO说\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《技术管理之巅》<a href=\"https://union-click.jd.com/jdc?d=LgRBUW\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=技术管理之巅\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《网易一千零一夜：互联网产品项目管理实战》<a href=\"https://union-click.jd.com/jdc?d=jcRz2r\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"基础理论-1\"><a href=\"#基础理论-1\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h4><ul>\n<li>《数学之美》<a href=\"https://union-click.jd.com/jdc?d=ghIES2\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=数学之美\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《编程珠玑》<a href=\"https://union-click.jd.com/jdc?d=YmhdEu\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=编程珠玑\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"工具方面\"><a href=\"#工具方面\" class=\"headerlink\" title=\"工具方面\"></a>工具方面</h4><p>TODO</p>\n<h4 id=\"大数据方面\"><a href=\"#大数据方面\" class=\"headerlink\" title=\"大数据方面\"></a>大数据方面</h4><h1 id=\"技术资源\"><a href=\"#技术资源\" class=\"headerlink\" title=\"技术资源\"></a>技术资源</h1><h2 id=\"开源资源\"><a href=\"#开源资源\" class=\"headerlink\" title=\"开源资源\"></a>开源资源</h2><ul>\n<li><p><a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n</li>\n<li><p><a href=\"https://www.apache.org/index.html\" target=\"_blank\" rel=\"noopener\">Apache 软件基金会</a></p>\n</li>\n</ul>\n<h2 id=\"手册、文档、教程\"><a href=\"#手册、文档、教程\" class=\"headerlink\" title=\"手册、文档、教程\"></a>手册、文档、教程</h2><p><strong>国内：</strong></p>\n<ul>\n<li><a href=\"http://w3cschool.cn\" target=\"_blank\" rel=\"noopener\">W3Cschool</a> </li>\n<li><p><a href=\"http://www.runoob.com/\" target=\"_blank\" rel=\"noopener\">Runoob.com</a></p>\n<ul>\n<li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li>\n</ul>\n</li>\n<li><p><a href=\"https://love2.io/\" target=\"_blank\" rel=\"noopener\">Love2.io</a></p>\n<ul>\n<li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.cn/\" target=\"_blank\" rel=\"noopener\">gitbook.cn</a><ul>\n<li>付费电子书。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.apachecn.org/\" target=\"_blank\" rel=\"noopener\">ApacheCN</a><ul>\n<li>AI、大数据方面系列中文文档。</li>\n</ul>\n</li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"http://www.quickcode.co/\" target=\"_blank\" rel=\"noopener\">Quick Code</a><ul>\n<li>免费在线技术教程。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.com\" target=\"_blank\" rel=\"noopener\">gitbook.com</a><ul>\n<li>有部分中文电子书。</li>\n</ul>\n</li>\n<li><a href=\"https://www.cheatography.com/\" target=\"_blank\" rel=\"noopener\">Cheatography</a><ul>\n<li>Cheat Sheets 大全，单页文档网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.tutorialspoint.com/index.htm\" target=\"_blank\" rel=\"noopener\">Tutorialspoint</a><ul>\n<li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在线课堂\"><a href=\"#在线课堂\" class=\"headerlink\" title=\"在线课堂\"></a>在线课堂</h2><ul>\n<li><a href=\"http://www.xuetuwuyou.com/\" target=\"_blank\" rel=\"noopener\">学徒无忧</a></li>\n<li><a href=\"https://time.geekbang.org/\" target=\"_blank\" rel=\"noopener\">极客时间</a></li>\n<li><a href=\"https://segmentfault.com/lives\" target=\"_blank\" rel=\"noopener\">segmentfault</a></li>\n<li><a href=\"https://new.stuq.org/course/explore\" target=\"_blank\" rel=\"noopener\">斯达克学院</a></li>\n<li><a href=\"http://nowcoder.com\" target=\"_blank\" rel=\"noopener\">牛客网</a></li>\n<li><a href=\"https://www.jikexueyuan.com/\" target=\"_blank\" rel=\"noopener\">极客学院</a></li>\n<li><a href=\"http://edu.51cto.com/\" target=\"_blank\" rel=\"noopener\">51CTO学院</a></li>\n</ul>\n<h2 id=\"会议、活动\"><a href=\"#会议、活动\" class=\"headerlink\" title=\"会议、活动\"></a>会议、活动</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/qcon/\" target=\"_blank\" rel=\"noopener\">QCon</a></li>\n<li><a href=\"https://archsummit.com\" target=\"_blank\" rel=\"noopener\">ArchSummit</a></li>\n<li><a href=\"http://www.thegitc.com/\" target=\"_blank\" rel=\"noopener\">GITC全球互联网技术大会</a></li>\n</ul>\n<p><strong>活动发布平台:</strong> </p>\n<ul>\n<li><a href=\"http://www.huodongxing.com/\" target=\"_blank\" rel=\"noopener\">活动行</a></li>\n</ul>\n<h2 id=\"常用APP\"><a href=\"#常用APP\" class=\"headerlink\" title=\"常用APP\"></a>常用APP</h2><ul>\n<li><a href=\"https://time.geekbang.org\" target=\"_blank\" rel=\"noopener\">极客时间</a></li>\n<li><a href=\"https://www.igetget.com\" target=\"_blank\" rel=\"noopener\">得到</a></li>\n</ul>\n<h2 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h2><ul>\n<li><a href=\"https://www.zhipin.com\" target=\"_blank\" rel=\"noopener\">Boss直聘</a></li>\n<li><a href=\"https://www.lagou.com\" target=\"_blank\" rel=\"noopener\">拉勾网</a></li>\n<li><a href=\"https://www.liepin.com\" target=\"_blank\" rel=\"noopener\">猎聘</a></li>\n<li><a href=\"https://cn.100offer.com/\" target=\"_blank\" rel=\"noopener\">100Offer</a></li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><a href=\"https://s.geekbang.org/\" target=\"_blank\" rel=\"noopener\">极客搜索</a><ul>\n<li>技术文章搜索引擎。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码托管\"><a href=\"#代码托管\" class=\"headerlink\" title=\"代码托管\"></a>代码托管</h2><ul>\n<li><a href=\"https://coding.net\" target=\"_blank\" rel=\"noopener\">Coding</a></li>\n<li><a href=\"https://gitee.com/\" target=\"_blank\" rel=\"noopener\">码云</a></li>\n</ul>\n<h2 id=\"文件服务\"><a href=\"#文件服务\" class=\"headerlink\" title=\"文件服务\"></a>文件服务</h2><ul>\n<li>七牛</li>\n<li>又拍云</li>\n</ul>\n<h2 id=\"综合云服务商\"><a href=\"#综合云服务商\" class=\"headerlink\" title=\"综合云服务商\"></a>综合云服务商</h2><ul>\n<li>阿里云</li>\n<li><a href=\"https://cloud.tencent.com/redirect.php?redirect=1012&amp;cps_key=c2665015d90871c0cb20fef91b7afc3c\" target=\"_blank\" rel=\"noopener\">腾讯云</a></li>\n<li>百度云</li>\n<li>新浪云</li>\n<li>金山云</li>\n<li><a href=\"https://amazonaws-china.com/cn/\" target=\"_blank\" rel=\"noopener\">亚马逊云(AWS)</a></li>\n<li><a href=\"https://cloud.google.com/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">谷歌云</a></li>\n<li><a href=\"https://azure.microsoft.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">微软云</a></li>\n</ul>\n<h3 id=\"VPS\"><a href=\"#VPS\" class=\"headerlink\" title=\"VPS\"></a>VPS</h3><ul>\n<li><a href=\"http://linode.com\" target=\"_blank\" rel=\"noopener\">Linode</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>列出了后端架构师要掌握的基本知识。少壮不努力，老大徒伤悲……</p>\n<p>本文拷贝自<a href=\"https://github.com/xingshaocheng/architect-awesome\" target=\"_blank\" rel=\"noopener\">https://github.com/xingshaocheng/architect-awesome</a></p>\n<h1>《后端架构师技术图谱》</h1>\n\n<p><strong>更新于20180513</strong></p>\n<ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据结构\" target=\"_blank\" rel=\"noopener\">数据结构</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#队列\" target=\"_blank\" rel=\"noopener\">队列</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#集合\" target=\"_blank\" rel=\"noopener\">集合</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#链表数组\" target=\"_blank\" rel=\"noopener\">链表、数组</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字典关联数组\" target=\"_blank\" rel=\"noopener\">字典、关联数组</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#栈\" target=\"_blank\" rel=\"noopener\">栈</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#树\" target=\"_blank\" rel=\"noopener\">树</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉树\" target=\"_blank\" rel=\"noopener\">二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#完全二叉树\" target=\"_blank\" rel=\"noopener\">完全二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平衡二叉树\" target=\"_blank\" rel=\"noopener\">平衡二叉树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二叉查找树bst\" target=\"_blank\" rel=\"noopener\">二叉查找树（BST）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#红黑树\" target=\"_blank\" rel=\"noopener\">红黑树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#b-bb树\" target=\"_blank\" rel=\"noopener\">B-，B+，B*树</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lsm-树\" target=\"_blank\" rel=\"noopener\">LSM 树</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#bitset\" target=\"_blank\" rel=\"noopener\">BitSet</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用算法\" target=\"_blank\" rel=\"noopener\">常用算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#排序查找算法\" target=\"_blank\" rel=\"noopener\">排序、查找算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#选择排序\" target=\"_blank\" rel=\"noopener\">选择排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#冒泡排序\" target=\"_blank\" rel=\"noopener\">冒泡排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#插入排序\" target=\"_blank\" rel=\"noopener\">插入排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#快速排序\" target=\"_blank\" rel=\"noopener\">快速排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#归并排序\" target=\"_blank\" rel=\"noopener\">归并排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#希尔排序\" target=\"_blank\" rel=\"noopener\">希尔排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#堆排序\" target=\"_blank\" rel=\"noopener\">堆排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计数排序\" target=\"_blank\" rel=\"noopener\">计数排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#桶排序\" target=\"_blank\" rel=\"noopener\">桶排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基数排序\" target=\"_blank\" rel=\"noopener\">基数排序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#二分查找\" target=\"_blank\" rel=\"noopener\">二分查找</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-中的排序工具\" target=\"_blank\" rel=\"noopener\">Java 中的排序工具</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#布隆过滤器\" target=\"_blank\" rel=\"noopener\">布隆过滤器</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#字符串比较\" target=\"_blank\" rel=\"noopener\">字符串比较</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kmp-算法\" target=\"_blank\" rel=\"noopener\">KMP 算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#深度优先广度优先\" target=\"_blank\" rel=\"noopener\">深度优先、广度优先</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贪心算法\" target=\"_blank\" rel=\"noopener\">贪心算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回溯算法\" target=\"_blank\" rel=\"noopener\">回溯算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#剪枝算法\" target=\"_blank\" rel=\"noopener\">剪枝算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#动态规划\" target=\"_blank\" rel=\"noopener\">动态规划</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#朴素贝叶斯\" target=\"_blank\" rel=\"noopener\">朴素贝叶斯</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐算法\" target=\"_blank\" rel=\"noopener\">推荐算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最小生成树算法\" target=\"_blank\" rel=\"noopener\">最小生成树算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#最短路径算法\" target=\"_blank\" rel=\"noopener\">最短路径算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#并发\" target=\"_blank\" rel=\"noopener\">并发</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多线程\" target=\"_blank\" rel=\"noopener\">多线程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程安全\" target=\"_blank\" rel=\"noopener\">线程安全</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性事务\" target=\"_blank\" rel=\"noopener\">一致性、事务</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务-acid-特性\" target=\"_blank\" rel=\"noopener\">事务 ACID 特性</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#事务的隔离级别\" target=\"_blank\" rel=\"noopener\">事务的隔离级别</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvcc\" target=\"_blank\" rel=\"noopener\">MVCC</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#锁\" target=\"_blank\" rel=\"noopener\">锁</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java中的锁和同步类\" target=\"_blank\" rel=\"noopener\">Java中的锁和同步类</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公平锁--非公平锁\" target=\"_blank\" rel=\"noopener\">公平锁 &amp; 非公平锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#悲观锁\" target=\"_blank\" rel=\"noopener\">悲观锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#乐观锁--cas\" target=\"_blank\" rel=\"noopener\">乐观锁 &amp; CAS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aba-问题\" target=\"_blank\" rel=\"noopener\">ABA 问题</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#copyonwrite容器\" target=\"_blank\" rel=\"noopener\">CopyOnWrite容器</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ringbuffer\" target=\"_blank\" rel=\"noopener\">RingBuffer</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#可重入锁--不可重入锁\" target=\"_blank\" rel=\"noopener\">可重入锁 &amp; 不可重入锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#互斥锁--共享锁\" target=\"_blank\" rel=\"noopener\">互斥锁 &amp; 共享锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#死锁\" target=\"_blank\" rel=\"noopener\">死锁</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#操作系统\" target=\"_blank\" rel=\"noopener\">操作系统</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#计算机原理\" target=\"_blank\" rel=\"noopener\">计算机原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cpu\" target=\"_blank\" rel=\"noopener\">CPU</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#多级缓存\" target=\"_blank\" rel=\"noopener\">多级缓存</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#进程\" target=\"_blank\" rel=\"noopener\">进程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#线程\" target=\"_blank\" rel=\"noopener\">线程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协程\" target=\"_blank\" rel=\"noopener\">协程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#linux\" target=\"_blank\" rel=\"noopener\">Linux</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式\" target=\"_blank\" rel=\"noopener\">设计模式</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计模式的六大原则\" target=\"_blank\" rel=\"noopener\">设计模式的六大原则</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#23种常见设计模式\" target=\"_blank\" rel=\"noopener\">23种常见设计模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景\" target=\"_blank\" rel=\"noopener\">应用场景</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单例模式\" target=\"_blank\" rel=\"noopener\">单例模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#责任链模式\" target=\"_blank\" rel=\"noopener\">责任链模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mvc\" target=\"_blank\" rel=\"noopener\">MVC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ioc\" target=\"_blank\" rel=\"noopener\">IOC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#aop\" target=\"_blank\" rel=\"noopener\">AOP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#uml\" target=\"_blank\" rel=\"noopener\">UML</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#微服务思想\" target=\"_blank\" rel=\"noopener\">微服务思想</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#康威定律\" target=\"_blank\" rel=\"noopener\">康威定律</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#运维--统计--技术支持\" target=\"_blank\" rel=\"noopener\">运维 &amp; 统计 &amp; 技术支持</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常规监控\" target=\"_blank\" rel=\"noopener\">常规监控</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apm\" target=\"_blank\" rel=\"noopener\">APM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#统计分析\" target=\"_blank\" rel=\"noopener\">统计分析</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#持续集成cicd\" target=\"_blank\" rel=\"noopener\">持续集成(CI/CD)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jenkins\" target=\"_blank\" rel=\"noopener\">Jenkins</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#环境分离\" target=\"_blank\" rel=\"noopener\">环境分离</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自动化运维\" target=\"_blank\" rel=\"noopener\">自动化运维</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ansible\" target=\"_blank\" rel=\"noopener\">Ansible</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#puppet\" target=\"_blank\" rel=\"noopener\">puppet</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#chef\" target=\"_blank\" rel=\"noopener\">chef</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#测试\" target=\"_blank\" rel=\"noopener\">测试</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tdd-理论\" target=\"_blank\" rel=\"noopener\">TDD 理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单元测试\" target=\"_blank\" rel=\"noopener\">单元测试</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#压力测试\" target=\"_blank\" rel=\"noopener\">压力测试</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全链路压测\" target=\"_blank\" rel=\"noopener\">全链路压测</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ab-灰度蓝绿测试\" target=\"_blank\" rel=\"noopener\">A/B 、灰度、蓝绿测试</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#虚拟化\" target=\"_blank\" rel=\"noopener\">虚拟化</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kvm\" target=\"_blank\" rel=\"noopener\">KVM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xen\" target=\"_blank\" rel=\"noopener\">Xen</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openvz\" target=\"_blank\" rel=\"noopener\">OpenVZ</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容器技术\" target=\"_blank\" rel=\"noopener\">容器技术</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#docker\" target=\"_blank\" rel=\"noopener\">Docker</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#云技术\" target=\"_blank\" rel=\"noopener\">云技术</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openstack\" target=\"_blank\" rel=\"noopener\">OpenStack</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#devops\" target=\"_blank\" rel=\"noopener\">DevOps</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文档管理\" target=\"_blank\" rel=\"noopener\">文档管理</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#中间件\" target=\"_blank\" rel=\"noopener\">中间件</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-server\" target=\"_blank\" rel=\"noopener\">Web Server</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nginx\" target=\"_blank\" rel=\"noopener\">Nginx</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#openresty\" target=\"_blank\" rel=\"noopener\">OpenResty</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#apache-httpd\" target=\"_blank\" rel=\"noopener\">Apache Httpd</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tomcat\" target=\"_blank\" rel=\"noopener\">Tomcat</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构原理\" target=\"_blank\" rel=\"noopener\">架构原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#调优方案\" target=\"_blank\" rel=\"noopener\">调优方案</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#jetty\" target=\"_blank\" rel=\"noopener\">Jetty</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#缓存\" target=\"_blank\" rel=\"noopener\">缓存</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#本地缓存\" target=\"_blank\" rel=\"noopener\">本地缓存</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#客户端缓存\" target=\"_blank\" rel=\"noopener\">客户端缓存</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务端缓存\" target=\"_blank\" rel=\"noopener\">服务端缓存</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web缓存\" target=\"_blank\" rel=\"noopener\">Web缓存</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#memcached\" target=\"_blank\" rel=\"noopener\">Memcached</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis\" target=\"_blank\" rel=\"noopener\">Redis</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构\" target=\"_blank\" rel=\"noopener\">架构</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#回收策略\" target=\"_blank\" rel=\"noopener\">回收策略</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tair\" target=\"_blank\" rel=\"noopener\">Tair</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息队列\" target=\"_blank\" rel=\"noopener\">消息队列</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息总线\" target=\"_blank\" rel=\"noopener\">消息总线</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#消息的顺序\" target=\"_blank\" rel=\"noopener\">消息的顺序</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rabbitmq\" target=\"_blank\" rel=\"noopener\">RabbitMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rocketmq\" target=\"_blank\" rel=\"noopener\">RocketMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#activemq\" target=\"_blank\" rel=\"noopener\">ActiveMQ</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka\" target=\"_blank\" rel=\"noopener\">Kafka</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#redis-消息推送\" target=\"_blank\" rel=\"noopener\">Redis 消息推送</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zeromq\" target=\"_blank\" rel=\"noopener\">ZeroMQ</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#定时调度\" target=\"_blank\" rel=\"noopener\">定时调度</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单机定时调度\" target=\"_blank\" rel=\"noopener\">单机定时调度</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式定时调度\" target=\"_blank\" rel=\"noopener\">分布式定时调度</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rpc\" target=\"_blank\" rel=\"noopener\">RPC</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dubbo\" target=\"_blank\" rel=\"noopener\">Dubbo</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#thrift\" target=\"_blank\" rel=\"noopener\">Thrift</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#grpc\" target=\"_blank\" rel=\"noopener\">gRPC</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库中间件\" target=\"_blank\" rel=\"noopener\">数据库中间件</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sharding-jdbc\" target=\"_blank\" rel=\"noopener\">Sharding Jdbc</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志系统\" target=\"_blank\" rel=\"noopener\">日志系统</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志搜集\" target=\"_blank\" rel=\"noopener\">日志搜集</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#配置中心\" target=\"_blank\" rel=\"noopener\">配置中心</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#api-网关\" target=\"_blank\" rel=\"noopener\">API 网关</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络\" target=\"_blank\" rel=\"noopener\">网络</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#协议\" target=\"_blank\" rel=\"noopener\">协议</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#osi-七层协议\" target=\"_blank\" rel=\"noopener\">OSI 七层协议</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcpip\" target=\"_blank\" rel=\"noopener\">TCP/IP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http\" target=\"_blank\" rel=\"noopener\">HTTP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#http20\" target=\"_blank\" rel=\"noopener\">HTTP2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#https\" target=\"_blank\" rel=\"noopener\">HTTPS</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络模型\" target=\"_blank\" rel=\"noopener\">网络模型</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#epoll\" target=\"_blank\" rel=\"noopener\">Epoll</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#java-nio\" target=\"_blank\" rel=\"noopener\">Java NIO</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kqueue\" target=\"_blank\" rel=\"noopener\">kqueue</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接和短连接\" target=\"_blank\" rel=\"noopener\">连接和短连接</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#框架\" target=\"_blank\" rel=\"noopener\">框架</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#零拷贝zero-copy\" target=\"_blank\" rel=\"noopener\">零拷贝（Zero-copy）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化二进制协议\" target=\"_blank\" rel=\"noopener\">序列化(二进制协议)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hessian\" target=\"_blank\" rel=\"noopener\">Hessian</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#protobuf\" target=\"_blank\" rel=\"noopener\">Protobuf</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库\" target=\"_blank\" rel=\"noopener\">数据库</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论\" target=\"_blank\" rel=\"noopener\">基础理论</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库设计的三大范式\" target=\"_blank\" rel=\"noopener\">数据库设计的三大范式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mysql\" target=\"_blank\" rel=\"noopener\">MySQL</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#原理\" target=\"_blank\" rel=\"noopener\">原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#innodb\" target=\"_blank\" rel=\"noopener\">InnoDB</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#优化\" target=\"_blank\" rel=\"noopener\">优化</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#索引\" target=\"_blank\" rel=\"noopener\">索引</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#聚集索引-非聚集索引\" target=\"_blank\" rel=\"noopener\">聚集索引, 非聚集索引</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#复合索引\" target=\"_blank\" rel=\"noopener\">复合索引</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#自适应哈希索引ahi\" target=\"_blank\" rel=\"noopener\">自适应哈希索引(AHI)</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#explain\" target=\"_blank\" rel=\"noopener\">explain</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#nosql\" target=\"_blank\" rel=\"noopener\">NoSQL</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mongodb\" target=\"_blank\" rel=\"noopener\">MongoDB</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hbase\" target=\"_blank\" rel=\"noopener\">Hbase</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎\" target=\"_blank\" rel=\"noopener\">搜索引擎</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#搜索引擎原理\" target=\"_blank\" rel=\"noopener\">搜索引擎原理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#lucene\" target=\"_blank\" rel=\"noopener\">Lucene</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#elasticsearch\" target=\"_blank\" rel=\"noopener\">Elasticsearch</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#solr\" target=\"_blank\" rel=\"noopener\">Solr</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sphinx\" target=\"_blank\" rel=\"noopener\">sphinx</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能\" target=\"_blank\" rel=\"noopener\">性能</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能优化方法论\" target=\"_blank\" rel=\"noopener\">性能优化方法论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容量评估\" target=\"_blank\" rel=\"noopener\">容量评估</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cdn-网络\" target=\"_blank\" rel=\"noopener\">CDN 网络</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#连接池\" target=\"_blank\" rel=\"noopener\">连接池</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#性能调优\" target=\"_blank\" rel=\"noopener\">性能调优</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据\" target=\"_blank\" rel=\"noopener\">大数据</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#流式计算\" target=\"_blank\" rel=\"noopener\">流式计算</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#storm\" target=\"_blank\" rel=\"noopener\">Storm</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#flink\" target=\"_blank\" rel=\"noopener\">Flink</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#kafka-stream\" target=\"_blank\" rel=\"noopener\">Kafka Stream</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用场景-1\" target=\"_blank\" rel=\"noopener\">应用场景</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hadoop\" target=\"_blank\" rel=\"noopener\">Hadoop</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hdfs\" target=\"_blank\" rel=\"noopener\">HDFS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#mapreduce\" target=\"_blank\" rel=\"noopener\">MapReduce</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#yarn\" target=\"_blank\" rel=\"noopener\">Yarn</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spark\" target=\"_blank\" rel=\"noopener\">Spark</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#安全\" target=\"_blank\" rel=\"noopener\">安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-安全\" target=\"_blank\" rel=\"noopener\">web 安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#xss\" target=\"_blank\" rel=\"noopener\">XSS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#csrf\" target=\"_blank\" rel=\"noopener\">CSRF</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#sql-注入\" target=\"_blank\" rel=\"noopener\">SQL 注入</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#hash-dos\" target=\"_blank\" rel=\"noopener\">Hash Dos</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#脚本注入\" target=\"_blank\" rel=\"noopener\">脚本注入</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#漏洞扫描工具\" target=\"_blank\" rel=\"noopener\">漏洞扫描工具</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#验证码\" target=\"_blank\" rel=\"noopener\">验证码</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddos-防范\" target=\"_blank\" rel=\"noopener\">DDoS 防范</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#用户隐私信息保护\" target=\"_blank\" rel=\"noopener\">用户隐私信息保护</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#序列化漏洞\" target=\"_blank\" rel=\"noopener\">序列化漏洞</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#加密解密\" target=\"_blank\" rel=\"noopener\">加密解密</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#对称加密\" target=\"_blank\" rel=\"noopener\">对称加密</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#哈希算法\" target=\"_blank\" rel=\"noopener\">哈希算法</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#非对称加密\" target=\"_blank\" rel=\"noopener\">非对称加密</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务器安全\" target=\"_blank\" rel=\"noopener\">服务器安全</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据安全\" target=\"_blank\" rel=\"noopener\">数据安全</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据备份\" target=\"_blank\" rel=\"noopener\">数据备份</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络隔离\" target=\"_blank\" rel=\"noopener\">网络隔离</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#内外网分离\" target=\"_blank\" rel=\"noopener\">内外网分离</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#登录跳板机\" target=\"_blank\" rel=\"noopener\">登录跳板机</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#授权认证\" target=\"_blank\" rel=\"noopener\">授权、认证</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rbac\" target=\"_blank\" rel=\"noopener\">RBAC</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#oauth20\" target=\"_blank\" rel=\"noopener\">OAuth2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#双因素认证2fa\" target=\"_blank\" rel=\"noopener\">双因素认证（2FA）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#单点登录sso\" target=\"_blank\" rel=\"noopener\">单点登录(SSO)</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用开源框架\" target=\"_blank\" rel=\"noopener\">常用开源框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源协议\" target=\"_blank\" rel=\"noopener\">开源协议</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#日志框架\" target=\"_blank\" rel=\"noopener\">日志框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#log4jlog4j2\" target=\"_blank\" rel=\"noopener\">Log4j、Log4j2</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#logback\" target=\"_blank\" rel=\"noopener\">Logback</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#orm\" target=\"_blank\" rel=\"noopener\">ORM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#网络框架\" target=\"_blank\" rel=\"noopener\">网络框架</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#web-框架\" target=\"_blank\" rel=\"noopener\">Web 框架</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#spring-家族\" target=\"_blank\" rel=\"noopener\">Spring 家族</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具框架\" target=\"_blank\" rel=\"noopener\">工具框架</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式设计\" target=\"_blank\" rel=\"noopener\">分布式设计</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#扩展性设计\" target=\"_blank\" rel=\"noopener\">扩展性设计</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#稳定性--高可用\" target=\"_blank\" rel=\"noopener\">稳定性 &amp; 高可用</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#硬件负载均衡\" target=\"_blank\" rel=\"noopener\">硬件负载均衡</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#软件负载均衡\" target=\"_blank\" rel=\"noopener\">软件负载均衡</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#限流\" target=\"_blank\" rel=\"noopener\">限流</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#应用层容灾\" target=\"_blank\" rel=\"noopener\">应用层容灾</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#跨机房容灾\" target=\"_blank\" rel=\"noopener\">跨机房容灾</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#容灾演练流程\" target=\"_blank\" rel=\"noopener\">容灾演练流程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#平滑启动\" target=\"_blank\" rel=\"noopener\">平滑启动</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#数据库扩展\" target=\"_blank\" rel=\"noopener\">数据库扩展</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#读写分离模式\" target=\"_blank\" rel=\"noopener\">读写分离模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分片模式\" target=\"_blank\" rel=\"noopener\">分片模式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务治理\" target=\"_blank\" rel=\"noopener\">服务治理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务注册与发现\" target=\"_blank\" rel=\"noopener\">服务注册与发现</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#服务路由控制\" target=\"_blank\" rel=\"noopener\">服务路由控制</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致\" target=\"_blank\" rel=\"noopener\">分布式一致</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#cap-与-base-理论\" target=\"_blank\" rel=\"noopener\">CAP 与 BASE 理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式锁\" target=\"_blank\" rel=\"noopener\">分布式锁</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致性算法\" target=\"_blank\" rel=\"noopener\">分布式一致性算法</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#paxos\" target=\"_blank\" rel=\"noopener\">PAXOS</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#zab\" target=\"_blank\" rel=\"noopener\">Zab</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#raft\" target=\"_blank\" rel=\"noopener\">Raft</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#gossip\" target=\"_blank\" rel=\"noopener\">Gossip</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#两阶段提交多阶段提交\" target=\"_blank\" rel=\"noopener\">两阶段提交、多阶段提交</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#幂等\" target=\"_blank\" rel=\"noopener\">幂等</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式一致方案\" target=\"_blank\" rel=\"noopener\">分布式一致方案</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式-leader-节点选举\" target=\"_blank\" rel=\"noopener\">分布式 Leader 节点选举</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#tcctryconfirmcancel-柔性事务\" target=\"_blank\" rel=\"noopener\">TCC(Try/Confirm/Cancel) 柔性事务</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#分布式文件系统\" target=\"_blank\" rel=\"noopener\">分布式文件系统</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#唯一id-生成\" target=\"_blank\" rel=\"noopener\">唯一ID 生成</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#全局唯一id\" target=\"_blank\" rel=\"noopener\">全局唯一ID</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#一致性hash算法\" target=\"_blank\" rel=\"noopener\">一致性Hash算法</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#设计思想--开发模式\" target=\"_blank\" rel=\"noopener\">设计思想 &amp; 开发模式</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#ddddomain-driven-design---领域驱动设计\" target=\"_blank\" rel=\"noopener\">DDD(Domain-driven Design - 领域驱动设计)</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#命令查询职责分离cqrs\" target=\"_blank\" rel=\"noopener\">命令查询职责分离(CQRS)</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#贫血充血模型\" target=\"_blank\" rel=\"noopener\">贫血，充血模型</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#actor-模式\" target=\"_blank\" rel=\"noopener\">Actor 模式</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#响应式编程\" target=\"_blank\" rel=\"noopener\">响应式编程</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#reactor\" target=\"_blank\" rel=\"noopener\">Reactor</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rxjava\" target=\"_blank\" rel=\"noopener\">RxJava</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vertx\" target=\"_blank\" rel=\"noopener\">Vert.x</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#dodaf20\" target=\"_blank\" rel=\"noopener\">DODAF2.0</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#serverless\" target=\"_blank\" rel=\"noopener\">Serverless</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#service-mesh\" target=\"_blank\" rel=\"noopener\">Service Mesh</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#项目管理\" target=\"_blank\" rel=\"noopener\">项目管理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构评审\" target=\"_blank\" rel=\"noopener\">架构评审</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#重构\" target=\"_blank\" rel=\"noopener\">重构</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码规范\" target=\"_blank\" rel=\"noopener\">代码规范</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码-review\" target=\"_blank\" rel=\"noopener\">代码 Review</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#rup\" target=\"_blank\" rel=\"noopener\">RUP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#看板管理\" target=\"_blank\" rel=\"noopener\">看板管理</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#scrum\" target=\"_blank\" rel=\"noopener\">SCRUM</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#敏捷开发\" target=\"_blank\" rel=\"noopener\">敏捷开发</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#极限编程xp\" target=\"_blank\" rel=\"noopener\">极限编程（XP）</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#结对编程\" target=\"_blank\" rel=\"noopener\">结对编程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#fmea管理模式\" target=\"_blank\" rel=\"noopener\">FMEA管理模式</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#通用业务术语\" target=\"_blank\" rel=\"noopener\">通用业务术语</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术趋势\" target=\"_blank\" rel=\"noopener\">技术趋势</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#政策法规\" target=\"_blank\" rel=\"noopener\">政策、法规</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#法律\" target=\"_blank\" rel=\"noopener\">法律</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#严格遵守刑法253法条\" target=\"_blank\" rel=\"noopener\">严格遵守刑法253法条</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构师素质\" target=\"_blank\" rel=\"noopener\">架构师素质</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队管理\" target=\"_blank\" rel=\"noopener\">团队管理</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#招聘\" target=\"_blank\" rel=\"noopener\">招聘</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#资讯\" target=\"_blank\" rel=\"noopener\">资讯</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业资讯\" target=\"_blank\" rel=\"noopener\">行业资讯</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#公众号列表\" target=\"_blank\" rel=\"noopener\">公众号列表</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#博客\" target=\"_blank\" rel=\"noopener\">博客</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#团队博客\" target=\"_blank\" rel=\"noopener\">团队博客</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#个人博客\" target=\"_blank\" rel=\"noopener\">个人博客</a></li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合门户社区\" target=\"_blank\" rel=\"noopener\">综合门户、社区</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#问答讨论类社区\" target=\"_blank\" rel=\"noopener\">问答、讨论类社区</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#行业数据分析\" target=\"_blank\" rel=\"noopener\">行业数据分析</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#专项网站\" target=\"_blank\" rel=\"noopener\">专项网站</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#其他类\" target=\"_blank\" rel=\"noopener\">其他类</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#推荐参考书\" target=\"_blank\" rel=\"noopener\">推荐参考书</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线电子书\" target=\"_blank\" rel=\"noopener\">在线电子书</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#纸质书\" target=\"_blank\" rel=\"noopener\">纸质书</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开发方面\" target=\"_blank\" rel=\"noopener\">开发方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#架构方面\" target=\"_blank\" rel=\"noopener\">架构方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术管理方面\" target=\"_blank\" rel=\"noopener\">技术管理方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#基础理论-1\" target=\"_blank\" rel=\"noopener\">基础理论</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具方面\" target=\"_blank\" rel=\"noopener\">工具方面</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#大数据方面\" target=\"_blank\" rel=\"noopener\">大数据方面</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#技术资源\" target=\"_blank\" rel=\"noopener\">技术资源</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#开源资源\" target=\"_blank\" rel=\"noopener\">开源资源</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#手册文档教程\" target=\"_blank\" rel=\"noopener\">手册、文档、教程</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#在线课堂\" target=\"_blank\" rel=\"noopener\">在线课堂</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#会议活动\" target=\"_blank\" rel=\"noopener\">会议、活动</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#常用app\" target=\"_blank\" rel=\"noopener\">常用APP</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#找工作\" target=\"_blank\" rel=\"noopener\">找工作</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#工具\" target=\"_blank\" rel=\"noopener\">工具</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#代码托管\" target=\"_blank\" rel=\"noopener\">代码托管</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#文件服务\" target=\"_blank\" rel=\"noopener\">文件服务</a></li>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#综合云服务商\" target=\"_blank\" rel=\"noopener\">综合云服务商</a><ul>\n<li><a href=\"https://github.com/xingshaocheng/architect-awesome/blob/master/README.md#vps\" target=\"_blank\" rel=\"noopener\">VPS</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<p><strong>（Toc generated by <a href=\"https://github.com/xingshaocheng/simple-php-github-toc\" target=\"_blank\" rel=\"noopener\">simple-php-github-toc</a> ）</strong></p>\n<h1 id=\"数据结构\"><a href=\"#数据结构\" class=\"headerlink\" title=\"数据结构\"></a>数据结构</h1><h2 id=\"队列\"><a href=\"#队列\" class=\"headerlink\" title=\"队列\"></a>队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/lemon-flm/p/7877898.html\" target=\"_blank\" rel=\"noopener\">《java队列——queue详细分析》</a></p>\n<ul>\n<li>非阻塞队列：ConcurrentLinkedQueue(无界线程安全)，采用CAS机制（compareAndSwapObject原子操作）。</li>\n<li>阻塞队列：ArrayBlockingQueue(有界)、LinkedBlockingQueue（无界）、DelayQueue、PriorityBlockingQueue，采用锁机制；使用 ReentrantLock 锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/mantu/p/5802393.html\" target=\"_blank\" rel=\"noopener\">《LinkedList、ConcurrentLinkedQueue、LinkedBlockingQueue对比分析》</a></p>\n</li>\n</ul>\n<h2 id=\"集合\"><a href=\"#集合\" class=\"headerlink\" title=\"集合\"></a>集合</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_33642117/article/details/52040345\" target=\"_blank\" rel=\"noopener\">《Java Set集合的详解》</a></li>\n</ul>\n<h2 id=\"链表、数组\"><a href=\"#链表、数组\" class=\"headerlink\" title=\"链表、数组\"></a>链表、数组</h2><ul>\n<li><a href=\"https://blog.csdn.net/wz249863091/article/details/52853360\" target=\"_blank\" rel=\"noopener\">《Java集合详解–什么是List》</a></li>\n</ul>\n<h2 id=\"字典、关联数组\"><a href=\"#字典、关联数组\" class=\"headerlink\" title=\"字典、关联数组\"></a>字典、关联数组</h2><ul>\n<li><a href=\"https://baike.xsoftlab.net/view/250.html\" target=\"_blank\" rel=\"noopener\">《Java map 详解 - 用法、遍历、排序、常用API等》</a></li>\n</ul>\n<h2 id=\"栈\"><a href=\"#栈\" class=\"headerlink\" title=\"栈\"></a>栈</h2><ul>\n<li><a href=\"https://blog.csdn.net/javazejian/article/details/53362993\" target=\"_blank\" rel=\"noopener\">《java数据结构与算法之栈（Stack）设计与实现》</a></li>\n<li><a href=\"http://www.runoob.com/java/java-stack-class.html\" target=\"_blank\" rel=\"noopener\">《Java Stack 类》</a></li>\n<li><a href=\"https://blog.csdn.net/f2006116/article/details/51375225\" target=\"_blank\" rel=\"noopener\">《java stack的详细实现分析》</a><ul>\n<li>Stack 是线程安全的。</li>\n<li>内部使用数组保存数据，不够时翻倍。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h2><h3 id=\"二叉树\"><a href=\"#二叉树\" class=\"headerlink\" title=\"二叉树\"></a>二叉树</h3><p>每个节点最多有两个叶子节点。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/cai2016/article/details/52589952\" target=\"_blank\" rel=\"noopener\">《二叉树》</a></li>\n</ul>\n<h3 id=\"完全二叉树\"><a href=\"#完全二叉树\" class=\"headerlink\" title=\"完全二叉树\"></a>完全二叉树</h3><ul>\n<li><a href=\"https://baike.baidu.com/item/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91/7773232?fr=aladdin\" target=\"_blank\" rel=\"noopener\">《完全二叉树》</a><ul>\n<li>叶节点只能出现在最下层和次下层，并且最下面一层的结点都集中在该层最左边的若干位置的二叉树。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平衡二叉树\"><a href=\"#平衡二叉树\" class=\"headerlink\" title=\"平衡二叉树\"></a>平衡二叉树</h3><p>左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/polly333/p/4798944.html\" target=\"_blank\" rel=\"noopener\">《浅谈数据结构-平衡二叉树》</a></li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-2-3-Search-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 八 平衡查找树之2-3树》</a></li>\n</ul>\n<h3 id=\"二叉查找树（BST）\"><a href=\"#二叉查找树（BST）\" class=\"headerlink\" title=\"二叉查找树（BST）\"></a>二叉查找树（BST）</h3><p>二叉查找树（Binary Search Tree），也称有序二叉树（ordered binary tree）,排序二叉树（sorted binary tree）。</p>\n<ul>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Binary-Search-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 七 二叉查找树》</a></li>\n</ul>\n<h3 id=\"红黑树\"><a href=\"#红黑树\" class=\"headerlink\" title=\"红黑树\"></a>红黑树</h3><ul>\n<li><a href=\"https://blog.csdn.net/sun_tttt/article/details/65445754\" target=\"_blank\" rel=\"noopener\">《最容易懂得红黑树》</a><ul>\n<li>添加阶段后，左旋或者右旋从而再次达到平衡。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html\" target=\"_blank\" rel=\"noopener\">《浅谈算法和数据结构: 九 平衡查找树之红黑树》</a></li>\n</ul>\n<h3 id=\"B-，B-，B-树\"><a href=\"#B-，B-，B-树\" class=\"headerlink\" title=\"B-，B+，B*树\"></a>B-，B+，B*树</h3><p>MySQL是基于B+树聚集索引组织表</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/aqzwss/article/details/53074186\" target=\"_blank\" rel=\"noopener\">《B-树，B+树，B*树详解》</a></li>\n<li><a href=\"https://blog.csdn.net/bigtree_3721/article/details/73632405\" target=\"_blank\" rel=\"noopener\">《B-树，B+树与B*树的优缺点比较》</a><ul>\n<li>B+ 树的叶子节点链表结构相比于 B- 树便于扫库，和范围检索。<h3 id=\"LSM-树\"><a href=\"#LSM-树\" class=\"headerlink\" title=\"LSM 树\"></a>LSM 树</h3></li>\n</ul>\n</li>\n</ul>\n<p>LSM（Log-Structured Merge-Trees）和 B+ 树相比，是牺牲了部分读的性能来换取写的性能(通过批量写入)，实现读写之间的。<br>Hbase、LevelDB、Tair（Long DB）、nessDB 采用 LSM 树的结构。LSM可以快速建立索引。</p>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/dbanote/article/details/8897599\" target=\"_blank\" rel=\"noopener\">《LSM树 VS B+树》</a></p>\n<ul>\n<li>B+ 树读性能好，但由于需要有序结构，当key比较分散时，磁盘寻道频繁，造成写性能。</li>\n<li>LSM 是将一个大树拆分成N棵小树，先写到内存（无寻道问题，性能高），在内存中构建一颗有序小树（有序树），随着小树越来越大，内存的小树会flush到磁盘上。当读时，由于不知道数据在哪棵小树上，因此必须遍历（二分查找）所有的小树，但在每颗小树内部数据是有序的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014774781/article/details/52105708\" target=\"_blank\" rel=\"noopener\">《LSM树（Log-Structured Merge Tree）存储引擎》</a></p>\n<ul>\n<li>极端的说，基于LSM树实现的HBase的写性能比MySQL高了一个数量级，读性能低了一个数量级。</li>\n<li>优化方式：Bloom filter 替代二分查找；compact 小数位大树，提高查询性能。</li>\n<li>Hbase 中，内存中达到一定阈值后，整体flush到磁盘上、形成一个文件（B+数），HDFS不支持update操作，所以Hbase做整体flush而不是merge update。flush到磁盘上的小树，定期会合并成一个大树。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"BitSet\"><a href=\"#BitSet\" class=\"headerlink\" title=\"BitSet\"></a>BitSet</h2><p>经常用于大规模数据的排重检查。</p>\n<ul>\n<li><a href=\"http://www.runoob.com/java/java-bitset-class.html\" target=\"_blank\" rel=\"noopener\">《Java Bitset类》</a></li>\n<li><a href=\"https://blog.csdn.net/caiandyong/article/details/51581160\" target=\"_blank\" rel=\"noopener\">《Java BitSet（位集）》</a></li>\n</ul>\n<h1 id=\"常用算法\"><a href=\"#常用算法\" class=\"headerlink\" title=\"常用算法\"></a>常用算法</h1><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\" target=\"_blank\" rel=\"noopener\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h2 id=\"排序、查找算法\"><a href=\"#排序、查找算法\" class=\"headerlink\" title=\"排序、查找算法\"></a>排序、查找算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/gane_cheng/article/details/52652705\" target=\"_blank\" rel=\"noopener\">《常见排序算法及对应的时间复杂度和空间复杂度》</a></li>\n</ul>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/shen-hua/p/5424059.html\" target=\"_blank\" rel=\"noopener\">《Java中的经典算法之选择排序（SelectionSort）》</a><ul>\n<li>每一趟从待排序的记录中选出最小的元素，顺序放在已排好序的序列最后，直到全部记录排序完毕。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h3><ul>\n<li><a href=\"https://blog.csdn.net/shuaizai88/article/details/73250615\" target=\"_blank\" rel=\"noopener\">《冒泡排序的2种写法》</a><ul>\n<li>相邻元素前后交换、把最大的排到最后。</li>\n<li>时间复杂度 O(n²) </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/hapjin/p/5517667.html\" target=\"_blank\" rel=\"noopener\">《排序算法总结之插入排序》</a></li>\n</ul>\n<h3 id=\"快速排序\"><a href=\"#快速排序\" class=\"headerlink\" title=\"快速排序\"></a>快速排序</h3><ul>\n<li><a href=\"http://developer.51cto.com/art/201403/430986.htm\" target=\"_blank\" rel=\"noopener\">《坐在马桶上看算法：快速排序》</a><ul>\n<li>一侧比另外一次都大或小。 <h3 id=\"归并排序\"><a href=\"#归并排序\" class=\"headerlink\" title=\"归并排序\"></a>归并排序</h3></li>\n</ul>\n</li>\n<li><a href=\"http://www.cnblogs.com/chengxiao/p/6194356.html\" target=\"_blank\" rel=\"noopener\">《图解排序算法(四)之归并排序》</a><ul>\n<li>分而治之，分成小份排序，在合并(重建一个新空间进行复制)。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h3><p>TODO</p>\n<h3 id=\"堆排序\"><a href=\"#堆排序\" class=\"headerlink\" title=\"堆排序\"></a>堆排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/chengxiao/p/6129630.html\" target=\"_blank\" rel=\"noopener\">《图解排序算法(三)之堆排序》</a><ul>\n<li>排序过程就是构建最大堆的过程，最大堆：每个结点的值都大于或等于其左右孩子结点的值，堆顶元素是最大值。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"计数排序\"><a href=\"#计数排序\" class=\"headerlink\" title=\"计数排序\"></a>计数排序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/suvllian/p/5495780.html\" target=\"_blank\" rel=\"noopener\">《计数排序和桶排序》</a><ul>\n<li>和桶排序过程比较像，差别在于桶的数量。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"桶排序\"><a href=\"#桶排序\" class=\"headerlink\" title=\"桶排序\"></a>桶排序</h3><ul>\n<li><a href=\"http://blog.51cto.com/ahalei/1362789\" target=\"_blank\" rel=\"noopener\">《【啊哈！算法】最快最简单的排序——桶排序》</a></li>\n<li><a href=\"https://blog.csdn.net/sunjinshengli/article/details/70738527\" target=\"_blank\" rel=\"noopener\">《排序算法（三）：计数排序与桶排序》</a><ul>\n<li>桶排序将[0,1)区间划分为n个相同的大小的子区间，这些子区间被称为桶。</li>\n<li>每个桶单独进行排序，然后再遍历每个桶。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"基数排序\"><a href=\"#基数排序\" class=\"headerlink\" title=\"基数排序\"></a>基数排序</h3><p>按照个位、十位、百位、…依次来排。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/51695211\" target=\"_blank\" rel=\"noopener\">《排序算法系列：基数排序》</a></li>\n<li><a href=\"https://www.cnblogs.com/skywang12345/p/3603669.html\" target=\"_blank\" rel=\"noopener\">《基数排序》</a></li>\n</ul>\n<h3 id=\"二分查找\"><a href=\"#二分查找\" class=\"headerlink\" title=\"二分查找\"></a>二分查找</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/coderising/p/5708632.html\" target=\"_blank\" rel=\"noopener\">《二分查找(java实现)》</a></p>\n<ul>\n<li>要求待查找的序列有序。</li>\n<li>时间复杂度 O(logN)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/maoyuanming0806/article/details/78176957\" target=\"_blank\" rel=\"noopener\">《java实现二分查找-两种方式》</a></p>\n<ul>\n<li>while + 递归。<h3 id=\"Java-中的排序工具\"><a href=\"#Java-中的排序工具\" class=\"headerlink\" title=\"Java 中的排序工具\"></a>Java 中的排序工具</h3></li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/u011410529/article/details/56668545?locationnum=6&amp;fps=1\" target=\"_blank\" rel=\"noopener\">《Arrays.sort和Collections.sort实现原理解析》</a><ul>\n<li>Collections.sort算法调用的是合并排序。</li>\n<li>Arrays.sort() 采用了2种排序算法 – 基本类型数据使用快速排序法，对象数组使用归并排序。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"布隆过滤器\"><a href=\"#布隆过滤器\" class=\"headerlink\" title=\"布隆过滤器\"></a>布隆过滤器</h2><p>常用于大数据的排重，比如email，url 等。<br>核心原理：将每条数据通过计算产生一个指纹（一个字节或多个字节，但一定比原始数据要少很多），其中每一位都是通过随机计算获得，在将指纹映射到一个大的按位存储的空间中。注意：会有一定的错误率。<br>优点：空间和时间效率都很高。<br>缺点：随着存入的元素数量增加，误算率随之增加。</p>\n<ul>\n<li><a href=\"https://segmentfault.com/a/1190000002729689\" target=\"_blank\" rel=\"noopener\">《布隆过滤器 – 空间效率很高的数据结构》</a></li>\n<li><a href=\"https://blog.csdn.net/zdxiq000/article/details/57626464\" target=\"_blank\" rel=\"noopener\">《大量数据去重：Bitmap和布隆过滤器(Bloom Filter)》</a></li>\n<li><a href=\"https://blog.csdn.net/qq_30242609/article/details/71024458\" target=\"_blank\" rel=\"noopener\">《基于Redis的布隆过滤器的实现》</a><ul>\n<li>基于 Redis 的 Bitmap 数据结构。</li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/lemon_tree12138/article/details/47973715\" target=\"_blank\" rel=\"noopener\">《网络爬虫：URL去重策略之布隆过滤器(BloomFilter)的使用》</a><ul>\n<li>使用Java中的 BitSet 类 和 加权和hash算法。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"字符串比较\"><a href=\"#字符串比较\" class=\"headerlink\" title=\"字符串比较\"></a>字符串比较</h2><h3 id=\"KMP-算法\"><a href=\"#KMP-算法\" class=\"headerlink\" title=\"KMP 算法\"></a>KMP 算法</h3><p>KMP：Knuth-Morris-Pratt算法（简称KMP）<br>核心原理是利用一个“部分匹配表”，跳过已经匹配过的元素。</p>\n<ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html\" target=\"_blank\" rel=\"noopener\">《字符串匹配的KMP算法》</a></li>\n</ul>\n<h2 id=\"深度优先、广度优先\"><a href=\"#深度优先、广度优先\" class=\"headerlink\" title=\"深度优先、广度优先\"></a>深度优先、广度优先</h2><ul>\n<li><a href=\"https://www.cnblogs.com/0kk470/p/7555033.html\" target=\"_blank\" rel=\"noopener\">《广度优先搜索BFS和深度优先搜索DFS》</a></li>\n</ul>\n<h2 id=\"贪心算法\"><a href=\"#贪心算法\" class=\"headerlink\" title=\"贪心算法\"></a>贪心算法</h2><ul>\n<li><a href=\"https://www.cnblogs.com/MrSaver/p/8641971.html\" target=\"_blank\" rel=\"noopener\">《算法：贪婪算法基础》</a></li>\n<li><a href=\"https://blog.csdn.net/a345017062/article/details/52443781\" target=\"_blank\" rel=\"noopener\">《常见算法及问题场景——贪心算法》</a></li>\n</ul>\n<h2 id=\"回溯算法\"><a href=\"#回溯算法\" class=\"headerlink\" title=\"回溯算法\"></a>回溯算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qfikh/article/details/51960331\" target=\"_blank\" rel=\"noopener\">《 五大常用算法之四：回溯法》</a></li>\n</ul>\n<h2 id=\"剪枝算法\"><a href=\"#剪枝算法\" class=\"headerlink\" title=\"剪枝算法\"></a>剪枝算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luningcsdn/article/details/50930276\" target=\"_blank\" rel=\"noopener\">《α-β剪枝算法》</a></li>\n</ul>\n<h2 id=\"动态规划\"><a href=\"#动态规划\" class=\"headerlink\" title=\"动态规划\"></a>动态规划</h2><ul>\n<li><a href=\"https://www.cnblogs.com/little-YTMM/p/5372680.html\" target=\"_blank\" rel=\"noopener\">《详解动态规划——邹博讲动态规划》</a></li>\n<li><a href=\"https://blog.csdn.net/yao_zi_jie/article/details/54580283\" target=\"_blank\" rel=\"noopener\">《动态规划算法的个人理解》</a></li>\n</ul>\n<h2 id=\"朴素贝叶斯\"><a href=\"#朴素贝叶斯\" class=\"headerlink\" title=\"朴素贝叶斯\"></a>朴素贝叶斯</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/amds123/article/details/70173402\" target=\"_blank\" rel=\"noopener\">《带你搞懂朴素贝叶斯分类算法》</a></p>\n<ul>\n<li>P(B|A)=P(A|B)P(B)/P(A)</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_one.html\" target=\"_blank\" rel=\"noopener\">《贝叶斯推断及其互联网应用1》</a></p>\n</li>\n<li><a href=\"http://www.ruanyifeng.com/blog/2011/08/bayesian_inference_part_two.html\" target=\"_blank\" rel=\"noopener\">《贝叶斯推断及其互联网应用2》</a></li>\n</ul>\n<h2 id=\"推荐算法\"><a href=\"#推荐算法\" class=\"headerlink\" title=\"推荐算法\"></a>推荐算法</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/recommendation-algorithm-overview-part01\" target=\"_blank\" rel=\"noopener\">《推荐算法综述》</a></li>\n<li><a href=\"https://www.oschina.net/news/51297/top-10-open-source-recommendation-systems\" target=\"_blank\" rel=\"noopener\">《TOP 10 开源的推荐系统简介》</a></li>\n</ul>\n<h2 id=\"最小生成树算法\"><a href=\"#最小生成树算法\" class=\"headerlink\" title=\"最小生成树算法\"></a>最小生成树算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/luoshixian099/article/details/51908175\" target=\"_blank\" rel=\"noopener\">《算法导论–最小生成树（Kruskal和Prim算法）》</a></li>\n</ul>\n<h2 id=\"最短路径算法\"><a href=\"#最短路径算法\" class=\"headerlink\" title=\"最短路径算法\"></a>最短路径算法</h2><ul>\n<li><a href=\"https://blog.csdn.net/qq_35644234/article/details/60870719\" target=\"_blank\" rel=\"noopener\">《Dijkstra算法详解》</a></li>\n</ul>\n<h1 id=\"并发\"><a href=\"#并发\" class=\"headerlink\" title=\"并发\"></a>并发</h1><h2 id=\"Java-并发\"><a href=\"#Java-并发\" class=\"headerlink\" title=\"Java 并发\"></a>Java 并发</h2><ul>\n<li><a href=\"https://github.com/CL0610/Java-concurrency\" target=\"_blank\" rel=\"noopener\">Java 并发知识合集</a></li>\n<li><a href=\"https://github.com/CL0610/Java-concurrency/blob/master/Java并发知识图谱.png\" target=\"_blank\" rel=\"noopener\">JAVA并发知识图谱</a></li>\n</ul>\n<h2 id=\"多线程\"><a href=\"#多线程\" class=\"headerlink\" title=\"多线程\"></a>多线程</h2><ul>\n<li><a href=\"http://www.importnew.com/18459.html\" target=\"_blank\" rel=\"noopener\">《40个Java多线程问题总结》</a></li>\n</ul>\n<h2 id=\"线程安全\"><a href=\"#线程安全\" class=\"headerlink\" title=\"线程安全\"></a>线程安全</h2><ul>\n<li><a href=\"https://www.cnblogs.com/zhanht/p/5450325.html\" target=\"_blank\" rel=\"noopener\">《Java并发编程——线程安全及解决机制简介》</a></li>\n</ul>\n<h2 id=\"一致性、事务\"><a href=\"#一致性、事务\" class=\"headerlink\" title=\"一致性、事务\"></a>一致性、事务</h2><h3 id=\"事务-ACID-特性\"><a href=\"#事务-ACID-特性\" class=\"headerlink\" title=\"事务 ACID 特性\"></a>事务 ACID 特性</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012440687/article/details/52116108\" target=\"_blank\" rel=\"noopener\">《数据库事务ACID特性》</a></li>\n</ul>\n<h3 id=\"事务的隔离级别\"><a href=\"#事务的隔离级别\" class=\"headerlink\" title=\"事务的隔离级别\"></a>事务的隔离级别</h3><ul>\n<li>未提交读：一个事务可以读取另一个未提交的数据，容易出现脏读的情况。</li>\n<li>读提交：一个事务等另外一个事务提交之后才可以读取数据，但会出现不可重复读的情况（多次读取的数据不一致），读取过程中出现UPDATE操作，会多。（大多数数据库默认级别是RC，比如SQL Server，Oracle），读取的时候不可以修改。</li>\n<li>可重复读： 同一个事务里确保每次读取的时候，获得的是同样的数据，但不保障原始数据被其他事务更新（幻读），Mysql InnoDB 就是这个级别。</li>\n<li><p>序列化：所有事物串行处理（牺牲了效率）</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/qq_33290787/article/details/51924963\" target=\"_blank\" rel=\"noopener\">《理解事务的4种隔离级别》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/z-sm/p/7245981.html\" target=\"_blank\" rel=\"noopener\">数据库事务的四大特性及事务隔离级别</a></p>\n</li>\n<li><p><a href=\"http://blog.sina.com.cn/s/blog_499740cb0100ugs7.html\" target=\"_blank\" rel=\"noopener\">《MySQL的InnoDB的幻读问题 》</a></p>\n<ul>\n<li>幻读的例子非常清楚。</li>\n<li>通过 SELECT … FOR UPDATE 解决。</li>\n</ul>\n</li>\n<li><p><a href=\"http://database.51cto.com/art/201804/570101.htm\" target=\"_blank\" rel=\"noopener\">《一篇文章带你读懂MySQL和InnoDB》</a></p>\n<ul>\n<li>图解脏读、不可重复读、幻读问题。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"MVCC\"><a href=\"#MVCC\" class=\"headerlink\" title=\"MVCC\"></a>MVCC</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/chenpingzhao/p/5065316.html\" target=\"_blank\" rel=\"noopener\">《【mysql】关于innodb中MVCC的一些理解》</a></p>\n<ul>\n<li>innodb 中 MVCC 用在 Repeatable-Read 隔离级别。</li>\n<li>MVCC 会产生幻读问题（更新时异常。）</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/whoamiyang/article/details/51901888\" target=\"_blank\" rel=\"noopener\">《轻松理解MYSQL MVCC 实现机制》</a></p>\n<ul>\n<li>通过隐藏版本列来实现 MVCC 控制，一列记录创建时间、一列记录删除时间，这里的时间</li>\n<li>每次只操作比当前版本小（或等于）的 行。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"锁\"><a href=\"#锁\" class=\"headerlink\" title=\"锁\"></a>锁</h2><h3 id=\"Java中的锁和同步类\"><a href=\"#Java中的锁和同步类\" class=\"headerlink\" title=\"Java中的锁和同步类\"></a>Java中的锁和同步类</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/qifengshi/p/6831055.html\" target=\"_blank\" rel=\"noopener\">《Java中的锁分类》</a></p>\n<ul>\n<li>主要包括 synchronized、ReentrantLock、和 ReadWriteLock。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/waterystone/p/4920797.html\" target=\"_blank\" rel=\"noopener\">《Java并发之AQS详解》</a></p>\n</li>\n<li><p><a href=\"http://cuisuqiang.iteye.com/blog/2020146\" target=\"_blank\" rel=\"noopener\">《Java中信号量 Semaphore》</a></p>\n<ul>\n<li>有数量控制</li>\n<li>申请用 acquire，申请不要则阻塞；释放用 release。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/davidwang456/p/6094947.html\" target=\"_blank\" rel=\"noopener\">《java开发中的Mutex vs Semaphore》</a></p>\n<ul>\n<li>简单的说 就是Mutex是排它的，只有一个可以获取到资源， Semaphore也具有排它性，但可以定义多个可以获取的资源的对象。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"公平锁-amp-非公平锁\"><a href=\"#公平锁-amp-非公平锁\" class=\"headerlink\" title=\"公平锁 &amp; 非公平锁\"></a>公平锁 &amp; 非公平锁</h3><p>公平锁的作用就是严格按照线程启动的顺序来执行的，不允许其他线程插队执行的；而非公平锁是允许插队的。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/EthanWhite/article/details/55508357\" target=\"_blank\" rel=\"noopener\">《公平锁与非公平锁》</a><ul>\n<li>默认情况下 ReentrantLock 和 synchronized 都是非公平锁。ReentrantLock 可以设置成公平锁。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"悲观锁\"><a href=\"#悲观锁\" class=\"headerlink\" title=\"悲观锁\"></a>悲观锁</h3><p>悲观锁如果使用不当（锁的条数过多），会引起服务大面积等待。推荐优先使用乐观锁+重试。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/zhiqian-ali/p/6200874.html\" target=\"_blank\" rel=\"noopener\">《【MySQL】悲观锁&amp;乐观锁》</a></p>\n<ul>\n<li>乐观锁的方式：版本号+重试方式</li>\n<li>悲观锁：通过 select … for update 进行行锁(不可读、不可写，share 锁可读不可写)。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/Lawson/p/5008741.html\" target=\"_blank\" rel=\"noopener\">《Mysql查询语句使用select.. for update导致的数据库死锁分析》</a></p>\n<ul>\n<li>mysql的innodb存储引擎实务锁虽然是锁行，但它内部是锁索引的。</li>\n<li>锁相同数据的不同索引条件可能会引起死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zejin2008/p/5262751.html\" target=\"_blank\" rel=\"noopener\">《Mysql并发时经典常见的死锁原因及解决方法》</a></p>\n</li>\n</ul>\n<h3 id=\"乐观锁-amp-CAS\"><a href=\"#乐观锁-amp-CAS\" class=\"headerlink\" title=\"乐观锁 &amp; CAS\"></a>乐观锁 &amp; CAS</h3><ul>\n<li><a href=\"http://www.importnew.com/20472.html\" target=\"_blank\" rel=\"noopener\">《乐观锁的一种实现方式——CAS》</a><ul>\n<li>和MySQL乐观锁方式相似，只不过是通过和原值进行比较。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"ABA-问题\"><a href=\"#ABA-问题\" class=\"headerlink\" title=\"ABA 问题\"></a>ABA 问题</h3><p>由于高并发，在CAS下，更新后可能此A非彼A。通过版本号可以解决，类似于上文Mysql 中提到的的乐观锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/549294286/p/3766717.html\" target=\"_blank\" rel=\"noopener\">《Java CAS 和ABA问题》</a></li>\n<li><a href=\"https://blog.csdn.net/li954644351/article/details/50511879\" target=\"_blank\" rel=\"noopener\">《Java 中 ABA问题及避免》</a><ul>\n<li>AtomicStampedReference 和 AtomicStampedReference。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"CopyOnWrite容器\"><a href=\"#CopyOnWrite容器\" class=\"headerlink\" title=\"CopyOnWrite容器\"></a>CopyOnWrite容器</h3><p>可以对CopyOnWrite容器进行并发的读，而不需要加锁。CopyOnWrite并发容器用于读多写少的并发场景。比如白名单，黑名单，商品类目的访问和更新场景，不适合需要数据强一致性的场景。</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/hapjin/p/4840107.html\" target=\"_blank\" rel=\"noopener\">《JAVA中写时复制(Copy-On-Write)Map实现》</a></p>\n<ul>\n<li>实现读写分离，读取发生在原始数据上，写入发生在副本上。  </li>\n<li>不用加锁，通过最终一致实现一致性。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/a494303877/article/details/53404623\" target=\"_blank\" rel=\"noopener\">《聊聊并发-Java中的Copy-On-Write容器》</a></p>\n</li>\n</ul>\n<h3 id=\"RingBuffer\"><a href=\"#RingBuffer\" class=\"headerlink\" title=\"RingBuffer\"></a>RingBuffer</h3><ul>\n<li><a href=\"http://www.cnblogs.com/l00l/p/4115001.html\" target=\"_blank\" rel=\"noopener\">《线程安全的无锁RingBuffer的实现【一个读线程，一个写线程】》</a></li>\n</ul>\n<h3 id=\"可重入锁-amp-不可重入锁\"><a href=\"#可重入锁-amp-不可重入锁\" class=\"headerlink\" title=\"可重入锁 &amp; 不可重入锁\"></a>可重入锁 &amp; 不可重入锁</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/dj3839/p/6580765.html\" target=\"_blank\" rel=\"noopener\">《可重入锁和不可重入锁》</a></p>\n<ul>\n<li>通过简单代码举例说明可重入锁和不可重入锁。</li>\n<li>可重入锁指同一个线程可以再次获得之前已经获得的锁。</li>\n<li>可重入锁可以用户避免死锁。</li>\n<li>Java中的可重入锁：synchronized 和 java.util.concurrent.locks.ReentrantLock</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/baizhanshi/p/7211802.html\" target=\"_blank\" rel=\"noopener\">《ReenTrantLock可重入锁（和synchronized的区别）总结》</a></p>\n<ul>\n<li>synchronized 使用方便，编译器来加锁，是非公平锁。</li>\n<li>ReenTrantLock 使用灵活，锁的公平性可以定制。</li>\n<li>相同加锁场景下，推荐使用 synchronized。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"互斥锁-amp-共享锁\"><a href=\"#互斥锁-amp-共享锁\" class=\"headerlink\" title=\"互斥锁 &amp; 共享锁\"></a>互斥锁 &amp; 共享锁</h3><p>互斥锁：同时只能有一个线程获得锁。比如，ReentrantLock 是互斥锁，ReadWriteLock 中的写锁是互斥锁。<br>共享锁：可以有多个线程同时或的锁。比如，Semaphore、CountDownLatch 是共享锁，ReadWriteLock 中的读锁是共享锁。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/liang1101/p/6475555.html\" target=\"_blank\" rel=\"noopener\">《ReadWriteLock场景应用》</a></li>\n</ul>\n<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><ul>\n<li><a href=\"https://blog.csdn.net/yunfenglw/article/details/45950305\" target=\"_blank\" rel=\"noopener\">《“死锁”四个必要条件的合理解释》</a><ul>\n<li>互斥、持有、不可剥夺、环形等待。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014039577/article/details/52351626\" target=\"_blank\" rel=\"noopener\">Java如何查看死锁？</a></p>\n<ul>\n<li>JConsole 可以识别死锁。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/bohu83/article/details/51135061\" target=\"_blank\" rel=\"noopener\">java多线程系列：死锁及检测</a></p>\n<ul>\n<li>jstack 可以显示死锁。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h1><h2 id=\"计算机原理\"><a href=\"#计算机原理\" class=\"headerlink\" title=\"计算机原理\"></a>计算机原理</h2><ul>\n<li><a href=\"https://segmentfault.com/a/1190000003692840\" target=\"_blank\" rel=\"noopener\">《操作系统基础知识——操作系统的原理，类型和结构》</a></li>\n</ul>\n<h2 id=\"CPU\"><a href=\"#CPU\" class=\"headerlink\" title=\"CPU\"></a>CPU</h2><h3 id=\"多级缓存\"><a href=\"#多级缓存\" class=\"headerlink\" title=\"多级缓存\"></a>多级缓存</h3><p>典型的 CPU 有三级缓存，距离核心越近，速度越快，空间越小。L1 一般 32k，L2 一般 256k，L3 一般12M。内存速度需要200个 CPU 周期，CPU 缓存需要1个CPU周期。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/zero__007/article/details/54089730\" target=\"_blank\" rel=\"noopener\">《从Java视角理解CPU缓存和伪共享》</a></li>\n</ul>\n<h2 id=\"进程\"><a href=\"#进程\" class=\"headerlink\" title=\"进程\"></a>进程</h2><p>TODO</p>\n<h2 id=\"线程\"><a href=\"#线程\" class=\"headerlink\" title=\"线程\"></a>线程</h2><ul>\n<li><a href=\"https://blog.csdn.net/asdf_1024/article/details/78978437\" target=\"_blank\" rel=\"noopener\">《线程的生命周期及状态转换详解》</a></li>\n</ul>\n<h2 id=\"协程\"><a href=\"#协程\" class=\"headerlink\" title=\"协程\"></a>协程</h2><ul>\n<li><a href=\"https://www.thinksaas.cn/group/topic/839375/\" target=\"_blank\" rel=\"noopener\">《终结python协程—-从yield到actor模型的实现》</a><ul>\n<li>线程的调度是由操作系统负责，协程调度是程序自行负责</li>\n<li>与线程相比，协程减少了无谓的操作系统切换.</li>\n<li>实际上当遇到IO操作时做切换才更有意义，（因为IO操作不用占用CPU），如果没遇到IO操作，按照时间片切换.</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><ul>\n<li><a href=\"http://www.runoob.com/linux/linux-command-manual.html\" target=\"_blank\" rel=\"noopener\">《Linux 命令大全》</a></li>\n</ul>\n<h1 id=\"设计模式\"><a href=\"#设计模式\" class=\"headerlink\" title=\"设计模式\"></a>设计模式</h1><h2 id=\"设计模式的六大原则\"><a href=\"#设计模式的六大原则\" class=\"headerlink\" title=\"设计模式的六大原则\"></a>设计模式的六大原则</h2><ul>\n<li><a href=\"https://blog.csdn.net/q291611265/article/details/48465113\" target=\"_blank\" rel=\"noopener\">《设计模式的六大原则》</a><ul>\n<li>开闭原则：对扩展开放,对修改关闭，多使用抽象类和接口。</li>\n<li>里氏替换原则：基类可以被子类替换，使用抽象类继承,不使用具体类继承。</li>\n<li>依赖倒转原则：要依赖于抽象,不要依赖于具体，针对接口编程,不针对实现编程。</li>\n<li>接口隔离原则：使用多个隔离的接口,比使用单个接口好，建立最小的接口。</li>\n<li>迪米特法则：一个软件实体应当尽可能少地与其他实体发生相互作用，通过中间类建立联系。</li>\n<li>合成复用原则：尽量使用合成/聚合,而不是使用继承。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"23种常见设计模式\"><a href=\"#23种常见设计模式\" class=\"headerlink\" title=\"23种常见设计模式\"></a>23种常见设计模式</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/design-pattern-tutorial.html\" target=\"_blank\" rel=\"noopener\">《设计模式》</a></li>\n<li><a href=\"https://www.cnblogs.com/susanws/p/5510229.html\" target=\"_blank\" rel=\"noopener\">《23种设计模式全解析》</a></li>\n</ul>\n<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><ul>\n<li><p><a href=\"http://blog.jobbole.com/62314/\" target=\"_blank\" rel=\"noopener\">《细数JDK里的设计模式》</a></p>\n<ul>\n<li><p>结构型模式：</p>\n<ul>\n<li>适配器：用来把一个接口转化成另一个接口，如 java.util.Arrays#asList()。</li>\n<li>桥接模式：这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化，如JDBC；</li>\n<li>组合模式：使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数，如 Map.putAll，List.addAll、Set.addAll。</li>\n<li>装饰者模式：动态的给一个对象附加额外的功能，这也是子类的一种替代方式，如 java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap。</li>\n<li>享元模式：使用缓存来加速大量小对象的访问时间，如 valueOf(int)。</li>\n<li>代理模式：代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象，如 java.lang.reflect.Proxy</li>\n</ul>\n</li>\n<li><p>创建模式:</p>\n<ul>\n<li>抽象工厂模式：抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型，如 java.util.Calendar#getInstance()。</li>\n<li>建造模式(Builder)：定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建，如：java.lang.StringBuilder#append()。</li>\n<li>工厂方法：就是 <strong>一个返*</strong> 回具体对象的方法，而不是多个，如 java.lang.Object#toString()、java.lang.Class#newInstance()。</li>\n<li>原型模式：使得类的实例能够生成自身的拷贝、如：java.lang.Object#clone()。</li>\n<li>单例模式：全局只有一个实例，如 java.lang.Runtime#getRuntime()。</li>\n</ul>\n</li>\n<li>行为模式：<ul>\n<li>责任链模式：通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。如 javax.servlet.Filter#doFilter()。</li>\n<li>命令模式：将操作封装到对象内，以便存储，传递和返回，如：java.lang.Runnable。</li>\n<li>解释器模式：定义了一个语言的语法，然后解析相应语法的语句，如，java.text.Format，java.text.Normalizer。</li>\n<li>迭代器模式：提供一个一致的方法来顺序访问集合中的对象，如 java.util.Iterator。</li>\n<li>中介者模式：通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖，java.lang.reflect.Method#invoke()。</li>\n<li>空对象模式：如 java.util.Collections#emptyList()。</li>\n<li>观察者模式：它使得一个对象可以灵活的将消息发送给感兴趣的对象，如 java.util.EventListener。</li>\n<li>模板方法模式：让子类可以重写方法的一部分，而不是整个重写，如 java.util.Collections#sort()。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/hwaggLee/p/4510687.html\" target=\"_blank\" rel=\"noopener\">《Spring-涉及到的设计模式汇总》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/u012387062/article/details/54719114\" target=\"_blank\" rel=\"noopener\">《Mybatis使用的设计模式》</a></li>\n</ul>\n<h2 id=\"单例模式\"><a href=\"#单例模式\" class=\"headerlink\" title=\"单例模式\"></a>单例模式</h2><ul>\n<li><a href=\"https://blog.csdn.net/YECrazy/article/details/79481964\" target=\"_blank\" rel=\"noopener\">《单例模式的三种实现 以及各自的优缺点》</a></li>\n<li><a href=\"https://www.cnblogs.com/ttylinux/p/6498822.html\" target=\"_blank\" rel=\"noopener\">《单例模式－－反射－－防止序列化破坏单例模式》</a><ul>\n<li>使用枚举类型。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"责任链模式\"><a href=\"#责任链模式\" class=\"headerlink\" title=\"责任链模式\"></a>责任链模式</h2><p>TODO</p>\n<h2 id=\"MVC\"><a href=\"#MVC\" class=\"headerlink\" title=\"MVC\"></a>MVC</h2><ul>\n<li><a href=\"http://www.runoob.com/design-pattern/mvc-pattern.html\" target=\"_blank\" rel=\"noopener\">《MVC 模式》</a><ul>\n<li>模型(model)－视图(view)－控制器(controller) </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"IOC\"><a href=\"#IOC\" class=\"headerlink\" title=\"IOC\"></a>IOC</h2><ul>\n<li><a href=\"https://www.zhihu.com/question/23277575\" target=\"_blank\" rel=\"noopener\">《理解 IOC》</a></li>\n<li><a href=\"https://www.cnblogs.com/NancyStartOnce/p/6813162.html\" target=\"_blank\" rel=\"noopener\">《IOC 的理解与解释》</a><ul>\n<li>正向控制：传统通过new的方式。反向控制，通过容器注入对象。</li>\n<li>作用：用于模块解耦。</li>\n<li>DI：Dependency Injection，即依赖注入，只关心资源使用，不关心资源来源。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"AOP\"><a href=\"#AOP\" class=\"headerlink\" title=\"AOP\"></a>AOP</h2><ul>\n<li><a href=\"https://my.oschina.net/yanquan345/blog/203415\" target=\"_blank\" rel=\"noopener\">《轻松理解AOP(面向切面编程)》</a></li>\n<li><a href=\"https://www.cnblogs.com/hongwz/p/5764917.html\" target=\"_blank\" rel=\"noopener\">《Spring AOP详解》</a></li>\n<li><a href=\"http://www.importnew.com/24305.html\" target=\"_blank\" rel=\"noopener\">《Spring AOP的实现原理》</a><ul>\n<li>Spring AOP使用的动态代理，主要有两种方式：JDK动态代理和CGLIB动态代理。</li>\n</ul>\n</li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-springaopcglib/\" target=\"_blank\" rel=\"noopener\">《Spring AOP 实现原理与 CGLIB 应用》</a><ul>\n<li>Spring AOP 框架对 AOP 代理类的处理原则是：如果目标对象的实现类实现了接口，Spring AOP 将会采用 JDK 动态代理来生成 AOP 代理类；如果目标对象的实现类没有实现接口，Spring AOP 将会采用 CGLIB 来生成 AOP 代理类 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"UML\"><a href=\"#UML\" class=\"headerlink\" title=\"UML\"></a>UML</h2><ul>\n<li><a href=\"https://www.w3cschool.cn/uml_tutorial/\" target=\"_blank\" rel=\"noopener\">《UML教程》</a></li>\n</ul>\n<h2 id=\"微服务思想\"><a href=\"#微服务思想\" class=\"headerlink\" title=\"微服务思想\"></a>微服务思想</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/6219259.html\" target=\"_blank\" rel=\"noopener\">《微服务架构设计》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/micro-service-technology-stack\" target=\"_blank\" rel=\"noopener\">《微服务架构技术栈选型手册》</a></li>\n</ul>\n<h3 id=\"康威定律\"><a href=\"#康威定律\" class=\"headerlink\" title=\"康威定律\"></a>康威定律</h3><ul>\n<li><p><a href=\"https://yq.aliyun.com/articles/8611\" target=\"_blank\" rel=\"noopener\">《微服务架构的理论基础 - 康威定律》</a></p>\n<ul>\n<li>定律一：组织沟通方式会通过系统设计表达出来，就是说架构的布局和组织结构会有相似。</li>\n<li>定律二：时间再多一件事情也不可能做的完美，但总有时间做完一件事情。一口气吃不成胖子，先搞定能搞定的。</li>\n<li>定律三：线型系统和线型组织架构间有潜在的异质同态特性。种瓜得瓜，做独立自治的子系统减少沟通成本。</li>\n<li>定律四：大的系统组织总是比小系统更倾向于分解。合久必分，分而治之。</li>\n</ul>\n</li>\n<li><p><a href=\"https://static.geekbang.org/PDF-%E4%BF%AE%E6%94%B9%E7%89%88-%E6%9E%81%E5%AE%A2%E6%97%B6%E9%97%B4-%E5%9B%BE%E7%89%87-%E6%9D%A8%E6%B3%A2-%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84.pdf\" target=\"_blank\" rel=\"noopener\">《微服务架构核⼼20讲》</a></p>\n</li>\n</ul>\n<h1 id=\"运维-amp-统计-amp-技术支持\"><a href=\"#运维-amp-统计-amp-技术支持\" class=\"headerlink\" title=\"运维 &amp; 统计 &amp; 技术支持\"></a>运维 &amp; 统计 &amp; 技术支持</h1><h2 id=\"常规监控\"><a href=\"#常规监控\" class=\"headerlink\" title=\"常规监控\"></a>常规监控</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/77849205\" target=\"_blank\" rel=\"noopener\">《腾讯业务系统监控的修炼之路》</a></p>\n<ul>\n<li>监控的方式：主动、被动、旁路(比如舆情监控)</li>\n<li>监控类型： 基础监控、服务端监控、客户端监控、<br>监控、用户端监控</li>\n<li>监控的目标：全、块、准</li>\n<li>核心指标：请求量、成功率、耗时</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.oschina.net/news/67525/monitoring-tools\" target=\"_blank\" rel=\"noopener\">《开源还是商用？十大云运维监控工具横评》</a></p>\n<ul>\n<li>Zabbix、Nagios、Ganglia、Zenoss、Open-falcon、监控宝、 360网站服务监控、阿里云监控、百度云观测、小蜜蜂网站监测等。</li>\n</ul>\n</li>\n<li><p><a href=\"http://developer.51cto.com/art/201612/525373.htm\" target=\"_blank\" rel=\"noopener\">《监控报警系统搭建及二次开发经验》</a></p>\n</li>\n</ul>\n<p><strong>命令行监控工具</strong></p>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/44-an-quan-yu-yun-wei/445-fu-wu-qi-zhuang-tai-jian-ce/4451-ming-ling-xing-gong-ju.html\" target=\"_blank\" rel=\"noopener\">《常用命令行监控工具》</a></p>\n<ul>\n<li>top、sar、tsar、nload</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.jobbole.com/96846/\" target=\"_blank\" rel=\"noopener\">《20个命令行工具监控 Linux 系统性能》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/feichexia/blog/196575\" target=\"_blank\" rel=\"noopener\">《JVM性能调优监控工具jps、jstack、jmap、jhat、jstat、hprof使用详解》</a></p>\n</li>\n</ul>\n<h2 id=\"APM\"><a href=\"#APM\" class=\"headerlink\" title=\"APM\"></a>APM</h2><p>APM —  Application Performance Management</p>\n<ul>\n<li><p><a href=\"http://bigbully.github.io/Dapper-translation/\" target=\"_blank\" rel=\"noopener\">《Dapper，大规模分布式系统的跟踪系统》</a></p>\n</li>\n<li><p><a href=\"http://opentracing.io\" target=\"_blank\" rel=\"noopener\">CNCF OpenTracing</a>，<a href=\"https://github.com/opentracing-contrib/opentracing-specification-zh\" target=\"_blank\" rel=\"noopener\">中文版</a></p>\n</li>\n<li><p>主要开源软件，按字母排序</p>\n<ul>\n<li><a href=\"https://github.com/apache/incubator-skywalking\" target=\"_blank\" rel=\"noopener\">Apache SkyWalking</a></li>\n<li><a href=\"https://github.com/dianping/cat\" target=\"_blank\" rel=\"noopener\">CAT</a></li>\n<li><a href=\"https://github.com/jaegertracing/jaeger\" target=\"_blank\" rel=\"noopener\">CNCF jaeger</a></li>\n<li><a href=\"https://github.com/naver/pinpoint\" target=\"_blank\" rel=\"noopener\">Pinpoint</a></li>\n<li><a href=\"https://github.com/openzipkin/zipkin\" target=\"_blank\" rel=\"noopener\">Zipkin</a></li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/apm-Pinpoint-practice\" target=\"_blank\" rel=\"noopener\">《开源APM技术选型与实战》</a></p>\n<ul>\n<li>主要基于 Google的Dapper（大规模分布式系统的跟踪系统） 思想。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"统计分析\"><a href=\"#统计分析\" class=\"headerlink\" title=\"统计分析\"></a>统计分析</h2><ul>\n<li><p><a href=\"https://zhuanlan.zhihu.com/p/25195217\" target=\"_blank\" rel=\"noopener\">《流量统计的基础：埋点》</a></p>\n<ul>\n<li>常用指标：访问与访客、停留时长、跳出率、退出率、转化率、参与度</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.25xt.com/company/17066.html\" target=\"_blank\" rel=\"noopener\">《APP埋点常用的统计工具、埋点目标和埋点内容》</a></p>\n<ul>\n<li>第三方统计：友盟、百度移动、魔方、App Annie、talking data、神策数据等。</li>\n</ul>\n</li>\n<li><p><a href=\"https://tech.meituan.com/mt-mobile-analytics-practice.html\" target=\"_blank\" rel=\"noopener\">《美团点评前端无痕埋点实践》</a></p>\n<ul>\n<li>所谓无痕、即通过可视化工具配置采集节点，在前端自动解析配置并上报埋点数据，而非硬编码。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"持续集成-CI-CD\"><a href=\"#持续集成-CI-CD\" class=\"headerlink\" title=\"持续集成(CI/CD)\"></a>持续集成(CI/CD)</h2><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2015/09/continuous-integration.html\" target=\"_blank\" rel=\"noopener\">《持续集成是什么？》</a></li>\n<li><a href=\"https://www.testwo.com/article/1170\" target=\"_blank\" rel=\"noopener\">《8个流行的持续集成工具》</a></li>\n</ul>\n<h3 id=\"Jenkins\"><a href=\"#Jenkins\" class=\"headerlink\" title=\"Jenkins\"></a>Jenkins</h3><ul>\n<li><a href=\"https://www.liaoxuefeng.com/article/001463233913442cdb2d1bd1b1b42e3b0b29eb1ba736c5e000\" target=\"_blank\" rel=\"noopener\">《使用Jenkins进行持续集成》</a></li>\n</ul>\n<h3 id=\"环境分离\"><a href=\"#环境分离\" class=\"headerlink\" title=\"环境分离\"></a>环境分离</h3><p>开发、测试、生成环境分离。</p>\n<ul>\n<li><a href=\"https://my.oschina.net/sancuo/blog/214904\" target=\"_blank\" rel=\"noopener\">《开发环境、生产环境、测试环境的基本理解和区》</a></li>\n</ul>\n<h2 id=\"自动化运维\"><a href=\"#自动化运维\" class=\"headerlink\" title=\"自动化运维\"></a>自动化运维</h2><h3 id=\"Ansible\"><a href=\"#Ansible\" class=\"headerlink\" title=\"Ansible\"></a>Ansible</h3><ul>\n<li><a href=\"http://www.ansible.com.cn/\" target=\"_blank\" rel=\"noopener\">《Ansible中文权威指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/heiye123/articles/7855890.html\" target=\"_blank\" rel=\"noopener\">《Ansible基础配置和企业级项目实用案例》</a></li>\n</ul>\n<h3 id=\"puppet\"><a href=\"#puppet\" class=\"headerlink\" title=\"puppet\"></a>puppet</h3><ul>\n<li><a href=\"https://www.cnblogs.com/keerya/p/8040071.html\" target=\"_blank\" rel=\"noopener\">《自动化运维工具——puppet详解》</a></li>\n</ul>\n<h3 id=\"chef\"><a href=\"#chef\" class=\"headerlink\" title=\"chef\"></a>chef</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/cloud/library/1407_caomd_chef/\" target=\"_blank\" rel=\"noopener\">《Chef 的安装与使用》</a></li>\n</ul>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><h3 id=\"TDD-理论\"><a href=\"#TDD-理论\" class=\"headerlink\" title=\"TDD 理论\"></a>TDD 理论</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/62f16cd4fef3\" target=\"_blank\" rel=\"noopener\">《深度解读 - TDD（测试驱动开发）》</a><ul>\n<li>基于测试用例编码功能代码，XP（Extreme Programming）的核心实践.</li>\n<li>好处：一次关注一个点，降低思维负担；迎接需求变化或改善代码的设计；提前澄清需求；快速反馈； </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"单元测试\"><a href=\"#单元测试\" class=\"headerlink\" title=\"单元测试\"></a>单元测试</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyzm/p/6482886.html\" target=\"_blank\" rel=\"noopener\">《Java单元测试之JUnit篇》</a></li>\n<li><a href=\"https://blog.csdn.net/hotdust/article/details/53406086\" target=\"_blank\" rel=\"noopener\">《JUnit 4 与 TestNG 对比》</a><ul>\n<li>TestNG 覆盖 JUnit 功能，适用于更复杂的场景。 </li>\n</ul>\n</li>\n<li><a href=\"https://blog.csdn.net/wqetfg/article/details/50900512\" target=\"_blank\" rel=\"noopener\">《单元测试主要的测试功能点》</a><ul>\n<li>模块接口测试、局部数据结构测试、路径测试 、错误处理测试、边界条件测试 。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"压力测试\"><a href=\"#压力测试\" class=\"headerlink\" title=\"压力测试\"></a>压力测试</h3><ul>\n<li><a href=\"https://blog.csdn.net/blueheart20/article/details/52170790\" target=\"_blank\" rel=\"noopener\">《Apache ab 测试使用指南》</a></li>\n<li><a href=\"https://www.cnblogs.com/binyue/p/6141088.html\" target=\"_blank\" rel=\"noopener\">《大型网站压力测试及优化方案》</a></li>\n<li><a href=\"http://news.chinabyte.com/466/14126966.shtml\" target=\"_blank\" rel=\"noopener\">《10大主流压力/负载/性能测试工具推荐》</a></li>\n<li><a href=\"http://quentinxxz.iteye.com/blog/2249799\" target=\"_blank\" rel=\"noopener\">《真实流量压测工具 tcpcopy应用浅析》</a></li>\n<li><a href=\"https://www.cnblogs.com/jwentest/p/7136727.html\" target=\"_blank\" rel=\"noopener\">《nGrinder 简易使用教程》</a></li>\n</ul>\n<h3 id=\"全链路压测\"><a href=\"#全链路压测\" class=\"headerlink\" title=\"全链路压测\"></a>全链路压测</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/jd-618-upgrade-full-link-voltage-test-program-forcebot\" target=\"_blank\" rel=\"noopener\">《京东618：升级全链路压测方案，打造军演机器人ForceBot》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/30306892\" target=\"_blank\" rel=\"noopener\">《饿了么全链路压测的探索与实践》</a></li>\n<li><a href=\"https://zhuanlan.zhihu.com/p/28355759\" target=\"_blank\" rel=\"noopener\">《四大语言，八大框架｜滴滴全链路压测解决之道》</a></li>\n<li><a href=\"https://www.jianshu.com/p/27060fd61f72\" target=\"_blank\" rel=\"noopener\">《全链路压测经验》</a></li>\n</ul>\n<h3 id=\"A-B-、灰度、蓝绿测试\"><a href=\"#A-B-、灰度、蓝绿测试\" class=\"headerlink\" title=\"A/B 、灰度、蓝绿测试\"></a>A/B 、灰度、蓝绿测试</h3><ul>\n<li><a href=\"https://testerhome.com/topics/11165\" target=\"_blank\" rel=\"noopener\">《技术干货 | AB 测试和灰度发布探索及实践》</a></li>\n<li><p><a href=\"http://blog.51cto.com/purplegrape/1403123\" target=\"_blank\" rel=\"noopener\">《nginx 根据IP 进行灰度发布》</a></p>\n</li>\n<li><p><a href=\"https://www.v2ex.com/t/344341\" target=\"_blank\" rel=\"noopener\">《蓝绿部署、A/B 测试以及灰度发布》</a></p>\n</li>\n</ul>\n<h2 id=\"虚拟化\"><a href=\"#虚拟化\" class=\"headerlink\" title=\"虚拟化\"></a>虚拟化</h2><ul>\n<li><a href=\"https://blog.csdn.net/enweitech/article/details/52910082\" target=\"_blank\" rel=\"noopener\">《VPS的三种虚拟技术OpenVZ、Xen、KVM优缺点比较》</a></li>\n</ul>\n<h3 id=\"KVM\"><a href=\"#KVM\" class=\"headerlink\" title=\"KVM\"></a>KVM</h3><ul>\n<li><a href=\"http://blog.chinaunix.net/uid-20201831-id-5775661.html\" target=\"_blank\" rel=\"noopener\">《KVM详解，太详细太深入了，经典》</a></li>\n<li><a href=\"https://www.coderxing.com/kvm-install.html\" target=\"_blank\" rel=\"noopener\">《【图文】KVM 虚拟机安装详解》</a></li>\n</ul>\n<h3 id=\"Xen\"><a href=\"#Xen\" class=\"headerlink\" title=\"Xen\"></a>Xen</h3><ul>\n<li><a href=\"https://www.cnblogs.com/sddai/p/5931201.html\" target=\"_blank\" rel=\"noopener\">《Xen虚拟化基本原理详解》</a></li>\n</ul>\n<h3 id=\"OpenVZ\"><a href=\"#OpenVZ\" class=\"headerlink\" title=\"OpenVZ\"></a>OpenVZ</h3><ul>\n<li><a href=\"https://blog.csdn.net/longerzone/article/details/44829255\" target=\"_blank\" rel=\"noopener\">《开源Linux容器 OpenVZ 快速上手指南》</a></li>\n</ul>\n<h2 id=\"容器技术\"><a href=\"#容器技术\" class=\"headerlink\" title=\"容器技术\"></a>容器技术</h2><h3 id=\"Docker\"><a href=\"#Docker\" class=\"headerlink\" title=\"Docker\"></a>Docker</h3><ul>\n<li><a href=\"https://www.cnblogs.com/SzeCheng/p/6822905.html\" target=\"_blank\" rel=\"noopener\">《几张图帮你理解 docker 基本原理及快速入门》</a></li>\n<li><a href=\"https://draveness.me/docker\" target=\"_blank\" rel=\"noopener\">《Docker 核心技术与实现原理》</a></li>\n<li><a href=\"http://www.runoob.com/docker/docker-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Docker 教程》</a></li>\n</ul>\n<h2 id=\"云技术\"><a href=\"#云技术\" class=\"headerlink\" title=\"云技术\"></a>云技术</h2><h3 id=\"OpenStack\"><a href=\"#OpenStack\" class=\"headerlink\" title=\"OpenStack\"></a>OpenStack</h3><ul>\n<li><a href=\"https://www.cnblogs.com/klb561/p/8660264.html\" target=\"_blank\" rel=\"noopener\">《OpenStack构架知识梳理》</a></li>\n</ul>\n<h2 id=\"DevOps\"><a href=\"#DevOps\" class=\"headerlink\" title=\"DevOps\"></a>DevOps</h2><ul>\n<li><a href=\"https://www.cnblogs.com/jetzhang/p/6068773.html\" target=\"_blank\" rel=\"noopener\">《一分钟告诉你究竟DevOps是什么鬼？》</a></li>\n<li><a href=\"http://www.infoq.com/cn/articles/detail-analysis-of-devops\" target=\"_blank\" rel=\"noopener\">《DevOps详解》</a></li>\n</ul>\n<h2 id=\"文档管理\"><a href=\"#文档管理\" class=\"headerlink\" title=\"文档管理\"></a>文档管理</h2><ul>\n<li><a href=\"http://www.confluence.cn/\" target=\"_blank\" rel=\"noopener\">Confluence-收费文档管理系统</a></li>\n<li>GitLab?</li>\n<li>Wiki</li>\n</ul>\n<h1 id=\"中间件\"><a href=\"#中间件\" class=\"headerlink\" title=\"中间件\"></a>中间件</h1><h2 id=\"Web-Server\"><a href=\"#Web-Server\" class=\"headerlink\" title=\"Web Server\"></a>Web Server</h2><h3 id=\"Nginx\"><a href=\"#Nginx\" class=\"headerlink\" title=\"Nginx\"></a>Nginx</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_25797077/article/details/52200722\" target=\"_blank\" rel=\"noopener\">《Ngnix的基本学习-多进程和Apache的比较》</a></p>\n<ul>\n<li>Nginx 通过异步非阻塞的事件处理机制实现高并发。Apache 每个请求独占一个线程，非常消耗系统资源。</li>\n<li>事件驱动适合于IO密集型服务(Nginx)，多进程或线程适合于CPU密集型服务(Apache)，所以Nginx适合做反向代理，而非web服务器使用。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/cunkouzh/p/5410154.html\" target=\"_blank\" rel=\"noopener\">《nginx与Apache的对比以及优缺点》</a></p>\n<ul>\n<li>nginx只适合静态和反向代理，不适合处理动态请求。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"OpenResty\"><a href=\"#OpenResty\" class=\"headerlink\" title=\"OpenResty\"></a>OpenResty</h3><ul>\n<li><a href=\"http://openresty.org/cn/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://www.linkedkeeper.com/detail/blog.action?bid=1034\" target=\"_blank\" rel=\"noopener\">《浅谈 OpenResty》</a><ul>\n<li>通过 Lua 模块可以在Nginx上进行开发。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Apache-Httpd\"><a href=\"#Apache-Httpd\" class=\"headerlink\" title=\"Apache Httpd\"></a>Apache Httpd</h3><ul>\n<li><a href=\"http://httpd.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n</ul>\n<h3 id=\"Tomcat\"><a href=\"#Tomcat\" class=\"headerlink\" title=\"Tomcat\"></a>Tomcat</h3><h4 id=\"架构原理\"><a href=\"#架构原理\" class=\"headerlink\" title=\"架构原理\"></a>架构原理</h4><ul>\n<li><a href=\"https://www.cnblogs.com/hggen/p/6264475.html\" target=\"_blank\" rel=\"noopener\">《TOMCAT原理详解及请求过程》</a></li>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4706223.html\" target=\"_blank\" rel=\"noopener\">《Tomcat服务器原理详解》</a></li>\n<li><p><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-tomcat1/\" target=\"_blank\" rel=\"noopener\">《Tomcat 系统架构与设计模式,第 1 部分: 工作原理》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xlgen157387/article/details/79006434\" target=\"_blank\" rel=\"noopener\">《四张图带你了解Tomcat系统架构》</a></p>\n</li>\n<li><p><a href=\"https://www.futurehosting.com/blog/jboss-vs-tomcat-choosing-a-java-application-server/\" target=\"_blank\" rel=\"noopener\">《JBoss vs. Tomcat: Choosing A Java Application Server》</a></p>\n<ul>\n<li>Tomcat 是轻量级的 Serverlet 容器，没有实现全部 JEE 特性（比如持久化和事务处理），但可以通过其他组件代替，比如Srping。</li>\n<li>Jboss 实现全部了JEE特性，软件开源免费、文档收费。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"调优方案\"><a href=\"#调优方案\" class=\"headerlink\" title=\"调优方案\"></a>调优方案</h4><ul>\n<li><p><a href=\"https://www.cnblogs.com/sunfenqing/p/7339058.html\" target=\"_blank\" rel=\"noopener\">《Tomcat 调优方案》</a></p>\n<ul>\n<li>启动NIO模式（或者APR）；调整线程池；禁用AJP连接器（Nginx+tomcat的架构，不需要AJP）； </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.chinaunix.net/uid-20662363-id-3012760.html\" target=\"_blank\" rel=\"noopener\">《tomcat http协议与ajp协议》</a></p>\n</li>\n<li><a href=\"http://dmouse.iteye.com/blog/1354527\" target=\"_blank\" rel=\"noopener\">《AJP与HTTP比较和分析》</a><ul>\n<li>AJP 协议（8009端口）用于降低和前端Server（如Apache，而且需要支持AJP协议）的连接数(前端)，通过长连接提高性能。</li>\n<li>并发高时，AJP协议优于HTTP协议。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Jetty\"><a href=\"#Jetty\" class=\"headerlink\" title=\"Jetty\"></a>Jetty</h3><ul>\n<li><a href=\"https://www.ibm.com/developerworks/cn/java/j-lo-jetty/\" target=\"_blank\" rel=\"noopener\">《Jetty 的工作原理以及与 Tomcat 的比较》</a></li>\n<li><a href=\"https://blog.csdn.net/doutao6677/article/details/51957288\" target=\"_blank\" rel=\"noopener\">《jetty和tomcat优势比较》</a><ul>\n<li>架构比较:Jetty的架构比Tomcat的更为简单。</li>\n<li>性能比较：Jetty和Tomcat性能方面差异不大，Jetty默认采用NIO结束在处理I/O请求上更占优势，Tomcat默认采用BIO处理I/O请求，Tomcat适合处理少数非常繁忙的链接，处理静态资源时性能较差。</li>\n<li>其他方面：Jetty的应用更加快速，修改简单，对新的Servlet规范的支持较好;Tomcat 对JEE和Servlet 支持更加全面。 </li>\n</ul>\n</li>\n</ul>\n<h2 id=\"缓存\"><a href=\"#缓存\" class=\"headerlink\" title=\"缓存\"></a>缓存</h2><ul>\n<li><a href=\"https://blog.csdn.net/clementad/article/details/48229243\" target=\"_blank\" rel=\"noopener\">《缓存失效策略（FIFO 、LRU、LFU三种算法的区别）》</a></li>\n</ul>\n<h3 id=\"本地缓存\"><a href=\"#本地缓存\" class=\"headerlink\" title=\"本地缓存\"></a>本地缓存</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4211.html\" target=\"_blank\" rel=\"noopener\">《HashMap本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4212-ehcache.html\" target=\"_blank\" rel=\"noopener\">《EhCache本地缓存》</a></p>\n<ul>\n<li>堆内、堆外、磁盘三级缓存。</li>\n<li>可按照缓存空间容量进行设置。</li>\n<li>按照时间、次数等过期策略。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/421-ying-yong-ceng-ben-di-huan-cun/4213-guava-cache.html\" target=\"_blank\" rel=\"noopener\">《Guava Cache》</a></p>\n<ul>\n<li>简单轻量、无堆外、磁盘缓存。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/nginx-ben-di-huan-cun.html\" target=\"_blank\" rel=\"noopener\">《Nginx本地缓存》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/422-fu-wu-duan-ben-di-huan-cun/4222-pagespeed.html\" target=\"_blank\" rel=\"noopener\">《Pagespeed—懒人工具，服务器端加速》</a></p>\n</li>\n</ul>\n<h2 id=\"客户端缓存\"><a href=\"#客户端缓存\" class=\"headerlink\" title=\"客户端缓存\"></a>客户端缓存</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-er-pian-ff1a-feng-kuang-yuan-shi-ren/42-xing-neng-zhi-ben-di-huan-cun/423-ke-hu-duan-huan-cun.html\" target=\"_blank\" rel=\"noopener\">《浏览器端缓存》</a></p>\n<ul>\n<li>主要是利用 Cache-Control 参数。</li>\n</ul>\n</li>\n<li><p><a href=\"https://mp.weixin.qq.com/s/qHm_dJBhVbv0pJs8Crp77w\" target=\"_blank\" rel=\"noopener\">《H5 和移动端 WebView 缓存机制解析与实战》</a></p>\n</li>\n</ul>\n<h2 id=\"服务端缓存\"><a href=\"#服务端缓存\" class=\"headerlink\" title=\"服务端缓存\"></a>服务端缓存</h2><h3 id=\"Web缓存\"><a href=\"#Web缓存\" class=\"headerlink\" title=\"Web缓存\"></a>Web缓存</h3><ul>\n<li><a href=\"https://github.com/jiangwenyuan/nuster\" target=\"_blank\" rel=\"noopener\">nuster</a> - nuster cache</li>\n<li><a href=\"https://github.com/varnishcache/varnish-cache\" target=\"_blank\" rel=\"noopener\">varnish</a> - varnish cache</li>\n<li><a href=\"https://github.com/squid-cache/squid\" target=\"_blank\" rel=\"noopener\">squid</a> - squid cache</li>\n</ul>\n<h3 id=\"Memcached\"><a href=\"#Memcached\" class=\"headerlink\" title=\"Memcached\"></a>Memcached</h3><ul>\n<li><a href=\"http://www.runoob.com/Memcached/Memcached-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Memcached 教程》</a></li>\n<li><a href=\"https://blog.csdn.net/chenleixing/article/details/47035453\" target=\"_blank\" rel=\"noopener\">《深入理解Memcached原理》</a><ul>\n<li>采用多路复用技术提高并发性。</li>\n<li>slab分配算法： memcached给Slab分配内存空间，默认是1MB。分配给Slab之后 把slab的切分成大小相同的chunk，Chunk是用于缓存记录的内存空间，Chunk 的大小默认按照1.25倍的速度递增。好处是不会频繁申请内存，提高IO效率，坏处是会有一定的内存浪费。</li>\n</ul>\n</li>\n<li><a href=\"https://www.jianshu.com/p/36e5cd400580\" target=\"_blank\" rel=\"noopener\">《Memcached软件工作原理》</a></li>\n<li><p><a href=\"http://zhihuzeye.com/archives/2361\" target=\"_blank\" rel=\"noopener\">《Memcache技术分享：介绍、使用、存储、算法、优化、命中率》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/liu251890347/article/details/37690045\" target=\"_blank\" rel=\"noopener\">《memcache 中 add 、 set 、replace 的区别》</a></p>\n<ul>\n<li>区别在于当key存在还是不存在时，返回值是true和false的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://pan.baidu.com/s/1qX00Lti?errno=0&amp;errmsg=Auth%20Login%20Sucess&amp;&amp;bduss=&amp;ssnerror=0&amp;traceid=\" target=\"_blank\" rel=\"noopener\"><strong>《memcached全面剖析》</strong></a></p>\n</li>\n</ul>\n<h3 id=\"Redis\"><a href=\"#Redis\" class=\"headerlink\" title=\"Redis\"></a>Redis</h3><ul>\n<li><a href=\"http://www.runoob.com/redis/redis-tutorial.html\" target=\"_blank\" rel=\"noopener\">《Redis 教程》</a></li>\n<li><a href=\"https://blog.csdn.net/wcf373722432/article/details/78678504\" target=\"_blank\" rel=\"noopener\">《redis底层原理》</a><ul>\n<li>使用 ziplist 存储链表，ziplist是一种压缩链表，它的好处是更能节省内存空间，因为它所存储的内容都是在连续的内存区域当中的。</li>\n<li>使用 skiplist(跳跃表)来存储有序集合对象、查找上先从高Level查起、时间复杂度和红黑树相当，实现容易，无锁、并发性好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://doc.redisfans.com/topic/persistence.html\" target=\"_blank\" rel=\"noopener\">《Redis持久化方式》</a></p>\n<ul>\n<li>RDB方式：定期备份快照，常用于灾难恢复。优点：通过fork出的进程进行备份，不影响主进程、RDB 在恢复大数据集时的速度比 AOF 的恢复速度要快。缺点：会丢数据。</li>\n<li>AOF方式：保存操作日志方式。优点：恢复时数据丢失少，缺点：文件大，回复慢。</li>\n<li>也可以两者结合使用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chunlongyu/article/details/53346436\" target=\"_blank\" rel=\"noopener\">《分布式缓存–序列3–原子操作与CAS乐观锁》</a></p>\n</li>\n</ul>\n<h4 id=\"架构\"><a href=\"#架构\" class=\"headerlink\" title=\"架构\"></a>架构</h4><ul>\n<li><a href=\"https://blog.csdn.net/sunhuiliang85/article/details/73656830\" target=\"_blank\" rel=\"noopener\">《Redis单线程架构》</a></li>\n</ul>\n<h4 id=\"回收策略\"><a href=\"#回收策略\" class=\"headerlink\" title=\"回收策略\"></a>回收策略</h4><ul>\n<li><a href=\"https://blog.csdn.net/qq_29108585/article/details/63251491\" target=\"_blank\" rel=\"noopener\">《redis的回收策略》</a></li>\n</ul>\n<h3 id=\"Tair\"><a href=\"#Tair\" class=\"headerlink\" title=\"Tair\"></a>Tair</h3><ul>\n<li><a href=\"https://github.com/alibaba/tair\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://blog.csdn.net/farphone/article/details/53522383\" target=\"_blank\" rel=\"noopener\">《Tair和Redis的对比》</a></li>\n<li>特点：可以配置备份节点数目，通过异步同步到备份节点</li>\n<li>一致性Hash算法。</li>\n<li>架构：和Hadoop 的设计思想类似，有Configserver，DataServer，Configserver 通过心跳来检测，Configserver也有主备关系。</li>\n</ul>\n<p>几种存储引擎:</p>\n<ul>\n<li>MDB，完全内存性，可以用来存储Session等数据。</li>\n<li>Rdb（类似于Redis），轻量化，去除了aof之类的操作，支持Restfull操作</li>\n<li>LDB（LevelDB存储引擎），持久化存储，LDB 作为rdb的持久化，google实现，比较高效，理论基础是LSM(Log-Structured-Merge Tree)算法，现在内存中修改数据，达到一定量时（和内存汇总的旧数据一同写入磁盘）再写入磁盘，存储更加高效，县比喻Hash算法。</li>\n<li>Tair采用共享内存来存储数据，如果服务挂掉（非服务器），重启服务之后，数据亦然还在。</li>\n</ul>\n<h2 id=\"消息队列\"><a href=\"#消息队列\" class=\"headerlink\" title=\"消息队列\"></a>消息队列</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/charlesblc/p/6045238.html\" target=\"_blank\" rel=\"noopener\">《消息队列-推/拉模式学习 &amp; ActiveMQ及JMS学习》</a></p>\n<ul>\n<li>RabbitMQ 消费者默认是推模式（也支持拉模式）。</li>\n<li>Kafka 默认是拉模式。</li>\n<li>Push方式：优点是可以尽可能快地将消息发送给消费者，缺点是如果消费者处理能力跟不上，消费者的缓冲区可能会溢出。</li>\n<li>Pull方式：优点是消费端可以按处理能力进行拉去，缺点是会增加消息延迟。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yunfeng482/article/details/72856762\" target=\"_blank\" rel=\"noopener\">《Kafka、RabbitMQ、RocketMQ等消息中间件的对比 —— 消息发送性能和区别》</a></p>\n</li>\n</ul>\n<h3 id=\"消息总线\"><a href=\"#消息总线\" class=\"headerlink\" title=\"消息总线\"></a>消息总线</h3><p>消息总线相当于在消息队列之上做了一层封装，统一入口，统一管控、简化接入成本。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/yanghua_kobe/article/details/43877281\" target=\"_blank\" rel=\"noopener\">《消息总线VS消息队列》</a></li>\n</ul>\n<h3 id=\"消息的顺序\"><a href=\"#消息的顺序\" class=\"headerlink\" title=\"消息的顺序\"></a>消息的顺序</h3><ul>\n<li><a href=\"https://www.cnblogs.com/cjsblog/p/8267892.html\" target=\"_blank\" rel=\"noopener\">《如何保证消费者接收消息的顺序》</a></li>\n</ul>\n<h3 id=\"RabbitMQ\"><a href=\"#RabbitMQ\" class=\"headerlink\" title=\"RabbitMQ\"></a>RabbitMQ</h3><p>支持事务，推拉模式都是支持、适合需要可靠性消息传输的场景。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/whoamiyang/article/details/54954780\" target=\"_blank\" rel=\"noopener\">《RabbitMQ的应用场景以及基本原理介绍》</a></li>\n<li><a href=\"https://www.jianshu.com/p/79ca08116d57\" target=\"_blank\" rel=\"noopener\">《消息队列之 RabbitMQ》</a> </li>\n<li><a href=\"https://blog.csdn.net/u013256816/article/details/55515234\" target=\"_blank\" rel=\"noopener\">《RabbitMQ之消息确认机制（事务+Confirm）》</a></li>\n</ul>\n<h3 id=\"RocketMQ\"><a href=\"#RocketMQ\" class=\"headerlink\" title=\"RocketMQ\"></a>RocketMQ</h3><p>Java实现，推拉模式都是支持，吞吐量逊于Kafka。可以保证消息顺序。</p>\n<ul>\n<li><a href=\"https://www.jianshu.com/p/824066d70da8\" target=\"_blank\" rel=\"noopener\">《RocketMQ 实战之快速入门》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/RocketMQ/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《RocketMQ 源码解析》</a></li>\n</ul>\n<h3 id=\"ActiveMQ\"><a href=\"#ActiveMQ\" class=\"headerlink\" title=\"ActiveMQ\"></a>ActiveMQ</h3><p>纯Java实现，兼容JMS，可以内嵌于Java应用中。</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/wintersun/p/3962302.html\" target=\"_blank\" rel=\"noopener\">《ActiveMQ消息队列介绍》</a></li>\n</ul>\n<h3 id=\"Kafka\"><a href=\"#Kafka\" class=\"headerlink\" title=\"Kafka\"></a>Kafka</h3><p>高吞吐量、采用拉模式。适合高IO场景，比如日志同步。</p>\n<ul>\n<li><a href=\"http://kafka.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/allthesametome/article/details/47362451\" target=\"_blank\" rel=\"noopener\">《各消息队列对比，Kafka深度解析，众人推荐，精彩好文！》</a></li>\n<li><a href=\"http://lxw1234.com/archives/2015/10/538.htm\" target=\"_blank\" rel=\"noopener\">《Kafka分区机制介绍与示例》</a></li>\n</ul>\n<h3 id=\"Redis-消息推送\"><a href=\"#Redis-消息推送\" class=\"headerlink\" title=\"Redis 消息推送\"></a>Redis 消息推送</h3><p>生产者、消费者模式完全是客户端行为，list 和 拉模式实现，阻塞等待采用 blpop 指令。</p>\n<ul>\n<li><a href=\"https://blog.csdn.net/qq_34212276/article/details/78455004\" target=\"_blank\" rel=\"noopener\">《Redis学习笔记之十：Redis用作消息队列》</a></li>\n</ul>\n<h3 id=\"ZeroMQ\"><a href=\"#ZeroMQ\" class=\"headerlink\" title=\"ZeroMQ\"></a>ZeroMQ</h3><p> TODO</p>\n<h2 id=\"定时调度\"><a href=\"#定时调度\" class=\"headerlink\" title=\"定时调度\"></a>定时调度</h2><h3 id=\"单机定时调度\"><a href=\"#单机定时调度\" class=\"headerlink\" title=\"单机定时调度\"></a>单机定时调度</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/shuaiqing/p/7742382.html\" target=\"_blank\" rel=\"noopener\">《linux定时任务cron配置》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/daquan/blog/483305\" target=\"_blank\" rel=\"noopener\">《Linux cron运行原理》</a></p>\n<ul>\n<li>fork 进程 + sleep 轮询</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/drift-ice/p/3817269.html\" target=\"_blank\" rel=\"noopener\">《Quartz使用总结》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/wenniuwuren/article/details/42082981/\" target=\"_blank\" rel=\"noopener\">《Quartz源码解析 —- 触发器按时启动原理》</a></li>\n<li><a href=\"https://www.jianshu.com/p/bab8e4e32952\" target=\"_blank\" rel=\"noopener\">《quartz原理揭秘和源码解读》</a><ul>\n<li>定时调度在 QuartzSchedulerThread 代码中，while()无限循环，每次循环取出时间将到的trigger，触发对应的job，直到调度器线程被关闭。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式定时调度\"><a href=\"#分布式定时调度\" class=\"headerlink\" title=\"分布式定时调度\"></a>分布式定时调度</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/qq_16216221/article/details/70314337\" target=\"_blank\" rel=\"noopener\">《这些优秀的国产分布式任务调度系统，你用过几个？》</a></p>\n<ul>\n<li>opencron、LTS、XXL-JOB、Elastic-Job、Uncode-Schedule、Antares</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhenyuyaodidiao/p/4755649.html\" target=\"_blank\" rel=\"noopener\">《Quartz任务调度的基本实现原理》</a></p>\n<ul>\n<li>Quartz集群中，独立的Quartz节点并不与另一其的节点或是管理节点通信，而是通过相同的数据库表来感知到另一Quartz应用的 </li>\n</ul>\n</li>\n<li><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Lite/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Elastic-Job-Lite 源码解析》</a></li>\n<li><a href=\"http://www.iocoder.cn/categories/Elastic-Job-Cloud/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Elastic-Job-Cloud 源码解析》</a></li>\n</ul>\n<h2 id=\"RPC\"><a href=\"#RPC\" class=\"headerlink\" title=\"RPC\"></a>RPC</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/top_code/article/details/54615853\" target=\"_blank\" rel=\"noopener\">《从零开始实现RPC框架 - RPC原理及实现》</a></p>\n<ul>\n<li>核心角色：Server: 暴露服务的服务提供方、Client: 调用远程服务的服务消费方、Registry: 服务注册与发现的注册中心。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/testcs_dn/article/details/78050590\" target=\"_blank\" rel=\"noopener\">《分布式RPC框架性能大比拼 dubbo、motan、rpcx、gRPC、thrift的性能比较》</a></p>\n</li>\n</ul>\n<h3 id=\"Dubbo\"><a href=\"#Dubbo\" class=\"headerlink\" title=\"Dubbo\"></a>Dubbo</h3><ul>\n<li><a href=\"http://dubbo.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/steven520213/p/7606598.html\" target=\"_blank\" rel=\"noopener\">dubbo实现原理简单介绍</a></li>\n</ul>\n<p><strong> SPI </strong><br>TODO</p>\n<h3 id=\"Thrift\"><a href=\"#Thrift\" class=\"headerlink\" title=\"Thrift\"></a>Thrift</h3><ul>\n<li><a href=\"http://thrift.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/kesonyk/article/details/50924489\" target=\"_blank\" rel=\"noopener\">《Thrift RPC详解》</a><ul>\n<li>支持多语言，通过中间语言定义接口。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"gRPC\"><a href=\"#gRPC\" class=\"headerlink\" title=\"gRPC\"></a>gRPC</h3><p>服务端可以认证加密，在外网环境下，可以保证数据安全。</p>\n<ul>\n<li><a href=\"https://grpc.io/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://www.cnblogs.com/LBSer/p/4853234.html\" target=\"_blank\" rel=\"noopener\">《你应该知道的RPC原理》</a></li>\n</ul>\n<h2 id=\"数据库中间件\"><a href=\"#数据库中间件\" class=\"headerlink\" title=\"数据库中间件\"></a>数据库中间件</h2><h3 id=\"Sharding-Jdbc\"><a href=\"#Sharding-Jdbc\" class=\"headerlink\" title=\"Sharding Jdbc\"></a>Sharding Jdbc</h3><ul>\n<li><a href=\"http://shardingjdbc.io/\" target=\"_blank\" rel=\"noopener\">官网</a></li>\n</ul>\n<h2 id=\"日志系统\"><a href=\"#日志系统\" class=\"headerlink\" title=\"日志系统\"></a>日志系统</h2><h3 id=\"日志搜集\"><a href=\"#日志搜集\" class=\"headerlink\" title=\"日志搜集\"></a>日志搜集</h3><ul>\n<li><a href=\"http://cjting.me/misc/build-log-system-with-elkb/\" target=\"_blank\" rel=\"noopener\">《从零开始搭建一个ELKB日志收集系统》</a></li>\n<li><a href=\"https://blog.csdn.net/lzw_2006/article/details/51280058\" target=\"_blank\" rel=\"noopener\">《用ELK搭建简单的日志收集分析系统》</a></li>\n<li><a href=\"https://www.cnblogs.com/beginmind/p/6058194.html\" target=\"_blank\" rel=\"noopener\">《日志收集系统-探究》</a></li>\n</ul>\n<h2 id=\"配置中心\"><a href=\"#配置中心\" class=\"headerlink\" title=\"配置中心\"></a>配置中心</h2><ul>\n<li><p><a href=\"https://github.com/ctripcorp/apollo\" target=\"_blank\" rel=\"noopener\">Apollo - 携程开源的配置中心应用</a></p>\n<ul>\n<li>Spring Boot 和 Spring Cloud</li>\n<li>支持推、拉模式更新配置</li>\n<li>支持多种语言 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011320740/article/details/78742625\" target=\"_blank\" rel=\"noopener\">《基于zookeeper实现统一配置管理》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/shamo89/p/8016908.html\" target=\"_blank\" rel=\"noopener\">《 Spring Cloud Config 分布式配置中心使用教程》</a></p>\n</li>\n</ul>\n<p>servlet 3.0 异步特性可用于配置中心的客户端</p>\n<ul>\n<li><a href=\"https://www.cnblogs.com/dogdogwang/p/7151866.html\" target=\"_blank\" rel=\"noopener\">《servlet3.0 新特性——异步处理》</a></li>\n</ul>\n<h2 id=\"API-网关\"><a href=\"#API-网关\" class=\"headerlink\" title=\"API 网关\"></a>API 网关</h2><p>主要职责：请求转发、安全认证、协议转换、容灾。</p>\n<ul>\n<li><a href=\"http://yunlzheng.github.io/2017/03/14/the-things-about-api-gateway/\" target=\"_blank\" rel=\"noopener\">《API网关那些儿》</a></li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2016/07/API-background-architecture-floo\" target=\"_blank\" rel=\"noopener\">《谈API网关的背景、架构以及落地方案》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhanglh046/article/details/78651993\" target=\"_blank\" rel=\"noopener\">《使用Zuul构建API Gateway》</a></p>\n</li>\n<li><a href=\"http://www.iocoder.cn/categories/Spring-Cloud-Gateway/?vip&amp;architect-awesome\" target=\"_blank\" rel=\"noopener\">《Spring Cloud Gateway 源码解析》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s/LIq2CiXJQmmjBC0yvYLY5A\" target=\"_blank\" rel=\"noopener\">《HTTP API网关选择之一Kong介绍》</a></li>\n</ul>\n<h1 id=\"网络\"><a href=\"#网络\" class=\"headerlink\" title=\"网络\"></a>网络</h1><h2 id=\"协议\"><a href=\"#协议\" class=\"headerlink\" title=\"协议\"></a>协议</h2><h3 id=\"OSI-七层协议\"><a href=\"#OSI-七层协议\" class=\"headerlink\" title=\"OSI 七层协议\"></a>OSI 七层协议</h3><ul>\n<li><a href=\"https://www.cnblogs.com/Robin-YB/p/6668762.html\" target=\"_blank\" rel=\"noopener\">《OSI七层协议模型、TCP/IP四层模型学习笔记》</a></li>\n</ul>\n<h3 id=\"TCP-IP\"><a href=\"#TCP-IP\" class=\"headerlink\" title=\"TCP/IP\"></a>TCP/IP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/onepixel/p/7092302.html\" target=\"_blank\" rel=\"noopener\">《深入浅出 TCP/IP 协议》</a></li>\n<li><a href=\"https://blog.csdn.net/whuslei/article/details/6667471/\" target=\"_blank\" rel=\"noopener\">《TCP协议中的三次握手和四次挥手》</a></li>\n</ul>\n<h3 id=\"HTTP\"><a href=\"#HTTP\" class=\"headerlink\" title=\"HTTP\"></a>HTTP</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wangning528/p/6388464.html\" target=\"_blank\" rel=\"noopener\">《http协议详解(超详细)》</a></li>\n</ul>\n<h3 id=\"HTTP2-0\"><a href=\"#HTTP2-0\" class=\"headerlink\" title=\"HTTP2.0\"></a>HTTP2.0</h3><ul>\n<li><a href=\"https://blog.csdn.net/zhuyiquan/article/details/69257126\" target=\"_blank\" rel=\"noopener\">《HTTP 2.0 原理详细分析》</a></li>\n<li><a href=\"https://blog.csdn.net/u012657197/article/details/77877840\" target=\"_blank\" rel=\"noopener\">《HTTP2.0的基本单位为二进制帧》</a><ul>\n<li>利用二进制帧负责传输。</li>\n<li>多路复用。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"HTTPS\"><a href=\"#HTTPS\" class=\"headerlink\" title=\"HTTPS\"></a>HTTPS</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/zhangshitong/p/6478721.html\" target=\"_blank\" rel=\"noopener\">《https原理通俗了解》</a></p>\n<ul>\n<li>使用非对称加密协商加密算法</li>\n<li>使用对称加密方式传输数据</li>\n<li>使用第三方机构签发的证书，来加密公钥，用于公钥的安全传输、防止被中间人串改。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/enweitech/article/details/53213862\" target=\"_blank\" rel=\"noopener\">《八大免费SSL证书-给你的网站免费添加Https安全加密》</a></p>\n</li>\n</ul>\n<h2 id=\"网络模型\"><a href=\"#网络模型\" class=\"headerlink\" title=\"网络模型\"></a>网络模型</h2><ul>\n<li><p><a href=\"http://blog.51cto.com/litaotao/1289790\" target=\"_blank\" rel=\"noopener\">《web优化必须了解的原理之I/o的五种模型和web的三种工作模式》</a></p>\n<ul>\n<li>五种I/O模型：阻塞I/O，非阻塞I/O，I/O复用、事件(信号)驱动I/O、异步I/O，前四种I/O属于同步操作，I/O的第一阶段不同、第二阶段相同，最后的一种则属于异步操作。</li>\n<li>三种 Web Server 工作方式：Prefork(多进程)、Worker方式(线程方式)、Event方式。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Anker/p/3265058.html\" target=\"_blank\" rel=\"noopener\">《select、poll、epoll之间的区别总结》</a></p>\n<ul>\n<li>select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的。</li>\n<li>select 有打开文件描述符数量限制，默认1024（2048 for x64），100万并发，就要用1000个进程、切换开销大；poll采用链表结构，没有数量限制。</li>\n<li>select，poll “醒着”的时候要遍历整个fd集合，而epoll在“醒着”的时候只要判断一下就绪链表是否为空就行了，通过回调机制节省大量CPU时间；select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，而epoll只要一次拷贝。</li>\n<li>poll会随着并发增加，性能逐渐下降，epoll采用红黑树结构，性能稳定，不会随着连接数增加而降低。</li>\n</ul>\n</li>\n<li><p><a href=\"http://xingyunbaijunwei.blog.163.com/blog/static/76538067201241685556302/\" target=\"_blank\" rel=\"noopener\">《select，poll，epoll比较  》</a></p>\n<ul>\n<li>在连接数少并且连接都十分活跃的情况下，select和poll的性能可能比epoll好，毕竟epoll的通知机制需要很多函数回调。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/geason/p/5774096.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java NIO》</a></p>\n<ul>\n<li>NIO 是一种同步非阻塞的 IO 模型。同步是指线程不断轮询 IO 事件是否就绪，非阻塞是指线程在等待 IO 的时候，可以同时做其他任务</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/skiof007/article/details/52873421\" target=\"_blank\" rel=\"noopener\">《BIO与NIO、AIO的区别》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u013074465/article/details/46276967\" target=\"_blank\" rel=\"noopener\">《两种高效的服务器设计模型：Reactor和Proactor模型》</a></p>\n</li>\n</ul>\n<h3 id=\"Epoll\"><a href=\"#Epoll\" class=\"headerlink\" title=\"Epoll\"></a>Epoll</h3><ul>\n<li><a href=\"https://www.cnblogs.com/fnlingnzb-learner/p/5835573.html\" target=\"_blank\" rel=\"noopener\">《epoll使用详解（精髓）》</a></li>\n</ul>\n<h3 id=\"Java-NIO\"><a href=\"#Java-NIO\" class=\"headerlink\" title=\"Java NIO\"></a>Java NIO</h3><ul>\n<li><a href=\"https://www.cnblogs.com/geason/p/5774096.html\" target=\"_blank\" rel=\"noopener\">《深入理解Java NIO》</a></li>\n<li><a href=\"https://blog.csdn.net/xidianliuy/article/details/51612676\" target=\"_blank\" rel=\"noopener\">《Java NIO编写Socket服务器的一个例子》</a></li>\n</ul>\n<h3 id=\"kqueue\"><a href=\"#kqueue\" class=\"headerlink\" title=\"kqueue\"></a>kqueue</h3><ul>\n<li><a href=\"http://www.cnblogs.com/luminocean/p/5631336.html\" target=\"_blank\" rel=\"noopener\">《kqueue用法简介》</a></li>\n</ul>\n<h2 id=\"连接和短连接\"><a href=\"#连接和短连接\" class=\"headerlink\" title=\"连接和短连接\"></a>连接和短连接</h2><ul>\n<li><a href=\"https://www.cnblogs.com/pangguoping/p/5571422.html\" target=\"_blank\" rel=\"noopener\">《TCP/IP系列——长连接与短连接的区别》</a></li>\n</ul>\n<h2 id=\"框架\"><a href=\"#框架\" class=\"headerlink\" title=\"框架\"></a>框架</h2><ul>\n<li><a href=\"https://blog.csdn.net/excellentyuxiao/article/details/53390408\" target=\"_blank\" rel=\"noopener\">《Netty原理剖析》</a><ul>\n<li>Reactor 模式介绍。</li>\n<li>Netty 是 Reactor 模式的一种实现。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"零拷贝（Zero-copy）\"><a href=\"#零拷贝（Zero-copy）\" class=\"headerlink\" title=\"零拷贝（Zero-copy）\"></a>零拷贝（Zero-copy）</h2><ul>\n<li><a href=\"https://www.cnblogs.com/xys1228/p/6088805.html\" target=\"_blank\" rel=\"noopener\">《对于 Netty ByteBuf 的零拷贝(Zero Copy) 的理解》</a><ul>\n<li>多个物理分离的buffer，通过逻辑上合并成为一个，从而避免了数据在内存之间的拷贝。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"序列化-二进制协议\"><a href=\"#序列化-二进制协议\" class=\"headerlink\" title=\"序列化(二进制协议)\"></a>序列化(二进制协议)</h2><h3 id=\"Hessian\"><a href=\"#Hessian\" class=\"headerlink\" title=\"Hessian\"></a>Hessian</h3><ul>\n<li><a href=\"https://www.cnblogs.com/happyday56/p/4268249.html\" target=\"_blank\" rel=\"noopener\">《Hessian原理分析》</a><br>Binary-RPC;不仅仅是序列化</li>\n</ul>\n<h3 id=\"Protobuf\"><a href=\"#Protobuf\" class=\"headerlink\" title=\"Protobuf\"></a>Protobuf</h3><ul>\n<li><a href=\"https://blog.csdn.net/antgan/article/details/52103966\" target=\"_blank\" rel=\"noopener\">《Protobuf协议的Java应用例子》</a><br>Goolge出品、占用空间和效率完胜其他序列化类库，如Hessian；需要编写  .proto 文件。</li>\n<li><p><a href=\"https://worktile.com/tech/share/prototol-buffers\" target=\"_blank\" rel=\"noopener\">《Protocol Buffers序列化协议及应用》</a></p>\n<pre><code>* 关于协议的解释；缺点：可读性差;\n</code></pre></li>\n<li><p><a href=\"https://blog.csdn.net/eric520zenobia/article/details/53766571\" target=\"_blank\" rel=\"noopener\">《简单的使用 protobuf 和 protostuff》</a></p>\n<ul>\n<li>protostuff 的好处是不用写 .proto 文件，Java 对象直接就可以序列化。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"数据库\"><a href=\"#数据库\" class=\"headerlink\" title=\"数据库\"></a>数据库</h1><h2 id=\"基础理论\"><a href=\"#基础理论\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h2><h3 id=\"数据库设计的三大范式\"><a href=\"#数据库设计的三大范式\" class=\"headerlink\" title=\"数据库设计的三大范式\"></a>数据库设计的三大范式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/waj6511988/p/7027127.html\" target=\"_blank\" rel=\"noopener\">《数据库的三大范式以及五大约束》</a><ul>\n<li>第一范式：数据表中的每一列（每个字段）必须是不可拆分的最小单元，也就是确保每一列的原子性；</li>\n<li>第二范式（2NF）：满足1NF后，要求表中的所有列，都必须依赖于主键，而不能有任何一列与主键没有关系，也就是说一个表只描述一件事情；</li>\n<li>第三范式：必须先满足第二范式（2NF），要求：表中的每一列只与主键直接相关而不是间接相关，（表中的每一列只能依赖于主键）；</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"MySQL\"><a href=\"#MySQL\" class=\"headerlink\" title=\"MySQL\"></a>MySQL</h2><h3 id=\"原理\"><a href=\"#原理\" class=\"headerlink\" title=\"原理\"></a>原理</h3><ul>\n<li><p><a href=\"http://www.admin10000.com/document/5372.html\" target=\"_blank\" rel=\"noopener\">《MySQL的InnoDB索引原理详解》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/xifeijian/article/details/20316775\" target=\"_blank\" rel=\"noopener\">《MySQL存储引擎－－MyISAM与InnoDB区别》</a></p>\n<ul>\n<li>两种类型最主要的差别就是Innodb 支持事务处理与外键和行级锁</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201211/172380.html\" target=\"_blank\" rel=\"noopener\">《myisam和innodb索引实现的不同》</a></p>\n</li>\n</ul>\n<h3 id=\"InnoDB\"><a href=\"#InnoDB\" class=\"headerlink\" title=\"InnoDB\"></a>InnoDB</h3><ul>\n<li><a href=\"https://my.oschina.net/kailuncen/blog/1504217\" target=\"_blank\" rel=\"noopener\">《一篇文章带你读懂Mysql和InnoDB》</a></li>\n</ul>\n<h3 id=\"优化\"><a href=\"#优化\" class=\"headerlink\" title=\"优化\"></a>优化</h3><ul>\n<li><p><a href=\"http://vdisk.weibo.com/s/muWOT\" target=\"_blank\" rel=\"noopener\">《MySQL36条军规》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhouyusheng/p/8038224.html\" target=\"_blank\" rel=\"noopener\">《MYSQL性能优化的最佳20+条经验》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/when_less_is_more/article/details/70187459\" target=\"_blank\" rel=\"noopener\">《SQL优化之道》</a></li>\n<li><a href=\"https://www.cnblogs.com/sivkun/p/7518540.html\" target=\"_blank\" rel=\"noopener\">《mysql数据库死锁的产生原因及解决办法》</a></li>\n<li><a href=\"https://blog.csdn.net/monkey_d_feilong/article/details/52291556\" target=\"_blank\" rel=\"noopener\">《导致索引失效的可能情况》</a></li>\n<li><a href=\"https://blog.csdn.net/zy_281870667/article/details/51604540\" target=\"_blank\" rel=\"noopener\">《 MYSQL分页limit速度太慢优化方法》</a><ul>\n<li>原则上就是缩小扫描范围。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"索引\"><a href=\"#索引\" class=\"headerlink\" title=\"索引\"></a>索引</h3><h4 id=\"聚集索引-非聚集索引\"><a href=\"#聚集索引-非聚集索引\" class=\"headerlink\" title=\"聚集索引, 非聚集索引\"></a>聚集索引, 非聚集索引</h4><ul>\n<li><a href=\"https://blog.csdn.net/no_endless/article/details/77073549\" target=\"_blank\" rel=\"noopener\">《MySQL 聚集索引/非聚集索引简述》</a></li>\n<li><a href=\"https://www.cnblogs.com/zlcxbb/p/5757245.html\" target=\"_blank\" rel=\"noopener\">《MyISAM和InnoDB的索引实现》</a></li>\n</ul>\n<p>MyISAM 是非聚集，InnoDB 是聚集</p>\n<h4 id=\"复合索引\"><a href=\"#复合索引\" class=\"headerlink\" title=\"复合索引\"></a>复合索引</h4><ul>\n<li><a href=\"https://www.cnblogs.com/summer0space/p/7247778.html\" target=\"_blank\" rel=\"noopener\">《复合索引的优点和注意事项》</a></li>\n</ul>\n<h4 id=\"自适应哈希索引-AHI\"><a href=\"#自适应哈希索引-AHI\" class=\"headerlink\" title=\"自适应哈希索引(AHI)\"></a>自适应哈希索引(AHI)</h4><ul>\n<li><a href=\"https://blog.csdn.net/Linux_ever/article/details/62043708\" target=\"_blank\" rel=\"noopener\">《InnoDB存储引擎——自适应哈希索引》</a></li>\n</ul>\n<h3 id=\"explain\"><a href=\"#explain\" class=\"headerlink\" title=\"explain\"></a>explain</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000008131735\" target=\"_blank\" rel=\"noopener\">《MySQL 性能优化神器 Explain 使用分析》</a></li>\n</ul>\n<h2 id=\"NoSQL\"><a href=\"#NoSQL\" class=\"headerlink\" title=\"NoSQL\"></a>NoSQL</h2><h3 id=\"MongoDB\"><a href=\"#MongoDB\" class=\"headerlink\" title=\"MongoDB\"></a>MongoDB</h3><ul>\n<li><a href=\"http://www.runoob.com/mongodb/mongodb-tutorial.html\" target=\"_blank\" rel=\"noopener\">MongoDB 教程</a></li>\n<li><a href=\"http://mxdxm.iteye.com/blog/2093603\" target=\"_blank\" rel=\"noopener\">《Mongodb相对于关系型数据库的优缺点》</a><ul>\n<li>优点：弱一致性（最终一致），更能保证用户的访问速度；内置GridFS，支持大容量的存储；Schema-less 数据库，不用预先定义结构；内置Sharding；相比于其他NoSQL，第三方支持丰富；性能优越；</li>\n<li>缺点：mongodb不支持事务操作；mongodb占用空间过大；MongoDB没有如MySQL那样成熟的维护工具，这对于开发和IT运营都是个值得注意的地方；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Hbase\"><a href=\"#Hbase\" class=\"headerlink\" title=\"Hbase\"></a>Hbase</h3><ul>\n<li><a href=\"http://www.thebigdata.cn/HBase/35831.html\" target=\"_blank\" rel=\"noopener\">《简明 HBase 入门教程（开篇）》</a></li>\n<li><a href=\"https://www.cnblogs.com/qiaoyihang/p/6246424.html\" target=\"_blank\" rel=\"noopener\">《深入学习HBase架构原理》</a></li>\n<li><a href=\"https://blog.csdn.net/youzhouliu/article/details/67632882\" target=\"_blank\" rel=\"noopener\">《传统的行存储和（HBase）列存储的区别》</a></li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/lifuxiangcaohui/article/details/39891099\" target=\"_blank\" rel=\"noopener\">《Hbase与传统数据库的区别》</a></p>\n<ul>\n<li>空数据不存储，节省空间，且适用于并发。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u014091123/article/details/73163088\" target=\"_blank\" rel=\"noopener\">《HBase Rowkey设计》</a></p>\n<ul>\n<li>rowkey 按照字典顺序排列，便于批量扫描。</li>\n<li>通过散列可以避免热点。</li>\n</ul>\n</li>\n</ul>\n<h1 id=\"搜索引擎\"><a href=\"#搜索引擎\" class=\"headerlink\" title=\"搜索引擎\"></a>搜索引擎</h1><h2 id=\"搜索引擎原理\"><a href=\"#搜索引擎原理\" class=\"headerlink\" title=\"搜索引擎原理\"></a>搜索引擎原理</h2><ul>\n<li><a href=\"https://www.jianshu.com/p/0193dc44135b\" target=\"_blank\" rel=\"noopener\">《倒排索引–搜索引擎入门》</a></li>\n</ul>\n<h2 id=\"Lucene\"><a href=\"#Lucene\" class=\"headerlink\" title=\"Lucene\"></a>Lucene</h2><ul>\n<li><a href=\"https://www.cnblogs.com/rodge-run/p/6551152.html\" target=\"_blank\" rel=\"noopener\">《Lucene入门简介》</a></li>\n</ul>\n<h2 id=\"Elasticsearch\"><a href=\"#Elasticsearch\" class=\"headerlink\" title=\"Elasticsearch\"></a>Elasticsearch</h2><ul>\n<li><a href=\"https://blog.csdn.net/laoyang360/article/details/52244917\" target=\"_blank\" rel=\"noopener\">《Elasticsearch学习，请先看这一篇！》</a></li>\n<li><a href=\"https://blog.csdn.net/cyony/article/details/65437708\" target=\"_blank\" rel=\"noopener\">《Elasticsearch索引原理》</a></li>\n</ul>\n<h2 id=\"Solr\"><a href=\"#Solr\" class=\"headerlink\" title=\"Solr\"></a>Solr</h2><ul>\n<li><a href=\"https://blog.csdn.net/u011936655/article/details/51960005\" target=\"_blank\" rel=\"noopener\">《 Apache Solr入门教程》</a></li>\n<li><a href=\"https://blog.csdn.net/convict_eva/article/details/53537837\" target=\"_blank\" rel=\"noopener\">《elasticsearch与solr比较》</a></li>\n</ul>\n<h2 id=\"sphinx\"><a href=\"#sphinx\" class=\"headerlink\" title=\"sphinx\"></a>sphinx</h2><ul>\n<li><a href=\"http://blog.jobbole.com/101672/\" target=\"_blank\" rel=\"noopener\">《Sphinx 的介绍和原理探索》</a></li>\n</ul>\n<h1 id=\"性能\"><a href=\"#性能\" class=\"headerlink\" title=\"性能\"></a>性能</h1><h2 id=\"性能优化方法论\"><a href=\"#性能优化方法论\" class=\"headerlink\" title=\"性能优化方法论\"></a>性能优化方法论</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/huangwenyi1010/article/details/72673447?ref=myread\" target=\"_blank\" rel=\"noopener\">《15天的性能优化工作，5方面的调优经验》</a></p>\n<ul>\n<li>代码层面、业务层面、数据库层面、服务器层面、前端优化。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/tenglizhe/article/details/44563135\" target=\"_blank\" rel=\"noopener\">《系统性能优化的几个方面》</a></p>\n</li>\n</ul>\n<h2 id=\"容量评估\"><a href=\"#容量评估\" class=\"headerlink\" title=\"容量评估\"></a>容量评估</h2><ul>\n<li><a href=\"https://blog.csdn.net/u012528360/article/details/70054156\" target=\"_blank\" rel=\"noopener\">《联网性能与容量评估的方法论和典型案例》</a></li>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5ODYxMDA5OQ==&amp;mid=2651959542&amp;idx=1&amp;sn=2494bbea9a855e0e1c3ccd6d2562a600&amp;scene=21#wechat_redirect\" target=\"_blank\" rel=\"noopener\">《互联网架构，如何进行容量设计？》</a><ul>\n<li>评估总访问量、评估平均访问量QPS、评估高峰QPS、评估系统、单机极限QPS</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"CDN-网络\"><a href=\"#CDN-网络\" class=\"headerlink\" title=\"CDN 网络\"></a>CDN 网络</h2><ul>\n<li><a href=\"https://www.cnblogs.com/wxiaona/p/5867685.html\" target=\"_blank\" rel=\"noopener\">《CDN加速原理》</a></li>\n<li><a href=\"https://www.zhihu.com/question/20536932\" target=\"_blank\" rel=\"noopener\">《国内有哪些比较好的 CDN？》</a></li>\n</ul>\n<h2 id=\"连接池\"><a href=\"#连接池\" class=\"headerlink\" title=\"连接池\"></a>连接池</h2><ul>\n<li><a href=\"https://blog.csdn.net/fysuccess/article/details/66972554\" target=\"_blank\" rel=\"noopener\">《主流Java数据库连接池比较与开发配置实战》</a></li>\n</ul>\n<h2 id=\"性能调优\"><a href=\"#性能调优\" class=\"headerlink\" title=\"性能调优\"></a>性能调优</h2><ul>\n<li><a href=\"https://blog.csdn.net/yethyeth/article/details/73266455\" target=\"_blank\" rel=\"noopener\">《九大Java性能调试工具，必备至少一款》</a></li>\n</ul>\n<h1 id=\"大数据\"><a href=\"#大数据\" class=\"headerlink\" title=\"大数据\"></a>大数据</h1><h2 id=\"流式计算\"><a href=\"#流式计算\" class=\"headerlink\" title=\"流式计算\"></a>流式计算</h2><h3 id=\"Storm\"><a href=\"#Storm\" class=\"headerlink\" title=\"Storm\"></a>Storm</h3><ul>\n<li><a href=\"http://storm.apache.org/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"https://blog.csdn.net/uisoul/article/details/77989927\" target=\"_blank\" rel=\"noopener\">《最详细的Storm入门教程》</a></li>\n</ul>\n<h3 id=\"Flink\"><a href=\"#Flink\" class=\"headerlink\" title=\"Flink\"></a>Flink</h3><ul>\n<li><a href=\"https://blog.csdn.net/lisi1129/article/details/54844919\" target=\"_blank\" rel=\"noopener\">《Flink之一 Flink基本原理介绍》</a></li>\n</ul>\n<h3 id=\"Kafka-Stream\"><a href=\"#Kafka-Stream\" class=\"headerlink\" title=\"Kafka Stream\"></a>Kafka Stream</h3><ul>\n<li><a href=\"https://yq.aliyun.com/articles/58382\" target=\"_blank\" rel=\"noopener\">《Kafka Stream调研：一种轻量级流计算模式》</a></li>\n</ul>\n<h3 id=\"应用场景-1\"><a href=\"#应用场景-1\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h3><p>例如：</p>\n<ul>\n<li>广告相关实时统计；</li>\n<li>推荐系统用户画像标签实时更新；</li>\n<li>线上服务健康状况实时监测；</li>\n<li>实时榜单；</li>\n<li>实时数据统计。</li>\n</ul>\n<h2 id=\"Hadoop\"><a href=\"#Hadoop\" class=\"headerlink\" title=\"Hadoop\"></a>Hadoop</h2><ul>\n<li><a href=\"https://blog.csdn.net/houbin0912/article/details/72967178\" target=\"_blank\" rel=\"noopener\">《用通俗易懂的话说下hadoop是什么,能做什么》</a></li>\n<li><a href=\"http://gitbook.cn/books/5954c9600326c7705af8a92a/index.html\" target=\"_blank\" rel=\"noopener\">《史上最详细的Hadoop环境搭建》</a></li>\n</ul>\n<h3 id=\"HDFS\"><a href=\"#HDFS\" class=\"headerlink\" title=\"HDFS\"></a>HDFS</h3><ul>\n<li><a href=\"https://segmentfault.com/a/1190000011575458\" target=\"_blank\" rel=\"noopener\">《【Hadoop学习】HDFS基本原理》</a></li>\n</ul>\n<h3 id=\"MapReduce\"><a href=\"#MapReduce\" class=\"headerlink\" title=\"MapReduce\"></a>MapReduce</h3><ul>\n<li><a href=\"https://blog.csdn.net/oppo62258801/article/details/72884633\" target=\"_blank\" rel=\"noopener\">《用通俗易懂的大白话讲解Map/Reduce原理》</a></li>\n<li><a href=\"https://blog.csdn.net/foye12/article/details/78358292\" target=\"_blank\" rel=\"noopener\">《 简单的map-reduce的java例子》</a></li>\n</ul>\n<h3 id=\"Yarn\"><a href=\"#Yarn\" class=\"headerlink\" title=\"Yarn\"></a>Yarn</h3><ul>\n<li><a href=\"http://www.cnblogs.com/codeOfLife/p/5492740.html\" target=\"_blank\" rel=\"noopener\">《初步掌握Yarn的架构及原理》</a></li>\n</ul>\n<h2 id=\"Spark\"><a href=\"#Spark\" class=\"headerlink\" title=\"Spark\"></a>Spark</h2><ul>\n<li><a href=\"http://www.cnblogs.com/tgzhu/p/5818374.html\" target=\"_blank\" rel=\"noopener\">《Spark(一): 基本架构及原理》</a></li>\n</ul>\n<h1 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h1><h2 id=\"web-安全\"><a href=\"#web-安全\" class=\"headerlink\" title=\"web 安全\"></a>web 安全</h2><h3 id=\"XSS\"><a href=\"#XSS\" class=\"headerlink\" title=\"XSS\"></a>XSS</h3><ul>\n<li><a href=\"https://blog.csdn.net/qq_21956483/article/details/54377947\" target=\"_blank\" rel=\"noopener\">《xss攻击原理与解决方法》</a><h3 id=\"CSRF\"><a href=\"#CSRF\" class=\"headerlink\" title=\"CSRF\"></a>CSRF</h3></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6412-csrf.html\" target=\"_blank\" rel=\"noopener\">《CSRF原理及防范》</a></li>\n</ul>\n<h3 id=\"SQL-注入\"><a href=\"#SQL-注入\" class=\"headerlink\" title=\"SQL 注入\"></a>SQL 注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6413-sql-zhu-ru.html\" target=\"_blank\" rel=\"noopener\">《SQL注入》</a></li>\n</ul>\n<h3 id=\"Hash-Dos\"><a href=\"#Hash-Dos\" class=\"headerlink\" title=\"Hash Dos\"></a>Hash Dos</h3><ul>\n<li><a href=\"http://www.freebuf.com/articles/web/14199.html\" target=\"_blank\" rel=\"noopener\">《邪恶的JAVA HASH DOS攻击》</a><ul>\n<li>利用JsonObjet 上传大Json，JsonObject 底层使用HashMap；不同的数据产生相同的hash值，使得构建Hash速度变慢，耗尽CPU。</li>\n</ul>\n</li>\n<li><a href=\"https://yq.aliyun.com/articles/92194?t=t1\" target=\"_blank\" rel=\"noopener\">《一种高级的DoS攻击-Hash碰撞攻击》</a></li>\n<li><a href=\"http://www.iteye.com/news/23939/\" target=\"_blank\" rel=\"noopener\">《关于Hash Collision DoS漏洞：解析与解决方案》</a></li>\n</ul>\n<h3 id=\"脚本注入\"><a href=\"#脚本注入\" class=\"headerlink\" title=\"脚本注入\"></a>脚本注入</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/641-web-an-quan-fang-fan/6414-shang-chuan-wen-jian-guo-lv.html\" target=\"_blank\" rel=\"noopener\">《上传文件漏洞原理及防范》</a></li>\n</ul>\n<h3 id=\"漏洞扫描工具\"><a href=\"#漏洞扫描工具\" class=\"headerlink\" title=\"漏洞扫描工具\"></a>漏洞扫描工具</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/6421-dvwa.html\" target=\"_blank\" rel=\"noopener\">《DVWA》</a></li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/w3af.html\" target=\"_blank\" rel=\"noopener\">W3af</a></li>\n<li><a href=\"https://blog.csdn.net/xygg0801/article/details/53610640\" target=\"_blank\" rel=\"noopener\">OpenVAS详解</a></li>\n</ul>\n<h3 id=\"验证码\"><a href=\"#验证码\" class=\"headerlink\" title=\"验证码\"></a>验证码</h3><ul>\n<li><p><a href=\"https://blog.csdn.net/niaonao/article/details/51112686\" target=\"_blank\" rel=\"noopener\">《验证码原理分析及实现》</a></p>\n</li>\n<li><p><a href=\"https://my.oschina.net/jiangbianwanghai/blog/1031031\" target=\"_blank\" rel=\"noopener\">《详解滑动验证码的实现原理》</a></p>\n<ul>\n<li>滑动验证码是根据人在滑动滑块的响应时间，拖拽速度，时间，位置，轨迹，重试次数等来评估风险。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/xcj26/p/5242758.html\" target=\"_blank\" rel=\"noopener\">《淘宝滑动验证码研究》</a></p>\n</li>\n</ul>\n<h2 id=\"DDoS-防范\"><a href=\"#DDoS-防范\" class=\"headerlink\" title=\"DDoS 防范\"></a>DDoS 防范</h2><ul>\n<li><a href=\"http://netsecurity.51cto.com/art/201601/503799.htm\" target=\"_blank\" rel=\"noopener\">《学习手册：DDoS的攻击方式及防御手段》</a></li>\n<li><a href=\"http://netsecurity.51cto.com/art/201406/442756.htm\" target=\"_blank\" rel=\"noopener\">《免费DDoS攻击测试工具大合集》</a></li>\n</ul>\n<h2 id=\"用户隐私信息保护\"><a href=\"#用户隐私信息保护\" class=\"headerlink\" title=\"用户隐私信息保护\"></a>用户隐私信息保护</h2><ol>\n<li>用户密码非明文保存，加动态salt。</li>\n<li>身份证号，手机号如果要显示，用 “*” 替代部分字符。</li>\n<li>联系方式在的显示与否由用户自己控制。</li>\n<li>TODO</li>\n</ol>\n<ul>\n<li><a href=\"https://zhidao.baidu.com/question/1988017976673661587.html\" target=\"_blank\" rel=\"noopener\">《个人隐私包括哪些》</a></li>\n<li><p><a href=\"https://www.zhihu.com/question/20137108\" target=\"_blank\" rel=\"noopener\">《在互联网上，隐私的范围包括哪些？》</a></p>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6425-jia-mi-chang-jing-ff1a-yong-hu-mi-ma-bao-cun.html\" target=\"_blank\" rel=\"noopener\">《用户密码保存》</a></p>\n</li>\n</ul>\n<h2 id=\"序列化漏洞\"><a href=\"#序列化漏洞\" class=\"headerlink\" title=\"序列化漏洞\"></a>序列化漏洞</h2><ul>\n<li><a href=\"https://blog.chaitin.cn/2015-11-11_java_unserialize_rce/\" target=\"_blank\" rel=\"noopener\">《Lib之过？Java反序列化漏洞通用利用分析》</a></li>\n</ul>\n<h2 id=\"加密解密\"><a href=\"#加密解密\" class=\"headerlink\" title=\"加密解密\"></a>加密解密</h2><h3 id=\"对称加密\"><a href=\"#对称加密\" class=\"headerlink\" title=\"对称加密\"></a>对称加密</h3><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6421-chang-jian-dui-cheng-jia-mi-suan-fa.html\" target=\"_blank\" rel=\"noopener\">《常见对称加密算法》</a><ul>\n<li>DES、3DES、Blowfish、AES</li>\n<li>DES 采用 56位秘钥，Blowfish 采用1到448位变长秘钥，AES 128，192和256位长度的秘钥。</li>\n<li>DES 秘钥太短（只有56位）算法目前已经被 AES 取代，并且 AES 有硬件加速，性能很好。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"哈希算法\"><a href=\"#哈希算法\" class=\"headerlink\" title=\"哈希算法\"></a>哈希算法</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6422-chang-jian-ha-xi-suan-fa-and-hmac.html\" target=\"_blank\" rel=\"noopener\">《常用的哈希算法》</a></p>\n<ul>\n<li>MD5 和 SHA-1 已经不再安全，已被弃用。</li>\n<li>目前 SHA-256 是比较安全的。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zhangruhong168/article/details/78033202\" target=\"_blank\" rel=\"noopener\">《基于Hash摘要签名的公网URL签名验证设计方案》</a></p>\n</li>\n</ul>\n<h3 id=\"非对称加密\"><a href=\"#非对称加密\" class=\"headerlink\" title=\"非对称加密\"></a>非对称加密</h3><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/642-shu-ju-jia-mi/6424-chang-yong-fei-dui-cheng-jia-mi-suan-fa.html\" target=\"_blank\" rel=\"noopener\">《常见非对称加密算法》</a></p>\n<ul>\n<li>RSA、DSA、ECDSA(螺旋曲线加密算法)</li>\n<li>和 RSA 不同的是 DSA 仅能用于数字签名，不能进行数据加密解密，其安全性和RSA相当，但其性能要比RSA快。</li>\n<li><p>256位的ECC秘钥的安全性等同于3072位的RSA秘钥。</p>\n<p>  <a href=\"http://baijiahao.baidu.com/s?id=1578348858092033763&amp;wfr=spider&amp;for=pc\" target=\"_blank\" rel=\"noopener\">《区块链的加密技术》</a>    </p>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务器安全\"><a href=\"#服务器安全\" class=\"headerlink\" title=\"服务器安全\"></a>服务器安全</h2><ul>\n<li><a href=\"http://www.freebuf.com/articles/system/121540.html\" target=\"_blank\" rel=\"noopener\">《Linux强化论：15步打造一个安全的Linux服务器》</a></li>\n</ul>\n<h2 id=\"数据安全\"><a href=\"#数据安全\" class=\"headerlink\" title=\"数据安全\"></a>数据安全</h2><h3 id=\"数据备份\"><a href=\"#数据备份\" class=\"headerlink\" title=\"数据备份\"></a>数据备份</h3><p>TODO</p>\n<h2 id=\"网络隔离\"><a href=\"#网络隔离\" class=\"headerlink\" title=\"网络隔离\"></a>网络隔离</h2><h3 id=\"内外网分离\"><a href=\"#内外网分离\" class=\"headerlink\" title=\"内外网分离\"></a>内外网分离</h3><p>TODO</p>\n<h3 id=\"登录跳板机\"><a href=\"#登录跳板机\" class=\"headerlink\" title=\"登录跳板机\"></a>登录跳板机</h3><p>在内外环境中通过跳板机登录到线上主机。</p>\n<ul>\n<li><a href=\"http://blog.51cto.com/zero01/2062618\" target=\"_blank\" rel=\"noopener\">《搭建简易堡垒机》</a></li>\n</ul>\n<h2 id=\"授权、认证\"><a href=\"#授权、认证\" class=\"headerlink\" title=\"授权、认证\"></a>授权、认证</h2><h3 id=\"RBAC\"><a href=\"#RBAC\" class=\"headerlink\" title=\"RBAC\"></a>RBAC</h3><ul>\n<li><a href=\"https://www.cnblogs.com/zq8024/p/5003050.html\" target=\"_blank\" rel=\"noopener\">《基于组织角色的权限设计》</a></li>\n<li><a href=\"https://www.cnblogs.com/shijiaqi1066/p/3793894.html\" target=\"_blank\" rel=\"noopener\">《权限系统与RBAC模型概述》</a></li>\n<li><a href=\"https://blog.csdn.net/he90227/article/details/38663553\" target=\"_blank\" rel=\"noopener\">《Spring整合Shiro做权限控制模块详细案例分析》</a></li>\n</ul>\n<h3 id=\"OAuth2-0\"><a href=\"#OAuth2-0\" class=\"headerlink\" title=\"OAuth2.0\"></a>OAuth2.0</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html\" target=\"_blank\" rel=\"noopener\">《理解OAuth 2.0》</a></li>\n<li><a href=\"https://www.cnblogs.com/flashsun/p/7424071.html\" target=\"_blank\" rel=\"noopener\">《一张图搞定OAuth2.0》</a></li>\n</ul>\n<h3 id=\"双因素认证（2FA）\"><a href=\"#双因素认证（2FA）\" class=\"headerlink\" title=\"双因素认证（2FA）\"></a>双因素认证（2FA）</h3><p>2FA - Two-factor authentication，用于加强登录验证</p>\n<p>常用做法是 登录密码 + 手机验证码（或者令牌Key，类似于与网银的 USB key）</p>\n<ul>\n<li>【《双因素认证（2FA）教程》】(<a href=\"http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html\" target=\"_blank\" rel=\"noopener\">http://www.ruanyifeng.com/blog/2017/11/2fa-tutorial.html</a>)</li>\n</ul>\n<h3 id=\"单点登录-SSO\"><a href=\"#单点登录-SSO\" class=\"headerlink\" title=\"单点登录(SSO)\"></a>单点登录(SSO)</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/ywlaker/p/6113927.html\" target=\"_blank\" rel=\"noopener\">《单点登录原理与简单实现》</a></p>\n</li>\n<li><p><a href=\"https://github.com/apereo/cas\" target=\"_blank\" rel=\"noopener\">CAS单点登录框架</a></p>\n</li>\n</ul>\n<h1 id=\"常用开源框架\"><a href=\"#常用开源框架\" class=\"headerlink\" title=\"常用开源框架\"></a>常用开源框架</h1><h2 id=\"开源协议\"><a href=\"#开源协议\" class=\"headerlink\" title=\"开源协议\"></a>开源协议</h2><ul>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/chapter1/di-yi-zhang-ff1a-zhun-bei-qi-cheng/12-guan-yu-kai-yuan/123-kai-yuan-xie-yi-de-xuan-ze.html\" target=\"_blank\" rel=\"noopener\">《开源协议的选择》</a></p>\n</li>\n<li><p><a href=\"http://choosealicense.online/\" target=\"_blank\" rel=\"noopener\">如何选择一个开源软件协议</a></p>\n</li>\n</ul>\n<h2 id=\"日志框架\"><a href=\"#日志框架\" class=\"headerlink\" title=\"日志框架\"></a>日志框架</h2><h3 id=\"Log4j、Log4j2\"><a href=\"#Log4j、Log4j2\" class=\"headerlink\" title=\"Log4j、Log4j2\"></a>Log4j、Log4j2</h3><ul>\n<li><a href=\"https://blog.csdn.net/u012422446/article/details/51199724\" target=\"_blank\" rel=\"noopener\">《log4j 详细讲解》</a></li>\n<li><a href=\"https://blog.csdn.net/vbirdbest/article/details/71751835\" target=\"_blank\" rel=\"noopener\">《log4j2 实际使用详解》</a></li>\n<li><a href=\"https://my.oschina.net/OutOfMemory/blog/789267\" target=\"_blank\" rel=\"noopener\">《Log4j1,Logback以及Log4j2性能测试对比》</a><ul>\n<li>Log4J 异步日志性能优异。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Logback\"><a href=\"#Logback\" class=\"headerlink\" title=\"Logback\"></a>Logback</h3><ul>\n<li><a href=\"https://blog.csdn.net/rulon147/article/details/52620541\" target=\"_blank\" rel=\"noopener\">《最全LogBack 详解、含java案例和配置说明》</a></li>\n</ul>\n<h2 id=\"ORM\"><a href=\"#ORM\" class=\"headerlink\" title=\"ORM\"></a>ORM</h2><ul>\n<li><a href=\"https://blog.csdn.net/sinat_34093604/article/details/53082000\" target=\"_blank\" rel=\"noopener\">《ORM框架使用优缺点》</a><ul>\n<li>主要目的是为了提高开发效率。 </li>\n</ul>\n</li>\n</ul>\n<p><strong>MyBatis：</strong></p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/winclpt/articles/7511672.html\" target=\"_blank\" rel=\"noopener\">《mybatis缓存机制详解》</a></p>\n<ul>\n<li>一级缓存是SqlSession级别的缓存，缓存的数据只在SqlSession内有效</li>\n<li>二级缓存是mapper级别的缓存，同一个namespace公用这一个缓存，所以对SqlSession是共享的；使用 LRU 机制清理缓存，通过 cacheEnabled 参数开启。  </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/baidu_32877851/article/details/53959268\" target=\"_blank\" rel=\"noopener\">《MyBatis学习之代码生成器Generator》</a></p>\n</li>\n</ul>\n<h2 id=\"网络框架\"><a href=\"#网络框架\" class=\"headerlink\" title=\"网络框架\"></a>网络框架</h2><p>TODO</p>\n<h2 id=\"Web-框架\"><a href=\"#Web-框架\" class=\"headerlink\" title=\"Web 框架\"></a>Web 框架</h2><h3 id=\"Spring-家族\"><a href=\"#Spring-家族\" class=\"headerlink\" title=\"Spring 家族\"></a>Spring 家族</h3><p><strong>Spring</strong></p>\n<ul>\n<li><a href=\"https://www.w3cschool.cn/wkspring/\" target=\"_blank\" rel=\"noopener\">Spring 简明教程</a></li>\n</ul>\n<p><strong>Spring Boot</strong></p>\n<ul>\n<li><a href=\"http://projects.spring.io/spring-boot/\" target=\"_blank\" rel=\"noopener\">官方网站</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Boot%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">《Spring Boot基础教程》</a></li>\n</ul>\n<p><strong>Spring Cloud</strong></p>\n<ul>\n<li><a href=\"http://springboot.fun/\" target=\"_blank\" rel=\"noopener\">Spring Boot 中文索引站</a></li>\n<li><a href=\"https://springcloud.cc/\" target=\"_blank\" rel=\"noopener\">Spring Cloud 中文文档</a></li>\n<li><a href=\"http://blog.didispace.com/Spring-Cloud%E5%9F%BA%E7%A1%80%E6%95%99%E7%A8%8B/\" target=\"_blank\" rel=\"noopener\">《Spring Cloud基础教程》</a></li>\n</ul>\n<h2 id=\"工具框架\"><a href=\"#工具框架\" class=\"headerlink\" title=\"工具框架\"></a>工具框架</h2><ul>\n<li><a href=\"https://www.cnblogs.com/crazylqy/p/4872236.html\" target=\"_blank\" rel=\"noopener\">《Apache Commons 工具类介绍及简单使用》</a></li>\n<li><a href=\"http://ifeve.com/google-guava/\" target=\"_blank\" rel=\"noopener\">《Google guava 中文教程》</a></li>\n</ul>\n<h1 id=\"分布式设计\"><a href=\"#分布式设计\" class=\"headerlink\" title=\"分布式设计\"></a>分布式设计</h1><h2 id=\"扩展性设计\"><a href=\"#扩展性设计\" class=\"headerlink\" title=\"扩展性设计\"></a>扩展性设计</h2><ul>\n<li><p><a href=\"https://blog.csdn.net/hemin1003/article/details/53633926\" target=\"_blank\" rel=\"noopener\">《架构师不可不知的十大可扩展架构》</a></p>\n<ul>\n<li>总结下来，通用的套路就是分布、缓存及异步处理。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://yq.aliyun.com/articles/38119\" target=\"_blank\" rel=\"noopener\">《可扩展性设计之数据切分》</a></p>\n<ul>\n<li>水平切分+垂直切分</li>\n<li>利用中间件进行分片如，MySQL Proxy。</li>\n<li>利用分片策略进行切分，如按照ID取模。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/deniro_li/article/details/78458306\" target=\"_blank\" rel=\"noopener\">《说说如何实现可扩展性的大型网站架构》</a></p>\n<ul>\n<li>分布式服务+消息队列。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/chaofanwei/article/details/29191073\" target=\"_blank\" rel=\"noopener\">《大型网站技术架构（七）–网站的可扩展性架构》</a></p>\n</li>\n</ul>\n<h2 id=\"稳定性-amp-高可用\"><a href=\"#稳定性-amp-高可用\" class=\"headerlink\" title=\"稳定性 &amp; 高可用\"></a>稳定性 &amp; 高可用</h2><ul>\n<li><a href=\"https://blog.csdn.net/hustspy1990/article/details/78008324\" target=\"_blank\" rel=\"noopener\">《系统设计：关于高可用系统的一些技术方案》</a><ul>\n<li>可扩展：水平扩展、垂直扩展。 通过冗余部署，避免单点故障。</li>\n<li>隔离：避免单一业务占用全部资源。避免业务之间的相互影响 2. 机房隔离避免单点故障。</li>\n<li>解耦：降低维护成本，降低耦合风险。减少依赖，减少相互间的影响。</li>\n<li>限流：滑动窗口计数法、漏桶算法、令牌桶算法等算法。遇到突发流量时，保证系统稳定。</li>\n<li>降级：紧急情况下释放非核心功能的资源。牺牲非核心业务，保证核心业务的高可用。</li>\n<li>熔断：异常情况超出阈值进入熔断状态，快速失败。减少不稳定的外部依赖对核心服务的影响。</li>\n<li>自动化测试：通过完善的测试，减少发布引起的故障。</li>\n<li>灰度发布：灰度发布是速度与安全性作为妥协，能够有效减少发布故障。</li>\n</ul>\n</li>\n</ul>\n<ul>\n<li><a href=\"https://coolshell.cn/articles/17459.html\" target=\"_blank\" rel=\"noopener\">《关于高可用的系统》</a><ul>\n<li>设计原则：数据不丢(持久化)；服务高可用(服务副本)；绝对的100%高可用很难，目标是做到尽可能多的9，如99.999%（全年累计只有5分钟）。     </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"硬件负载均衡\"><a href=\"#硬件负载均衡\" class=\"headerlink\" title=\"硬件负载均衡\"></a>硬件负载均衡</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/wuyun-blog/p/6186198.html\" target=\"_blank\" rel=\"noopener\">《转！！负载均衡器技术Nginx和F5的优缺点对比》</a></p>\n<ul>\n<li>主要是和F5对比。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lcword/p/5773296.html\" target=\"_blank\" rel=\"noopener\">《软/硬件负载均衡产品 你知多少？》</a></p>\n</li>\n</ul>\n<h3 id=\"软件负载均衡\"><a href=\"#软件负载均衡\" class=\"headerlink\" title=\"软件负载均衡\"></a>软件负载均衡</h3><ul>\n<li><a href=\"https://www.cnblogs.com/tianzhiliang/articles/2317808.html\" target=\"_blank\" rel=\"noopener\">《几种负载均衡算法》</a><br>  轮寻、权重、负载、最少连接、QoS</li>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/611-dns-fang-shi.html\" target=\"_blank\" rel=\"noopener\">《DNS负载均衡》</a><ul>\n<li>配置简单，更新速度慢。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/613-nginx-fu-zai-jun-heng.html\" target=\"_blank\" rel=\"noopener\">《Nginx负载均衡》</a></p>\n<ul>\n<li>简单轻量、学习成本低；主要适用于web应用。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/edisonchou/p/4281978.html\" target=\"_blank\" rel=\"noopener\">《借助LVS+Keepalived实现负载均衡 》</a></p>\n<ul>\n<li>配置比较负载、只支持到4层，性能较高。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.ttlsa.com/linux/haproxy-study-tutorial/\" target=\"_blank\" rel=\"noopener\">《HAProxy用法详解 全网最详细中文文档》</a></p>\n<ul>\n<li>支持到七层（比如HTTP）、功能比较全面，性能也不错。</li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.itpub.net/25704976/viewspace-1319781/\" target=\"_blank\" rel=\"noopener\">《Haproxy+Keepalived+MySQL实现读均衡负载》</a></p>\n<ul>\n<li>主要是用户读请求的负载均衡。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/lylife/p/5584019.html\" target=\"_blank\" rel=\"noopener\">《rabbitmq+haproxy+keepalived实现高可用集群搭建》</a></p>\n</li>\n</ul>\n<h3 id=\"限流\"><a href=\"#限流\" class=\"headerlink\" title=\"限流\"></a>限流</h3><ul>\n<li><a href=\"https://www.cnblogs.com/haoxinyue/p/6792309.html\" target=\"_blank\" rel=\"noopener\">《谈谈高并发系统的限流》</a><ul>\n<li>计数器：通过滑动窗口计数器，控制单位时间内的请求次数，简单粗暴。</li>\n<li>漏桶算法：固定容量的漏桶，漏桶满了就丢弃请求，比较常用。</li>\n<li>令牌桶算法：固定容量的令牌桶，按照一定速率添加令牌，处理请求前需要拿到令牌，拿不到令牌则丢弃请求，或进入丢队列，可以通过控制添加令牌的速率，来控制整体速度。Guava 中的 RateLimiter 是令牌桶的实现。</li>\n<li>Nginx 限流：通过 <code>limit_req</code> 等模块限制并发连接数。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"应用层容灾\"><a href=\"#应用层容灾\" class=\"headerlink\" title=\"应用层容灾\"></a>应用层容灾</h3><ul>\n<li><p><a href=\"https://segmentfault.com/a/1190000005988895\" target=\"_blank\" rel=\"noopener\">《防雪崩利器：熔断器 Hystrix 的原理与使用》</a></p>\n<ul>\n<li>雪崩效应原因：硬件故障、硬件故障、程序Bug、重试加大流量、用户大量请求。 </li>\n<li>雪崩的对策：限流、改进缓存模式(缓存预加载、同步调用改异步)、自动扩容、降级。</li>\n<li>Hystrix设计原则：<ul>\n<li>资源隔离：Hystrix通过将每个依赖服务分配独立的线程池进行资源隔离, 从而避免服务雪崩。</li>\n<li>熔断开关：服务的健康状况 = 请求失败数 / 请求总数，通过阈值设定和滑动窗口控制开关。</li>\n<li>命令模式：通过继承 HystrixCommand 来包装服务调用逻辑。 </li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\" target=\"_blank\" rel=\"noopener\">《缓存穿透，缓存击穿，缓存雪崩解决方案分析》</a></p>\n</li>\n<li><a href=\"https://blog.csdn.net/zeb_perfect/article/details/54135506\" target=\"_blank\" rel=\"noopener\">《缓存击穿、失效以及热点key问题》</a> <ul>\n<li>主要策略：失效瞬间：单机使用锁；使用分布式锁；不过期；</li>\n<li>热点数据：热点数据单独存储；使用本地缓存；分成多个子key；</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"跨机房容灾\"><a href=\"#跨机房容灾\" class=\"headerlink\" title=\"跨机房容灾\"></a>跨机房容灾</h3><ul>\n<li><p><a href=\"http://dc.idcquan.com/ywgl/71559.shtml\" target=\"_blank\" rel=\"noopener\">《“异地多活”多机房部署经验谈》</a></p>\n<ul>\n<li>通过自研中间件进行数据同步。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/jeffreynicole/article/details/48135093\" target=\"_blank\" rel=\"noopener\">《异地多活（异地双活）实践经验》</a></p>\n<ul>\n<li>注意延迟问题，多次跨机房调用会将延时放大数倍。</li>\n<li>建房间专线很大概率会出现问题，做好运维和程序层面的容错。</li>\n<li>不能依赖于程序端数据双写，要有自动同步方案。 </li>\n<li>数据永不在高延迟和较差网络质量下，考虑同步质量问题。</li>\n<li>核心业务和次要业务分而治之，甚至只考虑核心业务。</li>\n<li>异地多活监控部署、测试也要跟上。</li>\n<li>业务允许的情况下考虑用户分区，尤其是游戏、邮箱业务。</li>\n<li>控制跨机房消息体大小，越小越好。</li>\n<li>考虑使用docker容器虚拟化技术，提高动态调度能力。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/yoara/article/details/38013751\" target=\"_blank\" rel=\"noopener\">容灾技术及建设经验介绍</a></p>\n</li>\n</ul>\n<h3 id=\"容灾演练流程\"><a href=\"#容灾演练流程\" class=\"headerlink\" title=\"容灾演练流程\"></a>容灾演练流程</h3><ul>\n<li><a href=\"https://mp.weixin.qq.com/s?__biz=MjM5MDE0Mjc4MA==&amp;mid=2650996320&amp;idx=1&amp;sn=0ed3be190bbee4a9277886ef88cbb2e5\" target=\"_blank\" rel=\"noopener\">《依赖治理、灰度发布、故障演练，阿里电商故障演练系统的设计与实战经验》</a><ul>\n<li>常见故障画像</li>\n<li>案例：预案有效性、预案有效性、故障复现、架构容灾测试、参数调优、参数调优、故障突袭、联合演练。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"平滑启动\"><a href=\"#平滑启动\" class=\"headerlink\" title=\"平滑启动\"></a>平滑启动</h3><ul>\n<li><p>平滑重启应用思路<br>1.端流量（如vip层）、2. flush 数据(如果有)、3, 重启应用</p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u011001084/article/details/73480432\" target=\"_blank\" rel=\"noopener\">《JVM安全退出（如何优雅的关闭java服务）》</a><br>推荐推出方式：System.exit，Kill SIGTERM；不推荐 kill-9；用 Runtime.addShutdownHook 注册钩子。</p>\n</li>\n<li><a href=\"http://ju.outofmemory.cn/entry/337235\" target=\"_blank\" rel=\"noopener\">《常见Java应用如何优雅关闭》</a><br>Java、Srping、Dubbo 优雅关闭方式。</li>\n</ul>\n<h2 id=\"数据库扩展\"><a href=\"#数据库扩展\" class=\"headerlink\" title=\"数据库扩展\"></a>数据库扩展</h2><h3 id=\"读写分离模式\"><a href=\"#读写分离模式\" class=\"headerlink\" title=\"读写分离模式\"></a>读写分离模式</h3><ul>\n<li><a href=\"https://www.cnblogs.com/houdj/p/6563771.html\" target=\"_blank\" rel=\"noopener\">《Mysql主从方案的实现》</a></li>\n<li><a href=\"https://www.cnblogs.com/edisonchou/p/4133148.html\" target=\"_blank\" rel=\"noopener\">《搭建MySQL主从复制经典架构》</a></li>\n<li><p><a href=\"https://blog.csdn.net/nimasike/article/details/48048341\" target=\"_blank\" rel=\"noopener\">《Haproxy+多台MySQL从服务器(Slave) 实现负载均衡》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zhangsubai/p/6801764.html\" target=\"_blank\" rel=\"noopener\">《DRBD+Heartbeat+Mysql高可用读写分离架构》</a></p>\n<ul>\n<li>DRDB 进行磁盘复制，避免单点问题。</li>\n</ul>\n</li>\n<li><p><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/62-ke-kuo-zhan-de-shu-ju-ku-jia-gou/621-gao-ke-yong-mysql-de-ji-zhong-fang-an/6214-mysql-cluster-fang-an.html\" target=\"_blank\" rel=\"noopener\">《MySQL Cluster 方式》</a></p>\n</li>\n</ul>\n<h3 id=\"分片模式\"><a href=\"#分片模式\" class=\"headerlink\" title=\"分片模式\"></a>分片模式</h3><ul>\n<li><p><a href=\"https://www.jianshu.com/p/32b3e91aa22c\" target=\"_blank\" rel=\"noopener\">《分库分表需要考虑的问题及方案》</a></p>\n<ul>\n<li>中间件： 轻量级：sharding-jdbc、TSharding；重量级：Atlas、MyCAT、Vitess等。</li>\n<li>问题：事务、Join、迁移、扩容、ID、分页等。</li>\n<li>事务补偿：对数据进行对帐检查;基于日志进行比对;定期同标准数据来源进行同步等。</li>\n<li>分库策略：数值范围；取模；日期等。</li>\n<li>分库数量：通常 MySQL 单库 5千万条、Oracle 单库一亿条需要分库。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.2cto.com/database/201503/380348.html\" target=\"_blank\" rel=\"noopener\">《MySql分表和表分区详解》</a></p>\n<ul>\n<li>分区：是MySQL内部机制，对客户端透明，数据存储在不同文件中，表面上看是同一个表。</li>\n<li>分表：物理上创建不同的表、客户端需要管理分表路由。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"服务治理\"><a href=\"#服务治理\" class=\"headerlink\" title=\"服务治理\"></a>服务治理</h2><h3 id=\"服务注册与发现\"><a href=\"#服务注册与发现\" class=\"headerlink\" title=\"服务注册与发现\"></a>服务注册与发现</h3><ul>\n<li><a href=\"https://blog.csdn.net/jiaolongdy/article/details/51188798\" target=\"_blank\" rel=\"noopener\">《永不失联！如何实现微服务架构中的服务发现？》</a><ul>\n<li>客户端服务发现模式：客户端直接查询注册表，同时自己负责负载均衡。Eureka 采用这种方式。</li>\n<li>服务器端服务发现模式：客户端通过负载均衡查询服务实例。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/u010963948/article/details/71730165\" target=\"_blank\" rel=\"noopener\">《SpringCloud服务注册中心比较:Consul vs Zookeeper vs Etcd vs Eureka》</a></p>\n<ul>\n<li>CAP支持：Consul（CA）、zookeeper（cp）、etcd（cp） 、euerka（ap）</li>\n<li>作者认为目前 Consul 对 Spring cloud 的支持比较好。</li>\n</ul>\n</li>\n<li><p><a href=\"http://mobile.51cto.com/news-502394.htm\" target=\"_blank\" rel=\"noopener\">《基于Zookeeper的服务注册与发现》</a></p>\n<ul>\n<li>优点：API简单、Pinterest，Airbnb 在用、多语言、通过watcher机制来实现配置PUSH，能快速响应配置变化。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"服务路由控制\"><a href=\"#服务路由控制\" class=\"headerlink\" title=\"服务路由控制\"></a>服务路由控制</h3><ul>\n<li><a href=\"https://blog.csdn.net/xundh/article/details/59492750\" target=\"_blank\" rel=\"noopener\">《分布式服务框架学习笔记4 服务路由》</a><ul>\n<li>原则：透明化路由</li>\n<li>负载均衡策略：随机、轮询、服务调用延迟、一致性哈希、粘滞连接</li>\n<li>本地路由有限策略：injvm(优先调用jvm内部的服务)，innative(优先使用相同物理机的服务),原则上找距离最近的服务。</li>\n<li>配置方式：统一注册表；本地配置；动态下发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式一致\"><a href=\"#分布式一致\" class=\"headerlink\" title=\"分布式一致\"></a>分布式一致</h2><h3 id=\"CAP-与-BASE-理论\"><a href=\"#CAP-与-BASE-理论\" class=\"headerlink\" title=\"CAP 与 BASE 理论\"></a>CAP 与 BASE 理论</h3><ul>\n<li><a href=\"http://www.cnblogs.com/szlbm/p/5588543.html\" target=\"_blank\" rel=\"noopener\">《从分布式一致性谈到CAP理论、BASE理论》</a><ul>\n<li>一致性分类：强一致(立即一致)；弱一致(可在单位时间内实现一致，比如秒级)；最终一致(弱一致的一种，一定时间内最终一致)</li>\n<li>CAP：一致性、可用性、分区容错性(网络故障引起)</li>\n<li>BASE：Basically Available（基本可用）、Soft state（软状态）和Eventually consistent（最终一致性）</li>\n<li>BASE理论的核心思想是：即使无法做到强一致性，但每个应用都可以根据自身业务特点，采用适当的方式来使系统达到最终一致性。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式锁\"><a href=\"#分布式锁\" class=\"headerlink\" title=\"分布式锁\"></a>分布式锁</h3><ul>\n<li><a href=\"http://www.hollischuang.com/archives/1716\" target=\"_blank\" rel=\"noopener\">《分布式锁的几种实现方式》</a><ul>\n<li>基于数据库的分布式锁：优点：操作简单、容易理解。缺点：存在单点问题、数据库性能够开销较大、不可重入；</li>\n<li>基于缓存的分布式锁：优点：非阻塞、性能好。缺点：操作不好容易造成锁无法释放的情况。</li>\n<li>Zookeeper 分布式锁：通过有序临时节点实现锁机制，自己对应的节点需要最小，则被认为是获得了锁。优点：集群可以透明解决单点问题，避免锁不被释放问题，同时锁可以重入。缺点：性能不如缓存方式，吞吐量会随着zk集群规模变大而下降。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.tuicool.com/articles/VZJr6fY\" target=\"_blank\" rel=\"noopener\">《基于Zookeeper的分布式锁》</a></p>\n<ul>\n<li>清楚的原理描述 + Java 代码示例。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/0201zcr/p/5942748.html\" target=\"_blank\" rel=\"noopener\">《jedisLock—redis分布式锁实现》</a></p>\n<ul>\n<li>基于 setnx(set if ont exists)，有则返回false，否则返回true。并支持过期时间。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/albertfly/article/details/77412333\" target=\"_blank\" rel=\"noopener\">《Memcached 和 Redis 分布式锁方案》</a></p>\n<ul>\n<li>利用 memcached 的 add（有别于set）操作，当key存在时，返回false。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致性算法\"><a href=\"#分布式一致性算法\" class=\"headerlink\" title=\"分布式一致性算法\"></a>分布式一致性算法</h3><h4 id=\"PAXOS\"><a href=\"#PAXOS\" class=\"headerlink\" title=\"PAXOS\"></a>PAXOS</h4><ul>\n<li><a href=\"https://www.cnblogs.com/linbingdong/p/6253479.html\" target=\"_blank\" rel=\"noopener\">《分布式系列文章——Paxos算法原理与推导》</a></li>\n<li><a href=\"https://blog.csdn.net/u010039929/article/details/70171672\" target=\"_blank\" rel=\"noopener\">《Paxos–&gt;Fast Paxos–&gt;Zookeeper分析》</a></li>\n<li><a href=\"https://www.cnblogs.com/leesf456/p/6012777.html\" target=\"_blank\" rel=\"noopener\">《【分布式】Zookeeper与Paxos》</a></li>\n</ul>\n<h4 id=\"Zab\"><a href=\"#Zab\" class=\"headerlink\" title=\"Zab\"></a>Zab</h4><ul>\n<li><a href=\"https://www.jianshu.com/p/fb527a64deee\" target=\"_blank\" rel=\"noopener\">《Zab：Zookeeper 中的分布式一致性协议介绍》</a></li>\n</ul>\n<h4 id=\"Raft\"><a href=\"#Raft\" class=\"headerlink\" title=\"Raft\"></a>Raft</h4><ul>\n<li><a href=\"http://www.cnblogs.com/mindwind/p/5231986.html\" target=\"_blank\" rel=\"noopener\">《Raft 为什么是更易理解的分布式一致性算法》</a><ul>\n<li>三种角色：Leader（领袖）、Follower（群众）、Candidate（候选人）</li>\n<li>通过随机等待的方式发出投票，得票多的获胜。</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"Gossip\"><a href=\"#Gossip\" class=\"headerlink\" title=\"Gossip\"></a>Gossip</h4><ul>\n<li><a href=\"http://blog.51cto.com/tianya23/530743\" target=\"_blank\" rel=\"noopener\">《Gossip算法》</a></li>\n</ul>\n<h4 id=\"两阶段提交、多阶段提交\"><a href=\"#两阶段提交、多阶段提交\" class=\"headerlink\" title=\"两阶段提交、多阶段提交\"></a>两阶段提交、多阶段提交</h4><ul>\n<li><a href=\"http://blog.jobbole.com/95632/\" target=\"_blank\" rel=\"noopener\">《关于分布式事务、两阶段提交协议、三阶提交协议》</a></li>\n</ul>\n<h3 id=\"幂等\"><a href=\"#幂等\" class=\"headerlink\" title=\"幂等\"></a>幂等</h3><ul>\n<li><a href=\"https://www.cnblogs.com/wxgblogs/p/6639272.html\" target=\"_blank\" rel=\"noopener\">《分布式系统—幂等性设计》</a><ul>\n<li>幂等特性的作用：该资源具备幂等性，请求方无需担心重复调用会产生错误。</li>\n<li>常见保证幂等的手段：MVCC（类似于乐观锁）、去重表(唯一索引)、悲观锁、一次性token、序列号方式。 </li>\n</ul>\n</li>\n</ul>\n<h3 id=\"分布式一致方案\"><a href=\"#分布式一致方案\" class=\"headerlink\" title=\"分布式一致方案\"></a>分布式一致方案</h3><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/solution-of-distributed-system-transaction-consistency\" target=\"_blank\" rel=\"noopener\">《分布式系统事务一致性解决方案》</a></li>\n<li><a href=\"https://weibo.com/ttarticle/p/show?id=2309403965965003062676\" target=\"_blank\" rel=\"noopener\">《保证分布式系统数据一致性的6种方案》</a></li>\n</ul>\n<h3 id=\"分布式-Leader-节点选举\"><a href=\"#分布式-Leader-节点选举\" class=\"headerlink\" title=\"分布式 Leader 节点选举\"></a>分布式 Leader 节点选举</h3><ul>\n<li><a href=\"https://blog.csdn.net/johnson_moon/article/details/78809995\" target=\"_blank\" rel=\"noopener\">《利用zookeeper实现分布式leader节点选举》</a></li>\n</ul>\n<h3 id=\"TCC-Try-Confirm-Cancel-柔性事务\"><a href=\"#TCC-Try-Confirm-Cancel-柔性事务\" class=\"headerlink\" title=\"TCC(Try/Confirm/Cancel) 柔性事务\"></a>TCC(Try/Confirm/Cancel) 柔性事务</h3><ul>\n<li><a href=\"https://www.jianshu.com/p/ab1a1c6b08a1\" target=\"_blank\" rel=\"noopener\">《传统事务与柔性事务》</a><ul>\n<li>基于BASE理论：基本可用、柔性状态、最终一致。</li>\n<li>解决方案：记录日志+补偿（正向补充或者回滚）、消息重试(要求程序要幂等)；“无锁设计”、采用乐观锁机制。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"分布式文件系统\"><a href=\"#分布式文件系统\" class=\"headerlink\" title=\"分布式文件系统\"></a>分布式文件系统</h2><ul>\n<li><a href=\"https://zhuanlan.zhihu.com/p/27666295\" target=\"_blank\" rel=\"noopener\">说说分布式文件存储系统-基本架构</a> ？</li>\n<li><a href=\"https://blog.csdn.net/gatieme/article/details/44982961\" target=\"_blank\" rel=\"noopener\">《各种分布式文件系统的比较》</a> ？<ul>\n<li>HDFS：大批量数据读写，用于高吞吐量的场景，不适合小文件。</li>\n<li>FastDFS：轻量级、适合小文件。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"唯一ID-生成\"><a href=\"#唯一ID-生成\" class=\"headerlink\" title=\"唯一ID 生成\"></a>唯一ID 生成</h2><h3 id=\"全局唯一ID\"><a href=\"#全局唯一ID\" class=\"headerlink\" title=\"全局唯一ID\"></a>全局唯一ID</h3><ul>\n<li><p><a href=\"https://www.cnblogs.com/baiwa/p/5318432.html\" target=\"_blank\" rel=\"noopener\">《高并发分布式系统中生成全局唯一Id汇总》</a></p>\n<ul>\n<li>Twitter 方案（Snowflake 算法）：41位时间戳+10位机器标识（比如IP，服务器名称等）+12位序列号(本地计数器)</li>\n<li>Flicker 方案：MySQL自增ID + “REPLACE INTO XXX:SELECT LAST_INSERT_ID();” </li>\n<li>UUID：缺点，无序，字符串过长，占用空间，影响检索性能。</li>\n<li>MongoDB 方案：利用 ObjectId。缺点：不能自增。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/hdu09075340/article/details/79103851\" target=\"_blank\" rel=\"noopener\">《TDDL 在分布式下的SEQUENCE原理》</a></p>\n<ul>\n<li>在数据库中创建 sequence 表，用于记录，当前已被占用的id最大值。</li>\n<li>每台客户端主机取一个id区间（比如 1000~2000）缓存在本地，并更新 sequence 表中的id最大值记录。</li>\n<li>客户端主机之间取不同的id区间，用完再取，使用乐观锁机制控制并发。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"一致性Hash算法\"><a href=\"#一致性Hash算法\" class=\"headerlink\" title=\"一致性Hash算法\"></a>一致性Hash算法</h2><ul>\n<li><a href=\"https://coderxing.gitbooks.io/architecture-evolution/di-san-pian-ff1a-bu-luo/631-yi-zhi-xing-ha-xi.html\" target=\"_blank\" rel=\"noopener\">《一致性哈希算法》</a></li>\n</ul>\n<h1 id=\"设计思想-amp-开发模式\"><a href=\"#设计思想-amp-开发模式\" class=\"headerlink\" title=\"设计思想 &amp; 开发模式\"></a>设计思想 &amp; 开发模式</h1><h2 id=\"DDD-Domain-driven-Design-领域驱动设计\"><a href=\"#DDD-Domain-driven-Design-领域驱动设计\" class=\"headerlink\" title=\"DDD(Domain-driven Design - 领域驱动设计)\"></a>DDD(Domain-driven Design - 领域驱动设计)</h2><ul>\n<li><p><a href=\"https://www.cnblogs.com/netfocus/p/5548025.html\" target=\"_blank\" rel=\"noopener\">《浅谈我对DDD领域驱动设计的理解》</a></p>\n<ul>\n<li>概念：DDD 主要对传统软件开发流程(分析-设计-编码)中各阶段的割裂问题而提出，避免由于一开始分析不明或在软件开发过程中的信息流转不一致而造成软件无法交付（和需求方设想不一致）的问题。DDD 强调一切以领域（Domain）为中心，强调领域专家（Domain Expert）的作用，强调先定义好领域模型之后在进行开发，并且领域模型可以指导开发（所谓的驱动）。</li>\n<li>过程：理解领域、拆分领域、细化领域，模型的准确性取决于模型的理解深度。</li>\n<li>设计：DDD 中提出了建模工具，比如聚合、实体、值对象、工厂、仓储、领域服务、领域事件来帮助领域建模。</li>\n</ul>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/butterfly100/p/7827870.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计的基础知识总结》</a></p>\n<ul>\n<li>领域（Doamin）本质上就是问题域，比如一个电商系统，一个论坛系统等。</li>\n<li>界限上下文（Bounded Context）：阐述子域之间的关系，可以简单理解成一个子系统或组件模块。</li>\n<li>领域模型（Domain Model）：DDD的核心是建立（用通用描述语言、工具—领域通用语言）正确的领域模型；反应业务需求的本质，包括实体和过程；其贯穿软件分析、设计、开发 的整个过程；常用表达领域模型的方式：图、代码或文字；</li>\n<li>领域通用语言：领域专家、开发设计人员都能立即的语言或工具。</li>\n<li>经典分层架构：用户界面/展示层、应用层、领域层、基础设施层，是四层架构模式。</li>\n<li>使用的模式：<ul>\n<li>关联尽量少，尽量单项，尽量降低整体复杂度。</li>\n<li>实体（Entity）：领域中的唯一标示，一个实体的属性尽量少，少则清晰。</li>\n<li>值对象（Value Object）：没有唯一标识，且属性值不可变，小二简单的对象，比如Date。</li>\n<li>领域服务（Domain Service）： 协调多个领域对象，只有方法没有状态(不存数据)；可以分为应用层服务，领域层服务、基础层服务。</li>\n<li>聚合及聚合根（Aggregate，Aggregate Root）：聚合定义了一组具有内聚关系的相关对象的集合；聚合根是对聚合引用的唯一元素；当修改一个聚合时，必须在事务级别；大部分领域模型中，有70%的聚合通常只有一个实体，30%只有2~3个实体；如果一个聚合只有一个实体，那么这个实体就是聚合根；如果有多个实体，那么我们可以思考聚合内哪个对象有独立存在的意义并且可以和外部直接进行交互；</li>\n<li>工厂（Factory）：类似于设计模式中的工厂模式。</li>\n<li>仓储（Repository）：持久化到DB，管理对象，且只对聚合设计仓储。</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/Leo_wl/p/3866629.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计(DDD)实现之路》</a></p>\n<ul>\n<li>聚合：比如一辆汽车（Car）包含了引擎（Engine）、车轮（Wheel）和油箱（Tank）等组件，缺一不可。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.hollischuang.com/archives/553\" target=\"_blank\" rel=\"noopener\">《领域驱动设计系列（2）浅析VO、DTO、DO、PO的概念、区别和用处》</a></p>\n</li>\n</ul>\n<h3 id=\"命令查询职责分离-CQRS\"><a href=\"#命令查询职责分离-CQRS\" class=\"headerlink\" title=\"命令查询职责分离(CQRS)\"></a>命令查询职责分离(CQRS)</h3><p>CQRS — Command Query Responsibility Seperation</p>\n<ul>\n<li><p><a href=\"https://www.cnblogs.com/cnblogsfans/p/4551990.html\" target=\"_blank\" rel=\"noopener\">《领域驱动设计系列 (六)：CQRS》</a></p>\n<ul>\n<li>核心思想：读写分离（查询和更新在不同的方法中），不同的流程只是不同的设计方式，CQ代码分离，分布式环境中会有明显体现（有冗余数据的情况下），目的是为了高性能。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.techweb.com.cn/network/system/2017-07-07/2553563.shtml\" target=\"_blank\" rel=\"noopener\">《DDD CQRS架构和传统架构的优缺点比较》</a></p>\n<ul>\n<li>最终一致的设计理念；依赖于高可用消息中间件。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.cnblogs.com/netfocus/p/4055346.html\" target=\"_blank\" rel=\"noopener\">《CQRS架构简介》</a></p>\n<ul>\n<li>一个实现 CQRS 的抽象案例。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.uml.org.cn/zjjs/201609221.asp\" target=\"_blank\" rel=\"noopener\">《深度长文：我对CQRS/EventSourcing架构的思考》</a></p>\n<ul>\n<li>CQRS 模式分析 + 12306 抢票案例</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"贫血，充血模型\"><a href=\"#贫血，充血模型\" class=\"headerlink\" title=\"贫血，充血模型\"></a>贫血，充血模型</h3><ul>\n<li><a href=\"https://kb.cnblogs.com/page/520743/\" target=\"_blank\" rel=\"noopener\">《贫血，充血模型的解释以及一些经验》</a><ul>\n<li>失血模型：老子和儿子分别定义，相互不知道，二者实体定义中完全没有业务逻辑，通过外部Service进行关联。</li>\n<li>贫血模型：老子知道儿子，儿子也知道老子；部分业务逻辑放到实体中；优点：各层单项依赖，结构清楚，易于维护；缺点：不符合OO思想，相比于充血模式，Service层较为厚重；</li>\n<li>充血模型：和贫血模型类似，区别在于如何划分业务逻辑。优点：Service层比较薄，只充当Facade的角色，不和DAO打交道、复合OO思想；缺点：非单项依赖，DO和DAO之间双向依赖、和Service层的逻辑划分容易造成混乱。</li>\n<li>肿胀模式：是一种极端情况，取消Service层、全部业务逻辑放在DO中；优点：符合OO思想、简化了分层；缺点：暴露信息过多、很多非DO逻辑也会强行并入DO。这种模式应该避免。</li>\n<li>作者主张使用贫血模式。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Actor-模式\"><a href=\"#Actor-模式\" class=\"headerlink\" title=\"Actor 模式\"></a>Actor 模式</h2><p>TODO</p>\n<h2 id=\"响应式编程\"><a href=\"#响应式编程\" class=\"headerlink\" title=\"响应式编程\"></a>响应式编程</h2><h3 id=\"Reactor\"><a href=\"#Reactor\" class=\"headerlink\" title=\"Reactor\"></a>Reactor</h3><p>TODO</p>\n<h3 id=\"RxJava\"><a href=\"#RxJava\" class=\"headerlink\" title=\"RxJava\"></a>RxJava</h3><p>TODO</p>\n<h3 id=\"Vert-x\"><a href=\"#Vert-x\" class=\"headerlink\" title=\"Vert.x\"></a>Vert.x</h3><p>TODO</p>\n<h2 id=\"DODAF2-0\"><a href=\"#DODAF2-0\" class=\"headerlink\" title=\"DODAF2.0\"></a>DODAF2.0</h2><ul>\n<li><a href=\"http://www.360doc.com/content/16/0627/19/33945750_571201779.shtml\" target=\"_blank\" rel=\"noopener\">《DODAF2.0方法论》</a></li>\n<li><a href=\"http://blog.51cto.com/xiaoyong/1553164\" target=\"_blank\" rel=\"noopener\">《DODAF2.0之能力视角如何落地》</a></li>\n</ul>\n<h2 id=\"Serverless\"><a href=\"#Serverless\" class=\"headerlink\" title=\"Serverless\"></a>Serverless</h2><p>无需过多关系服务器的服务架构理念。</p>\n<ul>\n<li><p><a href=\"http://www.jdon.com/soa/serverless.html\" target=\"_blank\" rel=\"noopener\">《什么是Serverless无服务器架构？》</a></p>\n<ul>\n<li>Serverless 不代表出去服务器，而是去除对服务器运行状态的关心。</li>\n<li>Serverless 代表一思维方式的转变，从“构建一套服务在一台服务器上，对对个事件进行响应转变为构建一个为服务器，来响应一个事件”。</li>\n<li>Serverless 不代表某个具体的框架。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/news/2017/10/how-to-understand-serverless\" target=\"_blank\" rel=\"noopener\">《如何理解Serverless？》</a></p>\n<ul>\n<li>依赖于 Baas （(Mobile) Backend as a Service） 和 Faas （Functions as a service）</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Service-Mesh\"><a href=\"#Service-Mesh\" class=\"headerlink\" title=\"Service Mesh\"></a>Service Mesh</h2><ul>\n<li><a href=\"https://time.geekbang.org/article/2355\" target=\"_blank\" rel=\"noopener\">《什么是Service Mesh？》</a></li>\n<li><p><a href=\"https://www.jianshu.com/p/e23e3e74538e\" target=\"_blank\" rel=\"noopener\">《初识 Service Mesh》</a></p>\n</li>\n<li><p><a href=\"https://time.geekbang.org/article/2355\" target=\"_blank\" rel=\"noopener\">《什么是Service Mesh？》</a></p>\n</li>\n</ul>\n<h1 id=\"项目管理\"><a href=\"#项目管理\" class=\"headerlink\" title=\"项目管理\"></a>项目管理</h1><h2 id=\"架构评审\"><a href=\"#架构评审\" class=\"headerlink\" title=\"架构评审\"></a>架构评审</h2><ul>\n<li><a href=\"http://developer.51cto.com/art/201506/478486.htm\" target=\"_blank\" rel=\"noopener\">《架构设计之如何评审架构设计说明书》</a></li>\n<li><a href=\"https://blog.csdn.net/wireless_com/article/details/45935591\" target=\"_blank\" rel=\"noopener\">《人人都是架构师：非功能性需求》</a></li>\n</ul>\n<h2 id=\"重构\"><a href=\"#重构\" class=\"headerlink\" title=\"重构\"></a>重构</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/articles/architect-12-rules-complete/\" target=\"_blank\" rel=\"noopener\">《架构之重构的12条军规》</a></li>\n</ul>\n<h2 id=\"代码规范\"><a href=\"#代码规范\" class=\"headerlink\" title=\"代码规范\"></a>代码规范</h2><ul>\n<li><a href=\"https://github.com/alibaba/p3c\" target=\"_blank\" rel=\"noopener\">《阿里巴巴Java开发手册》</a></li>\n</ul>\n<h2 id=\"代码-Review\"><a href=\"#代码-Review\" class=\"headerlink\" title=\"代码 Review\"></a>代码 Review</h2><p>制度还是制度!<br>另外，每个公司需要根据自己的需求和目标制定自己的 check list</p>\n<ul>\n<li><p><a href=\"http://www.sohu.com/a/229745352_181657\" target=\"_blank\" rel=\"noopener\">《为什么你做不好 Code Review？》</a></p>\n<ul>\n<li>代码 review 做的好，在于制度建设。</li>\n</ul>\n</li>\n<li><p><a href=\"https://blog.csdn.net/uxyheaven/article/details/49773619\" target=\"_blank\" rel=\"noopener\">《从零开始Code Review》</a></p>\n</li>\n<li><p><a href=\"https://www.cnblogs.com/zuoping/p/5477047.html\" target=\"_blank\" rel=\"noopener\">《Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://dzone.com/articles/java-code-review-checklist\" target=\"_blank\" rel=\"noopener\">《Java Code Review Checklist》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/legend0011/article/details/45585575\" target=\"_blank\" rel=\"noopener\">《如何用 gitlab 做 code review》</a></p>\n</li>\n</ul>\n<h2 id=\"RUP\"><a href=\"#RUP\" class=\"headerlink\" title=\"RUP\"></a>RUP</h2><ul>\n<li><a href=\"https://blog.csdn.net/apanious/article/details/51011946\" target=\"_blank\" rel=\"noopener\">《运用RUP 4+1视图方法进行软件架构设计》</a></li>\n</ul>\n<h2 id=\"看板管理\"><a href=\"#看板管理\" class=\"headerlink\" title=\"看板管理\"></a>看板管理</h2><ul>\n<li><a href=\"https://blog.csdn.net/tkchen/article/details/51637643\" target=\"_blank\" rel=\"noopener\">《说说看板在项目中的应用》</a></li>\n</ul>\n<h2 id=\"SCRUM\"><a href=\"#SCRUM\" class=\"headerlink\" title=\"SCRUM\"></a>SCRUM</h2><p>SCRUM - 争球</p>\n<ul>\n<li>3个角色:Product Owner(PO) 产品负责人;Scrum Master（SM），推动Scrum执行;Team 开发团队。</li>\n<li>3个工件：Product Backlog 产品TODOLIST，含优先级;Sprint Backlog 功能开发 TODO LIST；燃尽图；</li>\n<li>五个价值观：专注、勇气、公开、承诺、尊重。</li>\n</ul>\n<ul>\n<li><p><a href=\"https://blog.csdn.net/inny100_100/article/details/54633757\" target=\"_blank\" rel=\"noopener\">《敏捷项目管理流程-Scrum框架最全总结！》</a></p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/superkunkun/article/details/52951142\" target=\"_blank\" rel=\"noopener\">《敏捷其实很简单3—敏捷方法之scrum》</a></p>\n</li>\n</ul>\n<h2 id=\"敏捷开发\"><a href=\"#敏捷开发\" class=\"headerlink\" title=\"敏捷开发\"></a>敏捷开发</h2><p>TODO</p>\n<h2 id=\"极限编程（XP）\"><a href=\"#极限编程（XP）\" class=\"headerlink\" title=\"极限编程（XP）\"></a>极限编程（XP）</h2><p>XP - eXtreme Programming</p>\n<ul>\n<li><p><a href=\"http://www.woshipm.com/pmd/406917.html\" target=\"_blank\" rel=\"noopener\">《主流敏捷开发方法：极限编程XP》</a></p>\n<ul>\n<li>是一种指导开发人员的方法论。</li>\n<li><p>4大价值：</p>\n<ul>\n<li>沟通：鼓励口头沟通，提高效率。</li>\n<li>简单：够用就好。</li>\n<li>反馈：及时反馈、通知相关人。</li>\n<li>勇气：提倡拥抱变化，敢于重构。</li>\n</ul>\n</li>\n<li><p>5个原则：快速反馈、简单性假设、逐步修改、提倡更改（小步快跑）、优质工作（保证质量的前提下保证小步快跑）。</p>\n</li>\n<li>5个工作：阶段性冲刺；冲刺计划会议；每日站立会议；冲刺后review；回顾会议。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"结对编程\"><a href=\"#结对编程\" class=\"headerlink\" title=\"结对编程\"></a>结对编程</h2><p>边写码，边review。能够增强代码质量、减少bug。</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/%E7%BB%93%E5%AF%B9%E7%BC%96%E7%A8%8B\" target=\"_blank\" rel=\"noopener\">《结对编程》</a></li>\n</ul>\n<h2 id=\"PDCA-循环质量管理\"><a href=\"#PDCA-循环质量管理\" class=\"headerlink\" title=\"PDCA 循环质量管理\"></a>PDCA 循环质量管理</h2><p>P——PLAN 策划，D——DO 实施，C——CHECK 检查，A——ACT 改进</p>\n<ul>\n<li><a href=\"http://www.baike.com/wiki/PDCA\" target=\"_blank\" rel=\"noopener\">《PDCA》</a></li>\n</ul>\n<h2 id=\"FMEA管理模式\"><a href=\"#FMEA管理模式\" class=\"headerlink\" title=\"FMEA管理模式\"></a>FMEA管理模式</h2><p>TODO</p>\n<h1 id=\"通用业务术语\"><a href=\"#通用业务术语\" class=\"headerlink\" title=\"通用业务术语\"></a>通用业务术语</h1><p>TODO</p>\n<h1 id=\"技术趋势\"><a href=\"#技术趋势\" class=\"headerlink\" title=\"技术趋势\"></a>技术趋势</h1><p>TODO</p>\n<h1 id=\"政策、法规\"><a href=\"#政策、法规\" class=\"headerlink\" title=\"政策、法规\"></a>政策、法规</h1><p>TODO</p>\n<h2 id=\"法律\"><a href=\"#法律\" class=\"headerlink\" title=\"法律\"></a>法律</h2><h3 id=\"严格遵守刑法253法条\"><a href=\"#严格遵守刑法253法条\" class=\"headerlink\" title=\"严格遵守刑法253法条\"></a>严格遵守刑法253法条</h3><p>我国刑法第253条之一规定：</p>\n<blockquote>\n<ul>\n<li>国家机关或者金融、电信、交通、教育、医疗等单位的工作人员，违反国家规定，将本单位在履行职责或者提供服务过程中获得的公民个人信息，出售或者非法提供给他人，情节严重的，处3年以下有期徒刑或者拘役，并处或者单处罚金。</li>\n<li>窃取或者以其他方法非法获取上述信息，情节严重的，依照前款的规定处罚。 </li>\n<li>单位犯前两款罪的，对单位判处罚金，并对其直接负责的主管人员和其他直接责任人员，依照各该款的规定处罚。</li>\n</ul>\n</blockquote>\n<p>最高人民法院、最高人民检察院关于执行《中华人民共和国刑法》确定罪名的补充规定（四）规定：触犯刑法第253条之一第1款之规定，构成“出售、非法提供公民个人信息罪”；触犯刑法第253条之一第2款之规定，构成“非法获取公民个人信息罪”</p>\n<ul>\n<li><a href=\"https://baike.baidu.com/item/%E9%9D%9E%E6%B3%95%E8%8E%B7%E5%8F%96%E5%85%AC%E6%B0%91%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF%E7%BD%AA\" target=\"_blank\" rel=\"noopener\">《非法获取公民个人信息罪》</a></li>\n</ul>\n<h1 id=\"架构师素质\"><a href=\"#架构师素质\" class=\"headerlink\" title=\"架构师素质\"></a>架构师素质</h1><ul>\n<li><p><a href=\"http://hellojava.info/?p=430\" target=\"_blank\" rel=\"noopener\">《架构师画像》</a></p>\n<ul>\n<li>业务理解和抽象能力</li>\n<li>NB的代码能力</li>\n<li>全面：1. 在面对业务问题上，架构师脑海里是否会浮现出多种技术方案；2. 在做系统设计时是否考虑到了足够多的方方面面；3. 在做系统设计时是否考虑到了足够多的方方面面； </li>\n<li>全局：是否考虑到了对上下游的系统的影响。</li>\n<li>权衡：权衡投入产出比；优先级和节奏控制；</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/articles/architecture-optimization-and-design-the-architect-must-know\" target=\"_blank\" rel=\"noopener\">《关于架构优化和设计，架构师必须知道的事情》</a></p>\n<ul>\n<li>要去考虑的细节：模块化、轻耦合、无共享架构；减少各个组件之前的依赖、注意服务之间依赖所有造成的链式失败及影响等。</li>\n<li>基础设施、配置、测试、开发、运维综合考虑。</li>\n<li>考虑人、团队、和组织的影响。 </li>\n</ul>\n</li>\n<li><p><a href=\"https://www.zhihu.com/question/19841397\" target=\"_blank\" rel=\"noopener\">《如何才能真正的提高自己，成为一名出色的架构师？》</a> </p>\n</li>\n<li><p><a href=\"https://blog.csdn.net/sanbingyutuoniao123/article/details/54144129\" target=\"_blank\" rel=\"noopener\">《架构师的必备素质和成长途径》</a></p>\n<ul>\n<li>素质：业务理解、技术广度、技术深度、丰富经验、沟通能力、动手能力、美学素养。</li>\n<li>成长路径：2年积累知识、4年积累技能和组内影响力、7年积累部门内影响力、7年以上积累跨部门影响力。 </li>\n</ul>\n</li>\n<li><p><a href=\"http://blog.51cto.com/frankfan/1248401\" target=\"_blank\" rel=\"noopener\">《架构设计师—你在哪层楼？》</a></p>\n<ul>\n<li>第一层的架构师看到的只是产品本身</li>\n<li>第二层的架构师不仅看到自己的产品，还看到了整体的方案</li>\n<li>第三层的架构师看到的是商业价值 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"团队管理\"><a href=\"#团队管理\" class=\"headerlink\" title=\"团队管理\"></a>团队管理</h1><p>TODO</p>\n<h2 id=\"招聘\"><a href=\"#招聘\" class=\"headerlink\" title=\"招聘\"></a>招聘</h2><h1 id=\"资讯\"><a href=\"#资讯\" class=\"headerlink\" title=\"资讯\"></a>资讯</h1><h2 id=\"行业资讯\"><a href=\"#行业资讯\" class=\"headerlink\" title=\"行业资讯\"></a>行业资讯</h2><ul>\n<li><a href=\"http://36kr.com/\" target=\"_blank\" rel=\"noopener\">36kr</a></li>\n<li><a href=\"http://www.techweb.com.cn/\" target=\"_blank\" rel=\"noopener\">Techweb</a></li>\n</ul>\n<h2 id=\"公众号列表\"><a href=\"#公众号列表\" class=\"headerlink\" title=\"公众号列表\"></a>公众号列表</h2><p>TODO</p>\n<h2 id=\"博客\"><a href=\"#博客\" class=\"headerlink\" title=\"博客\"></a>博客</h2><h3 id=\"团队博客\"><a href=\"#团队博客\" class=\"headerlink\" title=\"团队博客\"></a>团队博客</h3><ul>\n<li><a href=\"http://jm.taobao.org/\" target=\"_blank\" rel=\"noopener\">阿里中间件博客</a></li>\n<li><a href=\"https://tech.meituan.com\" target=\"_blank\" rel=\"noopener\">美团点评技术团队博客</a></li>\n</ul>\n<h3 id=\"个人博客\"><a href=\"#个人博客\" class=\"headerlink\" title=\"个人博客\"></a>个人博客</h3><ul>\n<li><a href=\"http://www.ruanyifeng.com/\" target=\"_blank\" rel=\"noopener\">阮一峰的网络日志</a></li>\n<li><a href=\"https://coolshell.cn/\" target=\"_blank\" rel=\"noopener\">酷壳 - COOLSHELL-陈皓</a></li>\n<li><a href=\"http://hellojava.info/\" target=\"_blank\" rel=\"noopener\">hellojava-阿里毕玄</a></li>\n<li><a href=\"http://cmsblogs.com/\" target=\"_blank\" rel=\"noopener\">Cm’s Blog</a></li>\n<li><a href=\"http://blog.didispace.com/\" target=\"_blank\" rel=\"noopener\">程序猿DD-翟永超-《Spring Cloud微服务实战》作者</a></li>\n</ul>\n<h2 id=\"综合门户、社区\"><a href=\"#综合门户、社区\" class=\"headerlink\" title=\"综合门户、社区\"></a>综合门户、社区</h2><p><strong>国内：</strong></p>\n<ul>\n<li><a href=\"http://csdn.net\" target=\"_blank\" rel=\"noopener\">CSDN</a><br>   老牌技术社区、不必解释。</li>\n<li><a href=\"http://www.51cto.com/\" target=\"_blank\" rel=\"noopener\">51cto.com</a></li>\n<li><a href=\"http://www.iteye.com/\" target=\"_blank\" rel=\"noopener\">ITeye</a><ul>\n<li>偏 Java 方向 </li>\n</ul>\n</li>\n<li><a href=\"https://www.cnblogs.com\" target=\"_blank\" rel=\"noopener\">博客园</a></li>\n<li><a href=\"http://www.tom.net/\" target=\"_blank\" rel=\"noopener\">ChinaUnix</a><ul>\n<li>偏 Linux 方向 </li>\n</ul>\n</li>\n<li><a href=\"https://www.oschina.net/\" target=\"_blank\" rel=\"noopener\">开源中国社区</a></li>\n<li><a href=\"http://www.open-open.com/\" target=\"_blank\" rel=\"noopener\">深度开源</a></li>\n<li><p><a href=\"http://www.jobbole.com/\" target=\"_blank\" rel=\"noopener\">伯乐在线</a></p>\n<ul>\n<li>涵盖 IT职场、Web前端、后端、移动端、数据库等方面内容，偏技术端。</li>\n</ul>\n</li>\n<li><p><a href=\"http://www.itpub.net/\" target=\"_blank\" rel=\"noopener\">ITPUB</a></p>\n</li>\n<li><a href=\"https://cloud.tencent.com/developer/column\" target=\"_blank\" rel=\"noopener\">腾讯云— 云+社区</a></li>\n<li><a href=\"https://yq.aliyun.com/\" target=\"_blank\" rel=\"noopener\">阿里云— 云栖社区</a></li>\n<li><a href=\"https://www.ibm.com/developerworks/cn/\" target=\"_blank\" rel=\"noopener\">IBM DeveloperWorks</a></li>\n<li><a href=\"https://toutiao.io/\" target=\"_blank\" rel=\"noopener\">开发者头条</a></li>\n<li><a href=\"http://www.linkedkeeper.com\" target=\"_blank\" rel=\"noopener\">LinkedKeeper</a></li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"https://dzone.com\" target=\"_blank\" rel=\"noopener\">DZone</a></li>\n<li><a href=\"https://www.reddit.com\" target=\"_blank\" rel=\"noopener\">Reddit</a></li>\n</ul>\n<h2 id=\"问答、讨论类社区\"><a href=\"#问答、讨论类社区\" class=\"headerlink\" title=\"问答、讨论类社区\"></a>问答、讨论类社区</h2><ul>\n<li><a href=\"https://segmentfault.com\" target=\"_blank\" rel=\"noopener\">segmentfault</a><ul>\n<li>问答+专栏 </li>\n</ul>\n</li>\n<li><a href=\"https://www.zhihu.com/\" target=\"_blank\" rel=\"noopener\">知乎</a></li>\n<li><a href=\"https://stackoverflow.com/\" target=\"_blank\" rel=\"noopener\">stackoverflow</a></li>\n</ul>\n<h2 id=\"行业数据分析\"><a href=\"#行业数据分析\" class=\"headerlink\" title=\"行业数据分析\"></a>行业数据分析</h2><ul>\n<li><a href=\"http://report.iresearch.cn/\" target=\"_blank\" rel=\"noopener\">艾瑞网</a></li>\n<li><p><a href=\"https://www.questmobile.com.cn\" target=\"_blank\" rel=\"noopener\">QUEST MOBILE</a></p>\n</li>\n<li><p><a href=\"http://data.stats.gov.cn/\" target=\"_blank\" rel=\"noopener\">国家数据</a></p>\n</li>\n<li><p><a href=\"http://www.talkingdata.com/\" target=\"_blank\" rel=\"noopener\">TalkingData</a></p>\n</li>\n</ul>\n<h2 id=\"专项网站\"><a href=\"#专项网站\" class=\"headerlink\" title=\"专项网站\"></a>专项网站</h2><ul>\n<li><p>测试:</p>\n<ul>\n<li><a href=\"http://www.ltesting.net/\" target=\"_blank\" rel=\"noopener\">领测国际</a> </li>\n<li><a href=\"https://www.testwo.com/\" target=\"_blank\" rel=\"noopener\">测试窝</a></li>\n<li><a href=\"https://testerhome.com\" target=\"_blank\" rel=\"noopener\">TesterHome</a></li>\n</ul>\n</li>\n<li><p>运维:</p>\n<pre><code>* [运维派](http://www.yunweipai.com/) \n* [Abcdocker](https://www.abcdocker.com/)\n</code></pre></li>\n<li><p>Java:</p>\n<ul>\n<li><a href=\"http://www.importnew.com/\" target=\"_blank\" rel=\"noopener\">ImportNew</a><ul>\n<li>专注于 Java 技术分享</li>\n</ul>\n</li>\n<li><a href=\"https://howtodoinjava.com/\" target=\"_blank\" rel=\"noopener\">HowToDoInJava</a><ul>\n<li>英文博客</li>\n</ul>\n</li>\n</ul>\n</li>\n<li><p>安全</p>\n<ul>\n<li><a href=\"https://www.2cto.com/\" target=\"_blank\" rel=\"noopener\">红黑联盟</a> </li>\n<li><a href=\"http://www.freebuf.com/\" target=\"_blank\" rel=\"noopener\">FreeBuf</a></li>\n</ul>\n</li>\n<li><p>大数据</p>\n<ul>\n<li><a href=\"http://www.thebigdata.cn/\" target=\"_blank\" rel=\"noopener\">中国大数据</a> </li>\n</ul>\n</li>\n<li><p>其他专题网站：</p>\n<ul>\n<li><a href=\"http://www.dockerinfo.net/\" target=\"_blank\" rel=\"noopener\">DockerInfo</a><ul>\n<li>专注于 Docker 应用及咨询、教程的网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.linuxidc.com/\" target=\"_blank\" rel=\"noopener\">Linux公社</a><ul>\n<li>Linux 主题社区</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"其他类\"><a href=\"#其他类\" class=\"headerlink\" title=\"其他类\"></a>其他类</h2><ul>\n<li><a href=\"https://github.com/TeamStuQ/skill-map\" target=\"_blank\" rel=\"noopener\">程序员技能图谱</a></li>\n</ul>\n<h2 id=\"推荐参考书\"><a href=\"#推荐参考书\" class=\"headerlink\" title=\"推荐参考书\"></a>推荐参考书</h2><h3 id=\"在线电子书\"><a href=\"#在线电子书\" class=\"headerlink\" title=\"在线电子书\"></a>在线电子书</h3><ul>\n<li><a href=\"https://github.com/forezp/SpringCloudLearning\" target=\"_blank\" rel=\"noopener\">《深入理解Spring Cloud与微服务构建》</a></li>\n</ul>\n<ul>\n<li><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523849261680/AliTech101_RD.pdf\" target=\"_blank\" rel=\"noopener\">《阿里技术参考图册-研发篇》</a></li>\n<li><p><a href=\"http://techforum-img.cn-hangzhou.oss-pub.aliyun-inc.com/1523848064814/AliTech101_Algorithms.pdf\" target=\"_blank\" rel=\"noopener\">《阿里技术参考图册-算法篇》</a></p>\n</li>\n<li><p><a href=\"http://dpurl.cn/n/1lqcX\" target=\"_blank\" rel=\"noopener\">《2018美团点评技术年货（合辑）》70M</a></p>\n</li>\n<li><p><a href=\"http://www.infoq.com/cn/architect/\" target=\"_blank\" rel=\"noopener\">InfoQ《架构师》月刊</a></p>\n</li>\n<li><p><a href=\"https://www.w3cschool.cn/architectroad/\" target=\"_blank\" rel=\"noopener\">《架构师之路》</a></p>\n</li>\n</ul>\n<h3 id=\"纸质书\"><a href=\"#纸质书\" class=\"headerlink\" title=\"纸质书\"></a>纸质书</h3><h4 id=\"开发方面\"><a href=\"#开发方面\" class=\"headerlink\" title=\"开发方面\"></a>开发方面</h4><ul>\n<li>《阿里巴巴Java开发手册》<a href=\"https://union-click.jd.com/jdc?d=bVKwZQ\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=阿里巴巴Java开发手册\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"架构方面\"><a href=\"#架构方面\" class=\"headerlink\" title=\"架构方面\"></a>架构方面</h4><ul>\n<li>《软件架构师的12项修炼：技术技能篇》<a href=\"https://union-click.jd.com/jdc?d=gXvRd8\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=软件架构师的12项修炼：技术技能篇\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《架构之美》<a href=\"https://union-click.jd.com/jdc?d=xJit5I\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=架构之美\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《分布式服务架构》<a href=\"https://union-click.jd.com/jdc?d=JS5Od9\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=分布式服务架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《聊聊架构》 <a href=\"https://union-click.jd.com/jdc?d=FHooH4\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=聊聊架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《云原生应用架构实践》<a href=\"https://union-click.jd.com/jdc?d=orkJSj\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=云原生应用架构实践\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《亿级流量网站架构核心技术》<a href=\"https://union-click.jd.com/jdc?d=RnOSP5\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=亿级流量网站架构核心技术\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《淘宝技术这十年》<a href=\"https://union-click.jd.com/jdc?d=LwrDfD\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=淘宝技术这十年\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li><p>《企业IT架构转型之道-中台战略思想与架构实战》 <a href=\"https://union-click.jd.com/jdc?d=89pAEm\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=企业IT架构转型之道\" target=\"_blank\" rel=\"noopener\">淘宝</a></p>\n</li>\n<li><p>《高可用架构（第1卷）》<a href=\"https://item.jd.com/12195481.html\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=高可用架构\" target=\"_blank\" rel=\"noopener\">淘宝</a></p>\n</li>\n</ul>\n<h4 id=\"技术管理方面\"><a href=\"#技术管理方面\" class=\"headerlink\" title=\"技术管理方面\"></a>技术管理方面</h4><ul>\n<li>《CTO说》<a href=\"https://union-click.jd.com/jdc?d=zhTZyr\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=CTO说\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《技术管理之巅》<a href=\"https://union-click.jd.com/jdc?d=LgRBUW\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=技术管理之巅\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《网易一千零一夜：互联网产品项目管理实战》<a href=\"https://union-click.jd.com/jdc?d=jcRz2r\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=网易一千零一夜：互联网产品项目管理实战\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"基础理论-1\"><a href=\"#基础理论-1\" class=\"headerlink\" title=\"基础理论\"></a>基础理论</h4><ul>\n<li>《数学之美》<a href=\"https://union-click.jd.com/jdc?d=ghIES2\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=数学之美\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n<li>《编程珠玑》<a href=\"https://union-click.jd.com/jdc?d=YmhdEu\" target=\"_blank\" rel=\"noopener\">京东</a> <a href=\"https://s.taobao.com/search?q=编程珠玑\" target=\"_blank\" rel=\"noopener\">淘宝</a></li>\n</ul>\n<h4 id=\"工具方面\"><a href=\"#工具方面\" class=\"headerlink\" title=\"工具方面\"></a>工具方面</h4><p>TODO</p>\n<h4 id=\"大数据方面\"><a href=\"#大数据方面\" class=\"headerlink\" title=\"大数据方面\"></a>大数据方面</h4><h1 id=\"技术资源\"><a href=\"#技术资源\" class=\"headerlink\" title=\"技术资源\"></a>技术资源</h1><h2 id=\"开源资源\"><a href=\"#开源资源\" class=\"headerlink\" title=\"开源资源\"></a>开源资源</h2><ul>\n<li><p><a href=\"https://github.com\" target=\"_blank\" rel=\"noopener\">github</a></p>\n</li>\n<li><p><a href=\"https://www.apache.org/index.html\" target=\"_blank\" rel=\"noopener\">Apache 软件基金会</a></p>\n</li>\n</ul>\n<h2 id=\"手册、文档、教程\"><a href=\"#手册、文档、教程\" class=\"headerlink\" title=\"手册、文档、教程\"></a>手册、文档、教程</h2><p><strong>国内：</strong></p>\n<ul>\n<li><a href=\"http://w3cschool.cn\" target=\"_blank\" rel=\"noopener\">W3Cschool</a> </li>\n<li><p><a href=\"http://www.runoob.com/\" target=\"_blank\" rel=\"noopener\">Runoob.com</a></p>\n<ul>\n<li>HTML 、 CSS、XML、Java、Python、PHP、设计模式等入门手册。</li>\n</ul>\n</li>\n<li><p><a href=\"https://love2.io/\" target=\"_blank\" rel=\"noopener\">Love2.io</a></p>\n<ul>\n<li>很多很多中文在线电子书，是一个全新的开源技术文档分享平台。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.cn/\" target=\"_blank\" rel=\"noopener\">gitbook.cn</a><ul>\n<li>付费电子书。 </li>\n</ul>\n</li>\n<li><a href=\"http://www.apachecn.org/\" target=\"_blank\" rel=\"noopener\">ApacheCN</a><ul>\n<li>AI、大数据方面系列中文文档。</li>\n</ul>\n</li>\n</ul>\n<p><strong>国外：</strong></p>\n<ul>\n<li><a href=\"http://www.quickcode.co/\" target=\"_blank\" rel=\"noopener\">Quick Code</a><ul>\n<li>免费在线技术教程。</li>\n</ul>\n</li>\n<li><a href=\"http://gitbook.com\" target=\"_blank\" rel=\"noopener\">gitbook.com</a><ul>\n<li>有部分中文电子书。</li>\n</ul>\n</li>\n<li><a href=\"https://www.cheatography.com/\" target=\"_blank\" rel=\"noopener\">Cheatography</a><ul>\n<li>Cheat Sheets 大全，单页文档网站。</li>\n</ul>\n</li>\n<li><a href=\"https://www.tutorialspoint.com/index.htm\" target=\"_blank\" rel=\"noopener\">Tutorialspoint</a><ul>\n<li>知名教程网站，提供Java、Python、JS、SQL、大数据等高质量入门教程。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"在线课堂\"><a href=\"#在线课堂\" class=\"headerlink\" title=\"在线课堂\"></a>在线课堂</h2><ul>\n<li><a href=\"http://www.xuetuwuyou.com/\" target=\"_blank\" rel=\"noopener\">学徒无忧</a></li>\n<li><a href=\"https://time.geekbang.org/\" target=\"_blank\" rel=\"noopener\">极客时间</a></li>\n<li><a href=\"https://segmentfault.com/lives\" target=\"_blank\" rel=\"noopener\">segmentfault</a></li>\n<li><a href=\"https://new.stuq.org/course/explore\" target=\"_blank\" rel=\"noopener\">斯达克学院</a></li>\n<li><a href=\"http://nowcoder.com\" target=\"_blank\" rel=\"noopener\">牛客网</a></li>\n<li><a href=\"https://www.jikexueyuan.com/\" target=\"_blank\" rel=\"noopener\">极客学院</a></li>\n<li><a href=\"http://edu.51cto.com/\" target=\"_blank\" rel=\"noopener\">51CTO学院</a></li>\n</ul>\n<h2 id=\"会议、活动\"><a href=\"#会议、活动\" class=\"headerlink\" title=\"会议、活动\"></a>会议、活动</h2><ul>\n<li><a href=\"http://www.infoq.com/cn/qcon/\" target=\"_blank\" rel=\"noopener\">QCon</a></li>\n<li><a href=\"https://archsummit.com\" target=\"_blank\" rel=\"noopener\">ArchSummit</a></li>\n<li><a href=\"http://www.thegitc.com/\" target=\"_blank\" rel=\"noopener\">GITC全球互联网技术大会</a></li>\n</ul>\n<p><strong>活动发布平台:</strong> </p>\n<ul>\n<li><a href=\"http://www.huodongxing.com/\" target=\"_blank\" rel=\"noopener\">活动行</a></li>\n</ul>\n<h2 id=\"常用APP\"><a href=\"#常用APP\" class=\"headerlink\" title=\"常用APP\"></a>常用APP</h2><ul>\n<li><a href=\"https://time.geekbang.org\" target=\"_blank\" rel=\"noopener\">极客时间</a></li>\n<li><a href=\"https://www.igetget.com\" target=\"_blank\" rel=\"noopener\">得到</a></li>\n</ul>\n<h2 id=\"找工作\"><a href=\"#找工作\" class=\"headerlink\" title=\"找工作\"></a>找工作</h2><ul>\n<li><a href=\"https://www.zhipin.com\" target=\"_blank\" rel=\"noopener\">Boss直聘</a></li>\n<li><a href=\"https://www.lagou.com\" target=\"_blank\" rel=\"noopener\">拉勾网</a></li>\n<li><a href=\"https://www.liepin.com\" target=\"_blank\" rel=\"noopener\">猎聘</a></li>\n<li><a href=\"https://cn.100offer.com/\" target=\"_blank\" rel=\"noopener\">100Offer</a></li>\n</ul>\n<h2 id=\"工具\"><a href=\"#工具\" class=\"headerlink\" title=\"工具\"></a>工具</h2><ul>\n<li><a href=\"https://s.geekbang.org/\" target=\"_blank\" rel=\"noopener\">极客搜索</a><ul>\n<li>技术文章搜索引擎。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"代码托管\"><a href=\"#代码托管\" class=\"headerlink\" title=\"代码托管\"></a>代码托管</h2><ul>\n<li><a href=\"https://coding.net\" target=\"_blank\" rel=\"noopener\">Coding</a></li>\n<li><a href=\"https://gitee.com/\" target=\"_blank\" rel=\"noopener\">码云</a></li>\n</ul>\n<h2 id=\"文件服务\"><a href=\"#文件服务\" class=\"headerlink\" title=\"文件服务\"></a>文件服务</h2><ul>\n<li>七牛</li>\n<li>又拍云</li>\n</ul>\n<h2 id=\"综合云服务商\"><a href=\"#综合云服务商\" class=\"headerlink\" title=\"综合云服务商\"></a>综合云服务商</h2><ul>\n<li>阿里云</li>\n<li><a href=\"https://cloud.tencent.com/redirect.php?redirect=1012&amp;cps_key=c2665015d90871c0cb20fef91b7afc3c\" target=\"_blank\" rel=\"noopener\">腾讯云</a></li>\n<li>百度云</li>\n<li>新浪云</li>\n<li>金山云</li>\n<li><a href=\"https://amazonaws-china.com/cn/\" target=\"_blank\" rel=\"noopener\">亚马逊云(AWS)</a></li>\n<li><a href=\"https://cloud.google.com/?hl=zh-cn\" target=\"_blank\" rel=\"noopener\">谷歌云</a></li>\n<li><a href=\"https://azure.microsoft.com/zh-cn/\" target=\"_blank\" rel=\"noopener\">微软云</a></li>\n</ul>\n<h3 id=\"VPS\"><a href=\"#VPS\" class=\"headerlink\" title=\"VPS\"></a>VPS</h3><ul>\n<li><a href=\"http://linode.com\" target=\"_blank\" rel=\"noopener\">Linode</a></li>\n</ul>\n"}],"PostAsset":[{"_id":"source/_posts/idea-file-template/g.png","slug":"g.png","post":"cjp0m382j0026qcrgh0hgrdd6","modified":0,"renderable":0},{"_id":"source/_posts/apidoc-java/a.png","slug":"a.png","post":"cjp0m381c0006qcrgznqfv2u5","modified":0,"renderable":0},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","slug":"a.png","post":"cjp0m38120001qcrgbpimpoyi","modified":0,"renderable":0},{"_id":"source/_posts/docker-install-centos7/a.png","slug":"a.png","post":"cjp0m381s000uqcrg3zk9i3qh","modified":0,"renderable":0},{"_id":"source/_posts/docker-install-ubuntu16/a.png","slug":"a.png","post":"cjp0m381t000wqcrgds50tbhd","modified":0,"renderable":0},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","slug":"favicon.ico","post":"cjp0m382d001uqcrgxftrihof","modified":0,"renderable":0},{"_id":"source/_posts/hashicorp-vault/a.png","slug":"a.png","post":"cjp0m382e001xqcrg0vtnsryo","modified":0,"renderable":0},{"_id":"source/_posts/http-protocol-overview/a.png","slug":"a.png","post":"cjp0m382f0020qcrgscqxu8lw","modified":0,"renderable":0},{"_id":"source/_posts/http-protocol-overview/b.png","slug":"b.png","post":"cjp0m382f0020qcrgscqxu8lw","modified":0,"renderable":0},{"_id":"source/_posts/idea-file-template/a.png","slug":"a.png","post":"cjp0m382j0026qcrgh0hgrdd6","modified":0,"renderable":0},{"_id":"source/_posts/idea-file-template/b.png","slug":"b.png","post":"cjp0m382j0026qcrgh0hgrdd6","modified":0,"renderable":0},{"_id":"source/_posts/idea-file-template/c.png","slug":"c.png","post":"cjp0m382j0026qcrgh0hgrdd6","modified":0,"renderable":0},{"_id":"source/_posts/idea-file-template/d.png","slug":"d.png","post":"cjp0m382j0026qcrgh0hgrdd6","modified":0,"renderable":0},{"_id":"source/_posts/idea-file-template/e.png","slug":"e.png","post":"cjp0m382j0026qcrgh0hgrdd6","modified":0,"renderable":0},{"_id":"source/_posts/idea-file-template/f.png","slug":"f.png","post":"cjp0m382j0026qcrgh0hgrdd6","modified":0,"renderable":0},{"_id":"source/_posts/idea-file-template/j.png","slug":"j.png","post":"cjp0m382j0026qcrgh0hgrdd6","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/a.png","slug":"a.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/b.png","slug":"b.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/c.png","slug":"c.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/d.png","slug":"d.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/e.png","slug":"e.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/f.png","slug":"f.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/g.png","slug":"g.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/h.png","slug":"h.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/i.png","slug":"i.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/j.png","slug":"j.png","post":"cjp0m381m000gqcrge29afuy4","modified":0,"renderable":0},{"_id":"source/_posts/distributed-id-snowflake/a.png","slug":"a.png","post":"cjp0m38kr004vqcrgq7vgmmdt","modified":0,"renderable":0},{"_id":"source/_posts/microservice-think/a.png","slug":"a.png","post":"cjp0m38m3005qqcrgj8n2yu7t","modified":0,"renderable":0},{"_id":"source/_posts/redis-cluster-centos/a.png","slug":"a.png","post":"cjp0m38mf006kqcrgq1zqbv40","modified":0,"renderable":0},{"_id":"source/_posts/redmine-plugins/a.png","slug":"a.png","post":"cjp0m38mn0071qcrg7dxwz5wv","modified":0,"renderable":0},{"_id":"source/_posts/restful-api-dev/a.png","slug":"a.png","post":"cjp0m38mr0079qcrgpasphrab","modified":0,"renderable":0},{"_id":"source/_posts/sboot-change-contextpath/a.png","slug":"a.png","post":"cjp0m38mt007eqcrgalr5s2an","modified":0,"renderable":0},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","slug":"a.png","post":"cjp0m38mu007hqcrgfozkgje0","modified":0,"renderable":0},{"_id":"source/_posts/scloud-zuul-exception/a.png","slug":"a.png","post":"cjp0m38n1007wqcrgzpgb7xzd","modified":0,"renderable":0},{"_id":"source/_posts/scloud-zuul-filters/a.png","slug":"a.png","post":"cjp0m38n2007zqcrgycz5goml","modified":0,"renderable":0},{"_id":"source/_posts/scloud-zuul-start/a.png","slug":"a.png","post":"cjp0m38n30082qcrgpaaq6si0","modified":0,"renderable":0},{"_id":"source/_posts/spring-boot-dev-error-show/a.png","slug":"a.png","post":"cjp0m38nb008jqcrgvaset9cy","modified":0,"renderable":0},{"_id":"source/_posts/website-high-performance/favicon.ico","slug":"favicon.ico","post":"cjp0m38ns0096qcrgoniwylgc","modified":0,"renderable":0},{"_id":"source/_posts/javapoet-apt-annotation/a.png","slug":"a.png","post":"cjp0m38l3004yqcrgcacmokpl","modified":0,"renderable":0},{"_id":"source/_posts/javapoet-apt-annotation/b.png","slug":"b.png","post":"cjp0m38l3004yqcrgcacmokpl","modified":0,"renderable":0},{"_id":"source/_posts/linux-command-use/a.png","slug":"a.png","post":"cjp0m38lx005fqcrg08rwslp6","modified":0,"renderable":0},{"_id":"source/_posts/linux-command-use/b.png","slug":"b.png","post":"cjp0m38lx005fqcrg08rwslp6","modified":0,"renderable":0},{"_id":"source/_posts/maven-ofen/a.jpg","slug":"a.jpg","post":"cjp0m38m2005pqcrgrhizk6dn","modified":0,"renderable":0},{"_id":"source/_posts/maven-ofen/b.jpg","slug":"b.jpg","post":"cjp0m38m2005pqcrgrhizk6dn","modified":0,"renderable":0},{"_id":"source/_posts/wkhtmltopdf/Arial.zip","slug":"Arial.zip","post":"cjp0m38ny009hqcrgsnl5yzsk","modified":0,"renderable":0},{"_id":"source/_posts/wkhtmltopdf/simsun.ttc","slug":"simsun.ttc","post":"cjp0m38ny009hqcrgsnl5yzsk","modified":0,"renderable":0},{"_id":"source/_posts/pivotal-web-service-start/a.png","slug":"a.png","post":"cjp0m38mb006aqcrglmj4pijl","modified":0,"renderable":0},{"_id":"source/_posts/pivotal-web-service-start/b.png","slug":"b.png","post":"cjp0m38mb006aqcrglmj4pijl","modified":0,"renderable":0},{"_id":"source/_posts/pivotal-web-service-start/c.png","slug":"c.png","post":"cjp0m38mb006aqcrglmj4pijl","modified":0,"renderable":0},{"_id":"source/_posts/pivotal-web-service-start/d.png","slug":"d.png","post":"cjp0m38mb006aqcrglmj4pijl","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-Xshell/a-1.png","slug":"a-1.png","post":"cjp0m38no008yqcrgiqvh5vjg","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-Xshell/a-2.png","slug":"a-2.png","post":"cjp0m38no008yqcrgiqvh5vjg","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-Xshell/a-3.png","slug":"a-3.png","post":"cjp0m38no008yqcrgiqvh5vjg","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-Xshell/b-1.png","slug":"b-1.png","post":"cjp0m38no008yqcrgiqvh5vjg","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-Xshell/b-2.png","slug":"b-2.png","post":"cjp0m38no008yqcrgiqvh5vjg","modified":0,"renderable":0},{"_id":"source/_posts/shadowsocks-go/Shadowsocks-4.0.6.zip","slug":"Shadowsocks-4.0.6.zip","post":"cjp0m38n40084qcrgg8j0l8qt","modified":0,"renderable":0},{"_id":"source/_posts/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk","slug":"Shadowsocks_v4.2.5_apkpure.com.apk","post":"cjp0m38n40084qcrgg8j0l8qt","modified":0,"renderable":0},{"_id":"source/_posts/shadowsocks-go/a.png","slug":"a.png","post":"cjp0m38n40084qcrgg8j0l8qt","modified":0,"renderable":0},{"_id":"source/_posts/shadowsocks-go/b.png","slug":"b.png","post":"cjp0m38n40084qcrgg8j0l8qt","modified":0,"renderable":0},{"_id":"source/_posts/shadowsocks-go/client.tar.gz","slug":"client.tar.gz","post":"cjp0m38n40084qcrgg8j0l8qt","modified":0,"renderable":0},{"_id":"source/_posts/shadowsocks-go/go1.9.2.linux-amd64.tar.gz","slug":"go1.9.2.linux-amd64.tar.gz","post":"cjp0m38n40084qcrgg8j0l8qt","modified":0,"renderable":0},{"_id":"source/_posts/shadowsocks-go/server.tar.gz","slug":"server.tar.gz","post":"cjp0m38n40084qcrgg8j0l8qt","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/1.png","slug":"1.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/10.png","slug":"10.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/11.png","slug":"11.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/12.png","slug":"12.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/13.png","slug":"13.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/14.png","slug":"14.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/15.png","slug":"15.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/2.png","slug":"2.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/3.png","slug":"3.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/4.png","slug":"4.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/5.png","slug":"5.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/6.png","slug":"6.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/7.png","slug":"7.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/8.png","slug":"8.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/8_1.png","slug":"8_1.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/9.png","slug":"9.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/a.png","slug":"a.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/b.png","slug":"b.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/c.png","slug":"c.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/e.png","slug":"e.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/f.png","slug":"f.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/g.png","slug":"g.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/h.png","slug":"h.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/jenkins-java-maven/i.png","slug":"i.png","post":"cjp0m38lc0050qcrgflokitr0","modified":0,"renderable":0},{"_id":"source/_posts/spring-boot-filter/a.png","slug":"a.png","post":"cjp0m38p400csqcrguerazsp7","modified":0,"renderable":0},{"_id":"source/_posts/spring-boot-filter/b.png","slug":"b.png","post":"cjp0m38p400csqcrguerazsp7","modified":0,"renderable":0},{"_id":"source/_posts/redmine-start/a.png","slug":"a.png","post":"cjp0m38p300cqqcrg99n0g8g2","modified":0,"renderable":0},{"_id":"source/_posts/redmine-start/b.png","slug":"b.png","post":"cjp0m38p300cqqcrg99n0g8g2","modified":0,"renderable":0},{"_id":"source/_posts/redmine-start/c.png","slug":"c.png","post":"cjp0m38p300cqqcrg99n0g8g2","modified":0,"renderable":0},{"_id":"source/_posts/redmine-start/d.png","slug":"d.png","post":"cjp0m38p300cqqcrg99n0g8g2","modified":0,"renderable":0},{"_id":"source/_posts/api-version/a.png","slug":"a.png","post":"cjp0m38oz00cmqcrgnoqbte76","modified":0,"renderable":0},{"_id":"source/_posts/api-version/b.png","slug":"b.png","post":"cjp0m38oz00cmqcrgnoqbte76","modified":0,"renderable":0},{"_id":"source/_posts/api-version/c.png","slug":"c.png","post":"cjp0m38oz00cmqcrgnoqbte76","modified":0,"renderable":0},{"_id":"source/_posts/api-version/d.png","slug":"d.png","post":"cjp0m38oz00cmqcrgnoqbte76","modified":0,"renderable":0},{"_id":"source/_posts/api-version/e.png","slug":"e.png","post":"cjp0m38oz00cmqcrgnoqbte76","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-start/a.png","slug":"a.png","post":"cjp0m38p600cwqcrge3hsnka7","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-start/b.png","slug":"b.png","post":"cjp0m38p600cwqcrge3hsnka7","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-start/c.png","slug":"c.png","post":"cjp0m38p600cwqcrge3hsnka7","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-start/d.png","slug":"d.png","post":"cjp0m38p600cwqcrge3hsnka7","modified":0,"renderable":0},{"_id":"source/_posts/vagrant-start/e.png","slug":"e.png","post":"cjp0m38p600cwqcrge3hsnka7","modified":0,"renderable":0},{"_id":"source/_posts/docker-lesson3-images/a.png","slug":"a.png","post":"cjp0m38rx00deqcrgrcrtgt55","modified":0,"renderable":0},{"_id":"source/_posts/docker-lesson3-images/b.png","slug":"b.png","post":"cjp0m38rx00deqcrgrcrtgt55","modified":0,"renderable":0},{"_id":"source/_posts/docker-lesson3-images/c.png","slug":"c.png","post":"cjp0m38rx00deqcrgrcrtgt55","modified":0,"renderable":0},{"_id":"source/_posts/docker-lesson3-images/yy.png","slug":"yy.png","post":"cjp0m38rx00deqcrgrcrtgt55","modified":0,"renderable":0},{"_id":"source/_posts/shiro-start/shiro-01.png","slug":"shiro-01.png","post":"cjp0m38sw00duqcrgfi0lwzps","modified":0,"renderable":0},{"_id":"source/_posts/shiro-start/shiro-02.png","slug":"shiro-02.png","post":"cjp0m38sw00duqcrgfi0lwzps","modified":0,"renderable":0},{"_id":"source/_posts/shiro-start/shiro-03.png","slug":"shiro-03.png","post":"cjp0m38sw00duqcrgfi0lwzps","modified":0,"renderable":0},{"_id":"source/_posts/shiro-start/shiro-04.png","slug":"shiro-04.png","post":"cjp0m38sw00duqcrgfi0lwzps","modified":0,"renderable":0},{"_id":"source/_posts/shiro-start/shiro-05.png","slug":"shiro-05.png","post":"cjp0m38sw00duqcrgfi0lwzps","modified":0,"renderable":0},{"_id":"source/_posts/redmine-plugins/a-1.png","slug":"a-1.png","post":"cjp0m38mn0071qcrg7dxwz5wv","modified":0,"renderable":0}],"PostCategory":[{"post_id":"cjp0m38120001qcrgbpimpoyi","category_id":"cjp0m38180003qcrg07yh8vk2","_id":"cjp0m381l000dqcrgucfaf3bh"},{"post_id":"cjp0m38160002qcrg95r5ftw7","category_id":"cjp0m381g0008qcrgdckwjjwn","_id":"cjp0m381n000jqcrgyayw6ozs"},{"post_id":"cjp0m381a0005qcrgj9xnrg3o","category_id":"cjp0m381l000eqcrghikgomvz","_id":"cjp0m381r000pqcrgkul28m54"},{"post_id":"cjp0m381c0006qcrgznqfv2u5","category_id":"cjp0m381n000kqcrgzer04ef4","_id":"cjp0m381t000vqcrgvtua4t6f"},{"post_id":"cjp0m381f0007qcrgeqqww669","category_id":"cjp0m381r000qqcrgt50lerdr","_id":"cjp0m381z0012qcrgdmc2s010"},{"post_id":"cjp0m381i000bqcrgmhc5z0md","category_id":"cjp0m381u000xqcrgscowws48","_id":"cjp0m38240019qcrgfgup4xxb"},{"post_id":"cjp0m381k000cqcrgudhnuu3u","category_id":"cjp0m381u000xqcrgscowws48","_id":"cjp0m3826001fqcrggzsf69ek"},{"post_id":"cjp0m381m000gqcrge29afuy4","category_id":"cjp0m381u000xqcrgscowws48","_id":"cjp0m3829001kqcrg6t5r5ouw"},{"post_id":"cjp0m381n000iqcrgzxuhvdu4","category_id":"cjp0m3826001eqcrgulh66g2g","_id":"cjp0m382b001qqcrgpsq313mm"},{"post_id":"cjp0m381o000mqcrg6opu8k5i","category_id":"cjp0m3829001lqcrg24eac8ma","_id":"cjp0m382e001wqcrglg41al5u"},{"post_id":"cjp0m381p000oqcrgp3vnrfay","category_id":"cjp0m382c001rqcrgrmfm6c7n","_id":"cjp0m382h0023qcrgtytewfpn"},{"post_id":"cjp0m381r000sqcrg79qrb7ot","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m382l002aqcrg5lvactno"},{"post_id":"cjp0m381s000uqcrg3zk9i3qh","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m382n002gqcrgk6u4qgx0"},{"post_id":"cjp0m381t000wqcrgds50tbhd","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m382q002mqcrgo15vdtk5"},{"post_id":"cjp0m382o002hqcrgr4mifs4k","category_id":"cjp0m3829001lqcrg24eac8ma","_id":"cjp0m382r002oqcrgqrf66ajg"},{"post_id":"cjp0m381v0010qcrgep9e7wfd","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m382s002rqcrgphick8rl"},{"post_id":"cjp0m382p002jqcrg9z7g8jkk","category_id":"cjp0m3829001lqcrg24eac8ma","_id":"cjp0m382s002tqcrgc4svdhop"},{"post_id":"cjp0m381z0011qcrgo1hcjmqf","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m382t002wqcrgbi2ukpml"},{"post_id":"cjp0m38210015qcrgnibsvhv6","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m382u002zqcrg50i2zlf6"},{"post_id":"cjp0m38220017qcrglxzgtp4d","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m382v0032qcrg4s91rz8r"},{"post_id":"cjp0m3824001bqcrg6456hvgm","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m382v0035qcrgb66ksmm1"},{"post_id":"cjp0m3825001dqcrgsdir0jko","category_id":"cjp0m382u0031qcrgw1di0p63","_id":"cjp0m382w0039qcrgcu04o1kr"},{"post_id":"cjp0m3827001hqcrg2qcy4n0u","category_id":"cjp0m382v0036qcrgdw88dvqr","_id":"cjp0m382y003eqcrg7s1b25ib"},{"post_id":"cjp0m3828001jqcrg2vtctbbb","category_id":"cjp0m382u0031qcrgw1di0p63","_id":"cjp0m382z003iqcrg4mdcvct0"},{"post_id":"cjp0m3829001mqcrg2kwo5pm0","category_id":"cjp0m382u0031qcrgw1di0p63","_id":"cjp0m3830003mqcrgiq5w0okn"},{"post_id":"cjp0m382b001pqcrghxaxhfn9","category_id":"cjp0m382u0031qcrgw1di0p63","_id":"cjp0m3831003qqcrg9ewds774"},{"post_id":"cjp0m382c001sqcrgrbc6yqfc","category_id":"cjp0m382u0031qcrgw1di0p63","_id":"cjp0m3832003tqcrgaxmazszp"},{"post_id":"cjp0m382d001uqcrgxftrihof","category_id":"cjp0m3831003pqcrg2ftbydok","_id":"cjp0m3834003xqcrg874rqg3v"},{"post_id":"cjp0m382e001xqcrg0vtnsryo","category_id":"cjp0m3833003uqcrg50bi8ssy","_id":"cjp0m38350041qcrgzm3f4aed"},{"post_id":"cjp0m382f0020qcrgscqxu8lw","category_id":"cjp0m3834003yqcrg883llmwr","_id":"cjp0m38360045qcrg6cm4mrhx"},{"post_id":"cjp0m382g0022qcrg7eswvah9","category_id":"cjp0m38350042qcrgluefvgz8","_id":"cjp0m3838004aqcrghsroeptm"},{"post_id":"cjp0m382j0026qcrgh0hgrdd6","category_id":"cjp0m38350042qcrgluefvgz8","_id":"cjp0m3839004dqcrgpckzu0oe"},{"post_id":"cjp0m382k0028qcrg5agw49t5","category_id":"cjp0m38350042qcrgluefvgz8","_id":"cjp0m383a004gqcrgk5mrey3z"},{"post_id":"cjp0m382l002bqcrg34jbmh0x","category_id":"cjp0m3839004cqcrgy1xbja07","_id":"cjp0m383b004kqcrgkj10jxcg"},{"post_id":"cjp0m382m002eqcrgtyqbhz9i","category_id":"cjp0m383a004hqcrgpj5njwii","_id":"cjp0m383b004nqcrga8zd94dj"},{"post_id":"cjp0m38kq004uqcrgzsk7wyao","category_id":"cjp0m381u000xqcrgscowws48","_id":"cjp0m38l4004zqcrgo7mw4bsf"},{"post_id":"cjp0m38kr004vqcrgq7vgmmdt","category_id":"cjp0m382c001rqcrgrmfm6c7n","_id":"cjp0m38ld0051qcrgrcxre05o"},{"post_id":"cjp0m38kt004xqcrg46faueqy","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m38ll0056qcrgrb64n0p7"},{"post_id":"cjp0m38lc0050qcrgflokitr0","category_id":"cjp0m3826001eqcrgulh66g2g","_id":"cjp0m38lv005aqcrgjewkge3a"},{"post_id":"cjp0m38l3004yqcrgcacmokpl","category_id":"cjp0m38lk0053qcrg6djfmsw9","_id":"cjp0m38ly005gqcrglk0kjx2z"},{"post_id":"cjp0m38ll0055qcrgdzb0pbn2","category_id":"cjp0m38lv005bqcrgnfe2cwtn","_id":"cjp0m38m1005nqcrgg3nwxc1q"},{"post_id":"cjp0m38lt0057qcrg1p8guvdg","category_id":"cjp0m38lv005bqcrgnfe2cwtn","_id":"cjp0m38m4005sqcrgymd79whf"},{"post_id":"cjp0m38lw005dqcrgmy21segc","category_id":"cjp0m38m1005mqcrg5xkl036b","_id":"cjp0m38m6005yqcrgq5pca9af"},{"post_id":"cjp0m38lx005fqcrg08rwslp6","category_id":"cjp0m38m4005tqcrg7e0fu0tb","_id":"cjp0m38m80064qcrgt6wrkkus"},{"post_id":"cjp0m38lz005jqcrgnlr89z4c","category_id":"cjp0m38m6005zqcrgy79xsur5","_id":"cjp0m38mc006cqcrgrrb99mmb"},{"post_id":"cjp0m38m0005lqcrgeq70kd1x","category_id":"cjp0m38m6005zqcrgy79xsur5","_id":"cjp0m38me006gqcrgoszsnwn9"},{"post_id":"cjp0m38m2005pqcrgrhizk6dn","category_id":"cjp0m38mb006bqcrgru6zcpfe","_id":"cjp0m38mg006mqcrg21pzeanr"},{"post_id":"cjp0m38m3005qqcrgj8n2yu7t","category_id":"cjp0m38me006iqcrgb34t1jww","_id":"cjp0m38mj006sqcrg4i2qx4vo"},{"post_id":"cjp0m38m4005vqcrgzwtt16q7","category_id":"cjp0m38mh006oqcrg4y80bmmm","_id":"cjp0m38mm006zqcrg2lg71v6p"},{"post_id":"cjp0m38m5005wqcrgi7dqd9b3","category_id":"cjp0m38mb006bqcrgru6zcpfe","_id":"cjp0m38mp0075qcrg2jo6i9ib"},{"post_id":"cjp0m38m60060qcrgz7pnyowt","category_id":"cjp0m38mh006oqcrg4y80bmmm","_id":"cjp0m38mr007bqcrgn107dytg"},{"post_id":"cjp0m38m70062qcrgdk5zche4","category_id":"cjp0m38mh006oqcrg4y80bmmm","_id":"cjp0m38mu007gqcrgly0pgyis"},{"post_id":"cjp0m38mr0079qcrgpasphrab","category_id":"cjp0m381n000kqcrgzer04ef4","_id":"cjp0m38mv007kqcrgu5wo3wh4"},{"post_id":"cjp0m38m80065qcrg88ccgdnd","category_id":"cjp0m38mr007aqcrgyeqod3kg","_id":"cjp0m38mx007oqcrgy9uhukz1"},{"post_id":"cjp0m38ma0068qcrg7yet4adx","category_id":"cjp0m38mu007iqcrgrrehqmqu","_id":"cjp0m38n0007uqcrgjek1n4qq"},{"post_id":"cjp0m38mb006aqcrglmj4pijl","category_id":"cjp0m38my007pqcrgqht8v59g","_id":"cjp0m38n20080qcrg3b0d6csi"},{"post_id":"cjp0m38mc006eqcrg9z537ytr","category_id":"cjp0m38n0007vqcrggpo5i9bp","_id":"cjp0m38n60087qcrg4u7ax7sc"},{"post_id":"cjp0m38md006fqcrgp2ffuvl2","category_id":"cjp0m38n0007vqcrggpo5i9bp","_id":"cjp0m38n8008cqcrgqj25ol3k"},{"post_id":"cjp0m38n60088qcrgsn07ocox","category_id":"cjp0m3826001eqcrgulh66g2g","_id":"cjp0m38na008hqcrg4rzfrsrx"},{"post_id":"cjp0m38mf006kqcrgq1zqbv40","category_id":"cjp0m38n50086qcrgx1viyg6e","_id":"cjp0m38nf008lqcrgo1prl7m8"},{"post_id":"cjp0m38mg006lqcrgod6govbd","category_id":"cjp0m38n50086qcrgx1viyg6e","_id":"cjp0m38nj008rqcrgvhufxr7f"},{"post_id":"cjp0m38mh006pqcrgfah2vffr","category_id":"cjp0m38n50086qcrgx1viyg6e","_id":"cjp0m38nn008wqcrgr4ay2n1t"},{"post_id":"cjp0m38mi006rqcrgjt7vdp3b","category_id":"cjp0m38n50086qcrgx1viyg6e","_id":"cjp0m38nq0092qcrg4yw82spx"},{"post_id":"cjp0m38mk006vqcrg7qsyzyrb","category_id":"cjp0m38n50086qcrgx1viyg6e","_id":"cjp0m38nt0098qcrgih8caf6k"},{"post_id":"cjp0m38ml006xqcrgad9wjnge","category_id":"cjp0m38n50086qcrgx1viyg6e","_id":"cjp0m38nw009cqcrguck57tqc"},{"post_id":"cjp0m38nu009aqcrg96dxxtog","category_id":"cjp0m38n50086qcrgx1viyg6e","_id":"cjp0m38ny009iqcrgmzco2b34"},{"post_id":"cjp0m38mn0071qcrg7dxwz5wv","category_id":"cjp0m38nt0097qcrg9juhq249","_id":"cjp0m38nz009lqcrg1tkrpexd"},{"post_id":"cjp0m38mo0073qcrgp5bkok92","category_id":"cjp0m38nt0097qcrg9juhq249","_id":"cjp0m38o0009oqcrg7lpr8c0r"},{"post_id":"cjp0m38mp0076qcrgsc565s4s","category_id":"cjp0m38nt0097qcrg9juhq249","_id":"cjp0m38o1009rqcrg5t7lczmk"},{"post_id":"cjp0m38ms007cqcrg1mdsx40o","category_id":"cjp0m38o0009nqcrgv8p33cci","_id":"cjp0m38o1009vqcrg12ndkw0w"},{"post_id":"cjp0m38mt007eqcrgalr5s2an","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38o2009zqcrgyr47u5mf"},{"post_id":"cjp0m38mu007hqcrgfozkgje0","category_id":"cjp0m38o2009wqcrgfici4oms","_id":"cjp0m38o400a4qcrg8fqzz3ql"},{"post_id":"cjp0m38mv007lqcrgszga76y1","category_id":"cjp0m38o2009wqcrgfici4oms","_id":"cjp0m38o500a8qcrgne3s5vw5"},{"post_id":"cjp0m38mw007nqcrgreu51mhn","category_id":"cjp0m38o2009wqcrgfici4oms","_id":"cjp0m38o600acqcrgifi1zyor"},{"post_id":"cjp0m38my007rqcrg5iunx1ho","category_id":"cjp0m38o2009wqcrgfici4oms","_id":"cjp0m38o700agqcrgshmgz2ae"},{"post_id":"cjp0m38mz007tqcrgkns8r0qm","category_id":"cjp0m38o2009wqcrgfici4oms","_id":"cjp0m38o800ajqcrgjnkos40j"},{"post_id":"cjp0m38n1007wqcrgzpgb7xzd","category_id":"cjp0m38o2009wqcrgfici4oms","_id":"cjp0m38o900anqcrgb2kt06im"},{"post_id":"cjp0m38n2007zqcrgycz5goml","category_id":"cjp0m38o2009wqcrgfici4oms","_id":"cjp0m38oa00arqcrgso5i4xos"},{"post_id":"cjp0m38n30082qcrgpaaq6si0","category_id":"cjp0m38o2009wqcrgfici4oms","_id":"cjp0m38oa00atqcrgqgd01nzn"},{"post_id":"cjp0m38n40084qcrgg8j0l8qt","category_id":"cjp0m38oa00aqqcrgzdgqg20b","_id":"cjp0m38oc00ayqcrgg0bnri55"},{"post_id":"cjp0m38n7008aqcrgjocqdqng","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38od00b2qcrg7i182s5e"},{"post_id":"cjp0m38n8008dqcrgbrglkh56","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38oe00b6qcrgemfwoiqr"},{"post_id":"cjp0m38na008gqcrg4jyo3nb3","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38og00baqcrgoor93dcp"},{"post_id":"cjp0m38nb008jqcrgvaset9cy","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38oh00beqcrg7812aq5z"},{"post_id":"cjp0m38ng008mqcrgzejkvg7d","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38oi00biqcrg4mcp1fqk"},{"post_id":"cjp0m38ni008pqcrgys165lmp","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38oi00bkqcrgxk9ycrtb"},{"post_id":"cjp0m38nk008sqcrgws52kj3d","category_id":"cjp0m38oi00bhqcrgwnnp4bmn","_id":"cjp0m38oj00boqcrg986ce1ni"},{"post_id":"cjp0m38nm008uqcrgkz37oqse","category_id":"cjp0m38oj00bmqcrg27s008bw","_id":"cjp0m38ok00bsqcrgc2778uu5"},{"post_id":"cjp0m38no008yqcrgiqvh5vjg","category_id":"cjp0m38ok00bqqcrgngd73zxp","_id":"cjp0m38om00bxqcrgpzewbh99"},{"post_id":"cjp0m38np0090qcrgc88npqk9","category_id":"cjp0m38ok00bqqcrgngd73zxp","_id":"cjp0m38on00c1qcrgoly8t32w"},{"post_id":"cjp0m38nr0094qcrgr6axj54j","category_id":"cjp0m38ok00bqqcrgngd73zxp","_id":"cjp0m38oo00c4qcrgdzv52jk6"},{"post_id":"cjp0m38ns0096qcrgoniwylgc","category_id":"cjp0m38on00c0qcrg0pli6iww","_id":"cjp0m38op00c8qcrgj8udkmlu"},{"post_id":"cjp0m38nv009bqcrgyxqyge7h","category_id":"cjp0m38oo00c5qcrgw55j9zs9","_id":"cjp0m38oq00cdqcrgsymg3ayb"},{"post_id":"cjp0m38nx009gqcrgqcetecug","category_id":"cjp0m38oo00c5qcrgw55j9zs9","_id":"cjp0m38os00cfqcrgm08yqvg5"},{"post_id":"cjp0m38ny009hqcrgsnl5yzsk","category_id":"cjp0m38oq00ccqcrg7xct8ylc","_id":"cjp0m38os00ciqcrgv37nqry5"},{"post_id":"cjp0m38oz00cmqcrgnoqbte76","category_id":"cjp0m381n000kqcrgzer04ef4","_id":"cjp0m38p400crqcrgaglktxwj"},{"post_id":"cjp0m38p100cnqcrgruo1jxd4","category_id":"cjp0m381u000xqcrgscowws48","_id":"cjp0m38p500ctqcrgu2ya9pi7"},{"post_id":"cjp0m38p200cpqcrgsp04pp69","category_id":"cjp0m38180003qcrg07yh8vk2","_id":"cjp0m38p700cxqcrgudiyuzvu"},{"post_id":"cjp0m38p300cqqcrg99n0g8g2","category_id":"cjp0m38nt0097qcrg9juhq249","_id":"cjp0m38p800czqcrgyunucqtf"},{"post_id":"cjp0m38p400csqcrguerazsp7","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38p900d1qcrgky8vqosn"},{"post_id":"cjp0m38p600cwqcrge3hsnka7","category_id":"cjp0m38ok00bqqcrgngd73zxp","_id":"cjp0m38pa00d4qcrg21jzd9d8"},{"post_id":"cjp0m38p700cyqcrgvpmruzrh","category_id":"cjp0m38pa00d3qcrgf2nuero1","_id":"cjp0m38pb00d9qcrg8bjopg66"},{"post_id":"cjp0m38rx00deqcrgrcrtgt55","category_id":"cjp0m382f001yqcrgzuyzubgz","_id":"cjp0m38s300djqcrgojtadqvn"},{"post_id":"cjp0m38s000dhqcrgdvnnjpkz","category_id":"cjp0m38mh006oqcrg4y80bmmm","_id":"cjp0m38s400dmqcrg96ju4atc"},{"post_id":"cjp0m38s200diqcrg8ynkl0qn","category_id":"cjp0m38o1009sqcrgjbvgzzpu","_id":"cjp0m38s500dnqcrgaqd2arm7"},{"post_id":"cjp0m38rv00ddqcrgyr2vifa9","category_id":"cjp0m38ry00dfqcrgwy82yce8","_id":"cjp0m38s600dpqcrgyfq0uarl"},{"post_id":"cjp0m38sw00duqcrgfi0lwzps","category_id":"cjp0m38sz00dvqcrgfak2d6my","_id":"cjp0m38t100dyqcrg2lsk0pme"},{"post_id":"cjp0m38zk00dzqcrguy5x6lwb","category_id":"cjp0m38on00c0qcrg0pli6iww","_id":"cjp0m38zm00e1qcrgmqthdml9"}],"PostTag":[{"post_id":"cjp0m38120001qcrgbpimpoyi","tag_id":"cjp0m38190004qcrg6mpxsmkc","_id":"cjp0m381h000aqcrgnv48ui19"},{"post_id":"cjp0m38160002qcrg95r5ftw7","tag_id":"cjp0m381h0009qcrgimpls1rj","_id":"cjp0m381m000hqcrg9i45nqsf"},{"post_id":"cjp0m381a0005qcrgj9xnrg3o","tag_id":"cjp0m381l000fqcrg723hvfj9","_id":"cjp0m381p000nqcrg9tiwhwup"},{"post_id":"cjp0m381c0006qcrgznqfv2u5","tag_id":"cjp0m381o000lqcrgq5csruhj","_id":"cjp0m381s000tqcrgtumt69ym"},{"post_id":"cjp0m381f0007qcrgeqqww669","tag_id":"cjp0m381r000rqcrgnxxuk7c7","_id":"cjp0m381u000zqcrg8gxri27l"},{"post_id":"cjp0m381i000bqcrgmhc5z0md","tag_id":"cjp0m381u000yqcrg0qi7i05j","_id":"cjp0m38220016qcrg5yuyp3ki"},{"post_id":"cjp0m381k000cqcrgudhnuu3u","tag_id":"cjp0m38200014qcrghqrw7gtl","_id":"cjp0m3825001cqcrg4k1k8v8j"},{"post_id":"cjp0m381m000gqcrge29afuy4","tag_id":"cjp0m3824001aqcrgeyd428mp","_id":"cjp0m3828001iqcrg1j1b5cpm"},{"post_id":"cjp0m381n000iqcrgzxuhvdu4","tag_id":"cjp0m3827001gqcrgw5ob0q7g","_id":"cjp0m382a001oqcrg76286d49"},{"post_id":"cjp0m381o000mqcrg6opu8k5i","tag_id":"cjp0m382a001nqcrgj9bt2lh8","_id":"cjp0m382e001vqcrgbw0f1v8i"},{"post_id":"cjp0m381p000oqcrgp3vnrfay","tag_id":"cjp0m382d001tqcrg73fr7rnb","_id":"cjp0m382g0021qcrgtpko9izq"},{"post_id":"cjp0m381r000sqcrg79qrb7ot","tag_id":"cjp0m382f001zqcrg74i6fr54","_id":"cjp0m382j0027qcrgir2jnbp5"},{"post_id":"cjp0m381s000uqcrg3zk9i3qh","tag_id":"cjp0m382i0025qcrga4hjzqfe","_id":"cjp0m382m002dqcrgt7aepeyy"},{"post_id":"cjp0m381t000wqcrgds50tbhd","tag_id":"cjp0m382m002cqcrg1kzfs4mp","_id":"cjp0m382q002kqcrg2atubxlf"},{"post_id":"cjp0m381v0010qcrgep9e7wfd","tag_id":"cjp0m382p002iqcrgnpmtm3a8","_id":"cjp0m382r002qqcrgx7akn7rl"},{"post_id":"cjp0m381z0011qcrgo1hcjmqf","tag_id":"cjp0m382r002nqcrg1hyqrlhg","_id":"cjp0m382t002vqcrgulv5p63x"},{"post_id":"cjp0m38210015qcrgnibsvhv6","tag_id":"cjp0m382s002sqcrgy6abd72x","_id":"cjp0m382u0030qcrgw0jv54c4"},{"post_id":"cjp0m38220017qcrglxzgtp4d","tag_id":"cjp0m382t002xqcrgpqefj7ku","_id":"cjp0m382v0034qcrgr4k888oj"},{"post_id":"cjp0m3824001bqcrg6456hvgm","tag_id":"cjp0m382v0033qcrg0fj2b2dr","_id":"cjp0m382w0038qcrgn61g72jx"},{"post_id":"cjp0m3825001dqcrgsdir0jko","tag_id":"cjp0m382w0037qcrgqo3375qb","_id":"cjp0m382x003cqcrg0e0shqzd"},{"post_id":"cjp0m3827001hqcrg2qcy4n0u","tag_id":"cjp0m382x003bqcrgvjtoqr84","_id":"cjp0m382y003gqcrgyp9cmtyq"},{"post_id":"cjp0m3828001jqcrg2vtctbbb","tag_id":"cjp0m382y003fqcrgu9s37j1y","_id":"cjp0m382z003kqcrgelxuq7st"},{"post_id":"cjp0m3829001mqcrg2kwo5pm0","tag_id":"cjp0m382z003jqcrgq9vkpajf","_id":"cjp0m3831003oqcrgrjjjkk7i"},{"post_id":"cjp0m382b001pqcrghxaxhfn9","tag_id":"cjp0m3830003nqcrgnk7dphvm","_id":"cjp0m3832003sqcrgctai51ob"},{"post_id":"cjp0m382c001sqcrgrbc6yqfc","tag_id":"cjp0m3831003rqcrg3s9ufm3v","_id":"cjp0m3833003wqcrg7vg2tpfg"},{"post_id":"cjp0m382d001uqcrgxftrihof","tag_id":"cjp0m3833003vqcrggku6xc3r","_id":"cjp0m38340040qcrgwfefo6ny"},{"post_id":"cjp0m382e001xqcrg0vtnsryo","tag_id":"cjp0m3834003zqcrgixzrf631","_id":"cjp0m38360044qcrgk0uthk2h"},{"post_id":"cjp0m382f0020qcrgscqxu8lw","tag_id":"cjp0m38350043qcrgenpswsuv","_id":"cjp0m38370048qcrglyv103w6"},{"post_id":"cjp0m382g0022qcrg7eswvah9","tag_id":"cjp0m38370047qcrgxo15nn3z","_id":"cjp0m3839004eqcrg2femtpbc"},{"post_id":"cjp0m382j0026qcrgh0hgrdd6","tag_id":"cjp0m3838004bqcrgr364snz8","_id":"cjp0m383a004iqcrgbp0671s0"},{"post_id":"cjp0m382k0028qcrg5agw49t5","tag_id":"cjp0m3839004fqcrgndvoddbk","_id":"cjp0m383b004lqcrg55qbgagn"},{"post_id":"cjp0m382l002bqcrg34jbmh0x","tag_id":"cjp0m383a004jqcrg6kpxq50h","_id":"cjp0m383c004oqcrgsfzve2dt"},{"post_id":"cjp0m382m002eqcrgtyqbhz9i","tag_id":"cjp0m383b004mqcrg6eje98m3","_id":"cjp0m383c004qqcrgvtr9uoci"},{"post_id":"cjp0m382o002hqcrgr4mifs4k","tag_id":"cjp0m383c004pqcrgfcsy8vup","_id":"cjp0m383d004sqcrgniqra3zw"},{"post_id":"cjp0m382p002jqcrg9z7g8jkk","tag_id":"cjp0m383c004rqcrg6q3v3chx","_id":"cjp0m383d004tqcrgbbuhonyn"},{"post_id":"cjp0m38kq004uqcrgzsk7wyao","tag_id":"cjp0m38ks004wqcrgb1o07bsl","_id":"cjp0m38ll0054qcrg6zoyz4as"},{"post_id":"cjp0m38kr004vqcrgq7vgmmdt","tag_id":"cjp0m38ld0052qcrgieukgnf9","_id":"cjp0m38lv005cqcrg8ge9dseg"},{"post_id":"cjp0m38kt004xqcrg46faueqy","tag_id":"cjp0m38lu0058qcrg6e4rpscg","_id":"cjp0m38ly005iqcrgv7eu37ej"},{"post_id":"cjp0m38l3004yqcrgcacmokpl","tag_id":"cjp0m38lx005eqcrgpfkvtd9q","_id":"cjp0m38m2005oqcrg97cat79x"},{"post_id":"cjp0m38lc0050qcrgflokitr0","tag_id":"cjp0m38lz005kqcrgjnnj0vl9","_id":"cjp0m38m4005uqcrgi21fpcak"},{"post_id":"cjp0m38ll0055qcrgdzb0pbn2","tag_id":"cjp0m38m3005rqcrgulsbp6y2","_id":"cjp0m38m70061qcrgbzycdkiy"},{"post_id":"cjp0m38lt0057qcrg1p8guvdg","tag_id":"cjp0m38m6005xqcrgl2zzqs6h","_id":"cjp0m38ma0067qcrgkpwvl22w"},{"post_id":"cjp0m38lw005dqcrgmy21segc","tag_id":"cjp0m38m80063qcrgpjpsh77q","_id":"cjp0m38mc006dqcrg4wgbyojz"},{"post_id":"cjp0m38lx005fqcrg08rwslp6","tag_id":"cjp0m38mb0069qcrgtkjby3fr","_id":"cjp0m38mf006jqcrg2r998vnu"},{"post_id":"cjp0m38m0005lqcrgeq70kd1x","tag_id":"cjp0m38me006hqcrg8nw08ntp","_id":"cjp0m38mi006qqcrgjxh9z9za"},{"post_id":"cjp0m38m2005pqcrgrhizk6dn","tag_id":"cjp0m38mg006nqcrgu0la799l","_id":"cjp0m38ml006wqcrgk3rax3tc"},{"post_id":"cjp0m38m3005qqcrgj8n2yu7t","tag_id":"cjp0m38mj006tqcrghdjqen2p","_id":"cjp0m38mo0072qcrg98sueex9"},{"post_id":"cjp0m38m4005vqcrgzwtt16q7","tag_id":"cjp0m38mm0070qcrgwvulexyi","_id":"cjp0m38mq0078qcrggy8fxur8"},{"post_id":"cjp0m38m5005wqcrgi7dqd9b3","tag_id":"cjp0m38mq0077qcrg0ytkufqw","_id":"cjp0m38mt007fqcrga7vyzp28"},{"post_id":"cjp0m38m60060qcrgz7pnyowt","tag_id":"cjp0m38ms007dqcrgdbvv1mzi","_id":"cjp0m38mw007mqcrgqojm99th"},{"post_id":"cjp0m38m70062qcrgdk5zche4","tag_id":"cjp0m38mv007jqcrgnsndapfo","_id":"cjp0m38mz007sqcrgcda8vxl6"},{"post_id":"cjp0m38m80065qcrg88ccgdnd","tag_id":"cjp0m38my007qqcrgszy9rvhi","_id":"cjp0m38n2007yqcrgku2z5y5f"},{"post_id":"cjp0m38ma0068qcrg7yet4adx","tag_id":"cjp0m38n1007xqcrgrp8k5sx1","_id":"cjp0m38n50085qcrg6nqiawrb"},{"post_id":"cjp0m38mb006aqcrglmj4pijl","tag_id":"cjp0m38n40083qcrg3kl4quk0","_id":"cjp0m38n8008bqcrg9bny9m96"},{"post_id":"cjp0m38md006fqcrgp2ffuvl2","tag_id":"cjp0m38n70089qcrggpzie6u1","_id":"cjp0m38nb008iqcrgkw5whmz6"},{"post_id":"cjp0m38mf006kqcrgq1zqbv40","tag_id":"cjp0m38n9008fqcrgnm89hvdi","_id":"cjp0m38nh008oqcrgq4984dmq"},{"post_id":"cjp0m38mg006lqcrgod6govbd","tag_id":"cjp0m38nh008nqcrg6izsy35r","_id":"cjp0m38nn008xqcrgor47kx3v"},{"post_id":"cjp0m38mh006pqcrgfah2vffr","tag_id":"cjp0m38nm008tqcrg1l67c4o1","_id":"cjp0m38nr0093qcrg08yrafc4"},{"post_id":"cjp0m38mi006rqcrgjt7vdp3b","tag_id":"cjp0m38np008zqcrg00dixwdh","_id":"cjp0m38nt0099qcrgdf7yv8gi"},{"post_id":"cjp0m38mk006vqcrg7qsyzyrb","tag_id":"cjp0m38ns0095qcrg9c0xyarr","_id":"cjp0m38nx009fqcrgmqwuw613"},{"post_id":"cjp0m38ml006xqcrgad9wjnge","tag_id":"cjp0m38nw009dqcrge26q053z","_id":"cjp0m38nz009mqcrgx3fz9ofq"},{"post_id":"cjp0m38mn0071qcrg7dxwz5wv","tag_id":"cjp0m38nz009kqcrgav4y5o5d","_id":"cjp0m38o0009qqcrgnkzmiu9r"},{"post_id":"cjp0m38mo0073qcrgp5bkok92","tag_id":"cjp0m38o0009pqcrgubp35iyw","_id":"cjp0m38o1009uqcrgoah98g3l"},{"post_id":"cjp0m38mr0079qcrgpasphrab","tag_id":"cjp0m38o1009tqcrg0araqcai","_id":"cjp0m38o2009yqcrgtkmbb3px"},{"post_id":"cjp0m38ms007cqcrg1mdsx40o","tag_id":"cjp0m38o2009xqcrgttufyh1y","_id":"cjp0m38o300a2qcrg3eqihzoj"},{"post_id":"cjp0m38mt007eqcrgalr5s2an","tag_id":"cjp0m38o300a1qcrgg4ekbxaf","_id":"cjp0m38o400a6qcrgpda8t8fd"},{"post_id":"cjp0m38mu007hqcrgfozkgje0","tag_id":"cjp0m38o400a5qcrg0uxspalq","_id":"cjp0m38o500aaqcrg7uxsyutx"},{"post_id":"cjp0m38mv007lqcrgszga76y1","tag_id":"cjp0m38o500a9qcrgpqexxfj8","_id":"cjp0m38o600aeqcrgojws47pt"},{"post_id":"cjp0m38mw007nqcrgreu51mhn","tag_id":"cjp0m38o600adqcrgjf17eaph","_id":"cjp0m38o800akqcrgc8e853vn"},{"post_id":"cjp0m38my007rqcrg5iunx1ho","tag_id":"cjp0m38o700ahqcrg1pv0szay","_id":"cjp0m38o900aoqcrgbicor5mm"},{"post_id":"cjp0m38mz007tqcrgkns8r0qm","tag_id":"cjp0m38o800alqcrgmem5sqjh","_id":"cjp0m38oa00asqcrg62f4yp44"},{"post_id":"cjp0m38n1007wqcrgzpgb7xzd","tag_id":"cjp0m38o900apqcrg0304ts91","_id":"cjp0m38ob00awqcrgy3k5v9ei"},{"post_id":"cjp0m38n2007zqcrgycz5goml","tag_id":"cjp0m38oa00auqcrg19flpon7","_id":"cjp0m38oc00b0qcrgi97ylfok"},{"post_id":"cjp0m38n30082qcrgpaaq6si0","tag_id":"cjp0m38oc00azqcrghut7voyz","_id":"cjp0m38oe00b4qcrg5plm8bz1"},{"post_id":"cjp0m38n40084qcrgg8j0l8qt","tag_id":"cjp0m38od00b3qcrgh7b9vlk1","_id":"cjp0m38of00b8qcrgdvppuooe"},{"post_id":"cjp0m38n60088qcrgsn07ocox","tag_id":"cjp0m38of00b7qcrg2obwwy6y","_id":"cjp0m38og00bcqcrgyokass6c"},{"post_id":"cjp0m38n7008aqcrgjocqdqng","tag_id":"cjp0m38og00bbqcrgmhvzr7tu","_id":"cjp0m38oh00bgqcrg7pk40w8l"},{"post_id":"cjp0m38n8008dqcrgbrglkh56","tag_id":"cjp0m38oh00bfqcrgcpyurin2","_id":"cjp0m38oj00blqcrg9so1a2ch"},{"post_id":"cjp0m38na008gqcrg4jyo3nb3","tag_id":"cjp0m38oi00bjqcrgfgt9zwj8","_id":"cjp0m38oj00bpqcrgm4lv64t9"},{"post_id":"cjp0m38nb008jqcrgvaset9cy","tag_id":"cjp0m38oj00bnqcrg5yctja6n","_id":"cjp0m38ok00btqcrgrbjtygxg"},{"post_id":"cjp0m38ng008mqcrgzejkvg7d","tag_id":"cjp0m38ok00brqcrgw75ixnnl","_id":"cjp0m38om00byqcrgltt644aq"},{"post_id":"cjp0m38ni008pqcrgys165lmp","tag_id":"cjp0m38ol00bvqcrga8dkxxm8","_id":"cjp0m38on00c2qcrgmjebqobn"},{"post_id":"cjp0m38nk008sqcrgws52kj3d","tag_id":"cjp0m38on00bzqcrg7axb0n9w","_id":"cjp0m38oo00c6qcrgbk8yvxmd"},{"post_id":"cjp0m38ns0096qcrgoniwylgc","tag_id":"cjp0m38oo00c3qcrgkwgcmrv6","_id":"cjp0m38op00caqcrgilp1o6h5"},{"post_id":"cjp0m38nu009aqcrg96dxxtog","tag_id":"cjp0m38op00c7qcrg438hbih1","_id":"cjp0m38oq00ceqcrgitvgwkgw"},{"post_id":"cjp0m38nv009bqcrgyxqyge7h","tag_id":"cjp0m38oq00cbqcrgn68hyft3","_id":"cjp0m38os00chqcrg05rmqoer"},{"post_id":"cjp0m38nx009gqcrgqcetecug","tag_id":"cjp0m38os00cgqcrgfpay6hiu","_id":"cjp0m38ot00ckqcrgh32s1mka"},{"post_id":"cjp0m38ny009hqcrgsnl5yzsk","tag_id":"cjp0m38os00cjqcrg7bk96ffv","_id":"cjp0m38ot00clqcrguzlzpy7a"},{"post_id":"cjp0m38oz00cmqcrgnoqbte76","tag_id":"cjp0m38p200coqcrgea7q74hm","_id":"cjp0m38p600cvqcrg0gvypfl0"},{"post_id":"cjp0m38p100cnqcrgruo1jxd4","tag_id":"cjp0m38p500cuqcrggbp5fyct","_id":"cjp0m38p900d2qcrgh7rqlkuk"},{"post_id":"cjp0m38p200cpqcrgsp04pp69","tag_id":"cjp0m38p900d0qcrgo28xzg3c","_id":"cjp0m38pa00d6qcrg8edh0z0r"},{"post_id":"cjp0m38p400csqcrguerazsp7","tag_id":"cjp0m38pa00d5qcrgnrou5pv6","_id":"cjp0m38pb00d8qcrgo3ddlrow"},{"post_id":"cjp0m38p600cwqcrge3hsnka7","tag_id":"cjp0m38pb00d7qcrgbg8468s1","_id":"cjp0m38pc00dbqcrg3auc5ptb"},{"post_id":"cjp0m38p700cyqcrgvpmruzrh","tag_id":"cjp0m38pb00daqcrg04x3nzbn","_id":"cjp0m38pc00dcqcrgq047u5b1"},{"post_id":"cjp0m38rv00ddqcrgyr2vifa9","tag_id":"cjp0m38ry00dgqcrghlqw84ny","_id":"cjp0m38s400dlqcrgkrk2niqh"},{"post_id":"cjp0m38rx00deqcrgrcrtgt55","tag_id":"cjp0m38s300dkqcrg3nod35z9","_id":"cjp0m38s600dqqcrgyly8dmeh"},{"post_id":"cjp0m38s000dhqcrgdvnnjpkz","tag_id":"cjp0m38s500doqcrguec5ir0b","_id":"cjp0m38s800dsqcrgsrt5rrim"},{"post_id":"cjp0m38s200diqcrg8ynkl0qn","tag_id":"cjp0m38s700drqcrgaizq2syv","_id":"cjp0m38s900dtqcrgvfw6qusf"},{"post_id":"cjp0m38sw00duqcrgfi0lwzps","tag_id":"cjp0m38sz00dwqcrgcm77n8z1","_id":"cjp0m38t000dxqcrgly2x0vuf"},{"post_id":"cjp0m38zk00dzqcrguy5x6lwb","tag_id":"cjp0m38zl00e0qcrgrin6vvhv","_id":"cjp0m38zm00e2qcrg43l7jyd1"}],"Tag":[{"name":"nginx负载均衡","_id":"cjp0m38190004qcrg6mpxsmkc"},{"name":"angular入门","_id":"cjp0m381h0009qcrgimpls1rj"},{"name":"aws云服务器","_id":"cjp0m381l000fqcrg723hvfj9"},{"name":"apidoc","_id":"cjp0m381o000lqcrgq5csruhj"},{"name":"区块链哈希函数","_id":"cjp0m381r000rqcrgnxxuk7c7"},{"name":"centos登录","_id":"cjp0m381u000yqcrg0qi7i05j"},{"name":"centos-jdk8-install","_id":"cjp0m38200014qcrghqrw7gtl"},{"name":"centos-nexus","_id":"cjp0m3824001aqcrgeyd428mp"},{"name":"concourse","_id":"cjp0m3827001gqcrgw5ob0q7g"},{"name":"cron-grammar","_id":"cjp0m382a001nqcrgj9bt2lh8"},{"name":"distributed-difficulty","_id":"cjp0m382d001tqcrg73fr7rnb"},{"name":"docker安装应用","_id":"cjp0m382f001zqcrg74i6fr54"},{"name":"centos-docker-install","_id":"cjp0m382i0025qcrga4hjzqfe"},{"name":"docker ce安装","_id":"cjp0m382m002cqcrg1kzfs4mp"},{"name":"docker镜像创建、docker容器启动、docker发布web应用","_id":"cjp0m382p002iqcrgnpmtm3a8"},{"name":"基础概念","_id":"cjp0m382r002nqcrg1hyqrlhg"},{"name":"docker网络","_id":"cjp0m382s002sqcrgy6abd72x"},{"name":"docker数据管理","_id":"cjp0m382t002xqcrgpqefj7ku"},{"name":"docker-compose","_id":"cjp0m382v0033qcrg0fj2b2dr"},{"name":"git分支、github分支","_id":"cjp0m382w0037qcrgqo3375qb"},{"name":"fastdfs-安装使用","_id":"cjp0m382x003bqcrgvjtoqr84"},{"name":"git-install-in-centos","_id":"cjp0m382y003fqcrgu9s37j1y"},{"name":"git-tag","_id":"cjp0m382z003jqcrgq9vkpajf"},{"name":"git-server-build","_id":"cjp0m3830003nqcrgnk7dphvm"},{"name":"git问题","_id":"cjp0m3831003rqcrg3s9ufm3v"},{"name":"github-fork-repo-update","_id":"cjp0m3833003vqcrggku6xc3r"},{"name":"hashicorp-vault","_id":"cjp0m3834003zqcrgixzrf631"},{"name":"http-overview","_id":"cjp0m38350043qcrgenpswsuv"},{"name":"XRebel","_id":"cjp0m38370047qcrgxo15nn3z"},{"name":"idea注解模板","_id":"cjp0m3838004bqcrgr364snz8"},{"name":"idea插件利器","_id":"cjp0m3839004fqcrgndvoddbk"},{"name":"istio","_id":"cjp0m383a004jqcrg6kpxq50h"},{"name":"jackson","_id":"cjp0m383b004mqcrg6eje98m3"},{"name":"cglib","_id":"cjp0m383c004pqcrgfcsy8vup"},{"name":"java-nio-buffer","_id":"cjp0m383c004rqcrg6q3v3chx"},{"name":"mysql mysql8","_id":"cjp0m38ks004wqcrgb1o07bsl"},{"name":"snowflake算法","_id":"cjp0m38ld0052qcrgieukgnf9"},{"name":"docker 容器","_id":"cjp0m38lu0058qcrg6e4rpscg"},{"name":"javapoet-apt-annotation","_id":"cjp0m38lx005eqcrgpfkvtd9q"},{"name":"jenkins-java-maven","_id":"cjp0m38lz005kqcrgjnnj0vl9"},{"name":"jvm监控工具","_id":"cjp0m38m3005rqcrgulsbp6y2"},{"name":"gc垃圾回收","_id":"cjp0m38m6005xqcrgl2zzqs6h"},{"name":"k8s","_id":"cjp0m38m80063qcrgpjpsh77q"},{"name":"linux-command","_id":"cjp0m38mb0069qcrgtkjby3fr"},{"name":"ubuntu-navicat","_id":"cjp0m38me006hqcrg8nw08ntp"},{"name":"maven常用功能","_id":"cjp0m38mg006nqcrgu0la799l"},{"name":"微服务实践总结","_id":"cjp0m38mj006tqcrghdjqen2p"},{"name":"mysql复制","_id":"cjp0m38mm0070qcrgwvulexyi"},{"name":"maven-error","_id":"cjp0m38mq0077qcrg0ytkufqw"},{"name":"mysql建表规范","_id":"cjp0m38ms007dqcrgdbvv1mzi"},{"name":"mysql使用问题收藏","_id":"cjp0m38mv007jqcrgnsndapfo"},{"name":"ngrok使用","_id":"cjp0m38my007qqcrgszy9rvhi"},{"name":"npm使用问题","_id":"cjp0m38n1007xqcrgrp8k5sx1"},{"name":"pws-push","_id":"cjp0m38n40083qcrg3kl4quk0"},{"name":"rabbitmq-install","_id":"cjp0m38n70089qcrggpzie6u1"},{"name":"redis,主从,集群","_id":"cjp0m38n9008fqcrgnm89hvdi"},{"name":"redis,密码,安全","_id":"cjp0m38nh008nqcrg6izsy35r"},{"name":"redis命令","_id":"cjp0m38nm008tqcrg1l67c4o1"},{"name":"redis-install","_id":"cjp0m38np008zqcrg00dixwdh"},{"name":"redis分布式锁","_id":"cjp0m38ns0095qcrg9c0xyarr"},{"name":"redis哨兵模式","_id":"cjp0m38nw009dqcrge26q053z"},{"name":"redmine插件","_id":"cjp0m38nz009kqcrgav4y5o5d"},{"name":"redmine-mongrel-nginx","_id":"cjp0m38o0009pqcrgubp35iyw"},{"name":"restful-api","_id":"cjp0m38o1009tqcrg0araqcai"},{"name":"rocketmq入门","_id":"cjp0m38o2009xqcrgttufyh1y"},{"name":"change-contextpath-way","_id":"cjp0m38o300a1qcrgg4ekbxaf"},{"name":"feign使用常见问题","_id":"cjp0m38o400a5qcrg0uxspalq"},{"name":"spring-cloud(配置中心加解密)","_id":"cjp0m38o500a9qcrgpqexxfj8"},{"name":"feign","_id":"cjp0m38o600adqcrgjf17eaph"},{"name":"hystrix,dashboard","_id":"cjp0m38o700ahqcrg1pv0szay"},{"name":"hystrix","_id":"cjp0m38o800alqcrgmem5sqjh"},{"name":"zuul-exception","_id":"cjp0m38o900apqcrg0304ts91"},{"name":"zuul-filters","_id":"cjp0m38oa00auqcrg19flpon7"},{"name":"zuul-start","_id":"cjp0m38oc00azqcrghut7voyz"},{"name":"shadowsocks-go","_id":"cjp0m38od00b3qcrgh7b9vlk1"},{"name":"spinnaker-start","_id":"cjp0m38of00b7qcrg2obwwy6y"},{"name":"spring-boot-async","_id":"cjp0m38og00bbqcrgmhvzr7tu"},{"name":"spring cache","_id":"cjp0m38oh00bfqcrgcpyurin2"},{"name":"spring-cors","_id":"cjp0m38oi00bjqcrgfgt9zwj8"},{"name":"spring-boot使用经验","_id":"cjp0m38oj00bnqcrg5yctja6n"},{"name":"spring mvc国际化","_id":"cjp0m38ok00brqcrgw75ixnnl"},{"name":"spring-boot-jar","_id":"cjp0m38ol00bvqcrga8dkxxm8"},{"name":"teamcity-start","_id":"cjp0m38on00bzqcrg7axb0n9w"},{"name":"website-high-performance","_id":"cjp0m38oo00c3qcrgkwgcmrv6"},{"name":"redis发布订阅","_id":"cjp0m38op00c7qcrg438hbih1"},{"name":"apache curator","_id":"cjp0m38oq00cbqcrgn68hyft3"},{"name":"zookeeper安装使用","_id":"cjp0m38os00cgqcrgfpay6hiu"},{"name":"wkhtmltopdf","_id":"cjp0m38os00cjqcrg7bk96ffv"},{"name":"api-version-manage,spring-boot中API版本迭代管理","_id":"cjp0m38p200coqcrgea7q74hm"},{"name":"centos常用命令","_id":"cjp0m38p500cuqcrggbp5fyct"},{"name":"nginx能做什么","_id":"cjp0m38p900d0qcrgo28xzg3c"},{"name":"spring-boot-filter","_id":"cjp0m38pa00d5qcrgnrou5pv6"},{"name":"vagrant-start","_id":"cjp0m38pb00d7qcrgbg8468s1"},{"name":"vault","_id":"cjp0m38pb00daqcrg04x3nzbn"},{"name":"hibernate-relation","_id":"cjp0m38ry00dgqcrghlqw84ny"},{"name":"docker镜像","_id":"cjp0m38s300dkqcrg3nod35z9"},{"name":"mysql-expain","_id":"cjp0m38s500doqcrguec5ir0b"},{"name":"jpa读写分离配置","_id":"cjp0m38s700drqcrgaizq2syv"},{"name":"shiro入门","_id":"cjp0m38sz00dwqcrgcm77n8z1"},{"name":"后端架构师技术图谱","_id":"cjp0m38zl00e0qcrgrin6vvhv"}]}}