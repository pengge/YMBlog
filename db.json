{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon-1.ico","path":"favicon-1.ico","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":1,"renderable":1},{"_id":"source/about/index/a.png","path":"about/index/a.png","modified":1,"renderable":0},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/README.md","hash":"66c3ef7a779b6d65bad90daa2e03bcb7a1bb742f","modified":1506397161743},{"_id":"themes/BlueLake/README.en.md","hash":"6cc6e346635bf26dd71030b9c3c6443507cd4108","modified":1506397161737},{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1506397161735},{"_id":"themes/BlueLake/_config.yml","hash":"0a3ebf757d689c82322825d23e6b3f1d4e6c37c1","modified":1508475369683},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1506397161887},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"a127deb32d1df69bbe50a3824a5f90472513c9c3","modified":1506397161751},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"baa68725feeec6643f875a532a9d55ba8aacdb2c","modified":1506397161758},{"_id":"themes/BlueLake/languages/en.yml","hash":"95bac2c366505d016b5defc47370679b9f5f3c4b","modified":1506397161755},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"bd97d5e4b39d30da1644b90256dfc4e6b1d76988","modified":1506397161761},{"_id":"themes/BlueLake/languages/ko.yml","hash":"fc8826724f570136d9a2d3ec2705b7b7000e0f14","modified":1506397161765},{"_id":"themes/BlueLake/languages/tr.yml","hash":"5f13d55fdd5bdd1115075736e3e26a1ea1dd1dea","modified":1506397161770},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"d4d587ba81864910715c0c3879605cc6a9362e09","modified":1506397161776},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1506397161774},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1506397161862},{"_id":"themes/BlueLake/layout/base.jade","hash":"3805aaa6e96916e810b22d6a20d995f1fd3bf365","modified":1506397161866},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1506397161869},{"_id":"themes/BlueLake/layout/post.jade","hash":"0305258c33e4d02f977ee1aaf7f2429b993fda17","modified":1506397161879},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1506397161876},{"_id":"themes/BlueLake/layout/index.jade","hash":"dd81d9f7a6b388de2ab731b17b3ba55f70df4a5f","modified":1506397161872},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1506397161883},{"_id":"source/about/index.md","hash":"57df7860368f7ef928574c367758944a951c7c4d","modified":1506397161722},{"_id":"themes/BlueLake/source/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1506397161910},{"_id":"source/_posts/apidoc-java.md","hash":"3275ea6be4e1be2434129de9ca159bca92af2ea2","modified":1506397161662},{"_id":"source/_posts/api-version.md","hash":"528c5f3b739a5a6a06a5b200c0dd01e6368251b8","modified":1506407246648},{"_id":"source/_posts/cron-grammar.md","hash":"d2c9ea3b2a365bad6c6d9054f3ebd1642364e391","modified":1508812332441},{"_id":"themes/BlueLake/source/favicon-1.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1506397161905},{"_id":"source/_posts/distributed-id-snowflake.md","hash":"bc0fcf9cb5d5cb67f40e8ddb36ba83e1fcdffbae","modified":1506397161671},{"_id":"source/_posts/git-install-in-centos7.md","hash":"240c9d30e47863c0503b80d500a8c5e6253777a5","modified":1507946967704},{"_id":"source/_posts/Keepalived-LVS-Nginx.md","hash":"58e4f6a4616d9762e74834dfb7ead98430cff2ae","modified":1506397161653},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1506397161891},{"_id":"source/_posts/github-fork-repo-update.md","hash":"13e864d5d3282d90fbe399b45b927441171b9818","modified":1507859843172},{"_id":"source/_posts/jackson-show-time.md","hash":"f83b7c2899b17d623137555968f6ec3f017f4bf6","modified":1507946102419},{"_id":"source/_posts/jvm-gc.md","hash":"2f47e9e2b8ff504e0a596763eec7a4b1a1015922","modified":1508475133120},{"_id":"source/_posts/jvm-look-tools.md","hash":"0981f8163278b6b79d81be818805a270796bd1ad","modified":1508475198181},{"_id":"source/_posts/git-server-build.md","hash":"60a8320bca9568edd56fee8fb299ae1a44556ad9","modified":1508474372237},{"_id":"source/_posts/http-protocol-overview.md","hash":"a6c6882fb2c1ab271401a482fc3b6177b3552888","modified":1508474372240},{"_id":"source/_posts/linux-command-use.md","hash":"e22659dab45e38c36ed6fa8f552588797f780329","modified":1507966900529},{"_id":"source/_posts/microservice-think.md","hash":"857847b7b3953ddea45418c6383d2dc095b104fd","modified":1506397161680},{"_id":"source/_posts/hashicorp-vault.md","hash":"9174738ccc5a18381ed89e0e775168e2622f0ae9","modified":1507946102413},{"_id":"source/_posts/redis-cluster-centos.md","hash":"1af79c5853fa5c4d8b8166786ca74f1833de4c14","modified":1506397161690},{"_id":"source/_posts/restful-api-dev.md","hash":"2801e8a7e037d0b3992adc795ca8b1b11fcb8b21","modified":1506735099959},{"_id":"source/_posts/sboot-dev-error-show.md","hash":"2bf16856d86c9860166ca598148eed7595772447","modified":1506735063776},{"_id":"source/_posts/scloud-zuul-exception.md","hash":"338d5bdac28f1b324b0fbb4e60ccfd9861bf8f49","modified":1507708053183},{"_id":"source/_posts/scloud-zuul-filters.md","hash":"d091129d4e125e8e2865d1be81fc47a9b2e14767","modified":1507713674153},{"_id":"source/_posts/sboot-change-contextpath.md","hash":"58adffac65c55472abd340e398a2d255e6c04518","modified":1506579718172},{"_id":"source/_posts/pivotal-web-service-start.md","hash":"8553022730a6e3fa82f019ea61bd55172fbb91dc","modified":1507796634735},{"_id":"source/_posts/tslang-study-one.md","hash":"b81c8d6bdde2067462944f49647bbd6e00246e5d","modified":1507946102421},{"_id":"source/_posts/scloud-zuul-start.md","hash":"f27b17b984757bbb5b6d7c654db02981fd5adfe8","modified":1507710830826},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1506397161836},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1506397161843},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1506397161840},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1506397161848},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1506397161851},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1506397161854},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1506397161858},{"_id":"source/_posts/scloud-feign-anyquestion.md","hash":"97cccd89fe7a037ac6d9a680492371cf25ea4323","modified":1506397161700},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"c1f1955d12aee22a931a3f4ad9d0e9a408e80f3c","modified":1506397161789},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"3f11d2b5a4c647bf2b37c4d00bdc250cda80b770","modified":1506397161782},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1506397161785},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"d970c81b5cdbd7c0348ee28e93bcbb006d613b6d","modified":1506397161793},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1506397161809},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1506397161804},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1506397161813},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1506397161817},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1506397161820},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1506397161800},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1506397161827},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1506397161831},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e0aa5d7adc1218a324a484abe3513e9545f89067","modified":1506397161796},{"_id":"source/_posts/website-high-performance.md","hash":"88130b8064c88dcf9a711ceff310feb718d2c1b7","modified":1507873826408},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1506397161897},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"ba0839518db2cb9dafee67ca5e471219bfba2e90","modified":1506397161824},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1506397161919},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1506397161922},{"_id":"themes/BlueLake/source/css/style.styl","hash":"45776bc176bc8ed0d664e953e23d6a0a9a030929","modified":1506397161901},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1506397161937},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1506397161925},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1506397161942},{"_id":"source/about/index/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161727},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","hash":"e91f2139090c702ae554fa2a62f492bc2e175941","modified":1506397161659},{"_id":"source/_posts/api-version/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161668},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1506397161915},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1506397161952},{"_id":"source/_posts/apidoc-java/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161668},{"_id":"source/_posts/distributed-id-snowflake/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161678},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1506397161910},{"_id":"source/_posts/http-protocol-overview/b.png","hash":"d2158e4cc7c3129a86163fc087f3fdc70cc3f570","modified":1508474372253},{"_id":"source/_posts/microservice-think/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161687},{"_id":"source/_posts/hashicorp-vault/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1507946102416},{"_id":"source/_posts/linux-command-use/a.png","hash":"dc9aa307fe9221d90f71dfa95841ea3acbab18cc","modified":1507964983211},{"_id":"source/_posts/redis-cluster-centos/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161696},{"_id":"source/_posts/http-protocol-overview/a.png","hash":"cdc1232c447bc61a7c3df4fd8ecf4c7947b7c739","modified":1508474372247},{"_id":"source/_posts/restful-api-dev/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506735063774},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161706},{"_id":"source/_posts/scloud-zuul-exception/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161717},{"_id":"source/_posts/pivotal-web-service-start/d.png","hash":"70fedd27e98b3d0b83af6ad4f9538a3fc8a83c05","modified":1507795643856},{"_id":"source/_posts/linux-command-use/b.png","hash":"12fb8951ab9e7361d775a1b0ceb7546cfae5c7fe","modified":1507965022913},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1506397161932},{"_id":"source/_posts/pivotal-web-service-start/a.png","hash":"d6731486aa76a72a980706fda1735e5b7bc05942","modified":1507794087890},{"_id":"source/_posts/scloud-zuul-filters/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1507708559519},{"_id":"source/_posts/scloud-zuul-start/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1507708559519},{"_id":"source/_posts/sboot-dev-error-show/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506735063780},{"_id":"source/_posts/pivotal-web-service-start/c.png","hash":"222f2f53d4d37628d4d926c5da817e3a76f14458","modified":1507795612644},{"_id":"source/_posts/website-high-performance/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1506397161910},{"_id":"source/_posts/sboot-change-contextpath/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1506397161668},{"_id":"source/_posts/pivotal-web-service-start/b.png","hash":"2e35d944a620506caa3ab18f337d71c92fd391e0","modified":1507795425758}],"Category":[{"name":"api-manage","_id":"cj94zwuvp00031cra4rnv9gy3"},{"name":"java","_id":"cj94zwuwo000d1cralizvjhi7"},{"name":"分布式系统","_id":"cj94zwuwt000j1crae7r9uykr"},{"name":"git","_id":"cj94zwuwu000n1craen56k1sh"},{"name":"Nginx","_id":"cj94zwuwv000r1crad3wc6k3y"},{"name":"github","_id":"cj94zwuww000v1crasjqt4nyi"},{"name":"json","_id":"cj94zwuwx000z1cra4cwftmmp"},{"name":"jvm","_id":"cj94zwuxv00171cra8k3efa7m"},{"name":"linux","_id":"cj94zwuy0001d1crau8bwnqc4"},{"name":"http协议","_id":"cj94zwuy7001j1craytw0nxiu"},{"name":"micro-service","_id":"cj94zwuyd001q1crao7ur98tx"},{"name":"security","_id":"cj94zwuyk001w1cravxec8d8b"},{"name":"数据库","_id":"cj94zwuyr00241cra76awlq7m"},{"name":"spring-boot","_id":"cj94zwuyw002a1cramzp179ge"},{"name":"spring-cloud","_id":"cj94zwuyy002f1cra21xslmmu"},{"name":"Pivotal Web Service","_id":"cj94zwuz1002q1crazncf3szj"},{"name":"TypeScript","_id":"cj94zwuz2002v1cra1sbvge7k"},{"name":"架构","_id":"cj94zwv24003e1cra5kalhhl5"}],"Data":[],"Page":[{"title":"关于","date":"2017-09-20T03:52:09.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-09-20 11:52:09\n---\n","updated":"2017-09-26T03:39:21.722Z","path":"about/index.html","comments":1,"layout":"page","_id":"cj94zwuvg00001craqsfsxizj","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"apidoc在spring-mvc中实践","date":"2017-09-24T15:01:49.000Z","_content":"\n官网：http://apidocjs.com/\n","source":"_posts/apidoc-java.md","raw":"---\ntitle: apidoc在spring-mvc中实践\ndate: 2017-09-24 23:01:49\ncategories: api-manage\ntags: apidoc\n---\n\n官网：http://apidocjs.com/\n","slug":"apidoc-java","published":1,"updated":"2017-09-26T03:39:21.662Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuvi00011craow2fzfwr","content":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"external\">http://apidocjs.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"external\">http://apidocjs.com/</a></p>\n"},{"title":"rest-api版本迭代管理实践","date":"2017-09-26T06:23:44.000Z","_content":"","source":"_posts/api-version.md","raw":"---\ntitle: rest-api版本迭代管理实践\ndate: 2017-09-26 14:23:44\ncategories: api-manage\ntags: api-version-manage\n---\n","slug":"api-version","published":1,"updated":"2017-09-26T06:27:26.648Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuvm00021craur5a65ge","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"Cron 语法","date":"2017-10-24T02:23:19.000Z","_content":"\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]\n","source":"_posts/cron-grammar.md","raw":"---\ntitle:  Cron 语法\ndate: 2017-10-24 10:23:19\ncategories: java\ntags: cron-grammar\n---\n\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]\n","slug":"cron-grammar","published":1,"updated":"2017-10-24T02:32:12.441Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuvr00051crauepu8m4r","content":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]</p>\n"},{"title":"分布式ID生成-snowflake算法","date":"2017-09-20T03:06:57.000Z","_content":"## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","source":"_posts/distributed-id-snowflake.md","raw":"---\ntitle: 分布式ID生成-snowflake算法\ndate: 2017-09-20 11:06:57\ncategories: 分布式系统\ntags: snowflake算法\n---\n## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","slug":"distributed-id-snowflake","published":1,"updated":"2017-09-26T03:39:21.671Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuw200061cra3wf3jh0a","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\" alt=\"a.png\" title=\"\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\" alt=\"a.png\" title=\"\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>"},{"title":"git在centos7下源码编译安装","date":"2017-10-14T02:04:31.000Z","_content":"\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>   n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","source":"_posts/git-install-in-centos7.md","raw":"---\ntitle: git在centos7下源码编译安装\ndate: 2017-10-14 10:04:31\ncategories: git\ntags: git-install-in-centos\n---\n\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>   n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","slug":"git-install-in-centos7","published":1,"updated":"2017-10-14T02:09:27.704Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuwd00071cralq9h0f6f","content":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"external\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br>  n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"external\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"external\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"external\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br>  n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"external\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"external\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>"},{"title":"Keepalived+LVS+Nginx负载均衡之高可用","date":"2017-09-23T01:48:19.000Z","_content":"### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","source":"_posts/Keepalived-LVS-Nginx.md","raw":"---\ntitle: Keepalived+LVS+Nginx负载均衡之高可用\ndate: 2017-09-23 09:48:19\ncategories: Nginx\ntags: nginx负载均衡\n---\n### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","slug":"Keepalived-LVS-Nginx","published":1,"updated":"2017-09-26T03:39:21.653Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuwj000b1cra72v3jvwz","content":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"external\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"external\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\" alt=\"a.png\" title=\"\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"external\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"external\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\" alt=\"a.png\" title=\"\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>"},{"title":"如何直接在github网站上更新你fork的repo","date":"2017-10-13T01:39:58.000Z","_content":"玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","source":"_posts/github-fork-repo-update.md","raw":"---\ntitle: 如何直接在github网站上更新你fork的repo\ndate: 2017-10-13 09:39:58\ncategories: github\ntags: github-fork-repo-update\n---\n玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","slug":"github-fork-repo-update","published":1,"updated":"2017-10-13T01:57:23.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuwm000c1cra87y74jqw","content":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>"},{"title":"jackson使用录","date":"2017-10-01T01:07:36.000Z","_content":"## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","source":"_posts/jackson-show-time.md","raw":"---\ntitle: jackson使用录\ndate: 2017-10-01 09:07:36\ncategories: json\ntags: jackson\n---\n## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","slug":"jackson-show-time","published":1,"updated":"2017-10-14T01:55:02.419Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuwq000g1craavolr7pp","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"external\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"external\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>"},{"title":"jvm优化-垃圾回收机制","date":"2017-10-20T04:51:08.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1548866","source":"_posts/jvm-gc.md","raw":"---\ntitle: jvm优化-垃圾回收机制\ndate: 2017-10-20 12:51:08\ncategories: jvm\ntags: gc垃圾回收\n---\n\nhttps://my.oschina.net/u/1859679/blog/1548866","slug":"jvm-gc","published":1,"updated":"2017-10-20T04:52:13.120Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuxt00151craxf3b9arn","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n"},{"title":"git服务器使用","date":"2017-10-14T01:58:47.000Z","_content":"搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","source":"_posts/git-server-build.md","raw":"---\ntitle: git服务器使用\ndate: 2017-10-14 09:58:47\ncategories: git\ntags: git-server-build\n---\n搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","slug":"git-server-build","published":1,"updated":"2017-10-20T04:39:32.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuxu00161cral5uqq34a","content":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone git@119.23.78.160:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br>git@119.23.78.160’s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone git@119.23.78.160:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br>git@119.23.78.160’s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n"},{"title":"linux常用命令使用收藏","date":"2017-10-14T03:26:18.000Z","_content":"收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n","source":"_posts/linux-command-use.md","raw":"---\ntitle: linux常用命令使用收藏\ndate: 2017-10-14 11:26:18\ncategories: linux\ntags: linux-command\n---\n收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n","slug":"linux-command-use","published":1,"updated":"2017-10-14T07:41:40.529Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuxv00191cratx8edwgl","content":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p><em>警告</em> 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p><em>说明</em> 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2>","site":{"data":{}},"excerpt":"","more":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p><em>警告</em> 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p><em>说明</em> 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2>"},{"title":"jvm优化-监控工具","date":"2017-10-20T04:52:40.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1552290","source":"_posts/jvm-look-tools.md","raw":"---\ntitle: jvm优化-监控工具\ndate: 2017-10-20 12:52:40\ncategories: jvm\ntags: jvm监控工具\n---\n\nhttps://my.oschina.net/u/1859679/blog/1552290","slug":"jvm-look-tools","published":1,"updated":"2017-10-20T04:53:18.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuxx001a1crat17joq4z","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n"},{"title":"http协议概述(学习笔记)","date":"2017-10-17T13:45:50.000Z","_content":"\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","source":"_posts/http-protocol-overview.md","raw":"---\ntitle: http协议概述(学习笔记)\ndate: 2017-10-17 21:45:50\ncategories: http协议\ntags: http-overview\n---\n\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","slug":"http-protocol-overview","published":1,"updated":"2017-10-20T04:39:32.240Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuxz001b1craqzktna6x","content":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\" alt=\"a.png\" title=\"\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>","site":{"data":{}},"excerpt":"","more":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\" alt=\"a.png\" title=\"\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>"},{"title":"微服务实践思考","date":"2017-09-26T02:14:45.000Z","_content":"","source":"_posts/microservice-think.md","raw":"---\ntitle: 微服务实践思考\ndate: 2017-09-26 10:14:45\ncategories: micro-service\ntags: 微服务实践总结\n---\n","slug":"microservice-think","published":1,"updated":"2017-09-26T03:39:21.680Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuy2001g1cra4uob35ej","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"HashiCorp Vault使用　","date":"2017-09-30T15:40:58.000Z","_content":"## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","source":"_posts/hashicorp-vault.md","raw":"---\ntitle: HashiCorp Vault使用　\ndate: 2017-09-30 23:40:58\ncategories: security\ntags: hashicorp-vault\n---\n## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","slug":"hashicorp-vault","published":1,"updated":"2017-10-14T01:55:02.413Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuy4001h1craih5uqyzv","content":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"external\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"external\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"external\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"external\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"external\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"external\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n"},{"title":"redis一主多从集群配置","date":"2017-09-21T05:46:08.000Z","_content":"","source":"_posts/redis-cluster-centos.md","raw":"---\ntitle: redis一主多从集群配置\ndate: 2017-09-21 13:46:08\ncategories: 数据库\ntags:   redis\n---\n","slug":"redis-cluster-centos","published":1,"updated":"2017-09-26T03:39:21.690Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuy8001l1crazat6iypb","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"restful-api设计摘要","date":"2017-09-29T14:07:54.000Z","_content":"本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","source":"_posts/restful-api-dev.md","raw":"---\ntitle: restful-api设计摘要\ndate: 2017-09-29 22:07:54\ncategories: api-manage\ntags: restful-api\n---\n本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","slug":"restful-api-dev","published":1,"updated":"2017-09-30T01:31:39.959Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuya001o1craz7wisnk7","content":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"external\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"external\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"external\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"external\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"external\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"external\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n"},{"title":"spring-boot开发常见异常收录","date":"2017-09-28T16:31:25.000Z","_content":"\n## 1. 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n### 1.2　不传递依赖\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n### 1.3 在@SpringBootApplication中排除其注入\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n\n","source":"_posts/sboot-dev-error-show.md","raw":"---\ntitle: spring-boot开发常见异常收录\ndate: 2017-09-29 00:31:25\ncategories: spring-boot\ntags: sboot-often-error\n---\n\n## 1. 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n### 1.2　不传递依赖\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n### 1.3 在@SpringBootApplication中排除其注入\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n\n","slug":"sboot-dev-error-show","published":1,"updated":"2017-09-30T01:31:03.776Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuyf001s1crazt03rydq","content":"<h2 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1. 异常一：缺少jpa数据源配置\"></a>1. 异常一：缺少jpa数据源配置</h2><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h3 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h3><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h3 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2　不传递依赖\"></a>1.2　不传递依赖</h3><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h3 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h3><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1. 异常一：缺少jpa数据源配置\"></a>1. 异常一：缺少jpa数据源配置</h2><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h3 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h3><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h3 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2　不传递依赖\"></a>1.2　不传递依赖</h3><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h3 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h3><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre>"},{"title":"spring-cloud-zuul网关统一异常处理","date":"2017-09-23T09:48:05.000Z","_content":"","source":"_posts/scloud-zuul-exception.md","raw":"---\ntitle: spring-cloud-zuul网关统一异常处理\ndate: 2017-09-23 17:48:05\ncategories: spring-cloud\ntags: zuul-exception\n---\n","slug":"scloud-zuul-exception","published":1,"updated":"2017-10-11T07:47:33.183Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuyj001u1crab9xvyg05","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"scloud-zuul-filters网关过滤","date":"2017-10-11T08:56:22.000Z","_content":"在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","source":"_posts/scloud-zuul-filters.md","raw":"---\ntitle: scloud-zuul-filters网关过滤\ndate: 2017-10-11 16:56:22\ncategories: spring-cloud\ntags: zuul-filters\n---\n在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","slug":"scloud-zuul-filters","published":1,"updated":"2017-10-11T09:21:14.153Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuyl001y1crawe6pcadb","content":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n"},{"title":"spring-boot更改ContextPath方法","date":"2017-09-28T06:03:23.000Z","_content":"在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","source":"_posts/sboot-change-contextpath.md","raw":"---\ntitle: spring-boot更改ContextPath方法\ndate: 2017-09-28 14:03:23\ncategories: spring-boot\ntags: change-contextpath-way\n---\n在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","slug":"sboot-change-contextpath","published":1,"updated":"2017-09-28T06:21:58.172Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuym00211cra0cr84ubl","content":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n"},{"title":"在Pivotal Web Service上发布Spring Boot应用","date":"2017-10-12T07:08:33.000Z","_content":"\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","source":"_posts/pivotal-web-service-start.md","raw":"---\ntitle: 在Pivotal Web Service上发布Spring Boot应用\ndate: 2017-10-12 15:08:33\ncategories: Pivotal Web Service\ntags: pws-push\n---\n\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","slug":"pivotal-web-service-start","published":1,"updated":"2017-10-12T08:23:54.735Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuyn00231cram1s0pgo2","content":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"external\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\" alt=\"a.png\" title=\"\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"external\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\" alt=\"b.png\" title=\"\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\" alt=\"c.png\" title=\"\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"external\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\" alt=\"d.png\" title=\"\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"external\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\" alt=\"a.png\" title=\"\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"external\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\" alt=\"b.png\" title=\"\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\" alt=\"c.png\" title=\"\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"external\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\" alt=\"d.png\" title=\"\"></li>\n</ol>\n"},{"title":"TypeScript学习(一)","date":"2017-10-13T15:33:23.000Z","_content":"","source":"_posts/tslang-study-one.md","raw":"---\ntitle: TypeScript学习(一)\ndate: 2017-10-13 23:33:23\ncategories: TypeScript\ntags: \n---\n","slug":"tslang-study-one","published":1,"updated":"2017-10-14T01:55:02.421Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuyt00271cra10o9721d","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"spring-cloud-zuul网关入门","date":"2017-10-11T07:42:53.000Z","_content":"## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","source":"_posts/scloud-zuul-start.md","raw":"---\ntitle: spring-cloud-zuul网关入门\ndate: 2017-10-11 15:42:53\ncategories: spring-cloud\ntags: zuul-start\n---\n## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","slug":"scloud-zuul-start","published":1,"updated":"2017-10-11T08:33:50.826Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuyu00281crau2p2bjq9","content":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\" alt=\"a.png\" title=\"\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\" alt=\"a.png\" title=\"\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>"},{"title":"spring-cloud-feign在使用中遇到的一些问题","date":"2017-09-24T13:53:46.000Z","_content":"\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","source":"_posts/scloud-feign-anyquestion.md","raw":"---\ntitle: spring-cloud-feign在使用中遇到的一些问题\ndate: 2017-09-24 21:53:46\ncategories: spring-cloud\ntags: feign使用常见问题\n---\n\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","slug":"scloud-feign-anyquestion","published":1,"updated":"2017-09-26T03:39:21.700Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwuyx002c1cratmr8ixbq","content":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n"},{"title":"网站的高性能","date":"2017-10-13T02:33:45.000Z","_content":"_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","source":"_posts/website-high-performance.md","raw":"---\ntitle: 网站的高性能\ndate: 2017-10-13 10:33:45\ncategories: 架构\ntags: website-high-performance\n---\n_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","slug":"website-high-performance","published":1,"updated":"2017-10-13T05:50:26.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cj94zwv23003d1craui8wsme5","content":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n</blockquote>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol>\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol>\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol>\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol>\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>","site":{"data":{}},"excerpt":"","more":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n</blockquote>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol>\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol>\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol>\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol>\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>"}],"PostAsset":[{"_id":"source/_posts/apidoc-java/a.png","post":"cj94zwuvi00011craow2fzfwr","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/a.png","post":"cj94zwuvm00021craur5a65ge","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/distributed-id-snowflake/a.png","post":"cj94zwuw200061cra3wf3jh0a","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","post":"cj94zwuwm000c1cra87y74jqw","slug":"favicon.ico","modified":1,"renderable":1},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","post":"cj94zwuwj000b1cra72v3jvwz","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/microservice-think/a.png","post":"cj94zwuy2001g1cra4uob35ej","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/hashicorp-vault/a.png","post":"cj94zwuy4001h1craih5uqyzv","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/redis-cluster-centos/a.png","post":"cj94zwuy8001l1crazat6iypb","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/restful-api-dev/a.png","post":"cj94zwuya001o1craz7wisnk7","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/sboot-dev-error-show/a.png","post":"cj94zwuyf001s1crazt03rydq","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-exception/a.png","post":"cj94zwuyj001u1crab9xvyg05","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-filters/a.png","post":"cj94zwuyl001y1crawe6pcadb","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/sboot-change-contextpath/a.png","post":"cj94zwuym00211cra0cr84ubl","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-start/a.png","post":"cj94zwuyu00281crau2p2bjq9","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","post":"cj94zwuyx002c1cratmr8ixbq","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/http-protocol-overview/a.png","post":"cj94zwuxz001b1craqzktna6x","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/http-protocol-overview/b.png","post":"cj94zwuxz001b1craqzktna6x","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/linux-command-use/a.png","post":"cj94zwuxv00191cratx8edwgl","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/linux-command-use/b.png","post":"cj94zwuxv00191cratx8edwgl","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/a.png","post":"cj94zwuyn00231cram1s0pgo2","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/b.png","slug":"b.png","post":"cj94zwuyn00231cram1s0pgo2","modified":1,"renderable":0},{"_id":"source/_posts/pivotal-web-service-start/c.png","post":"cj94zwuyn00231cram1s0pgo2","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/d.png","post":"cj94zwuyn00231cram1s0pgo2","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/website-high-performance/favicon.ico","post":"cj94zwv23003d1craui8wsme5","slug":"favicon.ico","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cj94zwuvi00011craow2fzfwr","category_id":"cj94zwuvp00031cra4rnv9gy3","_id":"cj94zwuwo000e1cra2rnm6xbo"},{"post_id":"cj94zwuvm00021craur5a65ge","category_id":"cj94zwuvp00031cra4rnv9gy3","_id":"cj94zwuwt000i1craoa7nd29r"},{"post_id":"cj94zwuvr00051crauepu8m4r","category_id":"cj94zwuwo000d1cralizvjhi7","_id":"cj94zwuwu000m1cradmr7ffzm"},{"post_id":"cj94zwuw200061cra3wf3jh0a","category_id":"cj94zwuwt000j1crae7r9uykr","_id":"cj94zwuwv000q1cra16bf0q5m"},{"post_id":"cj94zwuwd00071cralq9h0f6f","category_id":"cj94zwuwu000n1craen56k1sh","_id":"cj94zwuww000u1crafypr4ci9"},{"post_id":"cj94zwuwj000b1cra72v3jvwz","category_id":"cj94zwuwv000r1crad3wc6k3y","_id":"cj94zwuwx000y1crap5p946l2"},{"post_id":"cj94zwuwm000c1cra87y74jqw","category_id":"cj94zwuww000v1crasjqt4nyi","_id":"cj94zwuwz00121cratjb1ab4q"},{"post_id":"cj94zwuwq000g1craavolr7pp","category_id":"cj94zwuwx000z1cra4cwftmmp","_id":"cj94zwux000141cra16468t3u"},{"post_id":"cj94zwuxu00161cral5uqq34a","category_id":"cj94zwuwu000n1craen56k1sh","_id":"cj94zwuy0001c1crag982j23b"},{"post_id":"cj94zwuxx001a1crat17joq4z","category_id":"cj94zwuxv00171cra8k3efa7m","_id":"cj94zwuy7001i1cra5m122178"},{"post_id":"cj94zwuxt00151craxf3b9arn","category_id":"cj94zwuxv00171cra8k3efa7m","_id":"cj94zwuy9001m1cra7w3exf7b"},{"post_id":"cj94zwuxv00191cratx8edwgl","category_id":"cj94zwuy0001d1crau8bwnqc4","_id":"cj94zwuyc001p1craek1xh1u2"},{"post_id":"cj94zwuxz001b1craqzktna6x","category_id":"cj94zwuy7001j1craytw0nxiu","_id":"cj94zwuyk001v1craawnlctlx"},{"post_id":"cj94zwuya001o1craz7wisnk7","category_id":"cj94zwuvp00031cra4rnv9gy3","_id":"cj94zwuym001z1cralnke3ng2"},{"post_id":"cj94zwuy2001g1cra4uob35ej","category_id":"cj94zwuyd001q1crao7ur98tx","_id":"cj94zwuyn00221cra8pr937jc"},{"post_id":"cj94zwuy4001h1craih5uqyzv","category_id":"cj94zwuyk001w1cravxec8d8b","_id":"cj94zwuyv00291crashny1fos"},{"post_id":"cj94zwuy8001l1crazat6iypb","category_id":"cj94zwuyr00241cra76awlq7m","_id":"cj94zwuyy002e1crat1eqya84"},{"post_id":"cj94zwuyf001s1crazt03rydq","category_id":"cj94zwuyw002a1cramzp179ge","_id":"cj94zwuyz002i1cramg3f79sj"},{"post_id":"cj94zwuyj001u1crab9xvyg05","category_id":"cj94zwuyy002f1cra21xslmmu","_id":"cj94zwuz0002n1crab2ogdykg"},{"post_id":"cj94zwuyl001y1crawe6pcadb","category_id":"cj94zwuyy002f1cra21xslmmu","_id":"cj94zwuz1002r1crawmdfb2zf"},{"post_id":"cj94zwuym00211cra0cr84ubl","category_id":"cj94zwuyw002a1cramzp179ge","_id":"cj94zwuz2002u1cra2b5iqjev"},{"post_id":"cj94zwuyn00231cram1s0pgo2","category_id":"cj94zwuz1002q1crazncf3szj","_id":"cj94zwuz3002y1cra999a2weq"},{"post_id":"cj94zwuyt00271cra10o9721d","category_id":"cj94zwuz2002v1cra1sbvge7k","_id":"cj94zwuz400331crag2zhdpen"},{"post_id":"cj94zwuyu00281crau2p2bjq9","category_id":"cj94zwuyy002f1cra21xslmmu","_id":"cj94zwuz500361crahrr1jlqg"},{"post_id":"cj94zwuyx002c1cratmr8ixbq","category_id":"cj94zwuyy002f1cra21xslmmu","_id":"cj94zwuz600391cravtp045bz"},{"post_id":"cj94zwv23003d1craui8wsme5","category_id":"cj94zwv24003e1cra5kalhhl5","_id":"cj94zwv25003h1crazshblocf"}],"PostTag":[{"post_id":"cj94zwuvi00011craow2fzfwr","tag_id":"cj94zwuvr00041craf68avi1c","_id":"cj94zwuwi000a1crar901tgjp"},{"post_id":"cj94zwuvm00021craur5a65ge","tag_id":"cj94zwuwf00091cra4ytm12qp","_id":"cj94zwuwr000h1crall8133np"},{"post_id":"cj94zwuvr00051crauepu8m4r","tag_id":"cj94zwuwp000f1crawqnw3h34","_id":"cj94zwuwu000l1cralqvzu15l"},{"post_id":"cj94zwuw200061cra3wf3jh0a","tag_id":"cj94zwuwt000k1crazbqsx7n0","_id":"cj94zwuwv000p1cra5hdtpfrl"},{"post_id":"cj94zwuwd00071cralq9h0f6f","tag_id":"cj94zwuwu000o1cra0zpgh6b4","_id":"cj94zwuww000t1crabnq3kdoy"},{"post_id":"cj94zwuwj000b1cra72v3jvwz","tag_id":"cj94zwuwv000s1cra0sggmtyi","_id":"cj94zwuwx000x1cra0v9j6z1z"},{"post_id":"cj94zwuwm000c1cra87y74jqw","tag_id":"cj94zwuww000w1cran47gvocb","_id":"cj94zwuwz00111crafc198zwo"},{"post_id":"cj94zwuwq000g1craavolr7pp","tag_id":"cj94zwuwx00101crafq5b6jwp","_id":"cj94zwuwz00131cralaqqxov0"},{"post_id":"cj94zwuxt00151craxf3b9arn","tag_id":"cj94zwuxv00181cra1nhoilk3","_id":"cj94zwuy1001f1cramhmp47lj"},{"post_id":"cj94zwuxu00161cral5uqq34a","tag_id":"cj94zwuy1001e1cra5ohd2o43","_id":"cj94zwuy9001n1crabe7wybx8"},{"post_id":"cj94zwuxv00191cratx8edwgl","tag_id":"cj94zwuy7001k1cranr3aqbct","_id":"cj94zwuyi001t1crauc39py5w"},{"post_id":"cj94zwuxx001a1crat17joq4z","tag_id":"cj94zwuye001r1cra8gtz8g2w","_id":"cj94zwuym00201craqjk4w6it"},{"post_id":"cj94zwuxz001b1craqzktna6x","tag_id":"cj94zwuyl001x1crancri8wtj","_id":"cj94zwuys00261cratj6qc6ts"},{"post_id":"cj94zwuy2001g1cra4uob35ej","tag_id":"cj94zwuys00251craw2i63ngu","_id":"cj94zwuyy002d1craclyi4v14"},{"post_id":"cj94zwuy4001h1craih5uqyzv","tag_id":"cj94zwuyw002b1crab126mx2e","_id":"cj94zwuyz002h1cra0up5wbjh"},{"post_id":"cj94zwuy8001l1crazat6iypb","tag_id":"cj94zwuyz002g1cra09ekyw1c","_id":"cj94zwuz0002l1crac1xnfh8x"},{"post_id":"cj94zwuya001o1craz7wisnk7","tag_id":"cj94zwuz0002k1cra68uqi1yh","_id":"cj94zwuz1002p1cra5ek8c8cd"},{"post_id":"cj94zwuyf001s1crazt03rydq","tag_id":"cj94zwuz1002o1crau78xmj94","_id":"cj94zwuz2002t1crawc42p51c"},{"post_id":"cj94zwuyj001u1crab9xvyg05","tag_id":"cj94zwuz2002s1cra3yxbrkud","_id":"cj94zwuz3002x1crany0svf7s"},{"post_id":"cj94zwuyl001y1crawe6pcadb","tag_id":"cj94zwuz3002w1cra5y8d0tyu","_id":"cj94zwuz400311craee0iuimw"},{"post_id":"cj94zwuym00211cra0cr84ubl","tag_id":"cj94zwuz400301craw4cf7b5z","_id":"cj94zwuz500351cra93lfb0b5"},{"post_id":"cj94zwuyn00231cram1s0pgo2","tag_id":"cj94zwuz500341crato9t1wsf","_id":"cj94zwuz600381craz4v4774r"},{"post_id":"cj94zwuyu00281crau2p2bjq9","tag_id":"cj94zwuz500371crao75y1awv","_id":"cj94zwuz6003b1crag6liyy39"},{"post_id":"cj94zwuyx002c1cratmr8ixbq","tag_id":"cj94zwuz6003a1crag9xzhkij","_id":"cj94zwuz6003c1craen8gyy1h"},{"post_id":"cj94zwv23003d1craui8wsme5","tag_id":"cj94zwv24003f1cray78f8eb7","_id":"cj94zwv25003g1cra0g19t4q8"}],"Tag":[{"name":"apidoc","_id":"cj94zwuvr00041craf68avi1c"},{"name":"api-version-manage","_id":"cj94zwuwf00091cra4ytm12qp"},{"name":"cron-grammar","_id":"cj94zwuwp000f1crawqnw3h34"},{"name":"snowflake算法","_id":"cj94zwuwt000k1crazbqsx7n0"},{"name":"git-install-in-centos","_id":"cj94zwuwu000o1cra0zpgh6b4"},{"name":"nginx负载均衡","_id":"cj94zwuwv000s1cra0sggmtyi"},{"name":"github-fork-repo-update","_id":"cj94zwuww000w1cran47gvocb"},{"name":"jackson","_id":"cj94zwuwx00101crafq5b6jwp"},{"name":"gc垃圾回收","_id":"cj94zwuxv00181cra1nhoilk3"},{"name":"git-server-build","_id":"cj94zwuy1001e1cra5ohd2o43"},{"name":"linux-command","_id":"cj94zwuy7001k1cranr3aqbct"},{"name":"jvm监控工具","_id":"cj94zwuye001r1cra8gtz8g2w"},{"name":"http-overview","_id":"cj94zwuyl001x1crancri8wtj"},{"name":"微服务实践总结","_id":"cj94zwuys00251craw2i63ngu"},{"name":"hashicorp-vault","_id":"cj94zwuyw002b1crab126mx2e"},{"name":"redis","_id":"cj94zwuyz002g1cra09ekyw1c"},{"name":"restful-api","_id":"cj94zwuz0002k1cra68uqi1yh"},{"name":"sboot-often-error","_id":"cj94zwuz1002o1crau78xmj94"},{"name":"zuul-exception","_id":"cj94zwuz2002s1cra3yxbrkud"},{"name":"zuul-filters","_id":"cj94zwuz3002w1cra5y8d0tyu"},{"name":"change-contextpath-way","_id":"cj94zwuz400301craw4cf7b5z"},{"name":"pws-push","_id":"cj94zwuz500341crato9t1wsf"},{"name":"zuul-start","_id":"cj94zwuz500371crao75y1awv"},{"name":"feign使用常见问题","_id":"cj94zwuz6003a1crag9xzhkij"},{"name":"website-high-performance","_id":"cj94zwv24003f1cray78f8eb7"}]}}