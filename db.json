{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon-1.ico","path":"favicon-1.ico","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"source/about/index/a.png","path":"about/index/a.png","modified":1,"renderable":0},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/_config.yml","hash":"21c112a085ddafdcefedabf88b07c490f94645ad","modified":1525872891621},{"_id":"themes/BlueLake/LICENSE","hash":"3e191ca3f51efc111863c4941051291a696ef43e","modified":1514711625518},{"_id":"themes/BlueLake/README.md","hash":"152969bd5a7e94a595d058f085c517b65d3b61d2","modified":1514711625518},{"_id":"themes/BlueLake/README.en.md","hash":"b9f84036214ec79a8c319c5383696e0076305dfe","modified":1514711625518},{"_id":"themes/BlueLake/package.json","hash":"e06eea20c64b2821631a49e8902e645bad2c5102","modified":1514711625518},{"_id":"source/_posts/Keepalived-LVS-Nginx.md","hash":"40e6768751ce4af43e5ce9ed623d37020d2fee4a","modified":1514711625226},{"_id":"source/_posts/api-version.md","hash":"4452f1ee34f9a81be8beeae1d8994d7d60e72ed4","modified":1524495128261},{"_id":"source/_posts/apidoc-java.md","hash":"69d3b383494ebcf132762faac05b87d1c074f37e","modified":1514711625226},{"_id":"source/_posts/centos-jdk8-install.md","hash":"c45d90571a3f16402a2e328c116fbff2bd08155f","modified":1514711625226},{"_id":"source/_posts/centos-login-without-pwd.md","hash":"c48676968d4286400b255e65258a55b1768f6113","modified":1514880056613},{"_id":"source/_posts/centos-maven-nexus.md","hash":"ca04509a6f1e085e630e410d7997a63dd365157d","modified":1514711625226},{"_id":"source/_posts/concourse-tutorial.md","hash":"80a15bc514afed5f10e901c27e105c1f3cd1fe47","modified":1521116223223},{"_id":"source/_posts/cron-grammar.md","hash":"378c95b617c1755d6319c0ef5d0d7b11b652e7f8","modified":1514711625234},{"_id":"source/_posts/distributed-difficulty.md","hash":"3fffdaa469a55ad0fca6b3a9f70afa8f703f0ba3","modified":1514711625234},{"_id":"source/_posts/distributed-id-snowflake.md","hash":"7e7225207976d2a10ebd5d52bf07cd6afcbb0b84","modified":1514711625234},{"_id":"source/_posts/docker-install-centos7.md","hash":"d248bb63ea89ffeeb858da676e0ca9b82796fb9d","modified":1514711625234},{"_id":"source/_posts/docker-install-ubuntu16.md","hash":"f02d682966c5ec0652b27d361df9ffc0b2de1863","modified":1519786956380},{"_id":"source/_posts/docker-lesson1.md","hash":"eeac1606b6f89e62ac26d516a71980c19feb5bd6","modified":1517542976647},{"_id":"source/_posts/docker-lesson3.md","hash":"4fdcf2a194101666ac3b473fd4c850e5484ec208","modified":1519873828394},{"_id":"source/_posts/fastdfs-start.md","hash":"21235d49d332718c07ba98a18f578b86497885be","modified":1525341506159},{"_id":"source/_posts/git-install-in-centos7.md","hash":"240c9d30e47863c0503b80d500a8c5e6253777a5","modified":1514711625234},{"_id":"source/_posts/docker-lesson2.md","hash":"2d5f52c05fef10266e28baee316405c5d6d55aa2","modified":1519782928509},{"_id":"source/_posts/git-server-build.md","hash":"824d7a106b63a96e769fcf961cfee087d6a3dacb","modified":1514711625234},{"_id":"source/_posts/github-fork-repo-update.md","hash":"13e864d5d3282d90fbe399b45b927441171b9818","modified":1514711625234},{"_id":"source/_posts/hashicorp-vault.md","hash":"22546b683001ab50ce0c4e926562eef79a3683b8","modified":1514711625234},{"_id":"source/_posts/hibernate-relation-mapping.md","hash":"3ce1c4a29bfcaf435063aa8b7625f33f9524a835","modified":1514711625234},{"_id":"source/_posts/http-protocol-overview.md","hash":"e9d01197107494acb41fe797399d6f9bb70db70d","modified":1514711625234},{"_id":"source/_posts/idea-XRebel.md","hash":"0c3f767b80f515e9bf688fc524b526f782e01f3b","modified":1514711625234},{"_id":"source/_posts/idea-file-template.md","hash":"b59b5557d6474113f2b75a0f8616139a381629b4","modified":1518252001612},{"_id":"source/_posts/idea-good-plug.md","hash":"6bde8d05160953db2491f6dfddf803f532a637d3","modified":1525742498500},{"_id":"source/_posts/istio-start.md","hash":"90e727779628930ba073d91af0ea103fac2ae45e","modified":1520902695217},{"_id":"source/_posts/jackson-show-time.md","hash":"0d0e805ff335c39b92dbb4dfda5d75bae7ddec1c","modified":1514711625234},{"_id":"source/_posts/javapoet-apt-annotation.md","hash":"154ee14e5645aafe4557a9f08fd6657a4bc8409e","modified":1525354133629},{"_id":"source/_posts/javase-cglib.md","hash":"28bc673e55cdbf49d72ac6e265e3d6d43ca07527","modified":1514711625234},{"_id":"source/_posts/javase-nio-buffer.md","hash":"99f2139fe4f828f97390955b6af9e382a2f73b1f","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven.md","hash":"55b37da48618eb533e5951810a356afccae2fbc1","modified":1514711625238},{"_id":"source/_posts/jvm-gc.md","hash":"2f47e9e2b8ff504e0a596763eec7a4b1a1015922","modified":1514711625242},{"_id":"source/_posts/jvm-look-tools.md","hash":"0981f8163278b6b79d81be818805a270796bd1ad","modified":1514711625242},{"_id":"source/_posts/jwt-study.md","hash":"38a5e245a5e4ad0aa25ecbeb5b2d2fc5c0b558c9","modified":1520498843050},{"_id":"source/_posts/k8s-start.md","hash":"6c8cb436687ad8f038e582c034d4bc59f64e7350","modified":1520902979380},{"_id":"source/_posts/linux-command-use.md","hash":"d459962ee2c06e386d85ace8680e885922d5cf43","modified":1514711625242},{"_id":"source/_posts/linux-ubuntu-commom.md","hash":"8078b801e2f2ffa4b3cb8092b4fee9884f3fe4e5","modified":1519897973400},{"_id":"source/_posts/maven-ofen.md","hash":"91ada3b19de201df8799328c20db6971cca5d00e","modified":1517624516039},{"_id":"source/_posts/maven-use-error-collect.md","hash":"1d4eead7bee6ee63d3f60616ae23ee241586c90d","modified":1514711625246},{"_id":"source/_posts/microservice-think.md","hash":"44e876382bd198bd346307655ab9b5e750367461","modified":1514711625246},{"_id":"source/_posts/mysql-create.md","hash":"3d91c19b96b817c7cd19e57d5b9af92167e7a053","modified":1514711625246},{"_id":"source/_posts/pivotal-web-service-start.md","hash":"8553022730a6e3fa82f019ea61bd55172fbb91dc","modified":1514711625246},{"_id":"source/_posts/mysql-explain.md","hash":"302bbe78c4ddfdc93582220bb703894e9372ac32","modified":1514711625246},{"_id":"source/_posts/rabbitmq-action.md","hash":"cbbaf9d1616307dea6bf8b2c59f0f1cbfba4d092","modified":1516335304850},{"_id":"source/_posts/rabbitmq-install.md","hash":"7153c5684af17548e6ff8f20e6dd111e524ae4a0","modified":1516335022232},{"_id":"source/_posts/redis-cluster-centos.md","hash":"9c6ec4aa152dbb469d7a4804fbc8871a7ac4e8ad","modified":1514711625250},{"_id":"source/_posts/redis-conf.md","hash":"2b75090a3a00ddc1713b8defa9f6db98a3959d2c","modified":1514711625250},{"_id":"source/_posts/redis-common.md","hash":"6a7c29245dd968fcea16c198bc4e8f61ebd24ff1","modified":1521798471316},{"_id":"source/_posts/redis-install.md","hash":"135d8a45f1c0e89c12d2d39f03f7a641e654c211","modified":1516280866365},{"_id":"source/_posts/restful-api-dev.md","hash":"50222baaa66ed240557283bdf87b354abf848598","modified":1514711625250},{"_id":"source/_posts/sboot-change-contextpath.md","hash":"58adffac65c55472abd340e398a2d255e6c04518","modified":1514711625250},{"_id":"source/_posts/scloud-config-server-encrypt-decrypt.md","hash":"7fd308896805b5d0aba4fe9eb69ee5a0dfaa6baf","modified":1525484797113},{"_id":"source/_posts/scloud-feign-anyquestion.md","hash":"d76023b458de7eb5c3e24b967bf9b54fb8c330b1","modified":1514711625250},{"_id":"source/_posts/scloud-feign-config.md","hash":"9e9ebf389d32f9db387cc797f959be28f335798b","modified":1525783017408},{"_id":"source/_posts/scloud-hystrix-dashboard.md","hash":"f3e89d3edbf9a6c35f9e8a3972e06809ea4c4a1e","modified":1525786644902},{"_id":"source/_posts/scloud-hystrix.md","hash":"e66a49c64d31243393466576d56bc7b866766d07","modified":1525782865849},{"_id":"source/_posts/scloud-zuul-exception.md","hash":"2a7f045c768111bf998b466a283d1af844d43614","modified":1514711625250},{"_id":"source/_posts/scloud-zuul-filters.md","hash":"d091129d4e125e8e2865d1be81fc47a9b2e14767","modified":1514711625254},{"_id":"source/_posts/scloud-zuul-start.md","hash":"f27b17b984757bbb5b6d7c654db02981fd5adfe8","modified":1514711625254},{"_id":"source/_posts/shadowsocks-go.md","hash":"13c067e99d2a1ca0d85b3a11d244367732333472","modified":1524302190402},{"_id":"source/_posts/spring-boot-cors.md","hash":"b3ecf6b7b5468674ab31163acd0f2b22d3be46ac","modified":1514711625514},{"_id":"source/_posts/spring-boot-dev-error-show.md","hash":"035200b8e7af162e55c71bcb612cdf1de274fd9e","modified":1525678936571},{"_id":"source/_posts/spring-boot-cache.md","hash":"2c53c2812969bf460832ca3c26d42042c9268230","modified":1521797450363},{"_id":"source/_posts/spring-boot-async.md","hash":"2abd76f79b6eb1a3416d410734ae0295db88301c","modified":1514711625514},{"_id":"source/_posts/spring-jpa-multiple-datasource.md","hash":"ef4040c36014f83c0ea56b741340ffa0728d6964","modified":1514711625514},{"_id":"source/_posts/spring-boot-filter.md","hash":"a0520948f2868828f290819ca050d8f20e779ea3","modified":1524818093285},{"_id":"source/_posts/teamcity-use-start.md","hash":"149746f07b783e5232142ed4695578ad1ebb9904","modified":1514711625514},{"_id":"source/_posts/tslang-study-one.md","hash":"769829a427d9a1e078e7685d63d2899595814630","modified":1514711625514},{"_id":"source/_posts/vagrant-start.md","hash":"830bf73204c79f5ae8887de80342060ea987d387","modified":1524810475023},{"_id":"source/_posts/vault-study.md","hash":"eaafd45efe6e395829124fa13591d023f57b6454","modified":1520905520782},{"_id":"source/_posts/website-high-performance.md","hash":"88130b8064c88dcf9a711ceff310feb718d2c1b7","modified":1514711625514},{"_id":"source/about/index.md","hash":"e3f4fa91e62fbda6fda728765c7f3ceedace178f","modified":1514711625514},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"3e78b20edc66b153cb6b708734ad9aa5381266bc","modified":1514711625518},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"83ee131065111147d20ec13c4634a27ee4fd541d","modified":1514711625518},{"_id":"themes/BlueLake/languages/en.yml","hash":"88f4e4cffce5598f949192d7e76c863a0d409981","modified":1514711625518},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"d9f90ef2c6b4d8c95d142d021a5f47dda8462715","modified":1514711625518},{"_id":"themes/BlueLake/languages/ko.yml","hash":"20c7df4087ee65d75e96f68c71fdb050eb63677f","modified":1514711625518},{"_id":"themes/BlueLake/languages/tr.yml","hash":"1c623122f1ff7878595de6783bd83afc3a746373","modified":1514711625518},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"0755af57d92a07ecff0e327f78eb25b0623a5852","modified":1514711625518},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"61f419488d4a8f62c2b90ee766b6e68ba2e88bd7","modified":1514711625518},{"_id":"themes/BlueLake/layout/archive.jade","hash":"0497469c869f0ac28f150295dbddf6920e6582c1","modified":1514711625518},{"_id":"themes/BlueLake/layout/base.jade","hash":"0f0291077c4ab6d8fd8450744137e83be21fc639","modified":1514711625518},{"_id":"themes/BlueLake/layout/category.jade","hash":"384e2e2588ecab3f518f03f11f2b052d3827fad8","modified":1514711625518},{"_id":"themes/BlueLake/layout/page.jade","hash":"7d2a48f6a902605fd6cfc237e3c2f9c02d76492e","modified":1514711625518},{"_id":"themes/BlueLake/layout/index.jade","hash":"ba1ea647af5c134b1a950638ea864663b29d4e22","modified":1514711625518},{"_id":"themes/BlueLake/layout/post.jade","hash":"3025e7e259d69551a35f17db3c3981aaa77fe7bc","modified":1514711625518},{"_id":"themes/BlueLake/layout/tag.jade","hash":"835da21846c730f0e3e344dc7e2e59154030b4f7","modified":1514711625518},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1514711625518},{"_id":"themes/BlueLake/source/favicon-1.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1514711625518},{"_id":"themes/BlueLake/source/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1514711625518},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","hash":"e91f2139090c702ae554fa2a62f492bc2e175941","modified":1514711625226},{"_id":"source/_posts/api-version/a.png","hash":"a20c7a7f6a7ff592a425625fc54d16f438c55e4e","modified":1524477861269},{"_id":"source/_posts/api-version/b.png","hash":"8571a75e4e87d975781b9e3ee105e89684b0e207","modified":1524493581410},{"_id":"source/_posts/api-version/c.png","hash":"c82a2265f368c807f4c215c1a77db2cb3d755013","modified":1524493840647},{"_id":"source/_posts/api-version/d.png","hash":"1e3b87d4365ce11477d699a2af6ce5522c07950e","modified":1524494996988},{"_id":"source/_posts/api-version/e.png","hash":"bb846b7dea9e424afad7c3bf245416f03f2407f6","modified":1524495019440},{"_id":"source/_posts/apidoc-java/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625226},{"_id":"source/_posts/centos-maven-nexus/a.png","hash":"5ae80ce14b4f22a0c5f4d79e1189800e1d98d85d","modified":1514711625226},{"_id":"source/_posts/distributed-id-snowflake/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625234},{"_id":"source/_posts/docker-install-centos7/a.png","hash":"53319885ee2b62298a8dd0bbf97e66e075d63c33","modified":1514711625234},{"_id":"source/_posts/docker-install-ubuntu16/a.png","hash":"c0c863a0be8921034af76f51a76c0d908735ed9d","modified":1519786899000},{"_id":"source/_posts/docker-lesson3/a.png","hash":"127496e0d28b06a73bc5a0947c0cfc91dfb35bcd","modified":1519799379101},{"_id":"source/_posts/docker-lesson3/b.png","hash":"b8e0f05db2ca87f59e5b3b4360639abf6d595768","modified":1519802126538},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1514711625234},{"_id":"source/_posts/hashicorp-vault/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625234},{"_id":"source/_posts/http-protocol-overview/a.png","hash":"cdc1232c447bc61a7c3df4fd8ecf4c7947b7c739","modified":1514711625234},{"_id":"source/_posts/http-protocol-overview/b.png","hash":"d2158e4cc7c3129a86163fc087f3fdc70cc3f570","modified":1514711625234},{"_id":"source/_posts/idea-file-template/d.png","hash":"297c07f9361f15c4a75c2b0ff2d6f8ea35b76827","modified":1518247253000},{"_id":"source/_posts/idea-file-template/j.png","hash":"81739226bb3fe7555e03210d8fe15790ba896376","modified":1518249180000},{"_id":"source/_posts/javapoet-apt-annotation/a.png","hash":"7a3629a2c00c64293346769a80fd3f2b4882eb33","modified":1525353122393},{"_id":"source/_posts/javapoet-apt-annotation/b.png","hash":"1f0698b9282cca313661656e1bfd9263f3d09bac","modified":1525353542487},{"_id":"source/_posts/jenkins-java-maven/1.png","hash":"c89c3f8f039bb7e3c7b1c8ba19aa421ae5857aba","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/11.png","hash":"3d4d301aeb6a173b5681f47dbdefde4f3d91fc38","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/13.png","hash":"17b95987316f24f5a4aaa69703b05fbfb52b3872","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/14.png","hash":"5eb1accc639b0941b54e6e1c2ec81bcd4133b873","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/15.png","hash":"9bdbf1d30b1e1f50df5148d71c69f78a584b522a","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/3.png","hash":"6070bc84371a9ef3d9dbfc50767e9c47759815b3","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/4.png","hash":"7476872c0a08be7fbeda0ae5a52ebde940cfc0f6","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/5.png","hash":"64a8107a2748e6ac2fe9d1a42287b53a7dafd314","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/6.png","hash":"00ff2355e8986eb0014b5894230b6fd79462eeeb","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/7.png","hash":"e16f5020b6038b856ea2a01301f03f305e5a5399","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/8_1.png","hash":"3b6647cdf713816d9f60deced0a25f59a55798e5","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/9.png","hash":"dc3d500c3de6fc1c7c0d17c05628042f244c264b","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/8.png","hash":"08b0b19249e2c677b6fc774655b586cbd8be8664","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/b.png","hash":"4dd65c11f708e2e1feaf1c84b2f2a97c6baffb58","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/e.png","hash":"038c511df2eaaf6a578ed59860a4fba5f99c560f","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/f.png","hash":"bcdfa5c4be7b749d533d2f78aeba07576a33e010","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/g.png","hash":"e8b5ab0bc4de16515059f0d854fca3455713aa40","modified":1514711625242},{"_id":"source/_posts/linux-command-use/a.png","hash":"dc9aa307fe9221d90f71dfa95841ea3acbab18cc","modified":1514711625246},{"_id":"source/_posts/linux-command-use/b.png","hash":"12fb8951ab9e7361d775a1b0ceb7546cfae5c7fe","modified":1514711625246},{"_id":"source/_posts/maven-ofen/a.jpg","hash":"636125fa0cc1f01d7f341619c5822cdc1b420bb2","modified":1517623449102},{"_id":"source/_posts/microservice-think/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625246},{"_id":"source/_posts/pivotal-web-service-start/d.png","hash":"70fedd27e98b3d0b83af6ad4f9538a3fc8a83c05","modified":1514711625250},{"_id":"source/_posts/redis-cluster-centos/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625250},{"_id":"source/_posts/restful-api-dev/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625250},{"_id":"source/_posts/sboot-change-contextpath/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625250},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625250},{"_id":"source/_posts/scloud-zuul-exception/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625254},{"_id":"source/_posts/shadowsocks-go/b.png","hash":"a0dac0425805a400c38eeb20cdd920fb806d4fa0","modified":1514711625258},{"_id":"source/_posts/shadowsocks-go/a.png","hash":"85d77fc8a4bcd6f9bb73eaaaed4a69fbc171b1fa","modified":1514711625258},{"_id":"source/_posts/spring-boot-dev-error-show/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625250},{"_id":"source/_posts/spring-boot-filter/a.png","hash":"96b8176f66bf1e15643484e17f2228c42ef6c572","modified":1524736249430},{"_id":"source/_posts/website-high-performance/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1514711625514},{"_id":"source/_posts/spring-boot-filter/b.png","hash":"07c9a6bba01baf00436ccb1414ba15c0a1ca570c","modified":1524736436000},{"_id":"source/about/index/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"26ae121ecc5bbe351927dd273d58871f69454500","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"52e4cacd58d5e0061924189ad75e0c3bf622aa7f","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"af9a4a65eba65c5140921326f2b5cae9db5d7d28","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"25e28dc48c392a5d10db1ed0f8a5899598d643d5","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"dbc5c401f4d8aa80fe9e73423aadb8b8969f0b62","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"acdf9e2d52ee86c831fa15ce1570930c5779bc78","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"b54b56faff9e47ab3ca3cdd55056c73e60776f3c","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"53f9cb77448e84a98da5eb688e2e12b173c555bb","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"d6ac5dc4e9c7a1b866f1f92d88988cfb35aded4c","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"a2d698c84bb6da08195fe870dbd7215f65388d3f","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"1c988c7e1f716036e428ee16b8005a7b1bfb33c7","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"28d79fbb9d8ecc5692d3063e439f16224188abac","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"0f0e6770e9d5dd8040e330d71bbbfadd2df36a28","modified":1514711625518},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"3e4141538285aef2bd019832ba62bafd094c6097","modified":1514711625518},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"082ae16dad18ada28913772675861d7230134bea","modified":1514711625518},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"ba43bd011d64cd86fa420677c9000d328f4f6114","modified":1514711625518},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"f8ae55d5514fe493651ec04fbe73cb5fc482f7cd","modified":1514711625518},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"ff46afdedc1ab3c075ffed686b98f23aed066124","modified":1514711625518},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"a0309137277323f2fd61a3c6691e1bc51026f711","modified":1514711625518},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"3df9a00a21d3bc151026b2d403a99c28fe1ccd13","modified":1514711625518},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"53e99461ae7f8efb2a1e78ad3090dd93d18bcd5c","modified":1514711625518},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"be9ad73454b7029311caafd8e1faa469a5d4f58d","modified":1514711625518},{"_id":"themes/BlueLake/source/css/style.styl","hash":"5852cc541b74868e6464c7224b65683ea5aaa8d8","modified":1514711625518},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1514711625518},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"2b6a0b21bf63bdf746130117baf432fcb44ad210","modified":1514711625518},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1514711625518},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1514711625518},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"a0e8dfee9b9845aabd64360d497df7c0767b7235","modified":1514711625518},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"ad6386bc746ff375715ca9da17af4716ea86e06a","modified":1514711625518},{"_id":"themes/BlueLake/source/js/totop.js","hash":"5b1131830209c2daaf6fe34c5e39ab7c1059bfa4","modified":1514711625518},{"_id":"source/_posts/centos-maven-nexus/c.png","hash":"0721cae59a5622f3dfcb6259c018f433598ae858","modified":1514711625230},{"_id":"source/_posts/centos-maven-nexus/d.png","hash":"4837ba62f9c498d52f0d516c33555909ff890419","modified":1514711625230},{"_id":"source/_posts/centos-maven-nexus/e.png","hash":"42bf2cfd4787980d2fd0105ad3dd89afc0cf36fb","modified":1514711625230},{"_id":"source/_posts/centos-maven-nexus/f.png","hash":"696a68fdcf708980f808d0e09b604a71b774a37f","modified":1514711625230},{"_id":"source/_posts/centos-maven-nexus/g.png","hash":"c0177448d5f462df7e3d759f29d14c3faf75eb1b","modified":1514711625234},{"_id":"source/_posts/centos-maven-nexus/h.png","hash":"119b973e074ab4069e934112e6daa5557023b704","modified":1514711625234},{"_id":"source/_posts/centos-maven-nexus/i.png","hash":"47e4f15afff60b872071c95fb23eaf5452e6329a","modified":1514711625234},{"_id":"source/_posts/centos-maven-nexus/j.png","hash":"4c3771a7c674c70043a68f478bce1bdb18cb1844","modified":1514711625234},{"_id":"source/_posts/docker-lesson3/c.png","hash":"2f3aa0341cfe8ff2c49a8cbca20e5f67a9c4f599","modified":1519809898811},{"_id":"source/_posts/idea-file-template/b.png","hash":"4d04d3e6dd87ba18162986e3a96d2c998f00338e","modified":1518244705000},{"_id":"source/_posts/idea-file-template/c.png","hash":"510c42e232b3106a1b7628610d617f906887bcd0","modified":1518245658000},{"_id":"source/_posts/idea-file-template/e.png","hash":"c2e2b2c5c2e00052157cca5cce8790bd9a867b03","modified":1518247388000},{"_id":"source/_posts/idea-file-template/f.png","hash":"0cf06ae696464acdbf9def1691e2343111879d9a","modified":1518247645000},{"_id":"source/_posts/jenkins-java-maven/10.png","hash":"29788dae623aaa45c8b30658d1c56bdab7fb0279","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/12.png","hash":"d6626668fc9a71cf602657cd5170b17f6ad8d85e","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/2.png","hash":"90cfb0af72732942f35b3455716b6ddd939f636a","modified":1514711625238},{"_id":"source/_posts/jenkins-java-maven/a.png","hash":"4aedb54123fd8918579a04102486d34a85762a0b","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/c.png","hash":"c0c740a0b1e6cd4cad1e8aa96cef96eabac51fcc","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/h.png","hash":"c6a10c564bcd131aa20b15cfd5c46411e3a42ceb","modified":1514711625242},{"_id":"source/_posts/jenkins-java-maven/i.png","hash":"1cd3776d2fe4e8a2782c71895bff5254cfb3296b","modified":1514711625242},{"_id":"source/_posts/pivotal-web-service-start/a.png","hash":"d6731486aa76a72a980706fda1735e5b7bc05942","modified":1514711625246},{"_id":"source/_posts/maven-ofen/b.jpg","hash":"dabd4b5d5703c961214903633009a9a02ebc758e","modified":1517623464556},{"_id":"source/_posts/scloud-zuul-filters/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1514711625254},{"_id":"source/_posts/scloud-zuul-start/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1514711625254},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1514711625518},{"_id":"source/_posts/centos-maven-nexus/b.png","hash":"b83a6edfb7e719a3f530c544111dcd93914a648b","modified":1514711625230},{"_id":"source/_posts/idea-file-template/a.png","hash":"1031c609ecca3600cab439e781daf45df27702c6","modified":1518244472000},{"_id":"source/_posts/idea-file-template/g.png","hash":"fc51c847dee563fca8425db6147670c8335551c2","modified":1518248253440},{"_id":"source/_posts/pivotal-web-service-start/c.png","hash":"222f2f53d4d37628d4d926c5da817e3a76f14458","modified":1514711625250},{"_id":"source/_posts/pivotal-web-service-start/b.png","hash":"2e35d944a620506caa3ab18f337d71c92fd391e0","modified":1514711625246},{"_id":"source/_posts/shadowsocks-go/server.tar.gz","hash":"5cc6db5fa8f70dad1c7e3ca4fd95d120357c5ac4","modified":1516610371000},{"_id":"source/_posts/shadowsocks-go/Shadowsocks-4.0.6.zip","hash":"bde73f5175fe3eb5127651e4602f78dbd5a5aed9","modified":1514711625258},{"_id":"source/_posts/shadowsocks-go/client.tar.gz","hash":"96035ed9ab98329f6b95f13f214c8a35ead5987a","modified":1516610317000},{"_id":"source/_posts/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk","hash":"08466b927332819300796822ab861c779eaf3af9","modified":1510492608000},{"_id":"source/_posts/shadowsocks-go/go1.9.2.linux-amd64.tar.gz","hash":"94c889e039e3d2e94ed95e8f8cb747c5bc1c2b58","modified":1514711625514}],"Category":[{"name":"api-manage","_id":"cjgz5ioi50003d5hsi2f3sua3"},{"name":"Nginx","_id":"cjgz5ioil0008d5hs8iof58re"},{"name":"CentOs","_id":"cjgz5ioix000ed5hsyuvqxigz"},{"name":"java","_id":"cjgz5ioja000wd5hsw5r95dpj"},{"name":"分布式系统","_id":"cjgz5iojd0013d5hs2efk1xu7"},{"name":"docker","_id":"cjgz5iojn001fd5hswcs90oyd"},{"name":"concourse","_id":"cjgz5iojw001md5hsvzpgg6bp"},{"name":"文件存储系统","_id":"cjgz5iokd0028d5hs0oo23m03"},{"name":"git","_id":"cjgz5iokh002fd5hs10k64e62"},{"name":"github","_id":"cjgz5iokv002zd5hsw66fyvm3"},{"name":"security","_id":"cjgz5ioky0036d5hs3wt203qn"},{"name":"jpa/hibernate","_id":"cjgz5iol1003cd5hsan8rdjq1"},{"name":"http协议","_id":"cjgz5iol7003id5hspfui0dde"},{"name":"idea","_id":"cjgz5iolm003pd5hsbfrgibwq"},{"name":"服务网格","_id":"cjgz5ioly0046d5hs55v4loxe"},{"name":"json","_id":"cjgz5iom3004dd5hsv7o826h0"},{"name":"javapoet","_id":"cjgz5iom5004jd5hscgv4rkoz"},{"name":"持续集成","_id":"cjgz5iomb004qd5hs7i387ux2"},{"name":"jvm","_id":"cjgz5iome004wd5hsz43wi7lq"},{"name":"Kubernetes","_id":"cjgz5iomn0057d5hsb6hr0end"},{"name":"linux","_id":"cjgz5iomr005ed5hshghghif6"},{"name":"ubuntu","_id":"cjgz5iomv005kd5hsamoqolpu"},{"name":"maven","_id":"cjgz5iomw005od5hsjwab1z58"},{"name":"micro-service","_id":"cjgz5iomx005vd5hs2x7shkta"},{"name":"mysql","_id":"cjgz5iomx0060d5hsgqyzzvqt"},{"name":"Pivotal Web Service","_id":"cjgz5iomz0064d5hsn5vq6g7c"},{"name":"rabbitmq","_id":"cjgz5ion1006bd5hs0286wv4q"},{"name":"redis","_id":"cjgz5ion2006jd5hsuleklzzw"},{"name":"spring-boot","_id":"cjgz5ion5006yd5hsj1i9zobf"},{"name":"spring-cloud","_id":"cjgz5ion60073d5hsajv7jygz"},{"name":"shadowsocks","_id":"cjgz5iond007wd5hszveywkwt"},{"name":"teamcity","_id":"cjgz5ioni008nd5hs1l3gwuut"},{"name":"TypeScript","_id":"cjgz5ionj008sd5hsiiefim0l"},{"name":"vagrant","_id":"cjgz5ionj008wd5hsontxer7d"},{"name":"密码","_id":"cjgz5ionk0090d5hs541jwkfk"},{"name":"架构","_id":"cjgz5ionl0094d5hs1ze4e2gm"}],"Data":[],"Page":[{"title":"关于","date":"2017-09-20T03:52:09.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-09-20 11:52:09\n---\n","updated":"2017-12-31T09:13:45.514Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjgz5iohy0001d5hsdrnczgaa","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"rest-api版本迭代管理实践","date":"2017-09-26T06:23:44.000Z","_content":"\n在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。  \n因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  \n\n通常，restful-api的版本迭代实现方式主要又两种：\n\n- 在url中显示设置，如：`https://api.example.com/v1/`。\n- 在http请求头中添加，如：\n        \n        设置请求头：\n        Content-Version: 1\n        \n        请求:\n        https://api.example.com\n \n-------------------------------------------------------------\n \n首先，建立spring-boot-web项目：\n\n{% asset_img a.png %}\n \n        \n## 在请求头中设置\n\n1.创建注解类ApiVersion\n在controller中添加注解标志api版本\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.bind.annotation.Mapping;\n    \n    import java.lang.annotation.*;\n    \n    /**\n     * \n     * 接口版本标识注解\n     *\n     */\n    @Target({ElementType.METHOD, ElementType.TYPE})\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Mapping\n    public @interface ApiVersion {\n        int value();\n    }\n\n2.创建处理类ApiVersionCondition\n继承RequestCondition，每次url请求都会首先进入该方法。\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import java.util.regex.Pattern;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        private int apiVersion;\n    \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n    \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        \tString path = request.getServletPath();\n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n    \t\tString contentVersion = request.getHeader(\"Content-Version\"); //在http请求头中定义api版本，而不是在url中\n            if (null == contentVersion || \"\".equals(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version非null非空\");\n            }\n            if (!isInteger(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version必须为整数\");\n            }\n    \n            int version = Integer.valueOf(contentVersion).intValue();\n            if(version >= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n        /**\n         * 判断字符串是否为整数。\n         * @param str\n         * @return\n         */\n        private boolean isInteger(String str) {\n            Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\");\n            return pattern.matcher(str).matches();\n        }\n    \n    }\n    \n3.自定义url注册回调类CustomRequestMappingHandlerMapping\nurl注解回调句柄类。继承RequestMappingHandlerMapping。\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 类。\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        /**\n         * 方法\n         * @param method\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n    \n\n4.创建web配置类并编辑内容：WebConfig\n配置自定义类RequestMappingHandlerMapping。\n    \n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    @Configuration\n    public class WebConfig extends WebMvcConfigurationSupport{\n    \n        @Override\n        @Bean\n        public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n            RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n            handlerMapping.setOrder(0);\n            handlerMapping.setInterceptors(getInterceptors()); \n            return handlerMapping;\n        }\n        \n    }\n\n5.创建演示类HelloController\n\n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.ApiVersion;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.RequestMethod;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    @RestController\n    @RequestMapping\n    public class HelloController {\n    \t\n    \t//---------------- api版本管理 demo start ------------------//\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        public String hello0(HttpServletRequest request){\n            print(request);\n            return \"hello\";\n        }\n    \n    \t@RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(1)\n        public String hello1(HttpServletRequest request){\n            print(request);\n            return \"hello:v1\";\n        }\n    \n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(5)\n        public String hello5(HttpServletRequest request){\n            print(request);\n            return \"hello:v5\";\n        }\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(2)\n        public String hello2(HttpServletRequest request){\n            print(request);\n            return \"hello:v2\";\n        }\n    \n        private void print(HttpServletRequest request) {\n            System.out.println(\"version:\" + request.getHeader(\"Content-Version\"));\n        }\n        \n    }    \n\n6.演示：\n\n{% asset_img b.png %}\n\n------------------------------\n\n{% asset_img c.png %}\n    \n\n## 在url中显示设置\n\n在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 \n\n1.修改CustomRequestMappingHandlerMapping类。\n只需要重写方法：\n\n    /**\n     * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set<String> s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(\"\");\n            if (s != null && !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!\"/error\".equals(str)) {\n                        pathNew.append(\"/{version}\");\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n        \n    -----------------------------------------------------\n        \n    完整代码如下：    \n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.RequestMappingInfo;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    import java.util.Set;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n         * 不用在每个类或方法的@RequestMapping中加。\n         * @param method\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n            RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n            if (requestMappingInfo != null) {\n                PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n                Set<String> s = pcOri.getPatterns();\n                StringBuilder pathNew = new StringBuilder(\"\");\n                if (s != null && !s.isEmpty()) {\n                    for (String str: s ) {\n                        if (!\"/error\".equals(str)) {\n                            pathNew.append(\"/{version}\");\n                            pathNew.append(str);\n                        } else {\n                            pathNew.append(str);\n                        }\n                    }\n                }\n    \n                PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n    \n                RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n    \n                return requestMappingInfoNew;\n    \n            }\n            return requestMappingInfo;\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n\n2.修改类ApiVersionCondition。\n主要修改方法：getMatchingCondition\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n    \n    -----------------------------------------------------------\n    \n    完整代码如下：\n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import java.util.regex.Matcher;\n    import java.util.regex.Pattern;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n        private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(\"v(\\\\d+)/\");\n        \n        private int apiVersion;\n        \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n        \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        \tString path = request.getServletPath(); \n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n            Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n            if(m.find()){\n                Integer version = Integer.valueOf(m.group(1));\n                if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                    return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n    }\n\n3.演示：\n\n{%asset_img d.png%}\n\n--------------------------------------\n\n{%asset_img e.png%}\n\n   ","source":"_posts/api-version.md","raw":"---\ntitle: rest-api版本迭代管理实践\ndate: 2017-09-26 14:23:44\ncategories: api-manage\ntags: api-version-manage,spring-boot中API版本迭代管理\n---\n\n在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。  \n因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  \n\n通常，restful-api的版本迭代实现方式主要又两种：\n\n- 在url中显示设置，如：`https://api.example.com/v1/`。\n- 在http请求头中添加，如：\n        \n        设置请求头：\n        Content-Version: 1\n        \n        请求:\n        https://api.example.com\n \n-------------------------------------------------------------\n \n首先，建立spring-boot-web项目：\n\n{% asset_img a.png %}\n \n        \n## 在请求头中设置\n\n1.创建注解类ApiVersion\n在controller中添加注解标志api版本\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.bind.annotation.Mapping;\n    \n    import java.lang.annotation.*;\n    \n    /**\n     * \n     * 接口版本标识注解\n     *\n     */\n    @Target({ElementType.METHOD, ElementType.TYPE})\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    @Mapping\n    public @interface ApiVersion {\n        int value();\n    }\n\n2.创建处理类ApiVersionCondition\n继承RequestCondition，每次url请求都会首先进入该方法。\n\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import java.util.regex.Pattern;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        private int apiVersion;\n    \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n    \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        \tString path = request.getServletPath();\n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n    \t\tString contentVersion = request.getHeader(\"Content-Version\"); //在http请求头中定义api版本，而不是在url中\n            if (null == contentVersion || \"\".equals(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version非null非空\");\n            }\n            if (!isInteger(contentVersion)) {\n                throw new IllegalArgumentException(\"Content-Version必须为整数\");\n            }\n    \n            int version = Integer.valueOf(contentVersion).intValue();\n            if(version >= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n        /**\n         * 判断字符串是否为整数。\n         * @param str\n         * @return\n         */\n        private boolean isInteger(String str) {\n            Pattern pattern = Pattern.compile(\"^[-\\\\+]?[\\\\d]*$\");\n            return pattern.matcher(str).matches();\n        }\n    \n    }\n    \n3.自定义url注册回调类CustomRequestMappingHandlerMapping\nurl注解回调句柄类。继承RequestMappingHandlerMapping。\n\n    package com.ymu.demo.springboot2apiversion.version;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 类。\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        /**\n         * 方法\n         * @param method\n         * @return\n         */\n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n    \n\n4.创建web配置类并编辑内容：WebConfig\n配置自定义类RequestMappingHandlerMapping。\n    \n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    @Configuration\n    public class WebConfig extends WebMvcConfigurationSupport{\n    \n        @Override\n        @Bean\n        public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n            RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n            handlerMapping.setOrder(0);\n            handlerMapping.setInterceptors(getInterceptors()); \n            return handlerMapping;\n        }\n        \n    }\n\n5.创建演示类HelloController\n\n    package com.ymu.demo.springboot2apiversion;\n    \n    import com.ymu.demo.springboot2apiversion.version.ApiVersion;\n    import org.springframework.web.bind.annotation.RequestMapping;\n    import org.springframework.web.bind.annotation.RequestMethod;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    @RestController\n    @RequestMapping\n    public class HelloController {\n    \t\n    \t//---------------- api版本管理 demo start ------------------//\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        public String hello0(HttpServletRequest request){\n            print(request);\n            return \"hello\";\n        }\n    \n    \t@RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(1)\n        public String hello1(HttpServletRequest request){\n            print(request);\n            return \"hello:v1\";\n        }\n    \n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(5)\n        public String hello5(HttpServletRequest request){\n            print(request);\n            return \"hello:v5\";\n        }\n    \n        @RequestMapping(value = \"/hello\",method = RequestMethod.GET)\n        @ApiVersion(2)\n        public String hello2(HttpServletRequest request){\n            print(request);\n            return \"hello:v2\";\n        }\n    \n        private void print(HttpServletRequest request) {\n            System.out.println(\"version:\" + request.getHeader(\"Content-Version\"));\n        }\n        \n    }    \n\n6.演示：\n\n{% asset_img b.png %}\n\n------------------------------\n\n{% asset_img c.png %}\n    \n\n## 在url中显示设置\n\n在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 \n\n1.修改CustomRequestMappingHandlerMapping类。\n只需要重写方法：\n\n    /**\n     * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set<String> s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(\"\");\n            if (s != null && !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!\"/error\".equals(str)) {\n                        pathNew.append(\"/{version}\");\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n        \n    -----------------------------------------------------\n        \n    完整代码如下：    \n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import org.springframework.core.annotation.AnnotationUtils;\n    import org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    import org.springframework.web.servlet.mvc.method.RequestMappingInfo;\n    import org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n    \n    import java.lang.reflect.Method;\n    import java.util.Set;\n    \n    public class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n    \n        /**\n         * 为所有注册路径添加\"/{version}\"匹配规则。目的，做api版本管理。\n         * 不用在每个类或方法的@RequestMapping中加。\n         * @param method\n         * @param handlerType\n         * @return\n         */\n        @Override\n        protected RequestMappingInfo getMappingForMethod(Method method, Class<?> handlerType) {\n            RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n            if (requestMappingInfo != null) {\n                PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n                Set<String> s = pcOri.getPatterns();\n                StringBuilder pathNew = new StringBuilder(\"\");\n                if (s != null && !s.isEmpty()) {\n                    for (String str: s ) {\n                        if (!\"/error\".equals(str)) {\n                            pathNew.append(\"/{version}\");\n                            pathNew.append(str);\n                        } else {\n                            pathNew.append(str);\n                        }\n                    }\n                }\n    \n                PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n    \n                RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n    \n                return requestMappingInfoNew;\n    \n            }\n            return requestMappingInfo;\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomTypeCondition(Class<?> handlerType) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n            return createCondition(apiVersion);\n        }\n    \n        @Override\n        protected RequestCondition<ApiVersionCondition> getCustomMethodCondition(Method method) {\n            ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n            return createCondition(apiVersion);\n        }\n        \n        private RequestCondition<ApiVersionCondition> createCondition(ApiVersion apiVersion) {\n            return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n        }\n    }\n\n2.修改类ApiVersionCondition。\n主要修改方法：getMatchingCondition\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n    \n    -----------------------------------------------------------\n    \n    完整代码如下：\n\n    package com.ymu.framework.spring.mvc.api;\n    \n    import java.util.regex.Matcher;\n    import java.util.regex.Pattern;\n    \n    import javax.servlet.http.HttpServletRequest;\n    \n    import org.springframework.web.servlet.mvc.condition.RequestCondition;\n    \n    public class ApiVersionCondition implements RequestCondition<ApiVersionCondition> {\n    \n        // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n        private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(\"v(\\\\d+)/\");\n        \n        private int apiVersion;\n        \n        public ApiVersionCondition(int apiVersion){\n            this.apiVersion = apiVersion;\n        }\n        \n        public ApiVersionCondition combine(ApiVersionCondition other) {\n            // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n            return new ApiVersionCondition(other.getApiVersion());\n        }\n    \n        public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n    //    \tString pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        \tString path = request.getServletPath(); \n        \tif (path == null) {\n    \t\t\treturn null;\n    \t\t}\n            Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n            if(m.find()){\n                Integer version = Integer.valueOf(m.group(1));\n                if(version >= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                    return this;\n            }\n            return null;\n        }\n    \n        public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n            // 优先匹配最新的版本号\n            return other.getApiVersion() - this.apiVersion;\n        }\n    \n        public int getApiVersion() {\n            return apiVersion;\n        }\n    \n    }\n\n3.演示：\n\n{%asset_img d.png%}\n\n--------------------------------------\n\n{%asset_img e.png%}\n\n   ","slug":"api-version","published":1,"updated":"2018-04-23T14:52:08.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iohs0000d5hsdhuvyf75","content":"<p>在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。<br>因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  </p>\n<p>通常，restful-api的版本迭代实现方式主要又两种：</p>\n<ul>\n<li>在url中显示设置，如：<code>https://api.example.com/v1/</code>。</li>\n<li><p>在http请求头中添加，如：</p>\n<pre><code>设置请求头：\nContent-Version: 1\n\n请求:\nhttps://api.example.com\n</code></pre></li>\n</ul>\n<hr>\n<p>首先，建立spring-boot-web项目：</p>\n<img src=\"/2017/09/26/api-version/a.png\">\n<h2 id=\"在请求头中设置\"><a href=\"#在请求头中设置\" class=\"headerlink\" title=\"在请求头中设置\"></a>在请求头中设置</h2><p>1.创建注解类ApiVersion<br>在controller中添加注解标志api版本</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.bind.annotation.Mapping;\n\nimport java.lang.annotation.*;\n\n/**\n * \n * 接口版本标识注解\n *\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Mapping\npublic @interface ApiVersion {\n    int value();\n}\n</code></pre><p>2.创建处理类ApiVersionCondition<br>继承RequestCondition，每次url请求都会首先进入该方法。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.regex.Pattern;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        String path = request.getServletPath();\n        if (path == null) {\n            return null;\n        }\n        String contentVersion = request.getHeader(&quot;Content-Version&quot;); //在http请求头中定义api版本，而不是在url中\n        if (null == contentVersion || &quot;&quot;.equals(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version非null非空&quot;);\n        }\n        if (!isInteger(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version必须为整数&quot;);\n        }\n\n        int version = Integer.valueOf(contentVersion).intValue();\n        if(version &gt;= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n    /**\n     * 判断字符串是否为整数。\n     * @param str\n     * @return\n     */\n    private boolean isInteger(String str) {\n        Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[\\\\d]*$&quot;);\n        return pattern.matcher(str).matches();\n    }\n\n}\n</code></pre><p>3.自定义url注册回调类CustomRequestMappingHandlerMapping<br>url注解回调句柄类。继承RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 类。\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    /**\n     * 方法\n     * @param method\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>4.创建web配置类并编辑内容：WebConfig<br>配置自定义类RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\n@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport{\n\n    @Override\n    @Bean\n    public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n        RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n        handlerMapping.setOrder(0);\n        handlerMapping.setInterceptors(getInterceptors()); \n        return handlerMapping;\n    }\n\n}\n</code></pre><p>5.创建演示类HelloController</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.ApiVersion;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@RestController\n@RequestMapping\npublic class HelloController {\n\n    //---------------- api版本管理 demo start ------------------//\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    public String hello0(HttpServletRequest request){\n        print(request);\n        return &quot;hello&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(1)\n    public String hello1(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v1&quot;;\n    }\n\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(5)\n    public String hello5(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v5&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(2)\n    public String hello2(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v2&quot;;\n    }\n\n    private void print(HttpServletRequest request) {\n        System.out.println(&quot;version:&quot; + request.getHeader(&quot;Content-Version&quot;));\n    }\n\n}    \n</code></pre><p>6.演示：</p>\n<img src=\"/2017/09/26/api-version/b.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/c.png\">\n<h2 id=\"在url中显示设置\"><a href=\"#在url中显示设置\" class=\"headerlink\" title=\"在url中显示设置\"></a>在url中显示设置</h2><p>在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 </p>\n<p>1.修改CustomRequestMappingHandlerMapping类。<br>只需要重写方法：</p>\n<pre><code>/**\n * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n * 不用在每个类或方法的@RequestMapping中加。\n * @param method\n * @param handlerType\n * @return\n */\n@Override\nprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n    RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n    if (requestMappingInfo != null) {\n        PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n        Set&lt;String&gt; s = pcOri.getPatterns();\n        StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n        if (s != null &amp;&amp; !s.isEmpty()) {\n            for (String str: s ) {\n                if (!&quot;/error&quot;.equals(str)) {\n                    pathNew.append(&quot;/{version}&quot;);\n                    pathNew.append(str);\n                } else {\n                    pathNew.append(str);\n                }\n            }\n        }\n\n        PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n        RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n        return requestMappingInfoNew;\n\n    }\n    return requestMappingInfo;\n}\n\n-----------------------------------------------------\n\n完整代码如下：    \n\npackage com.ymu.framework.spring.mvc.api;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\nimport java.util.Set;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set&lt;String&gt; s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n            if (s != null &amp;&amp; !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!&quot;/error&quot;.equals(str)) {\n                        pathNew.append(&quot;/{version}&quot;);\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>2.修改类ApiVersionCondition。<br>主要修改方法：getMatchingCondition</p>\n<pre><code>public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n    String path = request.getServletPath(); \n    if (path == null) {\n        return null;\n    }\n    Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n    if(m.find()){\n        Integer version = Integer.valueOf(m.group(1));\n        if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n    }\n    return null;\n}\n\n-----------------------------------------------------------\n\n完整代码如下：\n\npackage com.ymu.framework.spring.mvc.api;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n    private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(&quot;v(\\\\d+)/&quot;);\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n}\n</code></pre><p>3.演示：</p>\n<img src=\"/2017/09/26/api-version/d.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/e.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>在API系统设计，特别是有android或者ios移动客户端的系统设计过程中，当业务发生比较大的变动的时候，就会出现一个问题：我们为了使客户端的新旧版本（客户端有的用户可能不会主动升级版本）能准确的访问api接口并得到准确的数据，我们就不得不在该api接口实现中写代码做兼容。这样的话，随着业务的不断调整，整个api接口实现将变得臃肿不堪，同时bug不断，导致不能适用各个版本客户端的请求。<br>因此，对api接口做版本迭代，让接口实现变得简单、易于维护、减少bug就显得十分必要了。  </p>\n<p>通常，restful-api的版本迭代实现方式主要又两种：</p>\n<ul>\n<li>在url中显示设置，如：<code>https://api.example.com/v1/</code>。</li>\n<li><p>在http请求头中添加，如：</p>\n<pre><code>设置请求头：\nContent-Version: 1\n\n请求:\nhttps://api.example.com\n</code></pre></li>\n</ul>\n<hr>\n<p>首先，建立spring-boot-web项目：</p>\n<img src=\"/2017/09/26/api-version/a.png\">\n<h2 id=\"在请求头中设置\"><a href=\"#在请求头中设置\" class=\"headerlink\" title=\"在请求头中设置\"></a>在请求头中设置</h2><p>1.创建注解类ApiVersion<br>在controller中添加注解标志api版本</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.bind.annotation.Mapping;\n\nimport java.lang.annotation.*;\n\n/**\n * \n * 接口版本标识注解\n *\n */\n@Target({ElementType.METHOD, ElementType.TYPE})\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\n@Mapping\npublic @interface ApiVersion {\n    int value();\n}\n</code></pre><p>2.创建处理类ApiVersionCondition<br>继承RequestCondition，每次url请求都会首先进入该方法。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\nimport javax.servlet.http.HttpServletRequest;\nimport java.util.regex.Pattern;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n        String path = request.getServletPath();\n        if (path == null) {\n            return null;\n        }\n        String contentVersion = request.getHeader(&quot;Content-Version&quot;); //在http请求头中定义api版本，而不是在url中\n        if (null == contentVersion || &quot;&quot;.equals(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version非null非空&quot;);\n        }\n        if (!isInteger(contentVersion)) {\n            throw new IllegalArgumentException(&quot;Content-Version必须为整数&quot;);\n        }\n\n        int version = Integer.valueOf(contentVersion).intValue();\n        if(version &gt;= this.apiVersion) { // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n    /**\n     * 判断字符串是否为整数。\n     * @param str\n     * @return\n     */\n    private boolean isInteger(String str) {\n        Pattern pattern = Pattern.compile(&quot;^[-\\\\+]?[\\\\d]*$&quot;);\n        return pattern.matcher(str).matches();\n    }\n\n}\n</code></pre><p>3.自定义url注册回调类CustomRequestMappingHandlerMapping<br>url注解回调句柄类。继承RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion.version;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 类。\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    /**\n     * 方法\n     * @param method\n     * @return\n     */\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>4.创建web配置类并编辑内容：WebConfig<br>配置自定义类RequestMappingHandlerMapping。</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.CustomRequestMappingHandlerMapping;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.web.servlet.config.annotation.WebMvcConfigurationSupport;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\n@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport{\n\n    @Override\n    @Bean\n    public RequestMappingHandlerMapping requestMappingHandlerMapping() {\n        RequestMappingHandlerMapping handlerMapping = new CustomRequestMappingHandlerMapping();\n        handlerMapping.setOrder(0);\n        handlerMapping.setInterceptors(getInterceptors()); \n        return handlerMapping;\n    }\n\n}\n</code></pre><p>5.创建演示类HelloController</p>\n<pre><code>package com.ymu.demo.springboot2apiversion;\n\nimport com.ymu.demo.springboot2apiversion.version.ApiVersion;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RequestMethod;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport javax.servlet.http.HttpServletRequest;\n\n@RestController\n@RequestMapping\npublic class HelloController {\n\n    //---------------- api版本管理 demo start ------------------//\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    public String hello0(HttpServletRequest request){\n        print(request);\n        return &quot;hello&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(1)\n    public String hello1(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v1&quot;;\n    }\n\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(5)\n    public String hello5(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v5&quot;;\n    }\n\n    @RequestMapping(value = &quot;/hello&quot;,method = RequestMethod.GET)\n    @ApiVersion(2)\n    public String hello2(HttpServletRequest request){\n        print(request);\n        return &quot;hello:v2&quot;;\n    }\n\n    private void print(HttpServletRequest request) {\n        System.out.println(&quot;version:&quot; + request.getHeader(&quot;Content-Version&quot;));\n    }\n\n}    \n</code></pre><p>6.演示：</p>\n<img src=\"/2017/09/26/api-version/b.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/c.png\">\n<h2 id=\"在url中显示设置\"><a href=\"#在url中显示设置\" class=\"headerlink\" title=\"在url中显示设置\"></a>在url中显示设置</h2><p>在url中显示设置基本和上面过程一样。只不过是要稍微调整下注册路径，在注册路径中添加版本号。 </p>\n<p>1.修改CustomRequestMappingHandlerMapping类。<br>只需要重写方法：</p>\n<pre><code>/**\n * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n * 不用在每个类或方法的@RequestMapping中加。\n * @param method\n * @param handlerType\n * @return\n */\n@Override\nprotected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n    RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n    if (requestMappingInfo != null) {\n        PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n        Set&lt;String&gt; s = pcOri.getPatterns();\n        StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n        if (s != null &amp;&amp; !s.isEmpty()) {\n            for (String str: s ) {\n                if (!&quot;/error&quot;.equals(str)) {\n                    pathNew.append(&quot;/{version}&quot;);\n                    pathNew.append(str);\n                } else {\n                    pathNew.append(str);\n                }\n            }\n        }\n\n        PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n        RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n        return requestMappingInfoNew;\n\n    }\n    return requestMappingInfo;\n}\n\n-----------------------------------------------------\n\n完整代码如下：    \n\npackage com.ymu.framework.spring.mvc.api;\n\nimport org.springframework.core.annotation.AnnotationUtils;\nimport org.springframework.web.servlet.mvc.condition.PatternsRequestCondition;\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\nimport org.springframework.web.servlet.mvc.method.RequestMappingInfo;\nimport org.springframework.web.servlet.mvc.method.annotation.RequestMappingHandlerMapping;\n\nimport java.lang.reflect.Method;\nimport java.util.Set;\n\npublic class CustomRequestMappingHandlerMapping extends RequestMappingHandlerMapping {\n\n    /**\n     * 为所有注册路径添加&quot;/{version}&quot;匹配规则。目的，做api版本管理。\n     * 不用在每个类或方法的@RequestMapping中加。\n     * @param method\n     * @param handlerType\n     * @return\n     */\n    @Override\n    protected RequestMappingInfo getMappingForMethod(Method method, Class&lt;?&gt; handlerType) {\n        RequestMappingInfo requestMappingInfo = super.getMappingForMethod(method, handlerType);\n        if (requestMappingInfo != null) {\n            PatternsRequestCondition pcOri = requestMappingInfo.getPatternsCondition();\n            Set&lt;String&gt; s = pcOri.getPatterns();\n            StringBuilder pathNew = new StringBuilder(&quot;&quot;);\n            if (s != null &amp;&amp; !s.isEmpty()) {\n                for (String str: s ) {\n                    if (!&quot;/error&quot;.equals(str)) {\n                        pathNew.append(&quot;/{version}&quot;);\n                        pathNew.append(str);\n                    } else {\n                        pathNew.append(str);\n                    }\n                }\n            }\n\n            PatternsRequestCondition pcnNew = new PatternsRequestCondition(pathNew.toString());\n\n            RequestMappingInfo requestMappingInfoNew = new RequestMappingInfo(requestMappingInfo.getName(),pcnNew,requestMappingInfo.getMethodsCondition(),requestMappingInfo.getParamsCondition(),requestMappingInfo.getHeadersCondition(),requestMappingInfo.getConsumesCondition(),requestMappingInfo.getProducesCondition(),requestMappingInfo.getCustomCondition());\n\n            return requestMappingInfoNew;\n\n        }\n        return requestMappingInfo;\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomTypeCondition(Class&lt;?&gt; handlerType) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(handlerType, ApiVersion.class); \n        return createCondition(apiVersion);\n    }\n\n    @Override\n    protected RequestCondition&lt;ApiVersionCondition&gt; getCustomMethodCondition(Method method) {\n        ApiVersion apiVersion = AnnotationUtils.findAnnotation(method, ApiVersion.class);\n        return createCondition(apiVersion);\n    }\n\n    private RequestCondition&lt;ApiVersionCondition&gt; createCondition(ApiVersion apiVersion) {\n        return apiVersion == null ? null : new ApiVersionCondition(apiVersion.value());\n    }\n}\n</code></pre><p>2.修改类ApiVersionCondition。<br>主要修改方法：getMatchingCondition</p>\n<pre><code>public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n    String path = request.getServletPath(); \n    if (path == null) {\n        return null;\n    }\n    Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n    if(m.find()){\n        Integer version = Integer.valueOf(m.group(1));\n        if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n            return this;\n    }\n    return null;\n}\n\n-----------------------------------------------------------\n\n完整代码如下：\n\npackage com.ymu.framework.spring.mvc.api;\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport javax.servlet.http.HttpServletRequest;\n\nimport org.springframework.web.servlet.mvc.condition.RequestCondition;\n\npublic class ApiVersionCondition implements RequestCondition&lt;ApiVersionCondition&gt; {\n\n    // 路径中版本的前缀， 这里用 /v[1-9]/的形式\n    private final static Pattern VERSION_PREFIX_PATTERN = Pattern.compile(&quot;v(\\\\d+)/&quot;);\n\n    private int apiVersion;\n\n    public ApiVersionCondition(int apiVersion){\n        this.apiVersion = apiVersion;\n    }\n\n    public ApiVersionCondition combine(ApiVersionCondition other) {\n        // 采用最后定义优先原则，则方法上的定义覆盖类上面的定义\n        return new ApiVersionCondition(other.getApiVersion());\n    }\n\n    public ApiVersionCondition getMatchingCondition(HttpServletRequest request) {\n//        String pathInfo = request.getPathInfo();//这个方法获取是null，报错。\n        String path = request.getServletPath(); \n        if (path == null) {\n            return null;\n        }\n        Matcher m = VERSION_PREFIX_PATTERN.matcher(path);//匹配路径\n        if(m.find()){\n            Integer version = Integer.valueOf(m.group(1));\n            if(version &gt;= this.apiVersion) // 如果请求的版本号大于配置版本号， 则满足\n                return this;\n        }\n        return null;\n    }\n\n    public int compareTo(ApiVersionCondition other, HttpServletRequest request) {\n        // 优先匹配最新的版本号\n        return other.getApiVersion() - this.apiVersion;\n    }\n\n    public int getApiVersion() {\n        return apiVersion;\n    }\n\n}\n</code></pre><p>3.演示：</p>\n<img src=\"/2017/09/26/api-version/d.png\">\n<hr>\n<img src=\"/2017/09/26/api-version/e.png\">\n"},{"title":"Keepalived+LVS+Nginx负载均衡之高可用","date":"2017-09-23T01:48:19.000Z","_content":"### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","source":"_posts/Keepalived-LVS-Nginx.md","raw":"---\ntitle: Keepalived+LVS+Nginx负载均衡之高可用\ndate: 2017-09-23 09:48:19\ncategories: Nginx\ntags: nginx负载均衡\n---\n### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","slug":"Keepalived-LVS-Nginx","published":1,"updated":"2017-12-31T09:13:45.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioi20002d5hsvootadju","content":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"noopener\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"noopener\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"noopener\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>"},{"title":"centos7下jdk8安装","date":"2017-11-12T06:32:34.000Z","_content":"1、下载jdk(在官网找)\n如果还没安装axel，先安装axel：> yum -y install axel\n\n    > axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n\n2、新建安装目录\n\n    >  mkdir /usr/lib/jvm\n\n3、解压jdk到安装目录下\n\n    > tar xf jdk-8u131-linux-x64.tar.gz\n    > cd /usr/lib/jvm\n    > mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n    > mv jdk1.8.0_131/ jdk8 #更改名字\n\n4、配置环境变量\n\n    > vim /etc/profile\n    \n键盘按a键进入编辑模式，在末尾添加：\n#jdk\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n\n按Esc退出编辑模式\n按Shift+:,然后输入wq保存退出。\n\n5、使环境变量生效\n\n    > source /etc/profile\n\n6、验证安装是否成功\n\n    > java -version\n\n如果安装成功会看到：\n\n    java version \"1.8.0_131\"\n    Java(TM) SE Runtime Environment (build 1.8.0_131-b11)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)","source":"_posts/centos-jdk8-install.md","raw":"---\ntitle: centos7下jdk8安装\ndate: 2017-11-12 14:32:34\ncategories: CentOs\ntags: centos-jdk8-install\n---\n1、下载jdk(在官网找)\n如果还没安装axel，先安装axel：> yum -y install axel\n\n    > axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n\n2、新建安装目录\n\n    >  mkdir /usr/lib/jvm\n\n3、解压jdk到安装目录下\n\n    > tar xf jdk-8u131-linux-x64.tar.gz\n    > cd /usr/lib/jvm\n    > mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n    > mv jdk1.8.0_131/ jdk8 #更改名字\n\n4、配置环境变量\n\n    > vim /etc/profile\n    \n键盘按a键进入编辑模式，在末尾添加：\n#jdk\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n\n按Esc退出编辑模式\n按Shift+:,然后输入wq保存退出。\n\n5、使环境变量生效\n\n    > source /etc/profile\n\n6、验证安装是否成功\n\n    > java -version\n\n如果安装成功会看到：\n\n    java version \"1.8.0_131\"\n    Java(TM) SE Runtime Environment (build 1.8.0_131-b11)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)","slug":"centos-jdk8-install","published":1,"updated":"2017-12-31T09:13:45.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioi80005d5hsr3sg5wb7","content":"<p>1、下载jdk(在官网找)<br>如果还没安装axel，先安装axel：&gt; yum -y install axel</p>\n<pre><code>&gt; axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n</code></pre><p>2、新建安装目录</p>\n<pre><code>&gt;  mkdir /usr/lib/jvm\n</code></pre><p>3、解压jdk到安装目录下</p>\n<pre><code>&gt; tar xf jdk-8u131-linux-x64.tar.gz\n&gt; cd /usr/lib/jvm\n&gt; mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n&gt; mv jdk1.8.0_131/ jdk8 #更改名字\n</code></pre><p>4、配置环境变量</p>\n<pre><code>&gt; vim /etc/profile\n</code></pre><p>键盘按a键进入编辑模式，在末尾添加：</p>\n<p>#jdk<br>export JAVA_HOME=/usr/lib/jvm/jdk8<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>\n<p>按Esc退出编辑模式<br>按Shift+:,然后输入wq保存退出。</p>\n<p>5、使环境变量生效</p>\n<pre><code>&gt; source /etc/profile\n</code></pre><p>6、验证安装是否成功</p>\n<pre><code>&gt; java -version\n</code></pre><p>如果安装成功会看到：</p>\n<pre><code>java version &quot;1.8.0_131&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1、下载jdk(在官网找)<br>如果还没安装axel，先安装axel：&gt; yum -y install axel</p>\n<pre><code>&gt; axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n</code></pre><p>2、新建安装目录</p>\n<pre><code>&gt;  mkdir /usr/lib/jvm\n</code></pre><p>3、解压jdk到安装目录下</p>\n<pre><code>&gt; tar xf jdk-8u131-linux-x64.tar.gz\n&gt; cd /usr/lib/jvm\n&gt; mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n&gt; mv jdk1.8.0_131/ jdk8 #更改名字\n</code></pre><p>4、配置环境变量</p>\n<pre><code>&gt; vim /etc/profile\n</code></pre><p>键盘按a键进入编辑模式，在末尾添加：</p>\n<p>#jdk<br>export JAVA_HOME=/usr/lib/jvm/jdk8<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>\n<p>按Esc退出编辑模式<br>按Shift+:,然后输入wq保存退出。</p>\n<p>5、使环境变量生效</p>\n<pre><code>&gt; source /etc/profile\n</code></pre><p>6、验证安装是否成功</p>\n<pre><code>&gt; java -version\n</code></pre><p>如果安装成功会看到：</p>\n<pre><code>java version &quot;1.8.0_131&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n</code></pre>"},{"title":"apidoc在spring-mvc中实践","date":"2017-09-24T15:01:49.000Z","_content":"\n官网：http://apidocjs.com/\n","source":"_posts/apidoc-java.md","raw":"---\ntitle: apidoc在spring-mvc中实践\ndate: 2017-09-24 23:01:49\ncategories: api-manage\ntags: apidoc\n---\n\n官网：http://apidocjs.com/\n","slug":"apidoc-java","published":1,"updated":"2017-12-31T09:13:45.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioig0006d5hsper78l2o","content":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"noopener\">http://apidocjs.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"noopener\">http://apidocjs.com/</a></p>\n"},{"title":"centos免密码登录","date":"2017-11-30T06:53:47.000Z","_content":"\n配置免密码登录服务器。不用每次都要输入密码。\n\n## 环境说明\n\n客户机:Mac OS X\n服务器:CentOS 7\n客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.\n\n## 客户机配置\n\n1. 查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  \n2. 生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.\n\n## 服务器配置\n\n1.修改sshd配置文件(/etc/ssh/sshd_config).  \n找到以下内容，并去掉注释符”#“\n\n> RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)\nPubkeyAuthentication yes\nAuthorizedKeysFile  .ssh/authorized_keys\n\n2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:\n\n    cat ~/.ssh/id_rsa.pub | ssh user@host “cat - >> ~/.ssh/authorized_keys”\n    \n>注意:\n1 .ssh目录的权限必须是700\n2 .ssh/authorized_keys文件权限必须是600\n\n重启ssh： service sshd restart   \n然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.\n\n-----------------------------------------------------------\n## 更简单方式\n\n1、执行命令：ssh-keygen -t rsa -C \"xx@qq.com\"(随便编个字符串，一般用邮箱）\n2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；\n3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件\n\n\n\nyutao@localhost ~]$ ssh-copy-id yutao@192.168.161.132 #把秘钥拷贝到远程服务器\n","source":"_posts/centos-login-without-pwd.md","raw":"---\ntitle: centos免密码登录\ndate: 2017-11-30 14:53:47\ncategories: CentOs\ntags: centos登录\n---\n\n配置免密码登录服务器。不用每次都要输入密码。\n\n## 环境说明\n\n客户机:Mac OS X\n服务器:CentOS 7\n客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.\n\n## 客户机配置\n\n1. 查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  \n2. 生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.\n\n## 服务器配置\n\n1.修改sshd配置文件(/etc/ssh/sshd_config).  \n找到以下内容，并去掉注释符”#“\n\n> RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)\nPubkeyAuthentication yes\nAuthorizedKeysFile  .ssh/authorized_keys\n\n2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:\n\n    cat ~/.ssh/id_rsa.pub | ssh user@host “cat - >> ~/.ssh/authorized_keys”\n    \n>注意:\n1 .ssh目录的权限必须是700\n2 .ssh/authorized_keys文件权限必须是600\n\n重启ssh： service sshd restart   \n然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.\n\n-----------------------------------------------------------\n## 更简单方式\n\n1、执行命令：ssh-keygen -t rsa -C \"xx@qq.com\"(随便编个字符串，一般用邮箱）\n2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；\n3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件\n\n\n\nyutao@localhost ~]$ ssh-copy-id yutao@192.168.161.132 #把秘钥拷贝到远程服务器\n","slug":"centos-login-without-pwd","published":1,"updated":"2018-01-02T08:00:56.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioik0007d5hszih6pgms","content":"<p>配置免密码登录服务器。不用每次都要输入密码。</p>\n<h2 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h2><p>客户机:Mac OS X<br>服务器:CentOS 7<br>客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.</p>\n<h2 id=\"客户机配置\"><a href=\"#客户机配置\" class=\"headerlink\" title=\"客户机配置\"></a>客户机配置</h2><ol>\n<li>查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  </li>\n<li>生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.</li>\n</ol>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>1.修改sshd配置文件(/etc/ssh/sshd_config).<br>找到以下内容，并去掉注释符”#“</p>\n<blockquote>\n<p>RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys</p>\n</blockquote>\n<p>2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:</p>\n<pre><code>cat ~/.ssh/id_rsa.pub | ssh user@host “cat - &gt;&gt; ~/.ssh/authorized_keys”\n</code></pre><blockquote>\n<p>注意:<br>1 .ssh目录的权限必须是700<br>2 .ssh/authorized_keys文件权限必须是600</p>\n</blockquote>\n<p>重启ssh： service sshd restart<br>然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.</p>\n<hr>\n<h2 id=\"更简单方式\"><a href=\"#更简单方式\" class=\"headerlink\" title=\"更简单方式\"></a>更简单方式</h2><p>1、执行命令：ssh-keygen -t rsa -C “xx@qq.com”(随便编个字符串，一般用邮箱）<br>2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；<br>3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件</p>\n<p>yutao@localhost ~]$ ssh-copy-id yutao@192.168.161.132 #把秘钥拷贝到远程服务器</p>\n","site":{"data":{}},"excerpt":"","more":"<p>配置免密码登录服务器。不用每次都要输入密码。</p>\n<h2 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h2><p>客户机:Mac OS X<br>服务器:CentOS 7<br>客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.</p>\n<h2 id=\"客户机配置\"><a href=\"#客户机配置\" class=\"headerlink\" title=\"客户机配置\"></a>客户机配置</h2><ol>\n<li>查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  </li>\n<li>生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.</li>\n</ol>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>1.修改sshd配置文件(/etc/ssh/sshd_config).<br>找到以下内容，并去掉注释符”#“</p>\n<blockquote>\n<p>RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys</p>\n</blockquote>\n<p>2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:</p>\n<pre><code>cat ~/.ssh/id_rsa.pub | ssh user@host “cat - &gt;&gt; ~/.ssh/authorized_keys”\n</code></pre><blockquote>\n<p>注意:<br>1 .ssh目录的权限必须是700<br>2 .ssh/authorized_keys文件权限必须是600</p>\n</blockquote>\n<p>重启ssh： service sshd restart<br>然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.</p>\n<hr>\n<h2 id=\"更简单方式\"><a href=\"#更简单方式\" class=\"headerlink\" title=\"更简单方式\"></a>更简单方式</h2><p>1、执行命令：ssh-keygen -t rsa -C “xx@qq.com”(随便编个字符串，一般用邮箱）<br>2、之后一路回车就行啦；会在～（home）目录下中产生.ssh（隐藏）文件夹；<br>3、里面有两个文件id_rsa(私钥)、id_rsa.pub(公钥)文件</p>\n<p>yutao@localhost ~]$ ssh-copy-id yutao@192.168.161.132 #把秘钥拷贝到远程服务器</p>\n"},{"title":"centos7下搭建maven私仓Nexus","date":"2017-11-12T06:47:38.000Z","_content":"\n项目组件化，共用jar包，统一获取墙外jar包…… \n\n官方文档 [sonatype](https://www.sonatype.com/)\n\n## 安装jdk\n参考其他文章……\n\n\n## 下载Nexus Repository OSS\n> 下载地址：http://www.sonatype.com/download-oss-sonatype\n\n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n\n解压：\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n    \n## 启动\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n    [root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n\n如果启动成功，可以看到：\n\n > Started Sonatype Nexus OSS 3.6.0-02\n\n防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。\n\n在浏览器访问：http://47.52.236.72:8081/\n可以看到：\n\n{% asset_img a.png %}\n\n## 配置为Linux Service\n\n1. 编辑`bin/nexus.rc`：\n\n`[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc`\n\n添加： \n> run_as_user=\"root\"\n\n2. 在`/etc/init.d`放nexus软连接\n\n` ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus`\n\n3. 设置服务随系统自启\n命令：*chkconfig*\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n    [root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n\n5. 启动\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\n    WARNING: ************************************************************\n    WARNING: Detected execution as \"root\" user.  This is NOT recommended!\n    WARNING: ************************************************************\n    Starting nexus\n\n## 界面操作\n\n*1. 登录*\n\n默认账号密码：\nusername: admin\npwd: admin123\n\n{% asset_img b.png %} \n\n*2. 修改admin密码*\n\n{% asset_img c.png %}\n\n点击`More`\n\n{% asset_img d.png %}\n    \n## 创建maven仓库\n\n{% asset_img e.png %}\n\n简单介绍下几种repository的类型:\n\n> - hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。\n> - proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。\n> - group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。\n\n这里我们选择创建本地仓库：\n{% asset_img f.png %}\n\n填写内容：\n{% asset_img g.png %}\n\n> version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。\n\n创建成功：\n{% asset_img h.png %}\n\n添加到maven-public仓库组：\n{% asset_img j.png %}\n\n## 查看仓库\n如果上传了项目，在Nexus用户界面，选择components -> xiaoming-host\n\n{% asset_img i.png %}\n\n\n\n\n    \n","source":"_posts/centos-maven-nexus.md","raw":"---\ntitle: centos7下搭建maven私仓Nexus\ndate: 2017-11-12 14:47:38\ncategories: CentOs\ntags: centos-nexus\n---\n\n项目组件化，共用jar包，统一获取墙外jar包…… \n\n官方文档 [sonatype](https://www.sonatype.com/)\n\n## 安装jdk\n参考其他文章……\n\n\n## 下载Nexus Repository OSS\n> 下载地址：http://www.sonatype.com/download-oss-sonatype\n\n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n\n解压：\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n    \n## 启动\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n    [root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n\n如果启动成功，可以看到：\n\n > Started Sonatype Nexus OSS 3.6.0-02\n\n防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。\n\n在浏览器访问：http://47.52.236.72:8081/\n可以看到：\n\n{% asset_img a.png %}\n\n## 配置为Linux Service\n\n1. 编辑`bin/nexus.rc`：\n\n`[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc`\n\n添加： \n> run_as_user=\"root\"\n\n2. 在`/etc/init.d`放nexus软连接\n\n` ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus`\n\n3. 设置服务随系统自启\n命令：*chkconfig*\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n    [root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n\n5. 启动\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\n    WARNING: ************************************************************\n    WARNING: Detected execution as \"root\" user.  This is NOT recommended!\n    WARNING: ************************************************************\n    Starting nexus\n\n## 界面操作\n\n*1. 登录*\n\n默认账号密码：\nusername: admin\npwd: admin123\n\n{% asset_img b.png %} \n\n*2. 修改admin密码*\n\n{% asset_img c.png %}\n\n点击`More`\n\n{% asset_img d.png %}\n    \n## 创建maven仓库\n\n{% asset_img e.png %}\n\n简单介绍下几种repository的类型:\n\n> - hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。\n> - proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。\n> - group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。\n\n这里我们选择创建本地仓库：\n{% asset_img f.png %}\n\n填写内容：\n{% asset_img g.png %}\n\n> version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。\n\n创建成功：\n{% asset_img h.png %}\n\n添加到maven-public仓库组：\n{% asset_img j.png %}\n\n## 查看仓库\n如果上传了项目，在Nexus用户界面，选择components -> xiaoming-host\n\n{% asset_img i.png %}\n\n\n\n\n    \n","slug":"centos-maven-nexus","published":1,"updated":"2017-12-31T09:13:45.226Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioip000bd5hskszbrp04","content":"<p>项目组件化，共用jar包，统一获取墙外jar包…… </p>\n<p>官方文档 <a href=\"https://www.sonatype.com/\" target=\"_blank\" rel=\"noopener\">sonatype</a></p>\n<h2 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h2><p>参考其他文章……</p>\n<h2 id=\"下载Nexus-Repository-OSS\"><a href=\"#下载Nexus-Repository-OSS\" class=\"headerlink\" title=\"下载Nexus Repository OSS\"></a>下载Nexus Repository OSS</h2><blockquote>\n<p>下载地址：<a href=\"http://www.sonatype.com/download-oss-sonatype\" target=\"_blank\" rel=\"noopener\">http://www.sonatype.com/download-oss-sonatype</a></p>\n</blockquote>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n</code></pre><p>解压：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n[root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n</code></pre><p>如果启动成功，可以看到：</p>\n<blockquote>\n<p>Started Sonatype Nexus OSS 3.6.0-02</p>\n</blockquote>\n<p>防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。</p>\n<p>在浏览器访问：<a href=\"http://47.52.236.72:8081/\" target=\"_blank\" rel=\"noopener\">http://47.52.236.72:8081/</a><br>可以看到：</p>\n<img src=\"/2017/11/12/centos-maven-nexus/a.png\">\n<h2 id=\"配置为Linux-Service\"><a href=\"#配置为Linux-Service\" class=\"headerlink\" title=\"配置为Linux Service\"></a>配置为Linux Service</h2><ol>\n<li>编辑<code>bin/nexus.rc</code>：</li>\n</ol>\n<p><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc</code></p>\n<p>添加： </p>\n<blockquote>\n<p>run_as_user=”root”</p>\n</blockquote>\n<ol>\n<li>在<code>/etc/init.d</code>放nexus软连接</li>\n</ol>\n<p><code>ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus</code></p>\n<ol>\n<li>设置服务随系统自启<br>命令：<em>chkconfig</em></li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n[root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n</code></pre><ol>\n<li>启动</li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\nWARNING: ************************************************************\nWARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!\nWARNING: ************************************************************\nStarting nexus\n</code></pre><h2 id=\"界面操作\"><a href=\"#界面操作\" class=\"headerlink\" title=\"界面操作\"></a>界面操作</h2><p><em>1. 登录</em></p>\n<p>默认账号密码：<br>username: admin<br>pwd: admin123</p>\n<img src=\"/2017/11/12/centos-maven-nexus/b.png\"> \n<p><em>2. 修改admin密码</em></p>\n<img src=\"/2017/11/12/centos-maven-nexus/c.png\">\n<p>点击<code>More</code></p>\n<img src=\"/2017/11/12/centos-maven-nexus/d.png\">\n<h2 id=\"创建maven仓库\"><a href=\"#创建maven仓库\" class=\"headerlink\" title=\"创建maven仓库\"></a>创建maven仓库</h2><img src=\"/2017/11/12/centos-maven-nexus/e.png\">\n<p>简单介绍下几种repository的类型:</p>\n<blockquote>\n<ul>\n<li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>\n<li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li>\n<li>group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li>\n</ul>\n</blockquote>\n<p>这里我们选择创建本地仓库：<br><img src=\"/2017/11/12/centos-maven-nexus/f.png\"></p>\n<p>填写内容：<br><img src=\"/2017/11/12/centos-maven-nexus/g.png\"></p>\n<blockquote>\n<p>version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。</p>\n</blockquote>\n<p>创建成功：<br><img src=\"/2017/11/12/centos-maven-nexus/h.png\"></p>\n<p>添加到maven-public仓库组：<br><img src=\"/2017/11/12/centos-maven-nexus/j.png\"></p>\n<h2 id=\"查看仓库\"><a href=\"#查看仓库\" class=\"headerlink\" title=\"查看仓库\"></a>查看仓库</h2><p>如果上传了项目，在Nexus用户界面，选择components -&gt; xiaoming-host</p>\n<img src=\"/2017/11/12/centos-maven-nexus/i.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>项目组件化，共用jar包，统一获取墙外jar包…… </p>\n<p>官方文档 <a href=\"https://www.sonatype.com/\" target=\"_blank\" rel=\"noopener\">sonatype</a></p>\n<h2 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h2><p>参考其他文章……</p>\n<h2 id=\"下载Nexus-Repository-OSS\"><a href=\"#下载Nexus-Repository-OSS\" class=\"headerlink\" title=\"下载Nexus Repository OSS\"></a>下载Nexus Repository OSS</h2><blockquote>\n<p>下载地址：<a href=\"http://www.sonatype.com/download-oss-sonatype\" target=\"_blank\" rel=\"noopener\">http://www.sonatype.com/download-oss-sonatype</a></p>\n</blockquote>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n</code></pre><p>解压：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n[root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n</code></pre><p>如果启动成功，可以看到：</p>\n<blockquote>\n<p>Started Sonatype Nexus OSS 3.6.0-02</p>\n</blockquote>\n<p>防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。</p>\n<p>在浏览器访问：<a href=\"http://47.52.236.72:8081/\" target=\"_blank\" rel=\"noopener\">http://47.52.236.72:8081/</a><br>可以看到：</p>\n<img src=\"/2017/11/12/centos-maven-nexus/a.png\">\n<h2 id=\"配置为Linux-Service\"><a href=\"#配置为Linux-Service\" class=\"headerlink\" title=\"配置为Linux Service\"></a>配置为Linux Service</h2><ol>\n<li>编辑<code>bin/nexus.rc</code>：</li>\n</ol>\n<p><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc</code></p>\n<p>添加： </p>\n<blockquote>\n<p>run_as_user=”root”</p>\n</blockquote>\n<ol>\n<li>在<code>/etc/init.d</code>放nexus软连接</li>\n</ol>\n<p><code>ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus</code></p>\n<ol>\n<li>设置服务随系统自启<br>命令：<em>chkconfig</em></li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n[root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n</code></pre><ol>\n<li>启动</li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\nWARNING: ************************************************************\nWARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!\nWARNING: ************************************************************\nStarting nexus\n</code></pre><h2 id=\"界面操作\"><a href=\"#界面操作\" class=\"headerlink\" title=\"界面操作\"></a>界面操作</h2><p><em>1. 登录</em></p>\n<p>默认账号密码：<br>username: admin<br>pwd: admin123</p>\n<img src=\"/2017/11/12/centos-maven-nexus/b.png\"> \n<p><em>2. 修改admin密码</em></p>\n<img src=\"/2017/11/12/centos-maven-nexus/c.png\">\n<p>点击<code>More</code></p>\n<img src=\"/2017/11/12/centos-maven-nexus/d.png\">\n<h2 id=\"创建maven仓库\"><a href=\"#创建maven仓库\" class=\"headerlink\" title=\"创建maven仓库\"></a>创建maven仓库</h2><img src=\"/2017/11/12/centos-maven-nexus/e.png\">\n<p>简单介绍下几种repository的类型:</p>\n<blockquote>\n<ul>\n<li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>\n<li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li>\n<li>group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li>\n</ul>\n</blockquote>\n<p>这里我们选择创建本地仓库：<br><img src=\"/2017/11/12/centos-maven-nexus/f.png\"></p>\n<p>填写内容：<br><img src=\"/2017/11/12/centos-maven-nexus/g.png\"></p>\n<blockquote>\n<p>version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。</p>\n</blockquote>\n<p>创建成功：<br><img src=\"/2017/11/12/centos-maven-nexus/h.png\"></p>\n<p>添加到maven-public仓库组：<br><img src=\"/2017/11/12/centos-maven-nexus/j.png\"></p>\n<h2 id=\"查看仓库\"><a href=\"#查看仓库\" class=\"headerlink\" title=\"查看仓库\"></a>查看仓库</h2><p>如果上传了项目，在Nexus用户界面，选择components -&gt; xiaoming-host</p>\n<img src=\"/2017/11/12/centos-maven-nexus/i.png\">\n"},{"title":"Cron 语法","date":"2017-10-24T02:23:19.000Z","_content":"\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]   \ncron语法主要用在定时任务上。linux系统有个类似的crontab。\n\n|   序号   |\t说明\t|是否必填|\t允许填写的值\t|允许的符号|\n|:---|:---|:---|:---|:---|\n|1\t|秒   |是\t|0－59\t|, - * /|\n |2\t|分\t    |是 |0－59\t|, - * /|\n |3\t|小时   |是\t |0－23 |\t, - * / |\n |4\t|日\t    |是\t |1－31\t|, - * ? / L W |\n |5\t|月\t    |是\t |1－12 or JAN-DEC\t|, - * /|\n |6\t|星期\t|是\t |1-7 or SUN-SAT\t|, - * ? / L #  |\n |7\t|年\t     |否\t|1970-2099\t|, - * / |\n \n> 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。\n\n_详细说明_\n\n“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。 \n“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。 \n“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。\n\n`*`表示所有值. 如在“分”上设置“`*`”，表示每分钟触发。 \n“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”\n\n“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同\n\n“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。 \n“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。 \n如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四\n\n> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n\nW表示离指定日期的最近那个工作日(周一至周五). \n例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。 \n如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。 \n如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。 \n如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。\n\n> 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；\n\n_常用示例_\n\n0 0 12 * * ? 每天12点触发\n\n0 15 10 ? * * 每天10点15分触发\n\n0 15 10 * * ? 每天10点15分触发\n\n0 15 10 * * ? * 每天10点15分触发\n\n0 15 10 * * ? 2005 2005年每天10点15分触发\n\n0 * 14 * * ? 每天14点到14点59分之间，每分钟触发一次\n\n0 0/5 14 * * ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）\n\n0 0/5 14，18 * * ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）\n\n0 0-5 14 * * ? 每天14点到14点05分之间，每分钟触发\n\n0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发\n\n0 15 10 ? * MON-FRI 周一到周五每天10点15分触发\n\n0 15 10 15 * ? 每月15号10点15分触发\n\n0 15 10 L * ? 每月最后一天的10点15分触发\n\n0 15 10 ? * 6L 每月最后一个周五的10点15分触发\n\n0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发\n\n0 15 10 ? * 6#3 每月第三个周五的10点15分触发\n\n0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次\n\n\n\n\n\n\n","source":"_posts/cron-grammar.md","raw":"---\ntitle:  Cron 语法\ndate: 2017-10-24 10:23:19\ncategories: java\ntags: cron-grammar\n---\n\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]   \ncron语法主要用在定时任务上。linux系统有个类似的crontab。\n\n|   序号   |\t说明\t|是否必填|\t允许填写的值\t|允许的符号|\n|:---|:---|:---|:---|:---|\n|1\t|秒   |是\t|0－59\t|, - * /|\n |2\t|分\t    |是 |0－59\t|, - * /|\n |3\t|小时   |是\t |0－23 |\t, - * / |\n |4\t|日\t    |是\t |1－31\t|, - * ? / L W |\n |5\t|月\t    |是\t |1－12 or JAN-DEC\t|, - * /|\n |6\t|星期\t|是\t |1-7 or SUN-SAT\t|, - * ? / L #  |\n |7\t|年\t     |否\t|1970-2099\t|, - * / |\n \n> 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。\n\n_详细说明_\n\n“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。 \n“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。 \n“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。\n\n`*`表示所有值. 如在“分”上设置“`*`”，表示每分钟触发。 \n“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”\n\n“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同\n\n“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。 \n“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。 \n如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四\n\n> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n\nW表示离指定日期的最近那个工作日(周一至周五). \n例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。 \n如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。 \n如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。 \n如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。\n\n> 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；\n\n_常用示例_\n\n0 0 12 * * ? 每天12点触发\n\n0 15 10 ? * * 每天10点15分触发\n\n0 15 10 * * ? 每天10点15分触发\n\n0 15 10 * * ? * 每天10点15分触发\n\n0 15 10 * * ? 2005 2005年每天10点15分触发\n\n0 * 14 * * ? 每天14点到14点59分之间，每分钟触发一次\n\n0 0/5 14 * * ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）\n\n0 0/5 14，18 * * ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）\n\n0 0-5 14 * * ? 每天14点到14点05分之间，每分钟触发\n\n0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发\n\n0 15 10 ? * MON-FRI 周一到周五每天10点15分触发\n\n0 15 10 15 * ? 每月15号10点15分触发\n\n0 15 10 L * ? 每月最后一天的10点15分触发\n\n0 15 10 ? * 6L 每月最后一个周五的10点15分触发\n\n0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发\n\n0 15 10 ? * 6#3 每月第三个周五的10点15分触发\n\n0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次\n\n\n\n\n\n\n","slug":"cron-grammar","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioiv000cd5hs004sfanh","content":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]<br>cron语法主要用在定时任务上。linux系统有个类似的crontab。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">允许填写的值</th>\n<th style=\"text-align:left\">允许的符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">秒</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">分</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">小时</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－23</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">日</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－31</td>\n<td style=\"text-align:left\">, - * ? / L W</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">月</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－12 or JAN-DEC</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">星期</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1-7 or SUN-SAT</td>\n<td style=\"text-align:left\">, - * ? / L #</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">1970-2099</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。</p>\n</blockquote>\n<p><em>详细说明</em></p>\n<p>“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。<br>“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。<br>“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。</p>\n<p><code>*</code>表示所有值. 如在“分”上设置“<code>*</code>”，表示每分钟触发。<br>“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”</p>\n<p>“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同</p>\n<p>“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。<br>“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。<br>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四</p>\n<blockquote>\n<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>\n</blockquote>\n<p>W表示离指定日期的最近那个工作日(周一至周五).<br>例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。<br>如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。<br>如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。<br>如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。</p>\n<blockquote>\n<p>小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；</p>\n</blockquote>\n<p><em>常用示例</em></p>\n<p>0 0 12 <em> </em> ? 每天12点触发</p>\n<p>0 15 10 ? <em> </em> 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? * 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 2005 2005年每天10点15分触发</p>\n<p>0 <em> 14 </em> * ? 每天14点到14点59分之间，每分钟触发一次</p>\n<p>0 0/5 14 <em> </em> ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）</p>\n<p>0 0/5 14，18 <em> </em> ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）</p>\n<p>0 0-5 14 <em> </em> ? 每天14点到14点05分之间，每分钟触发</p>\n<p>0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发</p>\n<p>0 15 10 ? * MON-FRI 周一到周五每天10点15分触发</p>\n<p>0 15 10 15 * ? 每月15号10点15分触发</p>\n<p>0 15 10 L * ? 每月最后一天的10点15分触发</p>\n<p>0 15 10 ? * 6L 每月最后一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6#3 每月第三个周五的10点15分触发</p>\n<p>0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]<br>cron语法主要用在定时任务上。linux系统有个类似的crontab。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">允许填写的值</th>\n<th style=\"text-align:left\">允许的符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">秒</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">分</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">小时</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－23</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">日</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－31</td>\n<td style=\"text-align:left\">, - * ? / L W</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">月</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－12 or JAN-DEC</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">星期</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1-7 or SUN-SAT</td>\n<td style=\"text-align:left\">, - * ? / L #</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">1970-2099</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。</p>\n</blockquote>\n<p><em>详细说明</em></p>\n<p>“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。<br>“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。<br>“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。</p>\n<p><code>*</code>表示所有值. 如在“分”上设置“<code>*</code>”，表示每分钟触发。<br>“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”</p>\n<p>“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同</p>\n<p>“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。<br>“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。<br>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四</p>\n<blockquote>\n<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>\n</blockquote>\n<p>W表示离指定日期的最近那个工作日(周一至周五).<br>例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。<br>如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。<br>如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。<br>如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。</p>\n<blockquote>\n<p>小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；</p>\n</blockquote>\n<p><em>常用示例</em></p>\n<p>0 0 12 <em> </em> ? 每天12点触发</p>\n<p>0 15 10 ? <em> </em> 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? * 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 2005 2005年每天10点15分触发</p>\n<p>0 <em> 14 </em> * ? 每天14点到14点59分之间，每分钟触发一次</p>\n<p>0 0/5 14 <em> </em> ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）</p>\n<p>0 0/5 14，18 <em> </em> ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）</p>\n<p>0 0-5 14 <em> </em> ? 每天14点到14点05分之间，每分钟触发</p>\n<p>0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发</p>\n<p>0 15 10 ? * MON-FRI 周一到周五每天10点15分触发</p>\n<p>0 15 10 15 * ? 每月15号10点15分触发</p>\n<p>0 15 10 L * ? 每月最后一天的10点15分触发</p>\n<p>0 15 10 ? * 6L 每月最后一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6#3 每月第三个周五的10点15分触发</p>\n<p>0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次</p>\n"},{"title":"分布式系统几大难点","date":"2017-11-08T06:57:10.000Z","_content":"\n## 1. 分布式ID\n\n## 2. 分布式事务\n\n## 3. 分布式缓存以及缓存与数据库的同步\n\n## 4. 数据库集群同步延迟问题\n\n## 5. 分布式跨库连表查询\n\n## 6. 分布式定时任务","source":"_posts/distributed-difficulty.md","raw":"---\ntitle: 分布式系统几大难点\ndate: 2017-11-08 14:57:10\ncategories: 分布式系统\ntags: distributed-difficulty\n---\n\n## 1. 分布式ID\n\n## 2. 分布式事务\n\n## 3. 分布式缓存以及缓存与数据库的同步\n\n## 4. 数据库集群同步延迟问题\n\n## 5. 分布式跨库连表查询\n\n## 6. 分布式定时任务","slug":"distributed-difficulty","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioiy000gd5hsbpo3msdm","content":"<h2 id=\"1-分布式ID\"><a href=\"#1-分布式ID\" class=\"headerlink\" title=\"1. 分布式ID\"></a>1. 分布式ID</h2><h2 id=\"2-分布式事务\"><a href=\"#2-分布式事务\" class=\"headerlink\" title=\"2. 分布式事务\"></a>2. 分布式事务</h2><h2 id=\"3-分布式缓存以及缓存与数据库的同步\"><a href=\"#3-分布式缓存以及缓存与数据库的同步\" class=\"headerlink\" title=\"3. 分布式缓存以及缓存与数据库的同步\"></a>3. 分布式缓存以及缓存与数据库的同步</h2><h2 id=\"4-数据库集群同步延迟问题\"><a href=\"#4-数据库集群同步延迟问题\" class=\"headerlink\" title=\"4. 数据库集群同步延迟问题\"></a>4. 数据库集群同步延迟问题</h2><h2 id=\"5-分布式跨库连表查询\"><a href=\"#5-分布式跨库连表查询\" class=\"headerlink\" title=\"5. 分布式跨库连表查询\"></a>5. 分布式跨库连表查询</h2><h2 id=\"6-分布式定时任务\"><a href=\"#6-分布式定时任务\" class=\"headerlink\" title=\"6. 分布式定时任务\"></a>6. 分布式定时任务</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-分布式ID\"><a href=\"#1-分布式ID\" class=\"headerlink\" title=\"1. 分布式ID\"></a>1. 分布式ID</h2><h2 id=\"2-分布式事务\"><a href=\"#2-分布式事务\" class=\"headerlink\" title=\"2. 分布式事务\"></a>2. 分布式事务</h2><h2 id=\"3-分布式缓存以及缓存与数据库的同步\"><a href=\"#3-分布式缓存以及缓存与数据库的同步\" class=\"headerlink\" title=\"3. 分布式缓存以及缓存与数据库的同步\"></a>3. 分布式缓存以及缓存与数据库的同步</h2><h2 id=\"4-数据库集群同步延迟问题\"><a href=\"#4-数据库集群同步延迟问题\" class=\"headerlink\" title=\"4. 数据库集群同步延迟问题\"></a>4. 数据库集群同步延迟问题</h2><h2 id=\"5-分布式跨库连表查询\"><a href=\"#5-分布式跨库连表查询\" class=\"headerlink\" title=\"5. 分布式跨库连表查询\"></a>5. 分布式跨库连表查询</h2><h2 id=\"6-分布式定时任务\"><a href=\"#6-分布式定时任务\" class=\"headerlink\" title=\"6. 分布式定时任务\"></a>6. 分布式定时任务</h2>"},{"title":"分布式ID生成-snowflake算法","date":"2017-09-20T03:06:57.000Z","_content":"## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","source":"_posts/distributed-id-snowflake.md","raw":"---\ntitle: 分布式ID生成-snowflake算法\ndate: 2017-09-20 11:06:57\ncategories: 分布式系统\ntags: snowflake算法\n---\n## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","slug":"distributed-id-snowflake","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioiz000jd5hsiklu902w","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>"},{"title":"centos7安装docker-ce","date":"2017-11-15T05:55:39.000Z","_content":"\n本文介绍docker在centos7系统上的安装。\n参考：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\n\n## 1. 卸载旧版本docker\n\n    $ sudo yum remove docker \\\n                      docker-common \\\n                      docker-selinux \\\n                      docker-engine\n\n---\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n    >                   docker-common \\\n    >                   docker-selinux \\\n    >                   docker-engine\n    Loaded plugins: fastestmirror\n    No Match for argument: docker\n    No Match for argument: docker-common\n    No Match for argument: docker-selinux\n    No Match for argument: docker-engine\n    No Packages marked for removal\n    \n    ---\n    表明没有旧版本\n    \n旧版本的会安装在`/var/lib/docker/`，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。\n \n## 2. 安装docker-ce\n\n共有三种方式安装,根据自己喜欢方式选择一种安装：\n- 配置安装源，从安装源拉取安装。推荐，但是网络要好\n- 下载安装包，执行安装。网络不好，采用。\n- 下载脚本执行安装。开发环境这种方式方便。\n\n### 2.1 repository方式安装，推荐\n第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。\n1. 安装依赖包\n\n\n    $ sudo yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n\n\n2. 安装源\n        \n        \n    $ sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo                   \n                      \n3. 可选: 开启edge和test源\n\n\n    $ sudo yum-config-manager --enable docker-ce-edge\n    $ sudo yum-config-manager --enable docker-ce-test                     \n    -----\n    关闭：\n    $ sudo yum-config-manager --disable docker-ce-edge    \n    \n4. 安装docker\n\n4.1 安装最新版本\n\n    $ sudo yum install docker-ce\n    \n> Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.\n\n4.2 安装指定版本\n在生成环境，有时候要安装指定版本。\n\n- 查看所有可用版本\n\n        $ yum list docker-ce --showduplicates | sort -r\n        \n        docker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n        \nThe contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).\n> Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.\n\n    $ sudo yum install <FULLY-QUALIFIED-PACKAGE-NAME>\n    \n4.3 启动docker                 \n    \n    $ sudo systemctl start docker                      \n\n4.4 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n会下载docker镜像，然后执行，打印信息。\n\n4.5 更新docker\n根据上面安装过程，重新安装即可。\n\n### 2.2 安装包方式（更喜欢方式）\n\n如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。\n\n1. 下载安装包：\n\n打开网址 *https://download.docker.com/linux/centos/7/x86_64/stable/Packages/*，下载`.rpm`合适版本下载。\n\n> Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.\n\n2. 安装docker\n指向包所在路径，如果是更新，把`install`改成`update`\n\n\n    $ sudo yum install /path/to/package.rpm\n      \n      \n3. 启动docker\n\n    $ sudo systemctl start docker\n    \n4. 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n{% asset_img a.png %}\n\n看到红色标注部分说明安装成功。    \n    \n5. 更新docker-ce\n下载新的安装包，用`yum -y upgrade`替换`yum -y install`,指向新的安装包。    \n\n## 3. 卸载docker-ce\n\n1. 卸载docker安装包：\n\n\n    $ sudo yum remove docker-ce\n    \n2. 卸载docker安装包不会自动删除相关资源，要手动删除：\n\n\n    $ sudo rm -rf /var/lib/docker\n                                      ","source":"_posts/docker-install-centos7.md","raw":"---\ntitle: centos7安装docker-ce\ndate: 2017-11-15 13:55:39\ncategories: docker\ntags: centos-docker-install\n---\n\n本文介绍docker在centos7系统上的安装。\n参考：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\n\n## 1. 卸载旧版本docker\n\n    $ sudo yum remove docker \\\n                      docker-common \\\n                      docker-selinux \\\n                      docker-engine\n\n---\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n    >                   docker-common \\\n    >                   docker-selinux \\\n    >                   docker-engine\n    Loaded plugins: fastestmirror\n    No Match for argument: docker\n    No Match for argument: docker-common\n    No Match for argument: docker-selinux\n    No Match for argument: docker-engine\n    No Packages marked for removal\n    \n    ---\n    表明没有旧版本\n    \n旧版本的会安装在`/var/lib/docker/`，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。\n \n## 2. 安装docker-ce\n\n共有三种方式安装,根据自己喜欢方式选择一种安装：\n- 配置安装源，从安装源拉取安装。推荐，但是网络要好\n- 下载安装包，执行安装。网络不好，采用。\n- 下载脚本执行安装。开发环境这种方式方便。\n\n### 2.1 repository方式安装，推荐\n第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。\n1. 安装依赖包\n\n\n    $ sudo yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n\n\n2. 安装源\n        \n        \n    $ sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo                   \n                      \n3. 可选: 开启edge和test源\n\n\n    $ sudo yum-config-manager --enable docker-ce-edge\n    $ sudo yum-config-manager --enable docker-ce-test                     \n    -----\n    关闭：\n    $ sudo yum-config-manager --disable docker-ce-edge    \n    \n4. 安装docker\n\n4.1 安装最新版本\n\n    $ sudo yum install docker-ce\n    \n> Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.\n\n4.2 安装指定版本\n在生成环境，有时候要安装指定版本。\n\n- 查看所有可用版本\n\n        $ yum list docker-ce --showduplicates | sort -r\n        \n        docker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n        \nThe contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).\n> Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.\n\n    $ sudo yum install <FULLY-QUALIFIED-PACKAGE-NAME>\n    \n4.3 启动docker                 \n    \n    $ sudo systemctl start docker                      \n\n4.4 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n会下载docker镜像，然后执行，打印信息。\n\n4.5 更新docker\n根据上面安装过程，重新安装即可。\n\n### 2.2 安装包方式（更喜欢方式）\n\n如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。\n\n1. 下载安装包：\n\n打开网址 *https://download.docker.com/linux/centos/7/x86_64/stable/Packages/*，下载`.rpm`合适版本下载。\n\n> Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.\n\n2. 安装docker\n指向包所在路径，如果是更新，把`install`改成`update`\n\n\n    $ sudo yum install /path/to/package.rpm\n      \n      \n3. 启动docker\n\n    $ sudo systemctl start docker\n    \n4. 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n{% asset_img a.png %}\n\n看到红色标注部分说明安装成功。    \n    \n5. 更新docker-ce\n下载新的安装包，用`yum -y upgrade`替换`yum -y install`,指向新的安装包。    \n\n## 3. 卸载docker-ce\n\n1. 卸载docker安装包：\n\n\n    $ sudo yum remove docker-ce\n    \n2. 卸载docker安装包不会自动删除相关资源，要手动删除：\n\n\n    $ sudo rm -rf /var/lib/docker\n                                      ","slug":"docker-install-centos7","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioj2000nd5hsc3np1na9","content":"<p>本文介绍docker在centos7系统上的安装。<br>参考：<a href=\"https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions</a></p>\n<h2 id=\"1-卸载旧版本docker\"><a href=\"#1-卸载旧版本docker\" class=\"headerlink\" title=\"1. 卸载旧版本docker\"></a>1. 卸载旧版本docker</h2><pre><code>$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n</code></pre><hr>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n&gt;                   docker-common \\\n&gt;                   docker-selinux \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror\nNo Match for argument: docker\nNo Match for argument: docker-common\nNo Match for argument: docker-selinux\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n---\n表明没有旧版本\n</code></pre><p>旧版本的会安装在<code>/var/lib/docker/</code>，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。</p>\n<h2 id=\"2-安装docker-ce\"><a href=\"#2-安装docker-ce\" class=\"headerlink\" title=\"2. 安装docker-ce\"></a>2. 安装docker-ce</h2><p>共有三种方式安装,根据自己喜欢方式选择一种安装：</p>\n<ul>\n<li>配置安装源，从安装源拉取安装。推荐，但是网络要好</li>\n<li>下载安装包，执行安装。网络不好，采用。</li>\n<li>下载脚本执行安装。开发环境这种方式方便。</li>\n</ul>\n<h3 id=\"2-1-repository方式安装，推荐\"><a href=\"#2-1-repository方式安装，推荐\" class=\"headerlink\" title=\"2.1 repository方式安装，推荐\"></a>2.1 repository方式安装，推荐</h3><p>第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。</p>\n<ol>\n<li>安装依赖包</li>\n</ol>\n<pre><code>$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre><ol>\n<li>安装源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo                   \n</code></pre><ol>\n<li>可选: 开启edge和test源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager --enable docker-ce-edge\n$ sudo yum-config-manager --enable docker-ce-test                     \n-----\n关闭：\n$ sudo yum-config-manager --disable docker-ce-edge    \n</code></pre><ol>\n<li>安装docker</li>\n</ol>\n<p>4.1 安装最新版本</p>\n<pre><code>$ sudo yum install docker-ce\n</code></pre><blockquote>\n<p>Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.</p>\n</blockquote>\n<p>4.2 安装指定版本<br>在生成环境，有时候要安装指定版本。</p>\n<ul>\n<li><p>查看所有可用版本</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n</code></pre></li>\n</ul>\n<p>The contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).</p>\n<blockquote>\n<p>Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.</p>\n</blockquote>\n<pre><code>$ sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt;\n</code></pre><p>4.3 启动docker                 </p>\n<pre><code>$ sudo systemctl start docker                      \n</code></pre><p>4.4 验证是否安装成功</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre><p>会下载docker镜像，然后执行，打印信息。</p>\n<p>4.5 更新docker<br>根据上面安装过程，重新安装即可。</p>\n<h3 id=\"2-2-安装包方式（更喜欢方式）\"><a href=\"#2-2-安装包方式（更喜欢方式）\" class=\"headerlink\" title=\"2.2 安装包方式（更喜欢方式）\"></a>2.2 安装包方式（更喜欢方式）</h3><p>如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。</p>\n<ol>\n<li>下载安装包：</li>\n</ol>\n<p>打开网址 <em><a href=\"https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></em>，下载<code>.rpm</code>合适版本下载。</p>\n<blockquote>\n<p>Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.</p>\n</blockquote>\n<ol>\n<li>安装docker<br>指向包所在路径，如果是更新，把<code>install</code>改成<code>update</code></li>\n</ol>\n<pre><code>$ sudo yum install /path/to/package.rpm\n</code></pre><ol>\n<li><p>启动docker</p>\n<p> $ sudo systemctl start docker</p>\n</li>\n<li><p>验证是否安装成功</p>\n<p> $ sudo docker run hello-world</p>\n</li>\n</ol>\n<img src=\"/2017/11/15/docker-install-centos7/a.png\">\n<p>看到红色标注部分说明安装成功。    </p>\n<ol>\n<li>更新docker-ce<br>下载新的安装包，用<code>yum -y upgrade</code>替换<code>yum -y install</code>,指向新的安装包。    </li>\n</ol>\n<h2 id=\"3-卸载docker-ce\"><a href=\"#3-卸载docker-ce\" class=\"headerlink\" title=\"3. 卸载docker-ce\"></a>3. 卸载docker-ce</h2><ol>\n<li>卸载docker安装包：</li>\n</ol>\n<pre><code>$ sudo yum remove docker-ce\n</code></pre><ol>\n<li>卸载docker安装包不会自动删除相关资源，要手动删除：</li>\n</ol>\n<pre><code>$ sudo rm -rf /var/lib/docker\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍docker在centos7系统上的安装。<br>参考：<a href=\"https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions</a></p>\n<h2 id=\"1-卸载旧版本docker\"><a href=\"#1-卸载旧版本docker\" class=\"headerlink\" title=\"1. 卸载旧版本docker\"></a>1. 卸载旧版本docker</h2><pre><code>$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n</code></pre><hr>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n&gt;                   docker-common \\\n&gt;                   docker-selinux \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror\nNo Match for argument: docker\nNo Match for argument: docker-common\nNo Match for argument: docker-selinux\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n---\n表明没有旧版本\n</code></pre><p>旧版本的会安装在<code>/var/lib/docker/</code>，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。</p>\n<h2 id=\"2-安装docker-ce\"><a href=\"#2-安装docker-ce\" class=\"headerlink\" title=\"2. 安装docker-ce\"></a>2. 安装docker-ce</h2><p>共有三种方式安装,根据自己喜欢方式选择一种安装：</p>\n<ul>\n<li>配置安装源，从安装源拉取安装。推荐，但是网络要好</li>\n<li>下载安装包，执行安装。网络不好，采用。</li>\n<li>下载脚本执行安装。开发环境这种方式方便。</li>\n</ul>\n<h3 id=\"2-1-repository方式安装，推荐\"><a href=\"#2-1-repository方式安装，推荐\" class=\"headerlink\" title=\"2.1 repository方式安装，推荐\"></a>2.1 repository方式安装，推荐</h3><p>第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。</p>\n<ol>\n<li>安装依赖包</li>\n</ol>\n<pre><code>$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre><ol>\n<li>安装源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo                   \n</code></pre><ol>\n<li>可选: 开启edge和test源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager --enable docker-ce-edge\n$ sudo yum-config-manager --enable docker-ce-test                     \n-----\n关闭：\n$ sudo yum-config-manager --disable docker-ce-edge    \n</code></pre><ol>\n<li>安装docker</li>\n</ol>\n<p>4.1 安装最新版本</p>\n<pre><code>$ sudo yum install docker-ce\n</code></pre><blockquote>\n<p>Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.</p>\n</blockquote>\n<p>4.2 安装指定版本<br>在生成环境，有时候要安装指定版本。</p>\n<ul>\n<li><p>查看所有可用版本</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n</code></pre></li>\n</ul>\n<p>The contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).</p>\n<blockquote>\n<p>Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.</p>\n</blockquote>\n<pre><code>$ sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt;\n</code></pre><p>4.3 启动docker                 </p>\n<pre><code>$ sudo systemctl start docker                      \n</code></pre><p>4.4 验证是否安装成功</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre><p>会下载docker镜像，然后执行，打印信息。</p>\n<p>4.5 更新docker<br>根据上面安装过程，重新安装即可。</p>\n<h3 id=\"2-2-安装包方式（更喜欢方式）\"><a href=\"#2-2-安装包方式（更喜欢方式）\" class=\"headerlink\" title=\"2.2 安装包方式（更喜欢方式）\"></a>2.2 安装包方式（更喜欢方式）</h3><p>如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。</p>\n<ol>\n<li>下载安装包：</li>\n</ol>\n<p>打开网址 <em><a href=\"https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\" target=\"_blank\" rel=\"noopener\">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></em>，下载<code>.rpm</code>合适版本下载。</p>\n<blockquote>\n<p>Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.</p>\n</blockquote>\n<ol>\n<li>安装docker<br>指向包所在路径，如果是更新，把<code>install</code>改成<code>update</code></li>\n</ol>\n<pre><code>$ sudo yum install /path/to/package.rpm\n</code></pre><ol>\n<li><p>启动docker</p>\n<p> $ sudo systemctl start docker</p>\n</li>\n<li><p>验证是否安装成功</p>\n<p> $ sudo docker run hello-world</p>\n</li>\n</ol>\n<img src=\"/2017/11/15/docker-install-centos7/a.png\">\n<p>看到红色标注部分说明安装成功。    </p>\n<ol>\n<li>更新docker-ce<br>下载新的安装包，用<code>yum -y upgrade</code>替换<code>yum -y install</code>,指向新的安装包。    </li>\n</ol>\n<h2 id=\"3-卸载docker-ce\"><a href=\"#3-卸载docker-ce\" class=\"headerlink\" title=\"3. 卸载docker-ce\"></a>3. 卸载docker-ce</h2><ol>\n<li>卸载docker安装包：</li>\n</ol>\n<pre><code>$ sudo yum remove docker-ce\n</code></pre><ol>\n<li>卸载docker安装包不会自动删除相关资源，要手动删除：</li>\n</ol>\n<pre><code>$ sudo rm -rf /var/lib/docker\n</code></pre>"},{"title":"concourse持续集成使用教程","date":"2018-02-10T02:35:22.000Z","_content":"\n官网：https://concourse.ci/","source":"_posts/concourse-tutorial.md","raw":"---\ntitle: concourse持续集成使用教程\ndate: 2018-02-10 10:35:22\ncategories: concourse\ntags: 持续集成交付\n---\n\n官网：https://concourse.ci/","slug":"concourse-tutorial","published":1,"updated":"2018-03-15T12:17:03.223Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioj4000pd5hsl3nkzhz4","content":"<p>官网：<a href=\"https://concourse.ci/\" target=\"_blank\" rel=\"noopener\">https://concourse.ci/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"https://concourse.ci/\" target=\"_blank\" rel=\"noopener\">https://concourse.ci/</a></p>\n"},{"title":"Ubuntu16.0.4安装docker-ce","date":"2018-02-28T01:55:22.000Z","_content":"\n本文介绍在Ubuntu环境下安装Docker ce……\n\n参考：https://docs.docker.com/install/linux/docker-ce/ubuntu/\n\n##  卸载旧版本：\n\n    $ sudo apt-get remove docker docker-engine docker.io\n\n## 安装系统可选内核\n\n参考：\nhttps://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\n\n## 使用 APT 安装\n\n- *更新系统包*\n\n\n    $ sudo apt-get update\n    \n    \n- *添加ca证书*\n\n由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。\n\n    \n    $ sudo apt-get install \\\n        apt-transport-https \\\n        ca-certificates \\\n        curl \\\n        software-properties-common    \n   \n如果出现错误：\n\n    E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\n    E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n\n执行下面命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n    \n然后再重试。\n\n\n- *添加软件源的GPG密钥*\n\n为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。\n\n    $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n    \n\n验证密钥：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\n    pub   4096R/0EBFCD88 2017-02-22\n          Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n    uid                  Docker Release (CE deb) <docker@docker.com>\n    sub   4096R/F273FCD8 2017-02-22\n    \n    mutian@mutian-ThinkPad-T440p:~$ \n\n\n- *添加Docker软件源* \n\n然后,我们需要向source.list\t中添加Docker软件源\n\n    $ sudo add-apt-repository \\\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n       $(lsb_release -cs) \\\n       stable\"\n       \n>以上命令会添加稳定版本的\tDocker\tCE\tAPT\t镜像源,如果需要最新或者测试版本的\nDocker\tCE\t请将\tstable\t改为\tedge\t或者\ttest。从\tDocker\t17.06\t开始,edge\ttest\t版本的\nAPT\t镜像源也会包含稳定版本的\tDocker。 \n\n- *安装DOCKER CE*\n\n1.更新系统包\n\n    $ sudo apt-get update\n    \n2.安装\n\n    $ sudo apt-get install docker-ce    \n\n\n## 镜像加速\n      \n国内从Docker\tHub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker\t官方和国\n内很多云服务商都提供了国内加速器服务,例如:   \n\n- [Docker官方提供的中国registry mirror](https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror)\n- [阿里云加速器](https://cr.console.aliyun.com/#/accelerator)\n- [DaoCloud\t加速器](https://www.daocloud.io/mirror#accelerator-doc) \n\n我们以Docker官方加速器为例进行介绍。\n\nUbuntu16.04+、Debian\t8+、CentOS7环境下：\n\n对于使用\tsystemd\t的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存\n在请新建该文件)\n\n    {\n    \t\t\"registry-mirrors\":\t[\n    \t\t\t\t\"https://registry.docker-cn.com\"\n    \t\t]\n    }\n    \n>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 \n\n之后重新启动服务。\n\n    $\tsudo systemctl daemon-reload\n    $\tsudo systemctl restart docker\n    \n\n## 测试安装是否成功\n\n    $ sudo docker run hello-world\n    \n\n如图出现则表示安装成功：\n\n{% asset_img a.png %}    \n    \n           ","source":"_posts/docker-install-ubuntu16.md","raw":"---\ntitle: Ubuntu16.0.4安装docker-ce\ndate: 2018-02-28 09:55:22\ncategories: docker\ntags: docker ce安装\n---\n\n本文介绍在Ubuntu环境下安装Docker ce……\n\n参考：https://docs.docker.com/install/linux/docker-ce/ubuntu/\n\n##  卸载旧版本：\n\n    $ sudo apt-get remove docker docker-engine docker.io\n\n## 安装系统可选内核\n\n参考：\nhttps://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\n\n## 使用 APT 安装\n\n- *更新系统包*\n\n\n    $ sudo apt-get update\n    \n    \n- *添加ca证书*\n\n由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。\n\n    \n    $ sudo apt-get install \\\n        apt-transport-https \\\n        ca-certificates \\\n        curl \\\n        software-properties-common    \n   \n如果出现错误：\n\n    E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\n    E: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n\n执行下面命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\n    mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n    \n然后再重试。\n\n\n- *添加软件源的GPG密钥*\n\n为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。\n\n    $ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n    \n\n验证密钥：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\n    pub   4096R/0EBFCD88 2017-02-22\n          Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\n    uid                  Docker Release (CE deb) <docker@docker.com>\n    sub   4096R/F273FCD8 2017-02-22\n    \n    mutian@mutian-ThinkPad-T440p:~$ \n\n\n- *添加Docker软件源* \n\n然后,我们需要向source.list\t中添加Docker软件源\n\n    $ sudo add-apt-repository \\\n       \"deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n       $(lsb_release -cs) \\\n       stable\"\n       \n>以上命令会添加稳定版本的\tDocker\tCE\tAPT\t镜像源,如果需要最新或者测试版本的\nDocker\tCE\t请将\tstable\t改为\tedge\t或者\ttest。从\tDocker\t17.06\t开始,edge\ttest\t版本的\nAPT\t镜像源也会包含稳定版本的\tDocker。 \n\n- *安装DOCKER CE*\n\n1.更新系统包\n\n    $ sudo apt-get update\n    \n2.安装\n\n    $ sudo apt-get install docker-ce    \n\n\n## 镜像加速\n      \n国内从Docker\tHub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker\t官方和国\n内很多云服务商都提供了国内加速器服务,例如:   \n\n- [Docker官方提供的中国registry mirror](https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror)\n- [阿里云加速器](https://cr.console.aliyun.com/#/accelerator)\n- [DaoCloud\t加速器](https://www.daocloud.io/mirror#accelerator-doc) \n\n我们以Docker官方加速器为例进行介绍。\n\nUbuntu16.04+、Debian\t8+、CentOS7环境下：\n\n对于使用\tsystemd\t的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存\n在请新建该文件)\n\n    {\n    \t\t\"registry-mirrors\":\t[\n    \t\t\t\t\"https://registry.docker-cn.com\"\n    \t\t]\n    }\n    \n>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 \n\n之后重新启动服务。\n\n    $\tsudo systemctl daemon-reload\n    $\tsudo systemctl restart docker\n    \n\n## 测试安装是否成功\n\n    $ sudo docker run hello-world\n    \n\n如图出现则表示安装成功：\n\n{% asset_img a.png %}    \n    \n           ","slug":"docker-install-ubuntu16","published":1,"updated":"2018-02-28T03:02:36.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioj8000td5hshrd3mb5s","content":"<p>本文介绍在Ubuntu环境下安装Docker ce……</p>\n<p>参考：<a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>\n<h2 id=\"卸载旧版本：\"><a href=\"#卸载旧版本：\" class=\"headerlink\" title=\"卸载旧版本：\"></a>卸载旧版本：</h2><pre><code>$ sudo apt-get remove docker docker-engine docker.io\n</code></pre><h2 id=\"安装系统可选内核\"><a href=\"#安装系统可选内核\" class=\"headerlink\" title=\"安装系统可选内核\"></a>安装系统可选内核</h2><p>参考：<br><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers</a></p>\n<h2 id=\"使用-APT-安装\"><a href=\"#使用-APT-安装\" class=\"headerlink\" title=\"使用 APT 安装\"></a>使用 APT 安装</h2><ul>\n<li><em>更新系统包</em></li>\n</ul>\n<pre><code>$ sudo apt-get update\n</code></pre><ul>\n<li><em>添加ca证书</em></li>\n</ul>\n<p>由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p>\n<pre><code>$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common    \n</code></pre><p>如果出现错误：</p>\n<pre><code>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\nE: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n</code></pre><p>执行下面命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\nmutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n</code></pre><p>然后再重试。</p>\n<ul>\n<li><em>添加软件源的GPG密钥</em></li>\n</ul>\n<p>为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。</p>\n<pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre><p>验证密钥：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\npub   4096R/0EBFCD88 2017-02-22\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) &lt;docker@docker.com&gt;\nsub   4096R/F273FCD8 2017-02-22\n\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><ul>\n<li><em>添加Docker软件源</em> </li>\n</ul>\n<p>然后,我们需要向source.list    中添加Docker软件源</p>\n<pre><code>$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre><blockquote>\n<p>以上命令会添加稳定版本的    Docker    CE    APT    镜像源,如果需要最新或者测试版本的<br>Docker    CE    请将    stable    改为    edge    或者    test。从    Docker    17.06    开始,edge    test    版本的<br>APT    镜像源也会包含稳定版本的    Docker。 </p>\n</blockquote>\n<ul>\n<li><em>安装DOCKER CE</em></li>\n</ul>\n<p>1.更新系统包</p>\n<pre><code>$ sudo apt-get update\n</code></pre><p>2.安装</p>\n<pre><code>$ sudo apt-get install docker-ce    \n</code></pre><h2 id=\"镜像加速\"><a href=\"#镜像加速\" class=\"headerlink\" title=\"镜像加速\"></a>镜像加速</h2><p>国内从Docker    Hub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker    官方和国<br>内很多云服务商都提供了国内加速器服务,例如:   </p>\n<ul>\n<li><a href=\"https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror\" target=\"_blank\" rel=\"noopener\">Docker官方提供的中国registry mirror</a></li>\n<li><a href=\"https://cr.console.aliyun.com/#/accelerator\" target=\"_blank\" rel=\"noopener\">阿里云加速器</a></li>\n<li><a href=\"https://www.daocloud.io/mirror#accelerator-doc\" target=\"_blank\" rel=\"noopener\">DaoCloud    加速器</a> </li>\n</ul>\n<p>我们以Docker官方加速器为例进行介绍。</p>\n<p>Ubuntu16.04+、Debian    8+、CentOS7环境下：</p>\n<p>对于使用    systemd    的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存<br>在请新建该文件)</p>\n<pre><code>{\n        &quot;registry-mirrors&quot;:    [\n                &quot;https://registry.docker-cn.com&quot;\n        ]\n}\n</code></pre><blockquote>\n<p>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 </p>\n</blockquote>\n<p>之后重新启动服务。</p>\n<pre><code>$    sudo systemctl daemon-reload\n$    sudo systemctl restart docker\n</code></pre><h2 id=\"测试安装是否成功\"><a href=\"#测试安装是否成功\" class=\"headerlink\" title=\"测试安装是否成功\"></a>测试安装是否成功</h2><pre><code>$ sudo docker run hello-world\n</code></pre><p>如图出现则表示安装成功：</p>\n<img src=\"/2018/02/28/docker-install-ubuntu16/a.png\">    \n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在Ubuntu环境下安装Docker ce……</p>\n<p>参考：<a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/</a></p>\n<h2 id=\"卸载旧版本：\"><a href=\"#卸载旧版本：\" class=\"headerlink\" title=\"卸载旧版本：\"></a>卸载旧版本：</h2><pre><code>$ sudo apt-get remove docker docker-engine docker.io\n</code></pre><h2 id=\"安装系统可选内核\"><a href=\"#安装系统可选内核\" class=\"headerlink\" title=\"安装系统可选内核\"></a>安装系统可选内核</h2><p>参考：<br><a href=\"https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers\" target=\"_blank\" rel=\"noopener\">https://docs.docker.com/install/linux/docker-ce/ubuntu/#supported-storage-drivers</a></p>\n<h2 id=\"使用-APT-安装\"><a href=\"#使用-APT-安装\" class=\"headerlink\" title=\"使用 APT 安装\"></a>使用 APT 安装</h2><ul>\n<li><em>更新系统包</em></li>\n</ul>\n<pre><code>$ sudo apt-get update\n</code></pre><ul>\n<li><em>添加ca证书</em></li>\n</ul>\n<p>由于apt源使用HTTPS以确保软件下载过程中不被篡改。因此,我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p>\n<pre><code>$ sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common    \n</code></pre><p>如果出现错误：</p>\n<pre><code>E: Could not get lock /var/lib/dpkg/lock - open (11: Resource temporarily unavailable)\nE: Unable to lock the administration directory (/var/lib/dpkg/), is another process using it?\n</code></pre><p>执行下面命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo rm /var/cache/apt/archives/lock\nmutian@mutian-ThinkPad-T440p:~$ sudo rm /var/lib/dpkg/lock \n</code></pre><p>然后再重试。</p>\n<ul>\n<li><em>添加软件源的GPG密钥</em></li>\n</ul>\n<p>为了确认所下载软件包的合法性,需要添加软件源的GPG密钥。</p>\n<pre><code>$ curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -\n</code></pre><p>验证密钥：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo apt-key fingerprint 0EBFCD88\npub   4096R/0EBFCD88 2017-02-22\n      Key fingerprint = 9DC8 5822 9FC7 DD38 854A  E2D8 8D81 803C 0EBF CD88\nuid                  Docker Release (CE deb) &lt;docker@docker.com&gt;\nsub   4096R/F273FCD8 2017-02-22\n\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><ul>\n<li><em>添加Docker软件源</em> </li>\n</ul>\n<p>然后,我们需要向source.list    中添加Docker软件源</p>\n<pre><code>$ sudo add-apt-repository \\\n   &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu \\\n   $(lsb_release -cs) \\\n   stable&quot;\n</code></pre><blockquote>\n<p>以上命令会添加稳定版本的    Docker    CE    APT    镜像源,如果需要最新或者测试版本的<br>Docker    CE    请将    stable    改为    edge    或者    test。从    Docker    17.06    开始,edge    test    版本的<br>APT    镜像源也会包含稳定版本的    Docker。 </p>\n</blockquote>\n<ul>\n<li><em>安装DOCKER CE</em></li>\n</ul>\n<p>1.更新系统包</p>\n<pre><code>$ sudo apt-get update\n</code></pre><p>2.安装</p>\n<pre><code>$ sudo apt-get install docker-ce    \n</code></pre><h2 id=\"镜像加速\"><a href=\"#镜像加速\" class=\"headerlink\" title=\"镜像加速\"></a>镜像加速</h2><p>国内从Docker    Hub拉取镜像有时会遇到困难,此时可以配置镜像加速器。Docker    官方和国<br>内很多云服务商都提供了国内加速器服务,例如:   </p>\n<ul>\n<li><a href=\"https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror\" target=\"_blank\" rel=\"noopener\">Docker官方提供的中国registry mirror</a></li>\n<li><a href=\"https://cr.console.aliyun.com/#/accelerator\" target=\"_blank\" rel=\"noopener\">阿里云加速器</a></li>\n<li><a href=\"https://www.daocloud.io/mirror#accelerator-doc\" target=\"_blank\" rel=\"noopener\">DaoCloud    加速器</a> </li>\n</ul>\n<p>我们以Docker官方加速器为例进行介绍。</p>\n<p>Ubuntu16.04+、Debian    8+、CentOS7环境下：</p>\n<p>对于使用    systemd    的系统,请在/etc/docker/daemon.json中写入如下内容(如果文件不存<br>在请新建该文件)</p>\n<pre><code>{\n        &quot;registry-mirrors&quot;:    [\n                &quot;https://registry.docker-cn.com&quot;\n        ]\n}\n</code></pre><blockquote>\n<p>注意,一定要保证该文件符合json规范,否则Docker将不能启动。 </p>\n</blockquote>\n<p>之后重新启动服务。</p>\n<pre><code>$    sudo systemctl daemon-reload\n$    sudo systemctl restart docker\n</code></pre><h2 id=\"测试安装是否成功\"><a href=\"#测试安装是否成功\" class=\"headerlink\" title=\"测试安装是否成功\"></a>测试安装是否成功</h2><pre><code>$ sudo docker run hello-world\n</code></pre><p>如图出现则表示安装成功：</p>\n<img src=\"/2018/02/28/docker-install-ubuntu16/a.png\">    \n"},{"title":"docker学习-第一课：基础概念理解","date":"2018-02-02T02:16:25.000Z","_content":"\nDocker\t包括三个基本概念\n镜像(Image)\n容器(Container)\n仓库(Repository)\n理解了这三个概念,就理解了\tDocker\t的整个生命周期。\n\n## Docker镜像\ndocker镜像就像是一个只读的模板。 \n\n例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 \n\n镜像可以用来创建容器。甚至多个容器。 \n\nDocker\t提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一\n个已经做好的镜像来直接使用。\n\n## Docker容器\ndocker利用容器来运行应用。 \n\n容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全\n的平台\n\n可以把容器看做是一个简易版的\tLinux\t环境(包括root用户权限、进程空间、用户空间和网络空间等)和运\n行在其中的应用程序。\n\n`注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。`\n\n## Docker仓库\n仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区\n分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的\n标签(tag)。\n\n仓库分为公开仓库(Public)和私有仓库(Private)两种形式。\n\n最大的公开仓库是[Docker\tHub](https://hub.docker.com/),存放了数量庞大的镜像供用户下载。\t国内的公开仓库包括[Docker Pool]()等,可以提供大陆用户更稳定快速的访问。\n\n当然,用户也可以在本地网络内创建一个私有仓库。\n\n当用户创建了自己的镜像之后就可以使用\t \tpush\t \t命令将它上传到公有或者私有仓库,这样下次在另外一台\n机器上使用这个镜像时候,只需要从仓库上\t \tpull\t \t下来就可以了。\n\n`注:Docker\t仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。`\n\n","source":"_posts/docker-lesson1.md","raw":"---\ntitle: docker学习-第一课：基础概念理解\ndate: 2018-02-02 10:16:25\ncategories: docker\ntags: 基础概念\n---\n\nDocker\t包括三个基本概念\n镜像(Image)\n容器(Container)\n仓库(Repository)\n理解了这三个概念,就理解了\tDocker\t的整个生命周期。\n\n## Docker镜像\ndocker镜像就像是一个只读的模板。 \n\n例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 \n\n镜像可以用来创建容器。甚至多个容器。 \n\nDocker\t提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一\n个已经做好的镜像来直接使用。\n\n## Docker容器\ndocker利用容器来运行应用。 \n\n容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全\n的平台\n\n可以把容器看做是一个简易版的\tLinux\t环境(包括root用户权限、进程空间、用户空间和网络空间等)和运\n行在其中的应用程序。\n\n`注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。`\n\n## Docker仓库\n仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区\n分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的\n标签(tag)。\n\n仓库分为公开仓库(Public)和私有仓库(Private)两种形式。\n\n最大的公开仓库是[Docker\tHub](https://hub.docker.com/),存放了数量庞大的镜像供用户下载。\t国内的公开仓库包括[Docker Pool]()等,可以提供大陆用户更稳定快速的访问。\n\n当然,用户也可以在本地网络内创建一个私有仓库。\n\n当用户创建了自己的镜像之后就可以使用\t \tpush\t \t命令将它上传到公有或者私有仓库,这样下次在另外一台\n机器上使用这个镜像时候,只需要从仓库上\t \tpull\t \t下来就可以了。\n\n`注:Docker\t仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。`\n\n","slug":"docker-lesson1","published":1,"updated":"2018-02-02T03:42:56.647Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioj9000vd5hsk4a9ogzv","content":"<p>Docker    包括三个基本概念<br>镜像(Image)<br>容器(Container)<br>仓库(Repository)<br>理解了这三个概念,就理解了    Docker    的整个生命周期。</p>\n<h2 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h2><p>docker镜像就像是一个只读的模板。 </p>\n<p>例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 </p>\n<p>镜像可以用来创建容器。甚至多个容器。 </p>\n<p>Docker    提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一<br>个已经做好的镜像来直接使用。</p>\n<h2 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h2><p>docker利用容器来运行应用。 </p>\n<p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全<br>的平台</p>\n<p>可以把容器看做是一个简易版的    Linux    环境(包括root用户权限、进程空间、用户空间和网络空间等)和运<br>行在其中的应用程序。</p>\n<p><code>注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。</code></p>\n<h2 id=\"Docker仓库\"><a href=\"#Docker仓库\" class=\"headerlink\" title=\"Docker仓库\"></a>Docker仓库</h2><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区<br>分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的<br>标签(tag)。</p>\n<p>仓库分为公开仓库(Public)和私有仓库(Private)两种形式。</p>\n<p>最大的公开仓库是<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker    Hub</a>,存放了数量庞大的镜像供用户下载。    国内的公开仓库包括<a href=\"\">Docker Pool</a>等,可以提供大陆用户更稳定快速的访问。</p>\n<p>当然,用户也可以在本地网络内创建一个私有仓库。</p>\n<p>当用户创建了自己的镜像之后就可以使用         push         命令将它上传到公有或者私有仓库,这样下次在另外一台<br>机器上使用这个镜像时候,只需要从仓库上         pull         下来就可以了。</p>\n<p><code>注:Docker    仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>Docker    包括三个基本概念<br>镜像(Image)<br>容器(Container)<br>仓库(Repository)<br>理解了这三个概念,就理解了    Docker    的整个生命周期。</p>\n<h2 id=\"Docker镜像\"><a href=\"#Docker镜像\" class=\"headerlink\" title=\"Docker镜像\"></a>Docker镜像</h2><p>docker镜像就像是一个只读的模板。 </p>\n<p>例如：一个docker镜像可以包含一个完整的centos系统，里面只安装了nginx或者其他的应用程序。 </p>\n<p>镜像可以用来创建容器。甚至多个容器。 </p>\n<p>Docker    提供了一个很简单的机制来创建镜像或者更新现有的镜像,用户甚至可以直接从其他人那里下载一<br>个已经做好的镜像来直接使用。</p>\n<h2 id=\"Docker容器\"><a href=\"#Docker容器\" class=\"headerlink\" title=\"Docker容器\"></a>Docker容器</h2><p>docker利用容器来运行应用。 </p>\n<p>容器是从镜像创建的运行实例。它可以被启动、开始、停止、删除。每个容器都是相互隔离的、保证安全<br>的平台</p>\n<p>可以把容器看做是一个简易版的    Linux    环境(包括root用户权限、进程空间、用户空间和网络空间等)和运<br>行在其中的应用程序。</p>\n<p><code>注：镜像是只读的,容器在启动的时候创建一层可写层作为最上层。</code></p>\n<h2 id=\"Docker仓库\"><a href=\"#Docker仓库\" class=\"headerlink\" title=\"Docker仓库\"></a>Docker仓库</h2><p>仓库是集中存放镜像文件的场所。有时候会把仓库和仓库注册服务器(Registry)混为一谈,并不严格区<br>分。实际上,仓库注册服务器上往往存放着多个仓库,每个仓库中又包含了多个镜像,每个镜像有不同的<br>标签(tag)。</p>\n<p>仓库分为公开仓库(Public)和私有仓库(Private)两种形式。</p>\n<p>最大的公开仓库是<a href=\"https://hub.docker.com/\" target=\"_blank\" rel=\"noopener\">Docker    Hub</a>,存放了数量庞大的镜像供用户下载。    国内的公开仓库包括<a href=\"\">Docker Pool</a>等,可以提供大陆用户更稳定快速的访问。</p>\n<p>当然,用户也可以在本地网络内创建一个私有仓库。</p>\n<p>当用户创建了自己的镜像之后就可以使用         push         命令将它上传到公有或者私有仓库,这样下次在另外一台<br>机器上使用这个镜像时候,只需要从仓库上         pull         下来就可以了。</p>\n<p><code>注:Docker    仓库的概念跟Git类似,注册服务器可以理解为GitHub这样的托管服务。</code></p>\n"},{"title":"docker学习-第三课：镜像","date":"2018-02-02T13:36:08.000Z","_content":"\nDocker\t运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker\t会从镜像仓库下载(默认是\nDocker\tHub\t公共注册服务器中的仓库)。\n\n本章将介绍更多关于镜像的内容,包括:\n- 从仓库获取镜像;\n- 管理本地主机上的镜像;\n- 介绍镜像实现的基本原理。\n\n## 获取镜像\n\n在官方[Docker Hub](https://hub.docker.com/explore/)有大量高质量可用镜像。下面我们来看怎样获取这些镜像。\n\n从Docker\t镜像仓库获取镜像的命令是docker\tpull。其命令格式为: \n\n    docker pull\t[选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n具体的先选可以通过`docker pull\t--help`命令查看。镜像名称的格式：\n\n- Docker 镜像仓库地址:地址的格式一般是`<域名/IP>[:端口号]`。默认地址是Docker Hub。\n- 仓库名:如之前所说,这里的仓库名是两段式名称,即`<用户名>/<软件名>`。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。\n\n比如:\n\n    $\tdocker\tpull\tubuntu:16.04\n    16.04:\tPulling\tfrom\tlibrary/ubuntu\n    bf5d46315322:\tPull\tcomplete\n    9f13e0ac480c:\tPull\tcomplete\n    e8988b5b3097:\tPull\tcomplete\n    40af181810e7:\tPull\tcomplete\n    e6f7c7e5c03e:\tPull\tcomplete\n    Digest:\tsha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\n    Status:\tDownloaded\tnewer\timage\tfor\tubuntu:16.04\n    \n上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04\t,因此将会获取官方镜像library/ubuntu\t仓库中标签为16.04的镜像。    \n\n例子： \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n    [sudo] password for mutian: \n    Using default tag: latest\n    latest: Pulling from library/centos\n    af4b0a2388c6: Pull complete \n    Digest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n    Status: Downloaded newer image for centos:latest\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n\n## 运行\n\n有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。\n\n`sudo docker run -it --rm centos bash`\n\n    [root@5f6c0a6b41c1 ~]# cat /etc/os-release \n    NAME=\"CentOS Linux\"\n    VERSION=\"7 (Core)\"\n    ID=\"centos\"\n    ID_LIKE=\"rhel fedora\"\n    VERSION_ID=\"7\"\n    PRETTY_NAME=\"CentOS Linux 7 (Core)\"\n    ANSI_COLOR=\"0;31\"\n    CPE_NAME=\"cpe:/o:centos:centos:7\"\n    HOME_URL=\"https://www.centos.org/\"\n    BUG_REPORT_URL=\"https://bugs.centos.org/\"\n    \n    CENTOS_MANTISBT_PROJECT=\"CentOS-7\"\n    CENTOS_MANTISBT_PROJECT_VERSION=\"7\"\n    REDHAT_SUPPORT_PRODUCT=\"centos\"\n    REDHAT_SUPPORT_PRODUCT_VERSION=\"7\"\n    \n    [root@5f6c0a6b41c1 ~]# \n\n通过上面信息我们可以看到容器内系统信息。\n\n命令说明：\n\n`docker\trun`就是运行容器的命令,具体格式我们会在\t容器\t一节进行详细讲解,我们这里简要的说明一下上面用到的参数。\n\n- `-it`:这是两个参数,一个是`-i`:交互式操作,一个是`-t`终端。我们这里打算进入`bash`执行一些命令并查看返回结果,因此我们需要交互式终端。\n- `--rm`:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动`docker\trm`。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用`--rm`可以避免浪费空间。\n- `centos`:这是指用`centos`镜像为基础来启动容器。\n- `bash`:放在镜像名后的是命令,这里我们希望有个交互式`Shell`,因此用的是`bash`。\n\n进入系统后我们可以执行任何linux下的命令。\n\n最后我们通过`exit`退出了这个容器。\n退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了`--rm`命令。\n\n## 列出所有的镜像\n\n想列出所有已经下载的镜像，可以使用命令`docker\timage ls`\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    [sudo] password for mutian: \n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest              f2a91732366c        3 months ago        1.85kB\n\n\n上面列表包含了`仓库名`、`标签`、`镜像ID`、`创建时间`以及所占用空间。\n镜像\tID\t则是镜像的唯一标识,一个镜像可以对应多个标签。\n\n- 镜像体积SIZE：\n上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比\n每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。\n\n你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\n    TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\n    Images              2                   1                   207.2MB             207.2MB (99%)\n    Containers          1                   0                   0B                  0B\n    Local Volumes       0                   0                   0B                  0B\n    Build Cache \n\n\n- 虚悬镜像\n\n{%asset_img a.png %}\n\n如上图，命令查出来的就是虚悬镜像。其产生的原因是：\n由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。\n\n这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：\n\n    $ sudo docker image\tprune\n\n- 中间层镜像\n为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可\n能会看到一些依赖的中间层镜像。默认的`docker image\tls`列表中只会显示顶层镜像,如果\n希望显示包括中间层镜像在内的所有镜像的话,需要加\t`-a`参数。\n\n\n    $ sudo docker image ls -a\n\n这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 \n\n- 列出部分镜像\n上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。\n\n根据仓库名称列出镜像：\n    \n    sudo docker image ls centos\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n\n列出特定的某个镜像,也就是说指定仓库名和标签\n\n{%asset_img b.png%}\n\n过滤查找镜像，使用`--filter`。具体使用请百度。\n\n- 以特定格式显示\n\n只显示ID列：\n\n    sudo docker image ls -q\n    ff426288ea90\n    f2a91732366c\n\n用go模板语法定制格式显示\n比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"{{.ID}}:{{.Repository}}\"\n    ff426288ea90:centos\n    f2a91732366c:hello-world\n\n或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n    IMAGE ID            REPOSITORY          TAG\n    ff426288ea90        centos              latest\n    f2a91732366c        hello-world         latest\n\n## 删除本地镜像\n\n可以使用`docker\timage\trm`命令来删除本地镜像。格式如下：\n\n    $\tdocker image rm [选项] <镜像1> [<镜像2> ...]\n\n- 用\tID、镜像名、摘要删除镜像\n\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest        \n\n    #删除hello-world，段id，id一部分，能区分就行。\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n\n用仓库名删除：\n    \n    $ sudo docker image\trm\thello-world    \n\n当然,更精确的是使用镜像摘要删除镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n\n- 用\t`docker\timage\tls`命令来配合\n\n比如,我们需要删除所有仓库名为redis的镜像:\n\n    $ docker image rm $(docker image ls -q redis)\n\n## 利用commit理解镜像构成\n镜像是一层一层构成的。\n\n现在让我们以定制一个Web\t服务器为例子,来讲解镜像是如何构建的。\n\n    docker run --name webserver -d -p 80:80 nginx\n\n在浏览器可查看：\n\n{%asset_img c.png%}\n\n现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎\tDocker的文字,我们可以使用`docker\texec`命令进入容器,修改其内容 \n\n    > sudo docker exec -it webserver bash\n    root@3729b97e8226:/# echo '<h1>Hello,Docker!</h1>' >\t/usr/share/nginx/html/index.html\n    root@3729b97e8226:/#\texit\n\n然后刷新浏览器，就可以看到更改了。\n\n我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过`docker\tdiff`命令看到具体的改动。\n\n下面我们可以用下面的命令将容器保存为镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n    > --author \"zmt\" \\\n    > --message \"修改了默认页面\" \\\n    > webserver \\\n    > nginx:v2\n    sha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n    \n    #查看\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               v2                  e8023c09eed5        8 seconds ago       109MB\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest  \n\n查看镜像内历史记录：\n\n    $ docker history nginx:v2\n\n新的镜像定制好后,我们可以来运行这个镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n\n\n在浏览器查看：http://localhost:81/\n\n停止容器：`sudo docker kill --signal=SIGINT web2`\n    \n至此,我们第一次完成了定制镜像,使用的是`docker\tcommit`命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。\n\n> 注意：通常不会使用`docker commit`来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。\n\n## 使用Dockerfile定制镜像\n从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。\n\nDockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,\n因此每一条指令的内容,就是描述该层应当如何构建。\n\n- 简单例子：\n\n1.创建Dockerfile文件\n\n    mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\n    mutian@mutian-ThinkPad-T440p:~$ cd mynginx/\n    mutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n\n2.打开Dockerfile文件，编辑如下内容：\n    \n    FROM nginx\n    RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n\n3.构建镜像\n进入Dockerfile所在目录，执行命令：\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\n    Sending build context to Docker daemon  2.048kB\n    Step 1/2 : FROM nginx\n     ---> e548f1a579cf\n    Step 2/2 : RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n     ---> Running in d8c0149adf7e\n    Removing intermediate container d8c0149adf7e\n     ---> b92f375b41f0\n    Successfully built b92f375b41f0\n    Successfully tagged nginx:v3\n\n4.查看\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\n    nginx               v3                  b92f375b41f0        About a minute ago   109MB\n    nginx               v2                  e8023c09eed5        17 hours ago         109MB\n    nginx               latest              e548f1a579cf        8 days ago           109MB\n    centos              latest              ff426288ea90        7 weeks ago          207MB\n    hello-world         latest              f2a91732366c        3 months ago    \n    \n我们看到，TAG为v3的镜像就是我们刚才构建。    \n\n- FROM指定基础镜像\n","source":"_posts/docker-lesson3.md","raw":"---\ntitle: docker学习-第三课：镜像\ndate: 2018-02-02 21:36:08\ncategories: docker\ntags: docker镜像\n---\n\nDocker\t运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker\t会从镜像仓库下载(默认是\nDocker\tHub\t公共注册服务器中的仓库)。\n\n本章将介绍更多关于镜像的内容,包括:\n- 从仓库获取镜像;\n- 管理本地主机上的镜像;\n- 介绍镜像实现的基本原理。\n\n## 获取镜像\n\n在官方[Docker Hub](https://hub.docker.com/explore/)有大量高质量可用镜像。下面我们来看怎样获取这些镜像。\n\n从Docker\t镜像仓库获取镜像的命令是docker\tpull。其命令格式为: \n\n    docker pull\t[选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n\n具体的先选可以通过`docker pull\t--help`命令查看。镜像名称的格式：\n\n- Docker 镜像仓库地址:地址的格式一般是`<域名/IP>[:端口号]`。默认地址是Docker Hub。\n- 仓库名:如之前所说,这里的仓库名是两段式名称,即`<用户名>/<软件名>`。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。\n\n比如:\n\n    $\tdocker\tpull\tubuntu:16.04\n    16.04:\tPulling\tfrom\tlibrary/ubuntu\n    bf5d46315322:\tPull\tcomplete\n    9f13e0ac480c:\tPull\tcomplete\n    e8988b5b3097:\tPull\tcomplete\n    40af181810e7:\tPull\tcomplete\n    e6f7c7e5c03e:\tPull\tcomplete\n    Digest:\tsha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\n    Status:\tDownloaded\tnewer\timage\tfor\tubuntu:16.04\n    \n上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04\t,因此将会获取官方镜像library/ubuntu\t仓库中标签为16.04的镜像。    \n\n例子： \n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n    [sudo] password for mutian: \n    Using default tag: latest\n    latest: Pulling from library/centos\n    af4b0a2388c6: Pull complete \n    Digest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\n    Status: Downloaded newer image for centos:latest\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n\n## 运行\n\n有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。\n\n`sudo docker run -it --rm centos bash`\n\n    [root@5f6c0a6b41c1 ~]# cat /etc/os-release \n    NAME=\"CentOS Linux\"\n    VERSION=\"7 (Core)\"\n    ID=\"centos\"\n    ID_LIKE=\"rhel fedora\"\n    VERSION_ID=\"7\"\n    PRETTY_NAME=\"CentOS Linux 7 (Core)\"\n    ANSI_COLOR=\"0;31\"\n    CPE_NAME=\"cpe:/o:centos:centos:7\"\n    HOME_URL=\"https://www.centos.org/\"\n    BUG_REPORT_URL=\"https://bugs.centos.org/\"\n    \n    CENTOS_MANTISBT_PROJECT=\"CentOS-7\"\n    CENTOS_MANTISBT_PROJECT_VERSION=\"7\"\n    REDHAT_SUPPORT_PRODUCT=\"centos\"\n    REDHAT_SUPPORT_PRODUCT_VERSION=\"7\"\n    \n    [root@5f6c0a6b41c1 ~]# \n\n通过上面信息我们可以看到容器内系统信息。\n\n命令说明：\n\n`docker\trun`就是运行容器的命令,具体格式我们会在\t容器\t一节进行详细讲解,我们这里简要的说明一下上面用到的参数。\n\n- `-it`:这是两个参数,一个是`-i`:交互式操作,一个是`-t`终端。我们这里打算进入`bash`执行一些命令并查看返回结果,因此我们需要交互式终端。\n- `--rm`:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动`docker\trm`。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用`--rm`可以避免浪费空间。\n- `centos`:这是指用`centos`镜像为基础来启动容器。\n- `bash`:放在镜像名后的是命令,这里我们希望有个交互式`Shell`,因此用的是`bash`。\n\n进入系统后我们可以执行任何linux下的命令。\n\n最后我们通过`exit`退出了这个容器。\n退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了`--rm`命令。\n\n## 列出所有的镜像\n\n想列出所有已经下载的镜像，可以使用命令`docker\timage ls`\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    [sudo] password for mutian: \n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest              f2a91732366c        3 months ago        1.85kB\n\n\n上面列表包含了`仓库名`、`标签`、`镜像ID`、`创建时间`以及所占用空间。\n镜像\tID\t则是镜像的唯一标识,一个镜像可以对应多个标签。\n\n- 镜像体积SIZE：\n上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比\n每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。\n\n你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\n    TYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\n    Images              2                   1                   207.2MB             207.2MB (99%)\n    Containers          1                   0                   0B                  0B\n    Local Volumes       0                   0                   0B                  0B\n    Build Cache \n\n\n- 虚悬镜像\n\n{%asset_img a.png %}\n\n如上图，命令查出来的就是虚悬镜像。其产生的原因是：\n由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。\n\n这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：\n\n    $ sudo docker image\tprune\n\n- 中间层镜像\n为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可\n能会看到一些依赖的中间层镜像。默认的`docker image\tls`列表中只会显示顶层镜像,如果\n希望显示包括中间层镜像在内的所有镜像的话,需要加\t`-a`参数。\n\n\n    $ sudo docker image ls -a\n\n这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 \n\n- 列出部分镜像\n上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。\n\n根据仓库名称列出镜像：\n    \n    sudo docker image ls centos\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n\n列出特定的某个镜像,也就是说指定仓库名和标签\n\n{%asset_img b.png%}\n\n过滤查找镜像，使用`--filter`。具体使用请百度。\n\n- 以特定格式显示\n\n只显示ID列：\n\n    sudo docker image ls -q\n    ff426288ea90\n    f2a91732366c\n\n用go模板语法定制格式显示\n比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"{{.ID}}:{{.Repository}}\"\n    ff426288ea90:centos\n    f2a91732366c:hello-world\n\n或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format \"table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}\"\n    IMAGE ID            REPOSITORY          TAG\n    ff426288ea90        centos              latest\n    f2a91732366c        hello-world         latest\n\n## 删除本地镜像\n\n可以使用`docker\timage\trm`命令来删除本地镜像。格式如下：\n\n    $\tdocker image rm [选项] <镜像1> [<镜像2> ...]\n\n- 用\tID、镜像名、摘要删除镜像\n\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest        \n\n    #删除hello-world，段id，id一部分，能区分就行。\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n\n用仓库名删除：\n    \n    $ sudo docker image\trm\thello-world    \n\n当然,更精确的是使用镜像摘要删除镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n\n- 用\t`docker\timage\tls`命令来配合\n\n比如,我们需要删除所有仓库名为redis的镜像:\n\n    $ docker image rm $(docker image ls -q redis)\n\n## 利用commit理解镜像构成\n镜像是一层一层构成的。\n\n现在让我们以定制一个Web\t服务器为例子,来讲解镜像是如何构建的。\n\n    docker run --name webserver -d -p 80:80 nginx\n\n在浏览器可查看：\n\n{%asset_img c.png%}\n\n现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎\tDocker的文字,我们可以使用`docker\texec`命令进入容器,修改其内容 \n\n    > sudo docker exec -it webserver bash\n    root@3729b97e8226:/# echo '<h1>Hello,Docker!</h1>' >\t/usr/share/nginx/html/index.html\n    root@3729b97e8226:/#\texit\n\n然后刷新浏览器，就可以看到更改了。\n\n我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过`docker\tdiff`命令看到具体的改动。\n\n下面我们可以用下面的命令将容器保存为镜像：\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n    > --author \"zmt\" \\\n    > --message \"修改了默认页面\" \\\n    > webserver \\\n    > nginx:v2\n    sha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n    \n    #查看\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\n    nginx               v2                  e8023c09eed5        8 seconds ago       109MB\n    nginx               latest              e548f1a579cf        7 days ago          109MB\n    centos              latest              ff426288ea90        7 weeks ago         207MB\n    hello-world         latest  \n\n查看镜像内历史记录：\n\n    $ docker history nginx:v2\n\n新的镜像定制好后,我们可以来运行这个镜像。\n\n    mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n\n\n在浏览器查看：http://localhost:81/\n\n停止容器：`sudo docker kill --signal=SIGINT web2`\n    \n至此,我们第一次完成了定制镜像,使用的是`docker\tcommit`命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。\n\n> 注意：通常不会使用`docker commit`来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。\n\n## 使用Dockerfile定制镜像\n从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。\n\nDockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,\n因此每一条指令的内容,就是描述该层应当如何构建。\n\n- 简单例子：\n\n1.创建Dockerfile文件\n\n    mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\n    mutian@mutian-ThinkPad-T440p:~$ cd mynginx/\n    mutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n\n2.打开Dockerfile文件，编辑如下内容：\n    \n    FROM nginx\n    RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n\n3.构建镜像\n进入Dockerfile所在目录，执行命令：\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\n    Sending build context to Docker daemon  2.048kB\n    Step 1/2 : FROM nginx\n     ---> e548f1a579cf\n    Step 2/2 : RUN echo '<h1>您好，我是Nginx！</h1>' > /usr/share/nginx/html/index.html\n     ---> Running in d8c0149adf7e\n    Removing intermediate container d8c0149adf7e\n     ---> b92f375b41f0\n    Successfully built b92f375b41f0\n    Successfully tagged nginx:v3\n\n4.查看\n    \n    mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\n    REPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\n    nginx               v3                  b92f375b41f0        About a minute ago   109MB\n    nginx               v2                  e8023c09eed5        17 hours ago         109MB\n    nginx               latest              e548f1a579cf        8 days ago           109MB\n    centos              latest              ff426288ea90        7 weeks ago          207MB\n    hello-world         latest              f2a91732366c        3 months ago    \n    \n我们看到，TAG为v3的镜像就是我们刚才构建。    \n\n- FROM指定基础镜像\n","slug":"docker-lesson3","published":1,"updated":"2018-03-01T03:10:28.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojb000yd5hs0cd4zdwu","content":"<p>Docker    运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker    会从镜像仓库下载(默认是<br>Docker    Hub    公共注册服务器中的仓库)。</p>\n<p>本章将介绍更多关于镜像的内容,包括:</p>\n<ul>\n<li>从仓库获取镜像;</li>\n<li>管理本地主机上的镜像;</li>\n<li>介绍镜像实现的基本原理。</li>\n</ul>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>在官方<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>有大量高质量可用镜像。下面我们来看怎样获取这些镜像。</p>\n<p>从Docker    镜像仓库获取镜像的命令是docker    pull。其命令格式为: </p>\n<pre><code>docker pull    [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n</code></pre><p>具体的先选可以通过<code>docker pull    --help</code>命令查看。镜像名称的格式：</p>\n<ul>\n<li>Docker 镜像仓库地址:地址的格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub。</li>\n<li>仓库名:如之前所说,这里的仓库名是两段式名称,即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。</li>\n</ul>\n<p>比如:</p>\n<pre><code>$    docker    pull    ubuntu:16.04\n16.04:    Pulling    from    library/ubuntu\nbf5d46315322:    Pull    complete\n9f13e0ac480c:    Pull    complete\ne8988b5b3097:    Pull    complete\n40af181810e7:    Pull    complete\ne6f7c7e5c03e:    Pull    complete\nDigest:    sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\nStatus:    Downloaded    newer    image    for    ubuntu:16.04\n</code></pre><p>上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04    ,因此将会获取官方镜像library/ubuntu    仓库中标签为16.04的镜像。    </p>\n<p>例子： </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n[sudo] password for mutian: \nUsing default tag: latest\nlatest: Pulling from library/centos\naf4b0a2388c6: Pull complete \nDigest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\nStatus: Downloaded newer image for centos:latest\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。</p>\n<p><code>sudo docker run -it --rm centos bash</code></p>\n<pre><code>[root@5f6c0a6b41c1 ~]# cat /etc/os-release \nNAME=&quot;CentOS Linux&quot;\nVERSION=&quot;7 (Core)&quot;\nID=&quot;centos&quot;\nID_LIKE=&quot;rhel fedora&quot;\nVERSION_ID=&quot;7&quot;\nPRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;\nANSI_COLOR=&quot;0;31&quot;\nCPE_NAME=&quot;cpe:/o:centos:centos:7&quot;\nHOME_URL=&quot;https://www.centos.org/&quot;\nBUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;\n\nCENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;\nCENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;\nREDHAT_SUPPORT_PRODUCT=&quot;centos&quot;\nREDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;\n\n[root@5f6c0a6b41c1 ~]# \n</code></pre><p>通过上面信息我们可以看到容器内系统信息。</p>\n<p>命令说明：</p>\n<p><code>docker    run</code>就是运行容器的命令,具体格式我们会在    容器    一节进行详细讲解,我们这里简要的说明一下上面用到的参数。</p>\n<ul>\n<li><code>-it</code>:这是两个参数,一个是<code>-i</code>:交互式操作,一个是<code>-t</code>终端。我们这里打算进入<code>bash</code>执行一些命令并查看返回结果,因此我们需要交互式终端。</li>\n<li><code>--rm</code>:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动<code>docker    rm</code>。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用<code>--rm</code>可以避免浪费空间。</li>\n<li><code>centos</code>:这是指用<code>centos</code>镜像为基础来启动容器。</li>\n<li><code>bash</code>:放在镜像名后的是命令,这里我们希望有个交互式<code>Shell</code>,因此用的是<code>bash</code>。</li>\n</ul>\n<p>进入系统后我们可以执行任何linux下的命令。</p>\n<p>最后我们通过<code>exit</code>退出了这个容器。<br>退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了<code>--rm</code>命令。</p>\n<h2 id=\"列出所有的镜像\"><a href=\"#列出所有的镜像\" class=\"headerlink\" title=\"列出所有的镜像\"></a>列出所有的镜像</h2><p>想列出所有已经下载的镜像，可以使用命令<code>docker    image ls</code></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n[sudo] password for mutian: \nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest              f2a91732366c        3 months ago        1.85kB\n</code></pre><p>上面列表包含了<code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code>以及所占用空间。<br>镜像    ID    则是镜像的唯一标识,一个镜像可以对应多个标签。</p>\n<ul>\n<li>镜像体积SIZE：<br>上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比<br>每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。</li>\n</ul>\n<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\nTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\nImages              2                   1                   207.2MB             207.2MB (99%)\nContainers          1                   0                   0B                  0B\nLocal Volumes       0                   0                   0B                  0B\nBuild Cache \n</code></pre><ul>\n<li>虚悬镜像</li>\n</ul>\n<img src=\"/2018/02/02/docker-lesson3/a.png\">\n<p>如上图，命令查出来的就是虚悬镜像。其产生的原因是：<br>由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。</none></p>\n<p>这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：</p>\n<pre><code>$ sudo docker image    prune\n</code></pre><ul>\n<li>中间层镜像<br>为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可<br>能会看到一些依赖的中间层镜像。默认的<code>docker image    ls</code>列表中只会显示顶层镜像,如果<br>希望显示包括中间层镜像在内的所有镜像的话,需要加    <code>-a</code>参数。</li>\n</ul>\n<pre><code>$ sudo docker image ls -a\n</code></pre><p>这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 </p>\n<ul>\n<li>列出部分镜像<br>上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。</li>\n</ul>\n<p>根据仓库名称列出镜像：</p>\n<pre><code>sudo docker image ls centos\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\n</code></pre><p>列出特定的某个镜像,也就是说指定仓库名和标签</p>\n<img src=\"/2018/02/02/docker-lesson3/b.png\">\n<p>过滤查找镜像，使用<code>--filter</code>。具体使用请百度。</p>\n<ul>\n<li>以特定格式显示</li>\n</ul>\n<p>只显示ID列：</p>\n<pre><code>sudo docker image ls -q\nff426288ea90\nf2a91732366c\n</code></pre><p>用go模板语法定制格式显示<br>比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;{{.ID}}:{{.Repository}}&quot;\nff426288ea90:centos\nf2a91732366c:hello-world\n</code></pre><p>或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}&quot;\nIMAGE ID            REPOSITORY          TAG\nff426288ea90        centos              latest\nf2a91732366c        hello-world         latest\n</code></pre><h2 id=\"删除本地镜像\"><a href=\"#删除本地镜像\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用<code>docker    image    rm</code>命令来删除本地镜像。格式如下：</p>\n<pre><code>$    docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]\n</code></pre><ul>\n<li>用    ID、镜像名、摘要删除镜像</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest        \n\n#删除hello-world，段id，id一部分，能区分就行。\nmutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n</code></pre><p>用仓库名删除：</p>\n<pre><code>$ sudo docker image    rm    hello-world    \n</code></pre><p>当然,更精确的是使用镜像摘要删除镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n</code></pre><ul>\n<li>用    <code>docker    image    ls</code>命令来配合</li>\n</ul>\n<p>比如,我们需要删除所有仓库名为redis的镜像:</p>\n<pre><code>$ docker image rm $(docker image ls -q redis)\n</code></pre><h2 id=\"利用commit理解镜像构成\"><a href=\"#利用commit理解镜像构成\" class=\"headerlink\" title=\"利用commit理解镜像构成\"></a>利用commit理解镜像构成</h2><p>镜像是一层一层构成的。</p>\n<p>现在让我们以定制一个Web    服务器为例子,来讲解镜像是如何构建的。</p>\n<pre><code>docker run --name webserver -d -p 80:80 nginx\n</code></pre><p>在浏览器可查看：</p>\n<img src=\"/2018/02/02/docker-lesson3/c.png\">\n<p>现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎    Docker的文字,我们可以使用<code>docker    exec</code>命令进入容器,修改其内容 </p>\n<pre><code>&gt; sudo docker exec -it webserver bash\nroot@3729b97e8226:/# echo &apos;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&apos; &gt;    /usr/share/nginx/html/index.html\nroot@3729b97e8226:/#    exit\n</code></pre><p>然后刷新浏览器，就可以看到更改了。</p>\n<p>我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过<code>docker    diff</code>命令看到具体的改动。</p>\n<p>下面我们可以用下面的命令将容器保存为镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n&gt; --author &quot;zmt&quot; \\\n&gt; --message &quot;修改了默认页面&quot; \\\n&gt; webserver \\\n&gt; nginx:v2\nsha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n\n#查看\nmutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               v2                  e8023c09eed5        8 seconds ago       109MB\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest  \n</code></pre><p>查看镜像内历史记录：</p>\n<pre><code>$ docker history nginx:v2\n</code></pre><p>新的镜像定制好后,我们可以来运行这个镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n</code></pre><p>在浏览器查看：<a href=\"http://localhost:81/\" target=\"_blank\" rel=\"noopener\">http://localhost:81/</a></p>\n<p>停止容器：<code>sudo docker kill --signal=SIGINT web2</code></p>\n<p>至此,我们第一次完成了定制镜像,使用的是<code>docker    commit</code>命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。</p>\n<blockquote>\n<p>注意：通常不会使用<code>docker commit</code>来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。</p>\n</blockquote>\n<h2 id=\"使用Dockerfile定制镜像\"><a href=\"#使用Dockerfile定制镜像\" class=\"headerlink\" title=\"使用Dockerfile定制镜像\"></a>使用Dockerfile定制镜像</h2><p>从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。</p>\n<p>Dockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,<br>因此每一条指令的内容,就是描述该层应当如何构建。</p>\n<ul>\n<li>简单例子：</li>\n</ul>\n<p>1.创建Dockerfile文件</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\nmutian@mutian-ThinkPad-T440p:~$ cd mynginx/\nmutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n</code></pre><p>2.打开Dockerfile文件，编辑如下内容：</p>\n<pre><code>FROM nginx\nRUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n</code></pre><p>3.构建镜像<br>进入Dockerfile所在目录，执行命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\nSending build context to Docker daemon  2.048kB\nStep 1/2 : FROM nginx\n ---&gt; e548f1a579cf\nStep 2/2 : RUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n ---&gt; Running in d8c0149adf7e\nRemoving intermediate container d8c0149adf7e\n ---&gt; b92f375b41f0\nSuccessfully built b92f375b41f0\nSuccessfully tagged nginx:v3\n</code></pre><p>4.查看</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\nnginx               v3                  b92f375b41f0        About a minute ago   109MB\nnginx               v2                  e8023c09eed5        17 hours ago         109MB\nnginx               latest              e548f1a579cf        8 days ago           109MB\ncentos              latest              ff426288ea90        7 weeks ago          207MB\nhello-world         latest              f2a91732366c        3 months ago    \n</code></pre><p>我们看到，TAG为v3的镜像就是我们刚才构建。    </p>\n<ul>\n<li>FROM指定基础镜像</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>Docker    运行容器前需要本地存在对应的镜像,如果镜像不存在本地,Docker    会从镜像仓库下载(默认是<br>Docker    Hub    公共注册服务器中的仓库)。</p>\n<p>本章将介绍更多关于镜像的内容,包括:</p>\n<ul>\n<li>从仓库获取镜像;</li>\n<li>管理本地主机上的镜像;</li>\n<li>介绍镜像实现的基本原理。</li>\n</ul>\n<h2 id=\"获取镜像\"><a href=\"#获取镜像\" class=\"headerlink\" title=\"获取镜像\"></a>获取镜像</h2><p>在官方<a href=\"https://hub.docker.com/explore/\" target=\"_blank\" rel=\"noopener\">Docker Hub</a>有大量高质量可用镜像。下面我们来看怎样获取这些镜像。</p>\n<p>从Docker    镜像仓库获取镜像的命令是docker    pull。其命令格式为: </p>\n<pre><code>docker pull    [选项] [Docker Registry 地址[:端口号]/]仓库名[:标签]\n</code></pre><p>具体的先选可以通过<code>docker pull    --help</code>命令查看。镜像名称的格式：</p>\n<ul>\n<li>Docker 镜像仓库地址:地址的格式一般是<code>&lt;域名/IP&gt;[:端口号]</code>。默认地址是Docker Hub。</li>\n<li>仓库名:如之前所说,这里的仓库名是两段式名称,即<code>&lt;用户名&gt;/&lt;软件名&gt;</code>。对于Docker Hub,如果不给出用户名,则默认为library,也就是官方镜像。</li>\n</ul>\n<p>比如:</p>\n<pre><code>$    docker    pull    ubuntu:16.04\n16.04:    Pulling    from    library/ubuntu\nbf5d46315322:    Pull    complete\n9f13e0ac480c:    Pull    complete\ne8988b5b3097:    Pull    complete\n40af181810e7:    Pull    complete\ne6f7c7e5c03e:    Pull    complete\nDigest:    sha256:147913621d9cdea08853f6ba9116c2e27a3ceffecf3b492983ae97c3d643fbbe\nStatus:    Downloaded    newer    image    for    ubuntu:16.04\n</code></pre><p>上面的命令中没有给出Docker镜像仓库地址,因此将会从Docker Hub获取镜像。而镜像名称是ubuntu:16.04    ,因此将会获取官方镜像library/ubuntu    仓库中标签为16.04的镜像。    </p>\n<p>例子： </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker pull centos\n[sudo] password for mutian: \nUsing default tag: latest\nlatest: Pulling from library/centos\naf4b0a2388c6: Pull complete \nDigest: sha256:6247c7082d4c86c61b00f7f2e3edbf7f072a24aa8edc28b5b68b3de3101bc1ce\nStatus: Downloaded newer image for centos:latest\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><h2 id=\"运行\"><a href=\"#运行\" class=\"headerlink\" title=\"运行\"></a>运行</h2><p>有了镜像后,我们就能够以这个镜像为基础启动并运行一个容器。以上面的为例,如果我们打算启动里面的bash并且进行交互式操作的话,可以执行下面的命令。</p>\n<p><code>sudo docker run -it --rm centos bash</code></p>\n<pre><code>[root@5f6c0a6b41c1 ~]# cat /etc/os-release \nNAME=&quot;CentOS Linux&quot;\nVERSION=&quot;7 (Core)&quot;\nID=&quot;centos&quot;\nID_LIKE=&quot;rhel fedora&quot;\nVERSION_ID=&quot;7&quot;\nPRETTY_NAME=&quot;CentOS Linux 7 (Core)&quot;\nANSI_COLOR=&quot;0;31&quot;\nCPE_NAME=&quot;cpe:/o:centos:centos:7&quot;\nHOME_URL=&quot;https://www.centos.org/&quot;\nBUG_REPORT_URL=&quot;https://bugs.centos.org/&quot;\n\nCENTOS_MANTISBT_PROJECT=&quot;CentOS-7&quot;\nCENTOS_MANTISBT_PROJECT_VERSION=&quot;7&quot;\nREDHAT_SUPPORT_PRODUCT=&quot;centos&quot;\nREDHAT_SUPPORT_PRODUCT_VERSION=&quot;7&quot;\n\n[root@5f6c0a6b41c1 ~]# \n</code></pre><p>通过上面信息我们可以看到容器内系统信息。</p>\n<p>命令说明：</p>\n<p><code>docker    run</code>就是运行容器的命令,具体格式我们会在    容器    一节进行详细讲解,我们这里简要的说明一下上面用到的参数。</p>\n<ul>\n<li><code>-it</code>:这是两个参数,一个是<code>-i</code>:交互式操作,一个是<code>-t</code>终端。我们这里打算进入<code>bash</code>执行一些命令并查看返回结果,因此我们需要交互式终端。</li>\n<li><code>--rm</code>:这个参数是说容器退出后随之将其删除。默认情况下,为了排障需求,退出的容器并不会立即删除,除非手动<code>docker    rm</code>。我们这里只是随便执行个命令,看看结果,不需要排障和保留结果,因此使用<code>--rm</code>可以避免浪费空间。</li>\n<li><code>centos</code>:这是指用<code>centos</code>镜像为基础来启动容器。</li>\n<li><code>bash</code>:放在镜像名后的是命令,这里我们希望有个交互式<code>Shell</code>,因此用的是<code>bash</code>。</li>\n</ul>\n<p>进入系统后我们可以执行任何linux下的命令。</p>\n<p>最后我们通过<code>exit</code>退出了这个容器。<br>退出后，之前操作的所有内容将删除，重新进入系统，已经看不到。因为加了<code>--rm</code>命令。</p>\n<h2 id=\"列出所有的镜像\"><a href=\"#列出所有的镜像\" class=\"headerlink\" title=\"列出所有的镜像\"></a>列出所有的镜像</h2><p>想列出所有已经下载的镜像，可以使用命令<code>docker    image ls</code></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\n[sudo] password for mutian: \nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest              f2a91732366c        3 months ago        1.85kB\n</code></pre><p>上面列表包含了<code>仓库名</code>、<code>标签</code>、<code>镜像ID</code>、<code>创建时间</code>以及所占用空间。<br>镜像    ID    则是镜像的唯一标识,一个镜像可以对应多个标签。</p>\n<ul>\n<li>镜像体积SIZE：<br>上面个看到的镜像体积可能比Docker Hub上的大，因为Docker Hub上的是压缩的，本地的是解压后的。所有镜像的总体积会比<br>每个加起来的小，因为镜像是分层存储的，有些镜像共用相同部分。</li>\n</ul>\n<p>你可以通过以下命令来便捷的查看镜像、容器、数据卷所占用的空间。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker system df\nTYPE                TOTAL               ACTIVE              SIZE                RECLAIMABLE\nImages              2                   1                   207.2MB             207.2MB (99%)\nContainers          1                   0                   0B                  0B\nLocal Volumes       0                   0                   0B                  0B\nBuild Cache \n</code></pre><ul>\n<li>虚悬镜像</li>\n</ul>\n<img src=\"/2018/02/02/docker-lesson3/a.png\">\n<p>如上图，命令查出来的就是虚悬镜像。其产生的原因是：<br>由于新旧镜像同名,旧镜像名称被取消,从而出现仓库名、标签均为<none>的镜像。</none></p>\n<p>这种镜像已经失去了存在的意义，是可以删除的，可以用下面命令删除：</p>\n<pre><code>$ sudo docker image    prune\n</code></pre><ul>\n<li>中间层镜像<br>为了加速镜像构建、重复利用资源,Docker会利用中间层镜像。所以在使用一段时间后,可<br>能会看到一些依赖的中间层镜像。默认的<code>docker image    ls</code>列表中只会显示顶层镜像,如果<br>希望显示包括中间层镜像在内的所有镜像的话,需要加    <code>-a</code>参数。</li>\n</ul>\n<pre><code>$ sudo docker image ls -a\n</code></pre><p>这样会看到很多无标签的镜像,与之前的虚悬镜像不同,这些无标签的镜像很多都是中间层镜像,是其它镜像所依赖的镜像。这些无标签镜像不应该删除,否则会导致上层镜像因为依赖丢失而出错。实际上,这些镜像也没必要删除,因为之前说过,相同的层只会存一遍,而这些镜像是别的镜像的依赖,因此并不会因为它们被列出来而多存了一份,无论如何你也会需要它们。只要删除那些依赖它们的镜像后,这些依赖的中间层镜像也会被连带删除。 </p>\n<ul>\n<li>列出部分镜像<br>上面查看的是全部镜像，有的时候我们只是需要查看需要查看的镜像。</li>\n</ul>\n<p>根据仓库名称列出镜像：</p>\n<pre><code>sudo docker image ls centos\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\ncentos              latest              ff426288ea90        7 weeks ago         207MB\n</code></pre><p>列出特定的某个镜像,也就是说指定仓库名和标签</p>\n<img src=\"/2018/02/02/docker-lesson3/b.png\">\n<p>过滤查找镜像，使用<code>--filter</code>。具体使用请百度。</p>\n<ul>\n<li>以特定格式显示</li>\n</ul>\n<p>只显示ID列：</p>\n<pre><code>sudo docker image ls -q\nff426288ea90\nf2a91732366c\n</code></pre><p>用go模板语法定制格式显示<br>比如,下面的命令会直接列出镜像结果,并且只包含镜像ID和仓库名:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;{{.ID}}:{{.Repository}}&quot;\nff426288ea90:centos\nf2a91732366c:hello-world\n</code></pre><p>或者打算以表格等距显示,并且有标题行,和默认一样,不过自己定义列:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --format &quot;table{{.ID}}\\t{{.Repository}}\\t{{.Tag}}&quot;\nIMAGE ID            REPOSITORY          TAG\nff426288ea90        centos              latest\nf2a91732366c        hello-world         latest\n</code></pre><h2 id=\"删除本地镜像\"><a href=\"#删除本地镜像\" class=\"headerlink\" title=\"删除本地镜像\"></a>删除本地镜像</h2><p>可以使用<code>docker    image    rm</code>命令来删除本地镜像。格式如下：</p>\n<pre><code>$    docker image rm [选项] &lt;镜像1&gt; [&lt;镜像2&gt; ...]\n</code></pre><ul>\n<li>用    ID、镜像名、摘要删除镜像</li>\n</ul>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest        \n\n#删除hello-world，段id，id一部分，能区分就行。\nmutian@mutian-ThinkPad-T440p:~$ sudo docker rm f2a91\n</code></pre><p>用仓库名删除：</p>\n<pre><code>$ sudo docker image    rm    hello-world    \n</code></pre><p>当然,更精确的是使用镜像摘要删除镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker image ls --digests\n</code></pre><ul>\n<li>用    <code>docker    image    ls</code>命令来配合</li>\n</ul>\n<p>比如,我们需要删除所有仓库名为redis的镜像:</p>\n<pre><code>$ docker image rm $(docker image ls -q redis)\n</code></pre><h2 id=\"利用commit理解镜像构成\"><a href=\"#利用commit理解镜像构成\" class=\"headerlink\" title=\"利用commit理解镜像构成\"></a>利用commit理解镜像构成</h2><p>镜像是一层一层构成的。</p>\n<p>现在让我们以定制一个Web    服务器为例子,来讲解镜像是如何构建的。</p>\n<pre><code>docker run --name webserver -d -p 80:80 nginx\n</code></pre><p>在浏览器可查看：</p>\n<img src=\"/2018/02/02/docker-lesson3/c.png\">\n<p>现在,假设我们非常不喜欢这个欢迎页面,我们希望改成欢迎    Docker的文字,我们可以使用<code>docker    exec</code>命令进入容器,修改其内容 </p>\n<pre><code>&gt; sudo docker exec -it webserver bash\nroot@3729b97e8226:/# echo &apos;&lt;h1&gt;Hello,Docker!&lt;/h1&gt;&apos; &gt;    /usr/share/nginx/html/index.html\nroot@3729b97e8226:/#    exit\n</code></pre><p>然后刷新浏览器，就可以看到更改了。</p>\n<p>我们修改了容器的文件,也就是改动了容器的存储层。我们可以通过<code>docker    diff</code>命令看到具体的改动。</p>\n<p>下面我们可以用下面的命令将容器保存为镜像：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker commit \\\n&gt; --author &quot;zmt&quot; \\\n&gt; --message &quot;修改了默认页面&quot; \\\n&gt; webserver \\\n&gt; nginx:v2\nsha256:e8023c09eed50cf1dead0b2e9da1f8e324db7f1adf7fbb042371b0503ccd71c3\n\n#查看\nmutian@mutian-ThinkPad-T440p:~$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED             SIZE\nnginx               v2                  e8023c09eed5        8 seconds ago       109MB\nnginx               latest              e548f1a579cf        7 days ago          109MB\ncentos              latest              ff426288ea90        7 weeks ago         207MB\nhello-world         latest  \n</code></pre><p>查看镜像内历史记录：</p>\n<pre><code>$ docker history nginx:v2\n</code></pre><p>新的镜像定制好后,我们可以来运行这个镜像。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ sudo docker run --name web2 -d -p 81:80 nginx:v2\n</code></pre><p>在浏览器查看：<a href=\"http://localhost:81/\" target=\"_blank\" rel=\"noopener\">http://localhost:81/</a></p>\n<p>停止容器：<code>sudo docker kill --signal=SIGINT web2</code></p>\n<p>至此,我们第一次完成了定制镜像,使用的是<code>docker    commit</code>命令,手动操作给旧的镜像添加了新的一层,形成新的镜像,对镜像多层存储应该有了更直观的感觉。</p>\n<blockquote>\n<p>注意：通常不会使用<code>docker commit</code>来创建镜像，这样容易导致镜像臃肿。另外也无法知道每次更改，变成黑箱操作。</p>\n</blockquote>\n<h2 id=\"使用Dockerfile定制镜像\"><a href=\"#使用Dockerfile定制镜像\" class=\"headerlink\" title=\"使用Dockerfile定制镜像\"></a>使用Dockerfile定制镜像</h2><p>从上面commit我们知道，镜像是一层层定制，为了把整个定制层次透明，于是我们用脚本命令方式，把整个层次透明化，同时减少创建臃肿的镜像。而这个脚本文件，就是Dockerfile。</p>\n<p>Dockerfile是一个文本文件,其内包含了一条条的指令(Instruction),每一条指令构建一层,<br>因此每一条指令的内容,就是描述该层应当如何构建。</p>\n<ul>\n<li>简单例子：</li>\n</ul>\n<p>1.创建Dockerfile文件</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ mkdir mynginx\nmutian@mutian-ThinkPad-T440p:~$ cd mynginx/\nmutian@mutian-ThinkPad-T440p:~/mynginx$ touch Dockerfile\n</code></pre><p>2.打开Dockerfile文件，编辑如下内容：</p>\n<pre><code>FROM nginx\nRUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n</code></pre><p>3.构建镜像<br>进入Dockerfile所在目录，执行命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker build -t nginx:v3 .\nSending build context to Docker daemon  2.048kB\nStep 1/2 : FROM nginx\n ---&gt; e548f1a579cf\nStep 2/2 : RUN echo &apos;&lt;h1&gt;您好，我是Nginx！&lt;/h1&gt;&apos; &gt; /usr/share/nginx/html/index.html\n ---&gt; Running in d8c0149adf7e\nRemoving intermediate container d8c0149adf7e\n ---&gt; b92f375b41f0\nSuccessfully built b92f375b41f0\nSuccessfully tagged nginx:v3\n</code></pre><p>4.查看</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~/mynginx$ sudo docker image ls\nREPOSITORY          TAG                 IMAGE ID            CREATED              SIZE\nnginx               v3                  b92f375b41f0        About a minute ago   109MB\nnginx               v2                  e8023c09eed5        17 hours ago         109MB\nnginx               latest              e548f1a579cf        8 days ago           109MB\ncentos              latest              ff426288ea90        7 weeks ago          207MB\nhello-world         latest              f2a91732366c        3 months ago    \n</code></pre><p>我们看到，TAG为v3的镜像就是我们刚才构建。    </p>\n<ul>\n<li>FROM指定基础镜像</li>\n</ul>\n"},{"title":"fastdfs-分布式文件系统安装使用","date":"2018-02-01T02:51:36.000Z","_content":"\n本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……\n\n网址：https://github.com/happyfish100/fastdfs\n\n参考：\nhttp://blog.csdn.net/xyang81/article/details/52837974\nhttp://blog.csdn.net/playadota/article/details/78381109\n\n## centos下搭建\n\n### 第一步：安装依赖\n安装fastdfs之前，先要安装相关依赖包libfastcommon。 \n\n下载地址：https://github.com/happyfish100/libfastcommon.git\n\n`git clone https://github.com/happyfish100/libfastcommon.git`\n\n编译安装：\n\n    > cd libfastcommon\n    > ./make.sh\n    > ./make.sh install\n\n### 第二部：安装fastdfs\n下载：https://github.com/happyfish100/fastdfs\n\n- step 2. download FastDFS source package and unpack it, \ntar xzf FastDFS_v5.x.tar.gz\n\n- step 3. enter the FastDFS dir\n\n    `cd FastDFS`\n\n- step 4. execute:\n\n    `./make.sh`\n\n- step 5. make install\n\n    ./make.sh install`\n\n- step 6. edit/modify the config file of tracker and storage\n\n\n    cd /etc/fdfs/\n    cp tracker.conf.sample tracker.conf\n    cp storage.conf.sample storage.conf\n    mkdir -p /server/data/fdfs\n\n首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。\n\nbase_path=/server/data/fdfs/tracker  \n\n启动：\n    \n    #start the tracker server:\n    /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n    #in Linux, you can start fdfs_trackerd as a service:\n    /sbin/service fdfs_trackerd start \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_trackerd `    \n    \n设置tracker服务开启启动：\n    \n\n--------------\n修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。\n\n        # the base path to store data and log files\n        base_path=/server/data/fdfs/storeage\n        # tracker_server can ocur more than once, and tracker_server format is\n        #  \"host:port\", host can be hostname or ip address\n        tracker_server=192.168.1.36:22122\n        # store_path#, based 0, if store_path0 not exists, it's value is base_path\n        # the paths must be exist\n        store_path0=/server/data/fdfs/storeage\n        #store_path1=/home/yuqing/fastdfs2\n        \n启动：\n    \n    #start the storage server:\n    /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n    #in Linux, you can start fdfs_storaged as a service:\n    /sbin/service fdfs_storaged start  \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_storaged `  \n    \n停止:\n\n    `/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n    \n设置storage服务开机启动  \n\n停止：\n\n`/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop`       \n\n……\n\n## 测试\n更改`/etc/fdfs/下client.conf配置文件。\n\n`base_path=~/dev/fastdfs/data/client`   \n`tracker_server=192.168.147` _不能是`localhost`或者`127.0.0.1`_\n\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \n    This is FastDFS client test program v5.08\n    \n    Copyright (C) 2008, Happy Fish / YuQing\n    \n    FastDFS may be copied only under the terms of the GNU General\n    Public License V3, which may be found in the FastDFS source kit.\n    Please visit the FastDFS Home Page http://www.csource.org/ \n    for more detail.\n    \n    [2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n    \n    tracker_query_storage_store_list_without_group: \n    \tserver 1. group_name=, ip_addr=192.168.1.146, port=23000\n    \n    group_name=group1, ip_addr=192.168.1.146, port=23000\n    storage_upload_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    storage_upload_slave_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n    ####\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \n    group1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ cd\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \n    group1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n    \n\n## ubuntu下搭建\n\n验证过，上面过程适用…… \n\n## 集成nginx模块\n\n参考：https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\n\n1.下载`fastdfs-nginx-module`\n\n`git clone https://github.com/happyfish100/fastdfs-nginx-module.git`\n\n注意：安装的FastDFS版本 >= 5.11\n\n2.安装nginx-1.8.1\n\n下载：http://nginx.org/en/download.html\n\n    > ./configure --prefix=~/nginx \\\n     --add-module=/home/mutian/fastdfs-nginx-module/src\n    \n    > make; make install\n    \n3.更改nginx配置，添加一行。\n\n如果文件分组  \n        \n    location ~/group([0-9])/M00 {\n    \n        ngx_fastdfs_module;\n    \n    }\n\n如果没分组\n\n    location /M00 {\n        root /home/mutian/dev/fastdfs/data/storage/data;\n        ngx_fastdfs_module;\n    }\n    \n> 注意：\n A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。\n B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:\n location ~/group([0-9])/M00 {\n     ngx_fastdfs_module;\n }\n    \n    \n4.拷贝fdfs_storage的文件存储软链接\n\n`ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00`          \n\n5.更改配置`mod_fastdfs.conf`\n\n拷贝到相关目录：\n\n    cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n    \n更改内容：\n\n    connect_timeout=10\n    base_path=/tmp\n    tracker_server=ip01:22122\n    storage_server_port=23000\n    group_name=group1\n    url_have_group_name = true\n    store_path0=/home/mutian/dev/fastdfs/data/storage      \n    \n6.复制FastDFS 的部分配置文件到`/etc/fdfs`目录\n\n    mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\n    mutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\n    anti-steal.jpg  http.conf   storage.conf      tracker.conf\n    client.conf     mime.types  storage_ids.conf\n\n    cp http.conf mime.types /etc/fdfs/   \n    \n7.启动nginx\n\n`~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx` \n\n8.测试\n按上面步骤，上传个文件，然后在浏览器打开：\n\nhttp://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png \n\nor \n\nhttp://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png          ","source":"_posts/fastdfs-start.md","raw":"---\ntitle: fastdfs-分布式文件系统安装使用\ndate: 2018-02-01 10:51:36\ncategories: 文件存储系统\ntags: fastdfs-安装使用\n---\n\n本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……\n\n网址：https://github.com/happyfish100/fastdfs\n\n参考：\nhttp://blog.csdn.net/xyang81/article/details/52837974\nhttp://blog.csdn.net/playadota/article/details/78381109\n\n## centos下搭建\n\n### 第一步：安装依赖\n安装fastdfs之前，先要安装相关依赖包libfastcommon。 \n\n下载地址：https://github.com/happyfish100/libfastcommon.git\n\n`git clone https://github.com/happyfish100/libfastcommon.git`\n\n编译安装：\n\n    > cd libfastcommon\n    > ./make.sh\n    > ./make.sh install\n\n### 第二部：安装fastdfs\n下载：https://github.com/happyfish100/fastdfs\n\n- step 2. download FastDFS source package and unpack it, \ntar xzf FastDFS_v5.x.tar.gz\n\n- step 3. enter the FastDFS dir\n\n    `cd FastDFS`\n\n- step 4. execute:\n\n    `./make.sh`\n\n- step 5. make install\n\n    ./make.sh install`\n\n- step 6. edit/modify the config file of tracker and storage\n\n\n    cd /etc/fdfs/\n    cp tracker.conf.sample tracker.conf\n    cp storage.conf.sample storage.conf\n    mkdir -p /server/data/fdfs\n\n首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。\n\nbase_path=/server/data/fdfs/tracker  \n\n启动：\n    \n    #start the tracker server:\n    /usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n    #in Linux, you can start fdfs_trackerd as a service:\n    /sbin/service fdfs_trackerd start \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_trackerd `    \n    \n设置tracker服务开启启动：\n    \n\n--------------\n修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。\n\n        # the base path to store data and log files\n        base_path=/server/data/fdfs/storeage\n        # tracker_server can ocur more than once, and tracker_server format is\n        #  \"host:port\", host can be hostname or ip address\n        tracker_server=192.168.1.36:22122\n        # store_path#, based 0, if store_path0 not exists, it's value is base_path\n        # the paths must be exist\n        store_path0=/server/data/fdfs/storeage\n        #store_path1=/home/yuqing/fastdfs2\n        \n启动：\n    \n    #start the storage server:\n    /usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n    #in Linux, you can start fdfs_storaged as a service:\n    /sbin/service fdfs_storaged start  \n    \n检查启动是否成功：\n    `ps -ef | grep fdfs_storaged `  \n    \n停止:\n\n    `/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n    \n设置storage服务开机启动  \n\n停止：\n\n`/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop`       \n\n……\n\n## 测试\n更改`/etc/fdfs/下client.conf配置文件。\n\n`base_path=~/dev/fastdfs/data/client`   \n`tracker_server=192.168.147` _不能是`localhost`或者`127.0.0.1`_\n\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \n    This is FastDFS client test program v5.08\n    \n    Copyright (C) 2008, Happy Fish / YuQing\n    \n    FastDFS may be copied only under the terms of the GNU General\n    Public License V3, which may be found in the FastDFS source kit.\n    Please visit the FastDFS Home Page http://www.csource.org/ \n    for more detail.\n    \n    [2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n    \n    tracker_query_storage_store_list_without_group: \n    \tserver 1. group_name=, ip_addr=192.168.1.146, port=23000\n    \n    group_name=group1, ip_addr=192.168.1.146, port=23000\n    storage_upload_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\n    storage_upload_slave_by_filename\n    group_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    source ip address: 192.168.1.146\n    file timestamp=2018-03-06 09:48:19\n    file size=29\n    file crc32=514679935\n    example file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n    ####\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \n    group1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\n    mutian@mutian-ThinkPad-T440p:~/Pictures$ cd\n    mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \n    group1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n    \n\n## ubuntu下搭建\n\n验证过，上面过程适用…… \n\n## 集成nginx模块\n\n参考：https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\n\n1.下载`fastdfs-nginx-module`\n\n`git clone https://github.com/happyfish100/fastdfs-nginx-module.git`\n\n注意：安装的FastDFS版本 >= 5.11\n\n2.安装nginx-1.8.1\n\n下载：http://nginx.org/en/download.html\n\n    > ./configure --prefix=~/nginx \\\n     --add-module=/home/mutian/fastdfs-nginx-module/src\n    \n    > make; make install\n    \n3.更改nginx配置，添加一行。\n\n如果文件分组  \n        \n    location ~/group([0-9])/M00 {\n    \n        ngx_fastdfs_module;\n    \n    }\n\n如果没分组\n\n    location /M00 {\n        root /home/mutian/dev/fastdfs/data/storage/data;\n        ngx_fastdfs_module;\n    }\n    \n> 注意：\n A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。\n B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:\n location ~/group([0-9])/M00 {\n     ngx_fastdfs_module;\n }\n    \n    \n4.拷贝fdfs_storage的文件存储软链接\n\n`ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00`          \n\n5.更改配置`mod_fastdfs.conf`\n\n拷贝到相关目录：\n\n    cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n    \n更改内容：\n\n    connect_timeout=10\n    base_path=/tmp\n    tracker_server=ip01:22122\n    storage_server_port=23000\n    group_name=group1\n    url_have_group_name = true\n    store_path0=/home/mutian/dev/fastdfs/data/storage      \n    \n6.复制FastDFS 的部分配置文件到`/etc/fdfs`目录\n\n    mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\n    mutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\n    anti-steal.jpg  http.conf   storage.conf      tracker.conf\n    client.conf     mime.types  storage_ids.conf\n\n    cp http.conf mime.types /etc/fdfs/   \n    \n7.启动nginx\n\n`~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx` \n\n8.测试\n按上面步骤，上传个文件，然后在浏览器打开：\n\nhttp://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png \n\nor \n\nhttp://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png          ","slug":"fastdfs-start","published":1,"updated":"2018-05-03T09:58:26.159Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojc0011d5hscnuylg8l","content":"<p>本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……</p>\n<p>网址：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xyang81/article/details/52837974\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xyang81/article/details/52837974</a><br><a href=\"http://blog.csdn.net/playadota/article/details/78381109\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/playadota/article/details/78381109</a></p>\n<h2 id=\"centos下搭建\"><a href=\"#centos下搭建\" class=\"headerlink\" title=\"centos下搭建\"></a>centos下搭建</h2><h3 id=\"第一步：安装依赖\"><a href=\"#第一步：安装依赖\" class=\"headerlink\" title=\"第一步：安装依赖\"></a>第一步：安装依赖</h3><p>安装fastdfs之前，先要安装相关依赖包libfastcommon。 </p>\n<p>下载地址：<a href=\"https://github.com/happyfish100/libfastcommon.git\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/libfastcommon.git</a></p>\n<p><code>git clone https://github.com/happyfish100/libfastcommon.git</code></p>\n<p>编译安装：</p>\n<pre><code>&gt; cd libfastcommon\n&gt; ./make.sh\n&gt; ./make.sh install\n</code></pre><h3 id=\"第二部：安装fastdfs\"><a href=\"#第二部：安装fastdfs\" class=\"headerlink\" title=\"第二部：安装fastdfs\"></a>第二部：安装fastdfs</h3><p>下载：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<ul>\n<li><p>step 2. download FastDFS source package and unpack it,<br>tar xzf FastDFS_v5.x.tar.gz</p>\n</li>\n<li><p>step 3. enter the FastDFS dir</p>\n<p>  <code>cd FastDFS</code></p>\n</li>\n<li><p>step 4. execute:</p>\n<p>  <code>./make.sh</code></p>\n</li>\n<li><p>step 5. make install</p>\n<p>  ./make.sh install`</p>\n</li>\n<li><p>step 6. edit/modify the config file of tracker and storage</p>\n</li>\n</ul>\n<pre><code>cd /etc/fdfs/\ncp tracker.conf.sample tracker.conf\ncp storage.conf.sample storage.conf\nmkdir -p /server/data/fdfs\n</code></pre><p>首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。</p>\n<p>base_path=/server/data/fdfs/tracker  </p>\n<p>启动：</p>\n<pre><code>#start the tracker server:\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n#in Linux, you can start fdfs_trackerd as a service:\n/sbin/service fdfs_trackerd start \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_trackerd</code>    </p>\n<p>设置tracker服务开启启动：</p>\n<hr>\n<p>修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。</p>\n<pre><code># the base path to store data and log files\nbase_path=/server/data/fdfs/storeage\n# tracker_server can ocur more than once, and tracker_server format is\n#  &quot;host:port&quot;, host can be hostname or ip address\ntracker_server=192.168.1.36:22122\n# store_path#, based 0, if store_path0 not exists, it&apos;s value is base_path\n# the paths must be exist\nstore_path0=/server/data/fdfs/storeage\n#store_path1=/home/yuqing/fastdfs2\n</code></pre><p>启动：</p>\n<pre><code>#start the storage server:\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n#in Linux, you can start fdfs_storaged as a service:\n/sbin/service fdfs_storaged start  \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_storaged</code>  </p>\n<p>停止:</p>\n<pre><code>`/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n</code></pre><p>设置storage服务开机启动  </p>\n<p>停止：</p>\n<p><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop</code>       </p>\n<p>……</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更改`/etc/fdfs/下client.conf配置文件。</p>\n<p><code>base_path=~/dev/fastdfs/data/client</code><br><code>tracker_server=192.168.147</code> <em>不能是<code>localhost</code>或者<code>127.0.0.1</code></em></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \nThis is FastDFS client test program v5.08\n\nCopyright (C) 2008, Happy Fish / YuQing\n\nFastDFS may be copied only under the terms of the GNU General\nPublic License V3, which may be found in the FastDFS source kit.\nPlease visit the FastDFS Home Page http://www.csource.org/ \nfor more detail.\n\n[2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n\ntracker_query_storage_store_list_without_group: \n    server 1. group_name=, ip_addr=192.168.1.146, port=23000\n\ngroup_name=group1, ip_addr=192.168.1.146, port=23000\nstorage_upload_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nstorage_upload_slave_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nmutian@mutian-ThinkPad-T440p:~$ \n\n####\nmutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \ngroup1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\nmutian@mutian-ThinkPad-T440p:~/Pictures$ cd\nmutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \ngroup1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n</code></pre><h2 id=\"ubuntu下搭建\"><a href=\"#ubuntu下搭建\" class=\"headerlink\" title=\"ubuntu下搭建\"></a>ubuntu下搭建</h2><p>验证过，上面过程适用…… </p>\n<h2 id=\"集成nginx模块\"><a href=\"#集成nginx模块\" class=\"headerlink\" title=\"集成nginx模块\"></a>集成nginx模块</h2><p>参考：<a href=\"https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL</a></p>\n<p>1.下载<code>fastdfs-nginx-module</code></p>\n<p><code>git clone https://github.com/happyfish100/fastdfs-nginx-module.git</code></p>\n<p>注意：安装的FastDFS版本 &gt;= 5.11</p>\n<p>2.安装nginx-1.8.1</p>\n<p>下载：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a></p>\n<pre><code>&gt; ./configure --prefix=~/nginx \\\n --add-module=/home/mutian/fastdfs-nginx-module/src\n\n&gt; make; make install\n</code></pre><p>3.更改nginx配置，添加一行。</p>\n<p>如果文件分组  </p>\n<pre><code>location ~/group([0-9])/M00 {\n\n    ngx_fastdfs_module;\n\n}\n</code></pre><p>如果没分组</p>\n<pre><code>location /M00 {\n    root /home/mutian/dev/fastdfs/data/storage/data;\n    ngx_fastdfs_module;\n}\n</code></pre><blockquote>\n<p>注意：<br> A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。<br> B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:<br> location ~/group([0-9])/M00 {<br>     ngx_fastdfs_module;<br> }</p>\n</blockquote>\n<p>4.拷贝fdfs_storage的文件存储软链接</p>\n<p><code>ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00</code>          </p>\n<p>5.更改配置<code>mod_fastdfs.conf</code></p>\n<p>拷贝到相关目录：</p>\n<pre><code>cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n</code></pre><p>更改内容：</p>\n<pre><code>connect_timeout=10\nbase_path=/tmp\ntracker_server=ip01:22122\nstorage_server_port=23000\ngroup_name=group1\nurl_have_group_name = true\nstore_path0=/home/mutian/dev/fastdfs/data/storage      \n</code></pre><p>6.复制FastDFS 的部分配置文件到<code>/etc/fdfs</code>目录</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\nmutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\nanti-steal.jpg  http.conf   storage.conf      tracker.conf\nclient.conf     mime.types  storage_ids.conf\n\ncp http.conf mime.types /etc/fdfs/   \n</code></pre><p>7.启动nginx</p>\n<p><code>~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx</code> </p>\n<p>8.测试<br>按上面步骤，上传个文件，然后在浏览器打开：</p>\n<p><a href=\"http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a> </p>\n<p>or </p>\n<p><a href=\"http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a>          </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文记录FastDFS分布式文件系统的在服务器的搭建，配置以及使用……</p>\n<p>网址：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<p>参考：<br><a href=\"http://blog.csdn.net/xyang81/article/details/52837974\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/xyang81/article/details/52837974</a><br><a href=\"http://blog.csdn.net/playadota/article/details/78381109\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/playadota/article/details/78381109</a></p>\n<h2 id=\"centos下搭建\"><a href=\"#centos下搭建\" class=\"headerlink\" title=\"centos下搭建\"></a>centos下搭建</h2><h3 id=\"第一步：安装依赖\"><a href=\"#第一步：安装依赖\" class=\"headerlink\" title=\"第一步：安装依赖\"></a>第一步：安装依赖</h3><p>安装fastdfs之前，先要安装相关依赖包libfastcommon。 </p>\n<p>下载地址：<a href=\"https://github.com/happyfish100/libfastcommon.git\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/libfastcommon.git</a></p>\n<p><code>git clone https://github.com/happyfish100/libfastcommon.git</code></p>\n<p>编译安装：</p>\n<pre><code>&gt; cd libfastcommon\n&gt; ./make.sh\n&gt; ./make.sh install\n</code></pre><h3 id=\"第二部：安装fastdfs\"><a href=\"#第二部：安装fastdfs\" class=\"headerlink\" title=\"第二部：安装fastdfs\"></a>第二部：安装fastdfs</h3><p>下载：<a href=\"https://github.com/happyfish100/fastdfs\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs</a></p>\n<ul>\n<li><p>step 2. download FastDFS source package and unpack it,<br>tar xzf FastDFS_v5.x.tar.gz</p>\n</li>\n<li><p>step 3. enter the FastDFS dir</p>\n<p>  <code>cd FastDFS</code></p>\n</li>\n<li><p>step 4. execute:</p>\n<p>  <code>./make.sh</code></p>\n</li>\n<li><p>step 5. make install</p>\n<p>  ./make.sh install`</p>\n</li>\n<li><p>step 6. edit/modify the config file of tracker and storage</p>\n</li>\n</ul>\n<pre><code>cd /etc/fdfs/\ncp tracker.conf.sample tracker.conf\ncp storage.conf.sample storage.conf\nmkdir -p /server/data/fdfs\n</code></pre><p>首先修改配置文件：  /etc/fdfs/tracker.conf，修改路径到/server/data/fdfs目录。</p>\n<p>base_path=/server/data/fdfs/tracker  </p>\n<p>启动：</p>\n<pre><code>#start the tracker server:\n/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf restart\n#in Linux, you can start fdfs_trackerd as a service:\n/sbin/service fdfs_trackerd start \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_trackerd</code>    </p>\n<p>设置tracker服务开启启动：</p>\n<hr>\n<p>修改配置文件：  /etc/fdfs/storag.conf，修改路径到/server/data/fdfs目录，同时配置tracker_server地址。</p>\n<pre><code># the base path to store data and log files\nbase_path=/server/data/fdfs/storeage\n# tracker_server can ocur more than once, and tracker_server format is\n#  &quot;host:port&quot;, host can be hostname or ip address\ntracker_server=192.168.1.36:22122\n# store_path#, based 0, if store_path0 not exists, it&apos;s value is base_path\n# the paths must be exist\nstore_path0=/server/data/fdfs/storeage\n#store_path1=/home/yuqing/fastdfs2\n</code></pre><p>启动：</p>\n<pre><code>#start the storage server:\n/usr/bin/fdfs_storaged /etc/fdfs/storage.conf restart\n#in Linux, you can start fdfs_storaged as a service:\n/sbin/service fdfs_storaged start  \n</code></pre><p>检查启动是否成功：<br>    <code>ps -ef | grep fdfs_storaged</code>  </p>\n<p>停止:</p>\n<pre><code>`/usr/bin/fdfs_trackerd /etc/fdfs/tracker.conf stop`    \n</code></pre><p>设置storage服务开机启动  </p>\n<p>停止：</p>\n<p><code>/usr/bin/fdfs_storaged /etc/fdfs/storage.conf stop</code>       </p>\n<p>……</p>\n<h2 id=\"测试\"><a href=\"#测试\" class=\"headerlink\" title=\"测试\"></a>测试</h2><p>更改`/etc/fdfs/下client.conf配置文件。</p>\n<p><code>base_path=~/dev/fastdfs/data/client</code><br><code>tracker_server=192.168.147</code> <em>不能是<code>localhost</code>或者<code>127.0.0.1</code></em></p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_test /etc/fdfs/client.conf upload /home/mutian/ifconfig.sh \nThis is FastDFS client test program v5.08\n\nCopyright (C) 2008, Happy Fish / YuQing\n\nFastDFS may be copied only under the terms of the GNU General\nPublic License V3, which may be found in the FastDFS source kit.\nPlease visit the FastDFS Home Page http://www.csource.org/ \nfor more detail.\n\n[2018-03-06 09:48:19] DEBUG - base_path=/home/mutian/dev/fastdfs/data/client, connect_timeout=30, network_timeout=60, tracker_server_count=1, anti_steal_token=0, anti_steal_secret_key length=0, use_connection_pool=0, g_connection_pool_max_idle_time=3600s, use_storage_id=0, storage server id count: 0\n\ntracker_query_storage_store_list_without_group: \n    server 1. group_name=, ip_addr=192.168.1.146, port=23000\n\ngroup_name=group1, ip_addr=192.168.1.146, port=23000\nstorage_upload_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071.sh\nstorage_upload_slave_by_filename\ngroup_name=group1, remote_filename=M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nsource ip address: 192.168.1.146\nfile timestamp=2018-03-06 09:48:19\nfile size=29\nfile crc32=514679935\nexample file url: http://192.168.1.146/group1/M00/00/00/wKgBklqd82OAfszHAAAAHR6tZH87071_big.sh\nmutian@mutian-ThinkPad-T440p:~$ \n\n####\nmutian@mutian-ThinkPad-T440p:~/Pictures$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf aa.png \ngroup1/M00/00/00/wKgBklqgqI6AbB6yAAGUbXc7zK4788.png\nmutian@mutian-ThinkPad-T440p:~/Pictures$ cd\nmutian@mutian-ThinkPad-T440p:~$ /usr/bin/fdfs_upload_file /etc/fdfs/client.conf south_air.zip \ngroup1/M00/00/00/wKgBklqgqSaABpepFCjSUGWmckg821.zip\n</code></pre><h2 id=\"ubuntu下搭建\"><a href=\"#ubuntu下搭建\" class=\"headerlink\" title=\"ubuntu下搭建\"></a>ubuntu下搭建</h2><p>验证过，上面过程适用…… </p>\n<h2 id=\"集成nginx模块\"><a href=\"#集成nginx模块\" class=\"headerlink\" title=\"集成nginx模块\"></a>集成nginx模块</h2><p>参考：<a href=\"https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL\" target=\"_blank\" rel=\"noopener\">https://github.com/happyfish100/fastdfs-nginx-module/blob/master/INSTALL</a></p>\n<p>1.下载<code>fastdfs-nginx-module</code></p>\n<p><code>git clone https://github.com/happyfish100/fastdfs-nginx-module.git</code></p>\n<p>注意：安装的FastDFS版本 &gt;= 5.11</p>\n<p>2.安装nginx-1.8.1</p>\n<p>下载：<a href=\"http://nginx.org/en/download.html\" target=\"_blank\" rel=\"noopener\">http://nginx.org/en/download.html</a></p>\n<pre><code>&gt; ./configure --prefix=~/nginx \\\n --add-module=/home/mutian/fastdfs-nginx-module/src\n\n&gt; make; make install\n</code></pre><p>3.更改nginx配置，添加一行。</p>\n<p>如果文件分组  </p>\n<pre><code>location ~/group([0-9])/M00 {\n\n    ngx_fastdfs_module;\n\n}\n</code></pre><p>如果没分组</p>\n<pre><code>location /M00 {\n    root /home/mutian/dev/fastdfs/data/storage/data;\n    ngx_fastdfs_module;\n}\n</code></pre><blockquote>\n<p>注意：<br> A、8888 端口值是要与/etc/fdfs/storage.conf 中的 http.server_port=8888 相对应, 因为 http.server_port 默认为 8888,如果想改成 80,则要对应修改过来。<br> B、Storage 对应有多个 group 的情况下,访问路径带 group 名,如/group1/M00/00/00/xxx, 对应的 Nginx 配置为:<br> location ~/group([0-9])/M00 {<br>     ngx_fastdfs_module;<br> }</p>\n</blockquote>\n<p>4.拷贝fdfs_storage的文件存储软链接</p>\n<p><code>ln -s /home/mutian/dev/fastdfs/data/storage/data  /home/mutian/dev/fastdfs/data/storage/data/M00</code>          </p>\n<p>5.更改配置<code>mod_fastdfs.conf</code></p>\n<p>拷贝到相关目录：</p>\n<pre><code>cp ~/dev/fastdfs/fastdfs-nginx-module/src/mod_fastdfs.conf /etc/fdfs/  \n</code></pre><p>更改内容：</p>\n<pre><code>connect_timeout=10\nbase_path=/tmp\ntracker_server=ip01:22122\nstorage_server_port=23000\ngroup_name=group1\nurl_have_group_name = true\nstore_path0=/home/mutian/dev/fastdfs/data/storage      \n</code></pre><p>6.复制FastDFS 的部分配置文件到<code>/etc/fdfs</code>目录</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ cd /home/mutian/dev/fastdfs/fastdfs-5.11/conf/\nmutian@mutian-ThinkPad-T440p:~/dev/fastdfs/fastdfs-5.11/conf$ ls\nanti-steal.jpg  http.conf   storage.conf      tracker.conf\nclient.conf     mime.types  storage_ids.conf\n\ncp http.conf mime.types /etc/fdfs/   \n</code></pre><p>7.启动nginx</p>\n<p><code>~/dev/nginx/sbin/nginx -s stop; ~/dev/nginx/sbin/nginx</code> </p>\n<p>8.测试<br>按上面步骤，上传个文件，然后在浏览器打开：</p>\n<p><a href=\"http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip:port/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a> </p>\n<p>or </p>\n<p><a href=\"http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png\" target=\"_blank\" rel=\"noopener\">http://ip/group1/M00/00/00/tlxkwlhttsGAU2ZXAAC07quU0oE095.png</a>          </p>\n"},{"title":"git在centos7下源码编译安装","date":"2017-10-14T02:04:31.000Z","_content":"\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>   n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","source":"_posts/git-install-in-centos7.md","raw":"---\ntitle: git在centos7下源码编译安装\ndate: 2017-10-14 10:04:31\ncategories: git\ntags: git-install-in-centos\n---\n\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>   n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","slug":"git-install-in-centos7","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioje0014d5hs4a9z3to6","content":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br>  n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br>  n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"noopener\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"noopener\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>"},{"title":"docker学习-第二课：发布一个web应用","date":"2018-02-02T03:00:11.000Z","_content":"\n介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……\n\n参考网址：https://github.com/docker/labs/tree/master/beginner/\n\n\n","source":"_posts/docker-lesson2.md","raw":"---\ntitle: docker学习-第二课：发布一个web应用\ndate: 2018-02-02 11:00:11\ncategories: docker\ntags: docker镜像创建、docker容器启动、docker发布web应用\n---\n\n介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……\n\n参考网址：https://github.com/docker/labs/tree/master/beginner/\n\n\n","slug":"docker-lesson2","published":1,"updated":"2018-02-28T01:55:28.509Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojg0016d5hsypx5goxp","content":"<p>介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……</p>\n<p>参考网址：<a href=\"https://github.com/docker/labs/tree/master/beginner/\" target=\"_blank\" rel=\"noopener\">https://github.com/docker/labs/tree/master/beginner/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>介绍docker镜像的创建，容器的运行，并发布应用到容器，浏览器访问……</p>\n<p>参考网址：<a href=\"https://github.com/docker/labs/tree/master/beginner/\" target=\"_blank\" rel=\"noopener\">https://github.com/docker/labs/tree/master/beginner/</a></p>\n"},{"title":"git服务器使用","date":"2017-10-14T01:58:47.000Z","_content":"搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","source":"_posts/git-server-build.md","raw":"---\ntitle: git服务器使用\ndate: 2017-10-14 09:58:47\ncategories: git\ntags: git-server-build\n---\n搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","slug":"git-server-build","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojh0019d5hs9qurwwee","content":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone git@119.23.78.160:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br>git@119.23.78.160’s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone git@119.23.78.160:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br>git@119.23.78.160’s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n"},{"title":"如何直接在github网站上更新你fork的repo","date":"2017-10-13T01:39:58.000Z","_content":"玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","source":"_posts/github-fork-repo-update.md","raw":"---\ntitle: 如何直接在github网站上更新你fork的repo\ndate: 2017-10-13 09:39:58\ncategories: github\ntags: github-fork-repo-update\n---\n玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","slug":"github-fork-repo-update","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojj001cd5hsejdsslrs","content":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>"},{"title":"HashiCorp Vault使用　","date":"2017-09-30T15:40:58.000Z","_content":"## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","source":"_posts/hashicorp-vault.md","raw":"---\ntitle: HashiCorp Vault使用　\ndate: 2017-09-30 23:40:58\ncategories: security\ntags: hashicorp-vault\n---\n## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","slug":"hashicorp-vault","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojl001ed5hslddgnmv4","content":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"noopener\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"noopener\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"noopener\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n"},{"title":"hibernate表关系映射示例","date":"2017-11-01T09:18:44.000Z","_content":"\n## 1. OneToOne\n一对一关系，存在n+1问题。\n\n#### 1.1 单向 @OneToOne\n- 实体：\n\n\n        @Entity(name = \"Phone\")\n        public static class Phone {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            @Column(name = \"`number`\")\n            private String number;\n        \n            @OneToOne\n            @JoinColumn(name = \"details_id\")\n            private PhoneDetails details;\n        \n            public Phone() {\n            }\n        \n            public Phone(String number) {\n                this.number = number;\n            }\n        \n            public Long getId() {\n                return id;\n            }\n        \n            public String getNumber() {\n                return number;\n            }\n        \n            public PhoneDetails getDetails() {\n                return details;\n            }\n        \n            public void setDetails(PhoneDetails details) {\n                this.details = details;\n            }\n        }\n\t\n---\t\n        @Entity(name = \"PhoneDetails\")\n        public static class PhoneDetails {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            private String provider;\n        \n            private String technology;\n        \n            public PhoneDetails() {\n            }\n        \n            public PhoneDetails(String provider, String technology) {\n                this.provider = provider;\n                this.technology = technology;\n            }\n        \n            public String getProvider() {\n                return provider;\n            }\n        \n            public String getTechnology() {\n                return technology;\n            }\n        \n            public void setTechnology(String technology) {\n                this.technology = technology;\n            }\n        }\n\t\n- *生成sql*：\n\n        CREATE TABLE Phone (\n            id BIGINT NOT NULL ,\n            number VARCHAR(255) ,\n            details_id BIGINT ,\n            PRIMARY KEY ( id )\n        )\n        \n        CREATE TABLE PhoneDetails (\n            id BIGINT NOT NULL ,\n            provider VARCHAR(255) ,\n            technology VARCHAR(255) ,\n            PRIMARY KEY ( id )\n        )\n        \n        ALTER TABLE Phone\n        ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\n        FOREIGN KEY (details_id) REFERENCES PhoneDetails\n\t\n\t\n- *操作*：\n\t作为外键，相当于ManyToOne作为外键操作\n\n---\n\t\n#### 1.2 双向 @OneToOne\n\n- 实体：\n\n\n    @Entity(name = \"Phone\")\n    public static class Phone {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n    \n        @Column(name = \"`number`\")\n        private String number;\n    \n        @OneToOne(mappedBy = \"phone\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n        private PhoneDetails details;\n    \n        public Phone() {\n        }\n    \n        public Phone(String number) {\n            this.number = number;\n        }\n    \n        public Long getId() {\n            return id;\n        }\n    \n        public String getNumber() {\n            return number;\n        }\n    \n        public PhoneDetails getDetails() {\n            return details;\n        }\n    \n        public void addDetails(PhoneDetails details) {\n            details.setPhone( this );\n            this.details = details;\n        }\n    \n        public void removeDetails() {\n            if ( details != null ) {\n                details.setPhone( null );\n                this.details = null;\n            }\n        }\n    }\n\t\n---\n\t\n\t@Entity(name = \"PhoneDetails\")\n\tpublic static class PhoneDetails {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String provider;\n\t\n\t    private String technology;\n\t\n\t    @OneToOne(fetch = FetchType.LAZY)\n\t    @JoinColumn(name = \"phone_id\")\n\t    private Phone phone;\n\t\n\t    public PhoneDetails() {\n\t    }\n\t\n\t    public PhoneDetails(String provider, String technology) {\n\t        this.provider = provider;\n\t        this.technology = technology;\n\t    }\n\t\n\t    public String getProvider() {\n\t        return provider;\n\t    }\n\t\n\t    public String getTechnology() {\n\t        return technology;\n\t    }\n\t\n\t    public void setTechnology(String technology) {\n\t        this.technology = technology;\n\t    }\n\t\n\t    public Phone getPhone() {\n\t        return phone;\n\t    }\n\t\n\t    public void setPhone(Phone phone) {\n\t        this.phone = phone;\n\t    }\n\t}\n\n- *生成sql*：\n\n\n    CREATE TABLE Phone (\n        id BIGINT NOT NULL ,\n        number VARCHAR(255) ,\n        PRIMARY KEY ( id )\n    )\n    \n    CREATE TABLE PhoneDetails (\n        id BIGINT NOT NULL ,\n        provider VARCHAR(255) ,\n        technology VARCHAR(255) ,\n        phone_id BIGINT ,\n        PRIMARY KEY ( id )\n    )\n    \n    ALTER TABLE PhoneDetails\n    ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\n    FOREIGN KEY (phone_id) REFERENCES Phone\n\n- *操作*：\n\n\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tPhoneDetails details = new PhoneDetails( \"T-Mobile\", \"GSM\" );\n\t\n\tphone.addDetails( details );\n\tentityManager.persist( phone );\n\t\n\t-------------------------------------\n\tINSERT INTO Phone ( number, id )\n\tVALUES ( '123 - 456 - 7890', 1 )\n\t\n\tINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\n\tVALUES ( 1, 'T - Mobile, GSM', 2 )\n\t\n\n---\n## 2. OneToMany\n一对多关系，一般在多的一段维护，也可双边维护关系。\n\n#### 2.1 单向 @OneToMany association\n\n- 实体:\n\n\n    @Entity(name = \"Person\")\n    public static class Person {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n        @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n        private List<Phone> phones = new ArrayList<>();\n    \n        public Person() {\n        }\n    \n        public List<Phone> getPhones() {\n            return phones;\n        }\n    }\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\n\tCREATE TABLE Person_Phone (\n\t    Person_id BIGINT NOT NULL ,\n\t    phones_id BIGINT NOT NULL\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\n\tUNIQUE (phones_id)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\n\tFOREIGN KEY (phones_id) REFERENCES Phone\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\n- *操作代码*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.getPhones().add( phone1 );\n\tperson.getPhones().add( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.getPhones().remove( phone1 );\n\t\n\t-----------------------------------------------\n\tINSERT INTO Person\n       ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '123 - 456 - 7890', 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '321 - 654 - 0987', 3 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Person_Phone\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n#### 2.2 双向@OneToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<Phone> phones = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(Long id) {\n\t        this.id = id;\n\t    }\n\t\n\t    public List<Phone> getPhones() {\n\t        return phones;\n\t    }\n\t\n\t    public void addPhone(Phone phone) {\n\t        phones.add( phone );\n\t        phone.setPerson( this );\n\t    }\n\t\n\t    public void removePhone(Phone phone) {\n\t        phones.remove( phone );\n\t        phone.setPerson( null );\n\t    }\n\t}\t\t\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    @Column(name = \"`number`\", unique = true)\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Phone phone = (Phone) o;\n\t        return Objects.equals( number, phone.number );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( number );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\n\tUNIQUE (number)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\n\tFOREIGN KEY (person_id) REFERENCES Person\n\n- *操作*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.addPhone( phone1 );\n\tperson.addPhone( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.removePhone( phone1 );\t\n\t\n\t-----------------------------------------\n\t\n\tINSERT INTO Phone\n       ( number, person_id, id )\n\tVALUES ( '123-456-7890', NULL, 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, person_id, id )\n\tVALUES ( '321-654-0987', NULL, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n---\n## 3. ManyToOne\n多对一关系\n\n#### 3.1 @ManyToOne association\n相当于外键\n\n- 实体\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t\t@Id\n\t\t@GeneratedValue\n\t\tprivate Long id;\n\t\t\n\t\tpublic Person() {\n\t\t\n\t\t}\n\t}\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    @JoinColumn(name = \"person_id\",\n\t            foreignKey = @ForeignKey(name = \"PERSON_ID_FK\")\n\t    )\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT PERSON_ID_FK\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n- *生命周期*:\n\n\n\tPerson person = new Person();\n\tentityManager.persist( person );\n\t\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tphone.setPerson( person );\n\tentityManager.persist( phone );\n\t\n\tentityManager.flush();\n\tphone.setPerson( null );\n\t\n\t实际sql：\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone ( number, person_id, id )\n\tVALUES ( '123-456-7890', 1, 2 )\n\t\n\tUPDATE Phone\n\tSET    number = '123-456-7890',\n\t       person_id = NULL\n\tWHERE  id = 2\n\n---\t\n## 4. ManyToMany\n多对多关系，两边都要维护。\n\n#### 4.1 单向 @ManyToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number) {\n\t        this.street = street;\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    Person_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person();\n\tPerson person2 = new Person();\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\" );\n\t\n\tperson1.getAddresses().add( address1 );\n\tperson1.getAddresses().add( address2 );\n\t\n\tperson2.getAddresses().add( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.getAddresses().remove( address1 );\n\t\n\t-------------------------------------------\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '12A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '18B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( id )\n\tVALUES ( 4 )\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 2 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.2 双向 @ManyToMany\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        addresses.add( address );\n\t        address.getOwners().add( this );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        addresses.remove( address );\n\t        address.getOwners().remove( this );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @ManyToMany(mappedBy = \"addresses\")\n\t    private List<Person> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<Person> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    owners_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\n\tFOREIGN KEY (owners_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.removeAddress( address1 );\n\t\n\t------------------------------------------\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'ABC-123', 1 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '12A', '4005A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '18B', '4007B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'DEF-456', 4 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  owners_id = 1\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.3 双向 many-to-many with a link entity\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public List<PersonAddress> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        addresses.add( personAddress );\n\t        address.getOwners().add( personAddress );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        address.getOwners().remove( personAddress );\n\t        addresses.remove( personAddress );\n\t        personAddress.setPerson( null );\n\t        personAddress.setAddress( null );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"PersonAddress\")\n\tpublic static class PersonAddress implements Serializable {\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Address address;\n\t\n\t    public PersonAddress() {\n\t    }\n\t\n\t    public PersonAddress(Person person, Address address) {\n\t        this.person = person;\n\t        this.address = address;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    public Address getAddress() {\n\t        return address;\n\t    }\n\t\n\t    public void setAddress(Address address) {\n\t        this.address = address;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        PersonAddress that = (PersonAddress) o;\n\t        return Objects.equals( person, that.person ) &&\n\t                Objects.equals( address, that.address );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( person, address );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @OneToMany(mappedBy = \"address\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<PersonAddress> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE PersonAddress (\n\t    person_id BIGINT NOT NULL ,\n\t    address_id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( person_id, address_id )\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\n\tFOREIGN KEY (address_id) REFERENCES Address\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.persist( address1 );\n\tentityManager.persist( address2 );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.flush();\n\t\n\tlog.info( \"Removing address\" );\n\tperson1.removeAddress( address1 );\n\t---------------------------------------------------\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'ABC-123', 1 )\n\t\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'DEF-456', 2 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '12A', '4005A', '12th Avenue', 3 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '18B', '4007B', '18th Avenue', 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 3 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 2, 3 )\n\t\n\tDELETE  FROM PersonAddress\n\tWHERE   person_id = 1 AND address_id = 3\n\t\n\n\t","source":"_posts/hibernate-relation-mapping.md","raw":"---\ntitle: hibernate表关系映射示例\ndate: 2017-11-01 17:18:44\ncategories: jpa/hibernate\ntags: hibernate-relation\n---\n\n## 1. OneToOne\n一对一关系，存在n+1问题。\n\n#### 1.1 单向 @OneToOne\n- 实体：\n\n\n        @Entity(name = \"Phone\")\n        public static class Phone {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            @Column(name = \"`number`\")\n            private String number;\n        \n            @OneToOne\n            @JoinColumn(name = \"details_id\")\n            private PhoneDetails details;\n        \n            public Phone() {\n            }\n        \n            public Phone(String number) {\n                this.number = number;\n            }\n        \n            public Long getId() {\n                return id;\n            }\n        \n            public String getNumber() {\n                return number;\n            }\n        \n            public PhoneDetails getDetails() {\n                return details;\n            }\n        \n            public void setDetails(PhoneDetails details) {\n                this.details = details;\n            }\n        }\n\t\n---\t\n        @Entity(name = \"PhoneDetails\")\n        public static class PhoneDetails {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            private String provider;\n        \n            private String technology;\n        \n            public PhoneDetails() {\n            }\n        \n            public PhoneDetails(String provider, String technology) {\n                this.provider = provider;\n                this.technology = technology;\n            }\n        \n            public String getProvider() {\n                return provider;\n            }\n        \n            public String getTechnology() {\n                return technology;\n            }\n        \n            public void setTechnology(String technology) {\n                this.technology = technology;\n            }\n        }\n\t\n- *生成sql*：\n\n        CREATE TABLE Phone (\n            id BIGINT NOT NULL ,\n            number VARCHAR(255) ,\n            details_id BIGINT ,\n            PRIMARY KEY ( id )\n        )\n        \n        CREATE TABLE PhoneDetails (\n            id BIGINT NOT NULL ,\n            provider VARCHAR(255) ,\n            technology VARCHAR(255) ,\n            PRIMARY KEY ( id )\n        )\n        \n        ALTER TABLE Phone\n        ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\n        FOREIGN KEY (details_id) REFERENCES PhoneDetails\n\t\n\t\n- *操作*：\n\t作为外键，相当于ManyToOne作为外键操作\n\n---\n\t\n#### 1.2 双向 @OneToOne\n\n- 实体：\n\n\n    @Entity(name = \"Phone\")\n    public static class Phone {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n    \n        @Column(name = \"`number`\")\n        private String number;\n    \n        @OneToOne(mappedBy = \"phone\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n        private PhoneDetails details;\n    \n        public Phone() {\n        }\n    \n        public Phone(String number) {\n            this.number = number;\n        }\n    \n        public Long getId() {\n            return id;\n        }\n    \n        public String getNumber() {\n            return number;\n        }\n    \n        public PhoneDetails getDetails() {\n            return details;\n        }\n    \n        public void addDetails(PhoneDetails details) {\n            details.setPhone( this );\n            this.details = details;\n        }\n    \n        public void removeDetails() {\n            if ( details != null ) {\n                details.setPhone( null );\n                this.details = null;\n            }\n        }\n    }\n\t\n---\n\t\n\t@Entity(name = \"PhoneDetails\")\n\tpublic static class PhoneDetails {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String provider;\n\t\n\t    private String technology;\n\t\n\t    @OneToOne(fetch = FetchType.LAZY)\n\t    @JoinColumn(name = \"phone_id\")\n\t    private Phone phone;\n\t\n\t    public PhoneDetails() {\n\t    }\n\t\n\t    public PhoneDetails(String provider, String technology) {\n\t        this.provider = provider;\n\t        this.technology = technology;\n\t    }\n\t\n\t    public String getProvider() {\n\t        return provider;\n\t    }\n\t\n\t    public String getTechnology() {\n\t        return technology;\n\t    }\n\t\n\t    public void setTechnology(String technology) {\n\t        this.technology = technology;\n\t    }\n\t\n\t    public Phone getPhone() {\n\t        return phone;\n\t    }\n\t\n\t    public void setPhone(Phone phone) {\n\t        this.phone = phone;\n\t    }\n\t}\n\n- *生成sql*：\n\n\n    CREATE TABLE Phone (\n        id BIGINT NOT NULL ,\n        number VARCHAR(255) ,\n        PRIMARY KEY ( id )\n    )\n    \n    CREATE TABLE PhoneDetails (\n        id BIGINT NOT NULL ,\n        provider VARCHAR(255) ,\n        technology VARCHAR(255) ,\n        phone_id BIGINT ,\n        PRIMARY KEY ( id )\n    )\n    \n    ALTER TABLE PhoneDetails\n    ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\n    FOREIGN KEY (phone_id) REFERENCES Phone\n\n- *操作*：\n\n\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tPhoneDetails details = new PhoneDetails( \"T-Mobile\", \"GSM\" );\n\t\n\tphone.addDetails( details );\n\tentityManager.persist( phone );\n\t\n\t-------------------------------------\n\tINSERT INTO Phone ( number, id )\n\tVALUES ( '123 - 456 - 7890', 1 )\n\t\n\tINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\n\tVALUES ( 1, 'T - Mobile, GSM', 2 )\n\t\n\n---\n## 2. OneToMany\n一对多关系，一般在多的一段维护，也可双边维护关系。\n\n#### 2.1 单向 @OneToMany association\n\n- 实体:\n\n\n    @Entity(name = \"Person\")\n    public static class Person {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n        @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n        private List<Phone> phones = new ArrayList<>();\n    \n        public Person() {\n        }\n    \n        public List<Phone> getPhones() {\n            return phones;\n        }\n    }\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\n\tCREATE TABLE Person_Phone (\n\t    Person_id BIGINT NOT NULL ,\n\t    phones_id BIGINT NOT NULL\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\n\tUNIQUE (phones_id)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\n\tFOREIGN KEY (phones_id) REFERENCES Phone\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\n- *操作代码*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.getPhones().add( phone1 );\n\tperson.getPhones().add( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.getPhones().remove( phone1 );\n\t\n\t-----------------------------------------------\n\tINSERT INTO Person\n       ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '123 - 456 - 7890', 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '321 - 654 - 0987', 3 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Person_Phone\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n#### 2.2 双向@OneToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<Phone> phones = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(Long id) {\n\t        this.id = id;\n\t    }\n\t\n\t    public List<Phone> getPhones() {\n\t        return phones;\n\t    }\n\t\n\t    public void addPhone(Phone phone) {\n\t        phones.add( phone );\n\t        phone.setPerson( this );\n\t    }\n\t\n\t    public void removePhone(Phone phone) {\n\t        phones.remove( phone );\n\t        phone.setPerson( null );\n\t    }\n\t}\t\t\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    @Column(name = \"`number`\", unique = true)\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Phone phone = (Phone) o;\n\t        return Objects.equals( number, phone.number );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( number );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\n\tUNIQUE (number)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\n\tFOREIGN KEY (person_id) REFERENCES Person\n\n- *操作*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.addPhone( phone1 );\n\tperson.addPhone( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.removePhone( phone1 );\t\n\t\n\t-----------------------------------------\n\t\n\tINSERT INTO Phone\n       ( number, person_id, id )\n\tVALUES ( '123-456-7890', NULL, 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, person_id, id )\n\tVALUES ( '321-654-0987', NULL, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n---\n## 3. ManyToOne\n多对一关系\n\n#### 3.1 @ManyToOne association\n相当于外键\n\n- 实体\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t\t@Id\n\t\t@GeneratedValue\n\t\tprivate Long id;\n\t\t\n\t\tpublic Person() {\n\t\t\n\t\t}\n\t}\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    @JoinColumn(name = \"person_id\",\n\t            foreignKey = @ForeignKey(name = \"PERSON_ID_FK\")\n\t    )\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT PERSON_ID_FK\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n- *生命周期*:\n\n\n\tPerson person = new Person();\n\tentityManager.persist( person );\n\t\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tphone.setPerson( person );\n\tentityManager.persist( phone );\n\t\n\tentityManager.flush();\n\tphone.setPerson( null );\n\t\n\t实际sql：\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone ( number, person_id, id )\n\tVALUES ( '123-456-7890', 1, 2 )\n\t\n\tUPDATE Phone\n\tSET    number = '123-456-7890',\n\t       person_id = NULL\n\tWHERE  id = 2\n\n---\t\n## 4. ManyToMany\n多对多关系，两边都要维护。\n\n#### 4.1 单向 @ManyToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number) {\n\t        this.street = street;\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    Person_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person();\n\tPerson person2 = new Person();\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\" );\n\t\n\tperson1.getAddresses().add( address1 );\n\tperson1.getAddresses().add( address2 );\n\t\n\tperson2.getAddresses().add( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.getAddresses().remove( address1 );\n\t\n\t-------------------------------------------\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '12A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '18B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( id )\n\tVALUES ( 4 )\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 2 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.2 双向 @ManyToMany\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        addresses.add( address );\n\t        address.getOwners().add( this );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        addresses.remove( address );\n\t        address.getOwners().remove( this );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @ManyToMany(mappedBy = \"addresses\")\n\t    private List<Person> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<Person> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    owners_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\n\tFOREIGN KEY (owners_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.removeAddress( address1 );\n\t\n\t------------------------------------------\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'ABC-123', 1 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '12A', '4005A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '18B', '4007B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'DEF-456', 4 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  owners_id = 1\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.3 双向 many-to-many with a link entity\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public List<PersonAddress> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        addresses.add( personAddress );\n\t        address.getOwners().add( personAddress );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        address.getOwners().remove( personAddress );\n\t        addresses.remove( personAddress );\n\t        personAddress.setPerson( null );\n\t        personAddress.setAddress( null );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"PersonAddress\")\n\tpublic static class PersonAddress implements Serializable {\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Address address;\n\t\n\t    public PersonAddress() {\n\t    }\n\t\n\t    public PersonAddress(Person person, Address address) {\n\t        this.person = person;\n\t        this.address = address;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    public Address getAddress() {\n\t        return address;\n\t    }\n\t\n\t    public void setAddress(Address address) {\n\t        this.address = address;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        PersonAddress that = (PersonAddress) o;\n\t        return Objects.equals( person, that.person ) &&\n\t                Objects.equals( address, that.address );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( person, address );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @OneToMany(mappedBy = \"address\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<PersonAddress> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE PersonAddress (\n\t    person_id BIGINT NOT NULL ,\n\t    address_id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( person_id, address_id )\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\n\tFOREIGN KEY (address_id) REFERENCES Address\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.persist( address1 );\n\tentityManager.persist( address2 );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.flush();\n\t\n\tlog.info( \"Removing address\" );\n\tperson1.removeAddress( address1 );\n\t---------------------------------------------------\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'ABC-123', 1 )\n\t\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'DEF-456', 2 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '12A', '4005A', '12th Avenue', 3 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '18B', '4007B', '18th Avenue', 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 3 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 2, 3 )\n\t\n\tDELETE  FROM PersonAddress\n\tWHERE   person_id = 1 AND address_id = 3\n\t\n\n\t","slug":"hibernate-relation-mapping","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojp001id5hs8i3y4dhf","content":"<h2 id=\"1-OneToOne\"><a href=\"#1-OneToOne\" class=\"headerlink\" title=\"1. OneToOne\"></a>1. OneToOne</h2><p>一对一关系，存在n+1问题。</p>\n<h4 id=\"1-1-单向-OneToOne\"><a href=\"#1-1-单向-OneToOne\" class=\"headerlink\" title=\"1.1 单向 @OneToOne\"></a>1.1 单向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne\n    @JoinColumn(name = &quot;details_id&quot;)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void setDetails(PhoneDetails details) {\n        this.details = details;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n}\n</code></pre><ul>\n<li><p><em>生成sql</em>：</p>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    details_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\nFOREIGN KEY (details_id) REFERENCES PhoneDetails\n</code></pre></li>\n</ul>\n<ul>\n<li><em>操作</em>：<br>  作为外键，相当于ManyToOne作为外键操作</li>\n</ul>\n<hr>\n<h4 id=\"1-2-双向-OneToOne\"><a href=\"#1-2-双向-OneToOne\" class=\"headerlink\" title=\"1.2 双向 @OneToOne\"></a>1.2 双向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne(mappedBy = &quot;phone&quot;, cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void addDetails(PhoneDetails details) {\n        details.setPhone( this );\n        this.details = details;\n    }\n\n    public void removeDetails() {\n        if ( details != null ) {\n            details.setPhone( null );\n            this.details = null;\n        }\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    @OneToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;phone_id&quot;)\n    private Phone phone;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    phone_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE PhoneDetails\nADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\nFOREIGN KEY (phone_id) REFERENCES Phone\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Phone phone = new Phone( &quot;123-456-7890&quot; );\nPhoneDetails details = new PhoneDetails( &quot;T-Mobile&quot;, &quot;GSM&quot; );\n\nphone.addDetails( details );\nentityManager.persist( phone );\n\n-------------------------------------\nINSERT INTO Phone ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 1 )\n\nINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\nVALUES ( 1, &apos;T - Mobile, GSM&apos;, 2 )\n</code></pre><hr>\n<h2 id=\"2-OneToMany\"><a href=\"#2-OneToMany\" class=\"headerlink\" title=\"2. OneToMany\"></a>2. OneToMany</h2><p>一对多关系，一般在多的一段维护，也可双边维护关系。</p>\n<h4 id=\"2-1-单向-OneToMany-association\"><a href=\"#2-1-单向-OneToMany-association\" class=\"headerlink\" title=\"2.1 单向 @OneToMany association\"></a>2.1 单向 @OneToMany association</h4><ul>\n<li>实体:</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Phone (\n    Person_id BIGINT NOT NULL ,\n    phones_id BIGINT NOT NULL\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\nUNIQUE (phones_id)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\nFOREIGN KEY (phones_id) REFERENCES Phone\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作代码</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.getPhones().add( phone1 );\nperson.getPhones().add( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.getPhones().remove( phone1 );\n\n-----------------------------------------------\nINSERT INTO Person\n   ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 2 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;321 - 654 - 0987&apos;, 3 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Person_Phone\nWHERE  Person_id = 1\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><h4 id=\"2-2-双向-OneToMany\"><a href=\"#2-2-双向-OneToMany\" class=\"headerlink\" title=\"2.2 双向@OneToMany\"></a>2.2 双向@OneToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(Long id) {\n        this.id = id;\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n\n    public void addPhone(Phone phone) {\n        phones.add( phone );\n        phone.setPerson( this );\n    }\n\n    public void removePhone(Phone phone) {\n        phones.remove( phone );\n        phone.setPerson( null );\n    }\n}        \n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    @Column(name = &quot;`number`&quot;, unique = true)\n    private String number;\n\n    @ManyToOne\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Phone phone = (Phone) o;\n        return Objects.equals( number, phone.number );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( number );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\nUNIQUE (number)\n\nALTER TABLE Phone\nADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.addPhone( phone1 );\nperson.addPhone( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.removePhone( phone1 );    \n\n-----------------------------------------\n\nINSERT INTO Phone\n   ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, NULL, 2 )\n\nINSERT INTO Phone\n       ( number, person_id, id )\nVALUES ( &apos;321-654-0987&apos;, NULL, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"3-ManyToOne\"><a href=\"#3-ManyToOne\" class=\"headerlink\" title=\"3. ManyToOne\"></a>3. ManyToOne</h2><p>多对一关系</p>\n<h4 id=\"3-1-ManyToOne-association\"><a href=\"#3-1-ManyToOne-association\" class=\"headerlink\" title=\"3.1 @ManyToOne association\"></a>3.1 @ManyToOne association</h4><p>相当于外键</p>\n<ul>\n<li>实体</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    public Person() {\n\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;person_id&quot;,\n            foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;)\n    )\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT PERSON_ID_FK\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>生命周期</em>:</li>\n</ul>\n<pre><code>Person person = new Person();\nentityManager.persist( person );\n\nPhone phone = new Phone( &quot;123-456-7890&quot; );\nphone.setPerson( person );\nentityManager.persist( phone );\n\nentityManager.flush();\nphone.setPerson( null );\n\n实际sql：\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, 1, 2 )\n\nUPDATE Phone\nSET    number = &apos;123-456-7890&apos;,\n       person_id = NULL\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"4-ManyToMany\"><a href=\"#4-ManyToMany\" class=\"headerlink\" title=\"4. ManyToMany\"></a>4. ManyToMany</h2><p>多对多关系，两边都要维护。</p>\n<h4 id=\"4-1-单向-ManyToMany\"><a href=\"#4-1-单向-ManyToMany\" class=\"headerlink\" title=\"4.1 单向 @ManyToMany\"></a>4.1 单向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Address() {\n    }\n\n    public Address(String street, String number) {\n        this.street = street;\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    Person_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person();\nPerson person2 = new Person();\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot; );\n\nperson1.getAddresses().add( address1 );\nperson1.getAddresses().add( address2 );\n\nperson2.getAddresses().add( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.getAddresses().remove( address1 );\n\n-------------------------------------------\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;12A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;18B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( id )\nVALUES ( 4 )\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 2 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  Person_id = 1\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-2-双向-ManyToMany\"><a href=\"#4-2-双向-ManyToMany\" class=\"headerlink\" title=\"4.2 双向 @ManyToMany\"></a>4.2 双向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        addresses.add( address );\n        address.getOwners().add( this );\n    }\n\n    public void removeAddress(Address address) {\n        addresses.remove( address );\n        address.getOwners().remove( this );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @ManyToMany(mappedBy = &quot;addresses&quot;)\n    private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;Person&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    owners_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\nFOREIGN KEY (owners_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.removeAddress( address1 );\n\n------------------------------------------\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;ABC-123&apos;, 1 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;DEF-456&apos;, 4 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  owners_id = 1\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-3-双向-many-to-many-with-a-link-entity\"><a href=\"#4-3-双向-many-to-many-with-a-link-entity\" class=\"headerlink\" title=\"4.3 双向 many-to-many with a link entity\"></a>4.3 双向 many-to-many with a link entity</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public List&lt;PersonAddress&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        addresses.add( personAddress );\n        address.getOwners().add( personAddress );\n    }\n\n    public void removeAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        address.getOwners().remove( personAddress );\n        addresses.remove( personAddress );\n        personAddress.setPerson( null );\n        personAddress.setAddress( null );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PersonAddress&quot;)\npublic static class PersonAddress implements Serializable {\n\n    @Id\n    @ManyToOne\n    private Person person;\n\n    @Id\n    @ManyToOne\n    private Address address;\n\n    public PersonAddress() {\n    }\n\n    public PersonAddress(Person person, Address address) {\n        this.person = person;\n        this.address = address;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        PersonAddress that = (PersonAddress) o;\n        return Objects.equals( person, that.person ) &amp;&amp;\n                Objects.equals( address, that.address );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( person, address );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;PersonAddress&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PersonAddress (\n    person_id BIGINT NOT NULL ,\n    address_id BIGINT NOT NULL ,\n    PRIMARY KEY ( person_id, address_id )\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\nFOREIGN KEY (person_id) REFERENCES Person\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\nFOREIGN KEY (address_id) REFERENCES Address\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.persist( address1 );\nentityManager.persist( address2 );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.flush();\n\nlog.info( &quot;Removing address&quot; );\nperson1.removeAddress( address1 );\n---------------------------------------------------\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;ABC-123&apos;, 1 )\n\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;DEF-456&apos;, 2 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 3 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 3 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 2, 3 )\n\nDELETE  FROM PersonAddress\nWHERE   person_id = 1 AND address_id = 3\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-OneToOne\"><a href=\"#1-OneToOne\" class=\"headerlink\" title=\"1. OneToOne\"></a>1. OneToOne</h2><p>一对一关系，存在n+1问题。</p>\n<h4 id=\"1-1-单向-OneToOne\"><a href=\"#1-1-单向-OneToOne\" class=\"headerlink\" title=\"1.1 单向 @OneToOne\"></a>1.1 单向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne\n    @JoinColumn(name = &quot;details_id&quot;)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void setDetails(PhoneDetails details) {\n        this.details = details;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n}\n</code></pre><ul>\n<li><p><em>生成sql</em>：</p>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    details_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\nFOREIGN KEY (details_id) REFERENCES PhoneDetails\n</code></pre></li>\n</ul>\n<ul>\n<li><em>操作</em>：<br>  作为外键，相当于ManyToOne作为外键操作</li>\n</ul>\n<hr>\n<h4 id=\"1-2-双向-OneToOne\"><a href=\"#1-2-双向-OneToOne\" class=\"headerlink\" title=\"1.2 双向 @OneToOne\"></a>1.2 双向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne(mappedBy = &quot;phone&quot;, cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void addDetails(PhoneDetails details) {\n        details.setPhone( this );\n        this.details = details;\n    }\n\n    public void removeDetails() {\n        if ( details != null ) {\n            details.setPhone( null );\n            this.details = null;\n        }\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    @OneToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;phone_id&quot;)\n    private Phone phone;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    phone_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE PhoneDetails\nADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\nFOREIGN KEY (phone_id) REFERENCES Phone\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Phone phone = new Phone( &quot;123-456-7890&quot; );\nPhoneDetails details = new PhoneDetails( &quot;T-Mobile&quot;, &quot;GSM&quot; );\n\nphone.addDetails( details );\nentityManager.persist( phone );\n\n-------------------------------------\nINSERT INTO Phone ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 1 )\n\nINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\nVALUES ( 1, &apos;T - Mobile, GSM&apos;, 2 )\n</code></pre><hr>\n<h2 id=\"2-OneToMany\"><a href=\"#2-OneToMany\" class=\"headerlink\" title=\"2. OneToMany\"></a>2. OneToMany</h2><p>一对多关系，一般在多的一段维护，也可双边维护关系。</p>\n<h4 id=\"2-1-单向-OneToMany-association\"><a href=\"#2-1-单向-OneToMany-association\" class=\"headerlink\" title=\"2.1 单向 @OneToMany association\"></a>2.1 单向 @OneToMany association</h4><ul>\n<li>实体:</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Phone (\n    Person_id BIGINT NOT NULL ,\n    phones_id BIGINT NOT NULL\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\nUNIQUE (phones_id)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\nFOREIGN KEY (phones_id) REFERENCES Phone\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作代码</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.getPhones().add( phone1 );\nperson.getPhones().add( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.getPhones().remove( phone1 );\n\n-----------------------------------------------\nINSERT INTO Person\n   ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 2 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;321 - 654 - 0987&apos;, 3 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Person_Phone\nWHERE  Person_id = 1\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><h4 id=\"2-2-双向-OneToMany\"><a href=\"#2-2-双向-OneToMany\" class=\"headerlink\" title=\"2.2 双向@OneToMany\"></a>2.2 双向@OneToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(Long id) {\n        this.id = id;\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n\n    public void addPhone(Phone phone) {\n        phones.add( phone );\n        phone.setPerson( this );\n    }\n\n    public void removePhone(Phone phone) {\n        phones.remove( phone );\n        phone.setPerson( null );\n    }\n}        \n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    @Column(name = &quot;`number`&quot;, unique = true)\n    private String number;\n\n    @ManyToOne\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Phone phone = (Phone) o;\n        return Objects.equals( number, phone.number );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( number );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\nUNIQUE (number)\n\nALTER TABLE Phone\nADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.addPhone( phone1 );\nperson.addPhone( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.removePhone( phone1 );    \n\n-----------------------------------------\n\nINSERT INTO Phone\n   ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, NULL, 2 )\n\nINSERT INTO Phone\n       ( number, person_id, id )\nVALUES ( &apos;321-654-0987&apos;, NULL, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"3-ManyToOne\"><a href=\"#3-ManyToOne\" class=\"headerlink\" title=\"3. ManyToOne\"></a>3. ManyToOne</h2><p>多对一关系</p>\n<h4 id=\"3-1-ManyToOne-association\"><a href=\"#3-1-ManyToOne-association\" class=\"headerlink\" title=\"3.1 @ManyToOne association\"></a>3.1 @ManyToOne association</h4><p>相当于外键</p>\n<ul>\n<li>实体</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    public Person() {\n\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;person_id&quot;,\n            foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;)\n    )\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT PERSON_ID_FK\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>生命周期</em>:</li>\n</ul>\n<pre><code>Person person = new Person();\nentityManager.persist( person );\n\nPhone phone = new Phone( &quot;123-456-7890&quot; );\nphone.setPerson( person );\nentityManager.persist( phone );\n\nentityManager.flush();\nphone.setPerson( null );\n\n实际sql：\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, 1, 2 )\n\nUPDATE Phone\nSET    number = &apos;123-456-7890&apos;,\n       person_id = NULL\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"4-ManyToMany\"><a href=\"#4-ManyToMany\" class=\"headerlink\" title=\"4. ManyToMany\"></a>4. ManyToMany</h2><p>多对多关系，两边都要维护。</p>\n<h4 id=\"4-1-单向-ManyToMany\"><a href=\"#4-1-单向-ManyToMany\" class=\"headerlink\" title=\"4.1 单向 @ManyToMany\"></a>4.1 单向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Address() {\n    }\n\n    public Address(String street, String number) {\n        this.street = street;\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    Person_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person();\nPerson person2 = new Person();\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot; );\n\nperson1.getAddresses().add( address1 );\nperson1.getAddresses().add( address2 );\n\nperson2.getAddresses().add( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.getAddresses().remove( address1 );\n\n-------------------------------------------\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;12A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;18B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( id )\nVALUES ( 4 )\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 2 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  Person_id = 1\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-2-双向-ManyToMany\"><a href=\"#4-2-双向-ManyToMany\" class=\"headerlink\" title=\"4.2 双向 @ManyToMany\"></a>4.2 双向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        addresses.add( address );\n        address.getOwners().add( this );\n    }\n\n    public void removeAddress(Address address) {\n        addresses.remove( address );\n        address.getOwners().remove( this );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @ManyToMany(mappedBy = &quot;addresses&quot;)\n    private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;Person&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    owners_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\nFOREIGN KEY (owners_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.removeAddress( address1 );\n\n------------------------------------------\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;ABC-123&apos;, 1 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;DEF-456&apos;, 4 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  owners_id = 1\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-3-双向-many-to-many-with-a-link-entity\"><a href=\"#4-3-双向-many-to-many-with-a-link-entity\" class=\"headerlink\" title=\"4.3 双向 many-to-many with a link entity\"></a>4.3 双向 many-to-many with a link entity</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public List&lt;PersonAddress&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        addresses.add( personAddress );\n        address.getOwners().add( personAddress );\n    }\n\n    public void removeAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        address.getOwners().remove( personAddress );\n        addresses.remove( personAddress );\n        personAddress.setPerson( null );\n        personAddress.setAddress( null );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PersonAddress&quot;)\npublic static class PersonAddress implements Serializable {\n\n    @Id\n    @ManyToOne\n    private Person person;\n\n    @Id\n    @ManyToOne\n    private Address address;\n\n    public PersonAddress() {\n    }\n\n    public PersonAddress(Person person, Address address) {\n        this.person = person;\n        this.address = address;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        PersonAddress that = (PersonAddress) o;\n        return Objects.equals( person, that.person ) &amp;&amp;\n                Objects.equals( address, that.address );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( person, address );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;PersonAddress&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PersonAddress (\n    person_id BIGINT NOT NULL ,\n    address_id BIGINT NOT NULL ,\n    PRIMARY KEY ( person_id, address_id )\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\nFOREIGN KEY (person_id) REFERENCES Person\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\nFOREIGN KEY (address_id) REFERENCES Address\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.persist( address1 );\nentityManager.persist( address2 );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.flush();\n\nlog.info( &quot;Removing address&quot; );\nperson1.removeAddress( address1 );\n---------------------------------------------------\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;ABC-123&apos;, 1 )\n\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;DEF-456&apos;, 2 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 3 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 3 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 2, 3 )\n\nDELETE  FROM PersonAddress\nWHERE   person_id = 1 AND address_id = 3\n</code></pre>"},{"title":"http协议概述(学习笔记)","date":"2017-10-17T13:45:50.000Z","_content":"\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","source":"_posts/http-protocol-overview.md","raw":"---\ntitle: http协议概述(学习笔记)\ndate: 2017-10-17 21:45:50\ncategories: http协议\ntags: http-overview\n---\n\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","slug":"http-protocol-overview","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojs001kd5hsn4x434xd","content":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>","site":{"data":{}},"excerpt":"","more":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"noopener\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>"},{"title":"idea集成XRebel分析web应用性能","date":"2017-12-04T07:50:14.000Z","_content":"XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。\n\nXRebel官方简明教程在这里 http://zeroturnaround.com/software/xrebel/quick-start/\n\n官方下载地址在这里 https://zeroturnaround.com/software/xrebel/download/#!/have-license","source":"_posts/idea-XRebel.md","raw":"---\ntitle: idea集成XRebel分析web应用性能\ndate: 2017-12-04 15:50:14\ncategories: idea\ntags: XRebel\n---\nXRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。\n\nXRebel官方简明教程在这里 http://zeroturnaround.com/software/xrebel/quick-start/\n\n官方下载地址在这里 https://zeroturnaround.com/software/xrebel/download/#!/have-license","slug":"idea-XRebel","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojx001nd5hs6q7fs4ye","content":"<p>XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。</p>\n<p>XRebel官方简明教程在这里 <a href=\"http://zeroturnaround.com/software/xrebel/quick-start/\" target=\"_blank\" rel=\"noopener\">http://zeroturnaround.com/software/xrebel/quick-start/</a></p>\n<p>官方下载地址在这里 <a href=\"https://zeroturnaround.com/software/xrebel/download/#!/have-license\" target=\"_blank\" rel=\"noopener\">https://zeroturnaround.com/software/xrebel/download/#!/have-license</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>XRebel 是不间断运行在 web 应用的交互式分析器，当发现问题会在浏览器中显示警告信息。XRebel 会实时监测应用代码的性能指标和可能会发生的问题。</p>\n<p>XRebel官方简明教程在这里 <a href=\"http://zeroturnaround.com/software/xrebel/quick-start/\" target=\"_blank\" rel=\"noopener\">http://zeroturnaround.com/software/xrebel/quick-start/</a></p>\n<p>官方下载地址在这里 <a href=\"https://zeroturnaround.com/software/xrebel/download/#!/have-license\" target=\"_blank\" rel=\"noopener\">https://zeroturnaround.com/software/xrebel/download/#!/have-license</a></p>\n"},{"title":"idea创建类，方法注解提示模板","date":"2018-02-10T06:30:29.000Z","_content":"\n为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……\n\n## java类的注解模板\n\n1. 首先，打开设计：\n`File->Settings->file and code template` \n\n{% asset_img a.png %}\n\n`#parse(\"File Header.java\")` \n这句：include 名字为File Header的模板进来。 \n\n2. 定义如图： \n\n{% asset_img b.png %}\n\n模板内容：\n\n       /**\n        * 功能简述:<br> \n        * \n        *\n        * @author zmt\n        * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n        * @updateTime \n        * @since 1.0.0\n        */\n        \n## java方法模板\n\n在File->Settings->Editor->Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template\n\n- 创建mygroup的Template,并定义名为/**的template。如下图：\n\n{% asset_img c.png %}\n\n模板内容：\n\n    /**\n     * 功能描述: <br>\n     * 〈$END$〉\n     *\n     $param$\n     * @return: $return$\n     * @since: 1.0.0\n     * @author: $user$\n     * @date: $DATE$ $TIME$\n     */\n     \n- 编辑模板的变量内容：\n\n点击右边的Edit Variables: \n\n{% asset_img e.png %}\n\n添加变量内容，如图： \n\n{% asset_img f.png %}\n\n注意：$param$这么添加，否则无效：\n\n    groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {result+='* @param ' + params[i] + ((i < params.size() - 1) ? '\\\\n ' : '')}; return result\", methodParameters())\n\n- 选定作用域：\n\n是应用在类上，还是方法上\n\n{% asset_img g.png %}\n\n- 测试：\n\n在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。\n\n`注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效`\n\n{% asset_img j.png %}\n\n\n     \n\n","source":"_posts/idea-file-template.md","raw":"---\ntitle: idea创建类，方法注解提示模板\ndate: 2018-02-10 14:30:29\ncategories: idea\ntags: idea注解模板\n---\n\n为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……\n\n## java类的注解模板\n\n1. 首先，打开设计：\n`File->Settings->file and code template` \n\n{% asset_img a.png %}\n\n`#parse(\"File Header.java\")` \n这句：include 名字为File Header的模板进来。 \n\n2. 定义如图： \n\n{% asset_img b.png %}\n\n模板内容：\n\n       /**\n        * 功能简述:<br> \n        * \n        *\n        * @author zmt\n        * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n        * @updateTime \n        * @since 1.0.0\n        */\n        \n## java方法模板\n\n在File->Settings->Editor->Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template\n\n- 创建mygroup的Template,并定义名为/**的template。如下图：\n\n{% asset_img c.png %}\n\n模板内容：\n\n    /**\n     * 功能描述: <br>\n     * 〈$END$〉\n     *\n     $param$\n     * @return: $return$\n     * @since: 1.0.0\n     * @author: $user$\n     * @date: $DATE$ $TIME$\n     */\n     \n- 编辑模板的变量内容：\n\n点击右边的Edit Variables: \n\n{% asset_img e.png %}\n\n添加变量内容，如图： \n\n{% asset_img f.png %}\n\n注意：$param$这么添加，否则无效：\n\n    groovyScript(\"def result=''; def params=\\\"${_1}\\\".replaceAll('[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]', '').split(',').toList(); for(i = 0; i < params.size(); i++) {result+='* @param ' + params[i] + ((i < params.size() - 1) ? '\\\\n ' : '')}; return result\", methodParameters())\n\n- 选定作用域：\n\n是应用在类上，还是方法上\n\n{% asset_img g.png %}\n\n- 测试：\n\n在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。\n\n`注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效`\n\n{% asset_img j.png %}\n\n\n     \n\n","slug":"idea-file-template","published":1,"updated":"2018-02-10T08:40:01.612Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iojz001qd5hs1s7k68p6","content":"<p>为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……</p>\n<h2 id=\"java类的注解模板\"><a href=\"#java类的注解模板\" class=\"headerlink\" title=\"java类的注解模板\"></a>java类的注解模板</h2><ol>\n<li>首先，打开设计：<br><code>File-&gt;Settings-&gt;file and code template</code> </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/a.png\">\n<p><code>#parse(&quot;File Header.java&quot;)</code><br>这句：include 名字为File Header的模板进来。 </p>\n<ol>\n<li>定义如图： </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/b.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能简述:&lt;br&gt; \n * \n *\n * @author zmt\n * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n * @updateTime \n * @since 1.0.0\n */\n</code></pre><h2 id=\"java方法模板\"><a href=\"#java方法模板\" class=\"headerlink\" title=\"java方法模板\"></a>java方法模板</h2><p>在File-&gt;Settings-&gt;Editor-&gt;Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template</p>\n<ul>\n<li>创建mygroup的Template,并定义名为/**的template。如下图：</li>\n</ul>\n<img src=\"/2018/02/10/idea-file-template/c.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能描述: &lt;br&gt;\n * 〈$END$〉\n *\n $param$\n * @return: $return$\n * @since: 1.0.0\n * @author: $user$\n * @date: $DATE$ $TIME$\n */\n</code></pre><ul>\n<li>编辑模板的变量内容：</li>\n</ul>\n<p>点击右边的Edit Variables: </p>\n<img src=\"/2018/02/10/idea-file-template/e.png\">\n<p>添加变量内容，如图： </p>\n<img src=\"/2018/02/10/idea-file-template/f.png\">\n<p>注意：$param$这么添加，否则无效：</p>\n<pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\\&quot;${_1}\\&quot;.replaceAll(&apos;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) {result+=&apos;* @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\\\n &apos; : &apos;&apos;)}; return result&quot;, methodParameters())\n</code></pre><ul>\n<li>选定作用域：</li>\n</ul>\n<p>是应用在类上，还是方法上</p>\n<img src=\"/2018/02/10/idea-file-template/g.png\">\n<ul>\n<li>测试：</li>\n</ul>\n<p>在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。</p>\n<p><code>注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效</code></p>\n<img src=\"/2018/02/10/idea-file-template/j.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>为了规范编码，在开发项目前，理应让团队每个人成员按公司编码规范定制好注释模板……</p>\n<h2 id=\"java类的注解模板\"><a href=\"#java类的注解模板\" class=\"headerlink\" title=\"java类的注解模板\"></a>java类的注解模板</h2><ol>\n<li>首先，打开设计：<br><code>File-&gt;Settings-&gt;file and code template</code> </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/a.png\">\n<p><code>#parse(&quot;File Header.java&quot;)</code><br>这句：include 名字为File Header的模板进来。 </p>\n<ol>\n<li>定义如图： </li>\n</ol>\n<img src=\"/2018/02/10/idea-file-template/b.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能简述:&lt;br&gt; \n * \n *\n * @author zmt\n * @create ${YEAR}-${MONTH}-${DAY} ${TIME}\n * @updateTime \n * @since 1.0.0\n */\n</code></pre><h2 id=\"java方法模板\"><a href=\"#java方法模板\" class=\"headerlink\" title=\"java方法模板\"></a>java方法模板</h2><p>在File-&gt;Settings-&gt;Editor-&gt;Live Templates下添加自定义Template Group，并在自定义Template Group下添加自定义Template</p>\n<ul>\n<li>创建mygroup的Template,并定义名为/**的template。如下图：</li>\n</ul>\n<img src=\"/2018/02/10/idea-file-template/c.png\">\n<p>模板内容：</p>\n<pre><code>/**\n * 功能描述: &lt;br&gt;\n * 〈$END$〉\n *\n $param$\n * @return: $return$\n * @since: 1.0.0\n * @author: $user$\n * @date: $DATE$ $TIME$\n */\n</code></pre><ul>\n<li>编辑模板的变量内容：</li>\n</ul>\n<p>点击右边的Edit Variables: </p>\n<img src=\"/2018/02/10/idea-file-template/e.png\">\n<p>添加变量内容，如图： </p>\n<img src=\"/2018/02/10/idea-file-template/f.png\">\n<p>注意：$param$这么添加，否则无效：</p>\n<pre><code>groovyScript(&quot;def result=&apos;&apos;; def params=\\&quot;${_1}\\&quot;.replaceAll(&apos;[\\\\\\\\[|\\\\\\\\]|\\\\\\\\s]&apos;, &apos;&apos;).split(&apos;,&apos;).toList(); for(i = 0; i &lt; params.size(); i++) {result+=&apos;* @param &apos; + params[i] + ((i &lt; params.size() - 1) ? &apos;\\\\n &apos; : &apos;&apos;)}; return result&quot;, methodParameters())\n</code></pre><ul>\n<li>选定作用域：</li>\n</ul>\n<p>是应用在类上，还是方法上</p>\n<img src=\"/2018/02/10/idea-file-template/g.png\">\n<ul>\n<li>测试：</li>\n</ul>\n<p>在完成如上配置后，只需在方法内执行/**+Tab键即可生成注释，切记这里说的是方法内部，因为methodParameters()的作用域只在方法内部，这也是Intellij IDEA比较蛋疼的一点。</p>\n<p><code>注意：在方法内部操作或者在方法尾部，总之要在方法参数后面，再把注解剪切到方法头上，否则parameters无效</code></p>\n<img src=\"/2018/02/10/idea-file-template/j.png\">\n"},{"title":"idea插件利器","date":"2017-11-10T01:55:50.000Z","_content":"\n## 1. GsonFormat\n1. 作用：json字符串自动生成javabean工具。\n2. 使用：\n\n\n\n## 2.web开发利器emmet\n\n官网：https://emmet.io/","source":"_posts/idea-good-plug.md","raw":"---\ntitle: idea插件利器\ndate: 2017-11-10 09:55:50\ncategories: idea\ntags: idea插件利器\n---\n\n## 1. GsonFormat\n1. 作用：json字符串自动生成javabean工具。\n2. 使用：\n\n\n\n## 2.web开发利器emmet\n\n官网：https://emmet.io/","slug":"idea-good-plug","published":1,"updated":"2018-05-08T01:21:38.500Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iok1001td5hsnchgs9g8","content":"<h2 id=\"1-GsonFormat\"><a href=\"#1-GsonFormat\" class=\"headerlink\" title=\"1. GsonFormat\"></a>1. GsonFormat</h2><ol>\n<li>作用：json字符串自动生成javabean工具。</li>\n<li>使用：</li>\n</ol>\n<h2 id=\"2-web开发利器emmet\"><a href=\"#2-web开发利器emmet\" class=\"headerlink\" title=\"2.web开发利器emmet\"></a>2.web开发利器emmet</h2><p>官网：<a href=\"https://emmet.io/\" target=\"_blank\" rel=\"noopener\">https://emmet.io/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-GsonFormat\"><a href=\"#1-GsonFormat\" class=\"headerlink\" title=\"1. GsonFormat\"></a>1. GsonFormat</h2><ol>\n<li>作用：json字符串自动生成javabean工具。</li>\n<li>使用：</li>\n</ol>\n<h2 id=\"2-web开发利器emmet\"><a href=\"#2-web开发利器emmet\" class=\"headerlink\" title=\"2.web开发利器emmet\"></a>2.web开发利器emmet</h2><p>官网：<a href=\"https://emmet.io/\" target=\"_blank\" rel=\"noopener\">https://emmet.io/</a></p>\n"},{"title":"服务网格istio入门","date":"2018-03-13T00:57:27.000Z","_content":"","source":"_posts/istio-start.md","raw":"---\ntitle: 服务网格istio入门\ndate: 2018-03-13 08:57:27\ncategories: 服务网格\ntags: istio\n---\n","slug":"istio-start","published":1,"updated":"2018-03-13T00:58:15.217Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iok3001vd5hs6sw3jl0o","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"jackson使用录","date":"2017-10-01T01:07:36.000Z","_content":"## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","source":"_posts/jackson-show-time.md","raw":"---\ntitle: jackson使用录\ndate: 2017-10-01 09:07:36\ncategories: json\ntags: jackson\n---\n## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","slug":"jackson-show-time","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iok5001zd5hsrp5fcrs2","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"noopener\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>"},{"title":"javapoet根据编译注解自动生成代码","date":"2018-05-03T12:54:06.000Z","_content":"\n本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……\n\n## 引入相关依赖包和插件\n\n1.依赖包\n\n    <!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service -->\n    <dependency>\n        <groupId>com.google.auto.service</groupId>\n        <artifactId>auto-service</artifactId>\n        <version>1.0-rc4</version>\n    </dependency>\n    <!--优雅生成代码-->\n    <!--https://github.com/square/javapoet-->\n    <dependency>\n        <groupId>com.squareup</groupId>\n        <artifactId>javapoet</artifactId>\n        <version>1.10.0</version>\n        <optional>true</optional>\n    </dependency>\n    \n- javapoet是square公司出品的用来优雅生成代码库。网址： https://github.com/square/javapoet\n\n- google auto-service是google公司的一个库，用来自动注册服务。\n\n2.apt插件\n\n    <plugin>\n        <groupId>com.mysema.maven</groupId>\n        <artifactId>maven-apt-plugin</artifactId>\n        <version>1.0.4</version>\n        <executions>\n            <execution>\n                <goals>\n                    <goal>process</goal>\n                </goals>\n                <phase>generate-sources</phase>\n                <configuration>\n                    <outputDirectory>${project.basedir}/target/generated-sources/java</outputDirectory>\n                    <processor>com.example.demo.HelloProcessor</processor>\n                    <processors>\n                        <processor>com.example.demo.HelloProcessor</processor>\n                    </processors>\n                    <showWarnings>true</showWarnings>\n                </configuration>\n            </execution>\n        </executions>\n    </plugin>\n    \n可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。\n\n## demo演示\n\n{% asset_img a.png %} \n\n1.新建注解类`HelloAnnotation`    \n\n    package com.example.demo;\n    \n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Retention(RetentionPolicy.CLASS)\n    @Target(ElementType.TYPE)\n    public @interface HelloAnnotation {\n    }\n\n\n2.新建注解处理类`HelloProcessor`\n\n    package com.example.demo;\n    \n    import com.google.auto.service.AutoService;\n    import com.squareup.javapoet.JavaFile;\n    import com.squareup.javapoet.MethodSpec;\n    import com.squareup.javapoet.TypeSpec;\n    \n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.Element;\n    import javax.lang.model.element.Modifier;\n    import javax.lang.model.element.Name;\n    import javax.lang.model.element.TypeElement;\n    import java.io.IOException;\n    import java.lang.reflect.Method;\n    import java.util.Collections;\n    import java.util.Set;\n    \n    @AutoService(Processor.class)\n    @SupportedAnnotationTypes(value = {\"com.example.demo.HelloAnnotation\"})\n    @SupportedSourceVersion(SourceVersion.RELEASE_8)\n    public final class HelloProcessor extends AbstractProcessor {\n    \n        private Filer filer;\n    \n        @Override\n        public synchronized void init(ProcessingEnvironment processingEnv) {\n            super.init(processingEnv);\n    \n            filer = processingEnv.getFiler(); // for creating file\n            System.out.println(\">>>processor init:\" + filer.toString());\n        }\n    \n        @Override\n        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n            System.out.println(\">>>> process:\" + annotations.size());\n            for (TypeElement element : annotations) {\n                /*Set<? extends Element> aa = roundEnv.getElementsAnnotatedWith(element);\n                for (Element e:\n                     aa) {\n                    String name = e.getClass().getTypeName();\n                    System.out.println(\">>>name:\" + name);\n                    Name s = e.getSimpleName();\n                    System.out.println(\">>>aa:\" + s.toString());\n    \n                    *//*Method[] m = e.getClass().getMethods();\n                    for (int i = 0; i < m.length; i++) {\n                        Method mm = m[i];\n                        System.out.println(mm.getName());\n                    }*//*\n                }*/\n                System.out.println(\">>>>>> process：\" + element.getQualifiedName().toString());\n                if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                    // main method\n                    MethodSpec main = MethodSpec.methodBuilder(\"main\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                            .returns(void.class)\n                            .addParameter(String[].class, \"args\")\n                            .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")\n                            .build();\n                    // HelloWorld class\n                    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                            .addMethod(main)\n                            .build();\n    \n                    try {\n                        // build com.example.HelloWorld.java\n                        JavaFile javaFile = JavaFile.builder(\"com.example\", helloWorld)\n                                .addFileComment(\" This codes are generated automatically. Do not modify!\")\n                                .build();\n                        // write to file\n                        javaFile.writeTo(filer);\n    \n                        javaFile.writeTo(System.out);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            return true;\n        }\n    \n        //采用注解\n        /*@Override\n        public Set<String> getSupportedAnnotationTypes() {\n            return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n        }*/\n    \n        //采用注解\n       /* @Override\n        public SourceVersion getSupportedSourceVersion() {\n            return SourceVersion.latestSupported();\n        }*/\n    }\n\n-  加上注解`@AutoService(Processor.class)`，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。\n\n{%asset_img b.png%}\n\n- 关键，覆盖方法`process`，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在`maven`插件中配置。\n\n3.定义使用类\n\n    package com.example.demo;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    @HelloAnnotation\n    @SpringBootApplication\n    public class DemoApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(DemoApplication.class, args);\n    //        HelloWorld.main(null);\n        }\n    }\n\n在类上添加注解`@HelloAnnotation`。  \n那么用`mvn install`或者运行该类编译代码时，将会调用注解处理类`HelloProcessor`进行代码生成。\n\n----------------------------------------------------------------------------------\n\n<<完>>","source":"_posts/javapoet-apt-annotation.md","raw":"---\ntitle: javapoet根据编译注解自动生成代码\ndate: 2018-05-03 20:54:06\ncategories: javapoet\ntags: javapoet-apt-annotation\n---\n\n本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……\n\n## 引入相关依赖包和插件\n\n1.依赖包\n\n    <!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service -->\n    <dependency>\n        <groupId>com.google.auto.service</groupId>\n        <artifactId>auto-service</artifactId>\n        <version>1.0-rc4</version>\n    </dependency>\n    <!--优雅生成代码-->\n    <!--https://github.com/square/javapoet-->\n    <dependency>\n        <groupId>com.squareup</groupId>\n        <artifactId>javapoet</artifactId>\n        <version>1.10.0</version>\n        <optional>true</optional>\n    </dependency>\n    \n- javapoet是square公司出品的用来优雅生成代码库。网址： https://github.com/square/javapoet\n\n- google auto-service是google公司的一个库，用来自动注册服务。\n\n2.apt插件\n\n    <plugin>\n        <groupId>com.mysema.maven</groupId>\n        <artifactId>maven-apt-plugin</artifactId>\n        <version>1.0.4</version>\n        <executions>\n            <execution>\n                <goals>\n                    <goal>process</goal>\n                </goals>\n                <phase>generate-sources</phase>\n                <configuration>\n                    <outputDirectory>${project.basedir}/target/generated-sources/java</outputDirectory>\n                    <processor>com.example.demo.HelloProcessor</processor>\n                    <processors>\n                        <processor>com.example.demo.HelloProcessor</processor>\n                    </processors>\n                    <showWarnings>true</showWarnings>\n                </configuration>\n            </execution>\n        </executions>\n    </plugin>\n    \n可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。\n\n## demo演示\n\n{% asset_img a.png %} \n\n1.新建注解类`HelloAnnotation`    \n\n    package com.example.demo;\n    \n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Retention(RetentionPolicy.CLASS)\n    @Target(ElementType.TYPE)\n    public @interface HelloAnnotation {\n    }\n\n\n2.新建注解处理类`HelloProcessor`\n\n    package com.example.demo;\n    \n    import com.google.auto.service.AutoService;\n    import com.squareup.javapoet.JavaFile;\n    import com.squareup.javapoet.MethodSpec;\n    import com.squareup.javapoet.TypeSpec;\n    \n    import javax.annotation.processing.*;\n    import javax.lang.model.SourceVersion;\n    import javax.lang.model.element.Element;\n    import javax.lang.model.element.Modifier;\n    import javax.lang.model.element.Name;\n    import javax.lang.model.element.TypeElement;\n    import java.io.IOException;\n    import java.lang.reflect.Method;\n    import java.util.Collections;\n    import java.util.Set;\n    \n    @AutoService(Processor.class)\n    @SupportedAnnotationTypes(value = {\"com.example.demo.HelloAnnotation\"})\n    @SupportedSourceVersion(SourceVersion.RELEASE_8)\n    public final class HelloProcessor extends AbstractProcessor {\n    \n        private Filer filer;\n    \n        @Override\n        public synchronized void init(ProcessingEnvironment processingEnv) {\n            super.init(processingEnv);\n    \n            filer = processingEnv.getFiler(); // for creating file\n            System.out.println(\">>>processor init:\" + filer.toString());\n        }\n    \n        @Override\n        public boolean process(Set<? extends TypeElement> annotations, RoundEnvironment roundEnv) {\n            System.out.println(\">>>> process:\" + annotations.size());\n            for (TypeElement element : annotations) {\n                /*Set<? extends Element> aa = roundEnv.getElementsAnnotatedWith(element);\n                for (Element e:\n                     aa) {\n                    String name = e.getClass().getTypeName();\n                    System.out.println(\">>>name:\" + name);\n                    Name s = e.getSimpleName();\n                    System.out.println(\">>>aa:\" + s.toString());\n    \n                    *//*Method[] m = e.getClass().getMethods();\n                    for (int i = 0; i < m.length; i++) {\n                        Method mm = m[i];\n                        System.out.println(mm.getName());\n                    }*//*\n                }*/\n                System.out.println(\">>>>>> process：\" + element.getQualifiedName().toString());\n                if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                    // main method\n                    MethodSpec main = MethodSpec.methodBuilder(\"main\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                            .returns(void.class)\n                            .addParameter(String[].class, \"args\")\n                            .addStatement(\"$T.out.println($S)\", System.class, \"Hello, JavaPoet!\")\n                            .build();\n                    // HelloWorld class\n                    TypeSpec helloWorld = TypeSpec.classBuilder(\"HelloWorld\")\n                            .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                            .addMethod(main)\n                            .build();\n    \n                    try {\n                        // build com.example.HelloWorld.java\n                        JavaFile javaFile = JavaFile.builder(\"com.example\", helloWorld)\n                                .addFileComment(\" This codes are generated automatically. Do not modify!\")\n                                .build();\n                        // write to file\n                        javaFile.writeTo(filer);\n    \n                        javaFile.writeTo(System.out);\n                    } catch (IOException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n            return true;\n        }\n    \n        //采用注解\n        /*@Override\n        public Set<String> getSupportedAnnotationTypes() {\n            return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n        }*/\n    \n        //采用注解\n       /* @Override\n        public SourceVersion getSupportedSourceVersion() {\n            return SourceVersion.latestSupported();\n        }*/\n    }\n\n-  加上注解`@AutoService(Processor.class)`，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。\n\n{%asset_img b.png%}\n\n- 关键，覆盖方法`process`，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在`maven`插件中配置。\n\n3.定义使用类\n\n    package com.example.demo;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    \n    @HelloAnnotation\n    @SpringBootApplication\n    public class DemoApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(DemoApplication.class, args);\n    //        HelloWorld.main(null);\n        }\n    }\n\n在类上添加注解`@HelloAnnotation`。  \n那么用`mvn install`或者运行该类编译代码时，将会调用注解处理类`HelloProcessor`进行代码生成。\n\n----------------------------------------------------------------------------------\n\n<<完>>","slug":"javapoet-apt-annotation","published":1,"updated":"2018-05-03T13:28:53.629Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iok70021d5hsbz728c5d","content":"<p>本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……</p>\n<h2 id=\"引入相关依赖包和插件\"><a href=\"#引入相关依赖包和插件\" class=\"headerlink\" title=\"引入相关依赖包和插件\"></a>引入相关依赖包和插件</h2><p>1.依赖包</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n    &lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n    &lt;version&gt;1.0-rc4&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--优雅生成代码--&gt;\n&lt;!--https://github.com/square/javapoet--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup&lt;/groupId&gt;\n    &lt;artifactId&gt;javapoet&lt;/artifactId&gt;\n    &lt;version&gt;1.10.0&lt;/version&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><ul>\n<li><p>javapoet是square公司出品的用来优雅生成代码库。网址： <a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">https://github.com/square/javapoet</a></p>\n</li>\n<li><p>google auto-service是google公司的一个库，用来自动注册服务。</p>\n</li>\n</ul>\n<p>2.apt插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-apt-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.0.4&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;process&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;phase&gt;generate-sources&lt;/phase&gt;\n            &lt;configuration&gt;\n                &lt;outputDirectory&gt;${project.basedir}/target/generated-sources/java&lt;/outputDirectory&gt;\n                &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;processors&gt;\n                    &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;/processors&gt;\n                &lt;showWarnings&gt;true&lt;/showWarnings&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。</p>\n<h2 id=\"demo演示\"><a href=\"#demo演示\" class=\"headerlink\" title=\"demo演示\"></a>demo演示</h2><img src=\"/2018/05/03/javapoet-apt-annotation/a.png\"> \n<p>1.新建注解类<code>HelloAnnotation</code>    </p>\n<pre><code>package com.example.demo;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface HelloAnnotation {\n}\n</code></pre><p>2.新建注解处理类<code>HelloProcessor</code></p>\n<pre><code>package com.example.demo;\n\nimport com.google.auto.service.AutoService;\nimport com.squareup.javapoet.JavaFile;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeSpec;\n\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.TypeElement;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Set;\n\n@AutoService(Processor.class)\n@SupportedAnnotationTypes(value = {&quot;com.example.demo.HelloAnnotation&quot;})\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\npublic final class HelloProcessor extends AbstractProcessor {\n\n    private Filer filer;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n\n        filer = processingEnv.getFiler(); // for creating file\n        System.out.println(&quot;&gt;&gt;&gt;processor init:&quot; + filer.toString());\n    }\n\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n        System.out.println(&quot;&gt;&gt;&gt;&gt; process:&quot; + annotations.size());\n        for (TypeElement element : annotations) {\n            /*Set&lt;? extends Element&gt; aa = roundEnv.getElementsAnnotatedWith(element);\n            for (Element e:\n                 aa) {\n                String name = e.getClass().getTypeName();\n                System.out.println(&quot;&gt;&gt;&gt;name:&quot; + name);\n                Name s = e.getSimpleName();\n                System.out.println(&quot;&gt;&gt;&gt;aa:&quot; + s.toString());\n\n                *//*Method[] m = e.getClass().getMethods();\n                for (int i = 0; i &lt; m.length; i++) {\n                    Method mm = m[i];\n                    System.out.println(mm.getName());\n                }*//*\n            }*/\n            System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt; process：&quot; + element.getQualifiedName().toString());\n            if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                // main method\n                MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                        .returns(void.class)\n                        .addParameter(String[].class, &quot;args&quot;)\n                        .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)\n                        .build();\n                // HelloWorld class\n                TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                        .addMethod(main)\n                        .build();\n\n                try {\n                    // build com.example.HelloWorld.java\n                    JavaFile javaFile = JavaFile.builder(&quot;com.example&quot;, helloWorld)\n                            .addFileComment(&quot; This codes are generated automatically. Do not modify!&quot;)\n                            .build();\n                    // write to file\n                    javaFile.writeTo(filer);\n\n                    javaFile.writeTo(System.out);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    //采用注解\n    /*@Override\n    public Set&lt;String&gt; getSupportedAnnotationTypes() {\n        return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n    }*/\n\n    //采用注解\n   /* @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }*/\n}\n</code></pre><ul>\n<li>加上注解<code>@AutoService(Processor.class)</code>，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。</li>\n</ul>\n<img src=\"/2018/05/03/javapoet-apt-annotation/b.png\">\n<ul>\n<li>关键，覆盖方法<code>process</code>，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在<code>maven</code>插件中配置。</li>\n</ul>\n<p>3.定义使用类</p>\n<pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@HelloAnnotation\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n//        HelloWorld.main(null);\n    }\n}\n</code></pre><p>在类上添加注解<code>@HelloAnnotation</code>。<br>那么用<code>mvn install</code>或者运行该类编译代码时，将会调用注解处理类<code>HelloProcessor</code>进行代码生成。</p>\n<hr>\n<p>&lt;&lt;完&gt;&gt;</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍利用apt技术，使用javapoet框架优雅的在编译阶段自动生成代码……</p>\n<h2 id=\"引入相关依赖包和插件\"><a href=\"#引入相关依赖包和插件\" class=\"headerlink\" title=\"引入相关依赖包和插件\"></a>引入相关依赖包和插件</h2><p>1.依赖包</p>\n<pre><code>&lt;!-- https://mvnrepository.com/artifact/com.google.auto.service/auto-service --&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.google.auto.service&lt;/groupId&gt;\n    &lt;artifactId&gt;auto-service&lt;/artifactId&gt;\n    &lt;version&gt;1.0-rc4&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;!--优雅生成代码--&gt;\n&lt;!--https://github.com/square/javapoet--&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.squareup&lt;/groupId&gt;\n    &lt;artifactId&gt;javapoet&lt;/artifactId&gt;\n    &lt;version&gt;1.10.0&lt;/version&gt;\n    &lt;optional&gt;true&lt;/optional&gt;\n&lt;/dependency&gt;\n</code></pre><ul>\n<li><p>javapoet是square公司出品的用来优雅生成代码库。网址： <a href=\"https://github.com/square/javapoet\" target=\"_blank\" rel=\"noopener\">https://github.com/square/javapoet</a></p>\n</li>\n<li><p>google auto-service是google公司的一个库，用来自动注册服务。</p>\n</li>\n</ul>\n<p>2.apt插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;com.mysema.maven&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-apt-plugin&lt;/artifactId&gt;\n    &lt;version&gt;1.0.4&lt;/version&gt;\n    &lt;executions&gt;\n        &lt;execution&gt;\n            &lt;goals&gt;\n                &lt;goal&gt;process&lt;/goal&gt;\n            &lt;/goals&gt;\n            &lt;phase&gt;generate-sources&lt;/phase&gt;\n            &lt;configuration&gt;\n                &lt;outputDirectory&gt;${project.basedir}/target/generated-sources/java&lt;/outputDirectory&gt;\n                &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;processors&gt;\n                    &lt;processor&gt;com.example.demo.HelloProcessor&lt;/processor&gt;\n                &lt;/processors&gt;\n                &lt;showWarnings&gt;true&lt;/showWarnings&gt;\n            &lt;/configuration&gt;\n        &lt;/execution&gt;\n    &lt;/executions&gt;\n&lt;/plugin&gt;\n</code></pre><p>可以在插件中添加注解处理类。在编译时将会调用相关注解处理类做处理生成代码。</p>\n<h2 id=\"demo演示\"><a href=\"#demo演示\" class=\"headerlink\" title=\"demo演示\"></a>demo演示</h2><img src=\"/2018/05/03/javapoet-apt-annotation/a.png\"> \n<p>1.新建注解类<code>HelloAnnotation</code>    </p>\n<pre><code>package com.example.demo;\n\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Retention(RetentionPolicy.CLASS)\n@Target(ElementType.TYPE)\npublic @interface HelloAnnotation {\n}\n</code></pre><p>2.新建注解处理类<code>HelloProcessor</code></p>\n<pre><code>package com.example.demo;\n\nimport com.google.auto.service.AutoService;\nimport com.squareup.javapoet.JavaFile;\nimport com.squareup.javapoet.MethodSpec;\nimport com.squareup.javapoet.TypeSpec;\n\nimport javax.annotation.processing.*;\nimport javax.lang.model.SourceVersion;\nimport javax.lang.model.element.Element;\nimport javax.lang.model.element.Modifier;\nimport javax.lang.model.element.Name;\nimport javax.lang.model.element.TypeElement;\nimport java.io.IOException;\nimport java.lang.reflect.Method;\nimport java.util.Collections;\nimport java.util.Set;\n\n@AutoService(Processor.class)\n@SupportedAnnotationTypes(value = {&quot;com.example.demo.HelloAnnotation&quot;})\n@SupportedSourceVersion(SourceVersion.RELEASE_8)\npublic final class HelloProcessor extends AbstractProcessor {\n\n    private Filer filer;\n\n    @Override\n    public synchronized void init(ProcessingEnvironment processingEnv) {\n        super.init(processingEnv);\n\n        filer = processingEnv.getFiler(); // for creating file\n        System.out.println(&quot;&gt;&gt;&gt;processor init:&quot; + filer.toString());\n    }\n\n    @Override\n    public boolean process(Set&lt;? extends TypeElement&gt; annotations, RoundEnvironment roundEnv) {\n        System.out.println(&quot;&gt;&gt;&gt;&gt; process:&quot; + annotations.size());\n        for (TypeElement element : annotations) {\n            /*Set&lt;? extends Element&gt; aa = roundEnv.getElementsAnnotatedWith(element);\n            for (Element e:\n                 aa) {\n                String name = e.getClass().getTypeName();\n                System.out.println(&quot;&gt;&gt;&gt;name:&quot; + name);\n                Name s = e.getSimpleName();\n                System.out.println(&quot;&gt;&gt;&gt;aa:&quot; + s.toString());\n\n                *//*Method[] m = e.getClass().getMethods();\n                for (int i = 0; i &lt; m.length; i++) {\n                    Method mm = m[i];\n                    System.out.println(mm.getName());\n                }*//*\n            }*/\n            System.out.println(&quot;&gt;&gt;&gt;&gt;&gt;&gt; process：&quot; + element.getQualifiedName().toString());\n            if (element.getQualifiedName().toString().equals(HelloAnnotation.class.getCanonicalName())) {\n                // main method\n                MethodSpec main = MethodSpec.methodBuilder(&quot;main&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.STATIC)\n                        .returns(void.class)\n                        .addParameter(String[].class, &quot;args&quot;)\n                        .addStatement(&quot;$T.out.println($S)&quot;, System.class, &quot;Hello, JavaPoet!&quot;)\n                        .build();\n                // HelloWorld class\n                TypeSpec helloWorld = TypeSpec.classBuilder(&quot;HelloWorld&quot;)\n                        .addModifiers(Modifier.PUBLIC, Modifier.FINAL)\n                        .addMethod(main)\n                        .build();\n\n                try {\n                    // build com.example.HelloWorld.java\n                    JavaFile javaFile = JavaFile.builder(&quot;com.example&quot;, helloWorld)\n                            .addFileComment(&quot; This codes are generated automatically. Do not modify!&quot;)\n                            .build();\n                    // write to file\n                    javaFile.writeTo(filer);\n\n                    javaFile.writeTo(System.out);\n                } catch (IOException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n        return true;\n    }\n\n    //采用注解\n    /*@Override\n    public Set&lt;String&gt; getSupportedAnnotationTypes() {\n        return Collections.singleton(HelloAnnotation.class.getCanonicalName());\n    }*/\n\n    //采用注解\n   /* @Override\n    public SourceVersion getSupportedSourceVersion() {\n        return SourceVersion.latestSupported();\n    }*/\n}\n</code></pre><ul>\n<li>加上注解<code>@AutoService(Processor.class)</code>，该注解为auto-service中的类，加上该注解，编译时候将会自动注册服务。在类路径下新增META-INF/services文件夹，并注册服务。</li>\n</ul>\n<img src=\"/2018/05/03/javapoet-apt-annotation/b.png\">\n<ul>\n<li>关键，覆盖方法<code>process</code>，并在该方法中利用javapoet库相关特性，优雅生成想要的java代码，并输出.java文件。输出路径可以在<code>maven</code>插件中配置。</li>\n</ul>\n<p>3.定义使用类</p>\n<pre><code>package com.example.demo;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\n\n@HelloAnnotation\n@SpringBootApplication\npublic class DemoApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(DemoApplication.class, args);\n//        HelloWorld.main(null);\n    }\n}\n</code></pre><p>在类上添加注解<code>@HelloAnnotation</code>。<br>那么用<code>mvn install</code>或者运行该类编译代码时，将会调用注解处理类<code>HelloProcessor</code>进行代码生成。</p>\n<hr>\n<p>&lt;&lt;完&gt;&gt;</p>\n"},{"title":"CGLIB介绍与原理","date":"2017-10-26T07:57:08.000Z","_content":"http://blog.csdn.net/zghwaicsdn/article/details/50957474","source":"_posts/javase-cglib.md","raw":"---\ntitle: CGLIB介绍与原理\ndate: 2017-10-26 15:57:08\ncategories: java\ntags: cglib\n---\nhttp://blog.csdn.net/zghwaicsdn/article/details/50957474","slug":"javase-cglib","published":1,"updated":"2017-12-31T09:13:45.234Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioka0025d5hs9zl0fhwh","content":"<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zghwaicsdn/article/details/50957474</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/zghwaicsdn/article/details/50957474</a></p>\n"},{"title":"Java Nio 缓冲区","date":"2017-10-25T06:57:22.000Z","_content":"","source":"_posts/javase-nio-buffer.md","raw":"---\ntitle: Java Nio 缓冲区\ndate: 2017-10-25 14:57:22\ncategories: java\ntags: java-nio-buffer\n---\n","slug":"javase-nio-buffer","published":1,"updated":"2017-12-31T09:13:45.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iokc0027d5hs2kn2c83j","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"jenkins-java-maven持续集成（CentOs7）","date":"2017-11-28T01:15:26.000Z","_content":"\n传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。\n\n参考：  \nhttp://www.jianshu.com/p/a7d7df97fe4b\n\n## 1. 安装并运行jenkins-war\n- [下载](https://jenkins.io/download/)\n- 运行 `java -jar jenkins.war --httpPort=8080.`\n- 在浏览器访问 http://localhost:8080. 记得开防火墙。\n\n图一：\n{% asset_img a.png %}\n\n## 2. 初次访问配置\n- 按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。\n- 按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。\n- 创建管理员账号，按照页面设置即可。\n\n这样，下面就可以开始使用jenkins了。\n\n\n## 3. maven，svn,springboot下持续构建java应用\n- 安装maven环境。[下载maven](http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz)\n\n### 3.1 配置jenkins\n\n{% asset_img b.png %}\n\n点击`系统管理`。\n\n{% asset_img c.png %}\n\n配置各种环境：\n\n- maven setting.xml\n\n{% asset_img e.png %}\n\n- jdk,取消自动安装\n\n{% asset_img f.png %}\n\n- maven,取消自动安装\n\n{% asset_img g.png %}\n\n### 3.2 安装maven插件\n\n{% asset_img h.png %}\n\n-------\n\n{% asset_img i.png %}\n\n点击直接安装即可。\n\n### 3.3 创建新项目\n\n{% asset_img 1.png %}\n\n选定。\n\n{% asset_img 2.png %}\n\n点击ok。\n\n### 3.4 配置项目各种信息\n{% asset_img 3.png %}\n\n------------\n{% asset_img 4.png %}\n\n### 3.5 开始构建项目\n\n{% asset_img 5.png %}\n\n查看构建结果\n\n{% asset_img 6.png %}\n\n然后再服务器相关目录下就能看到构建后的jar包:\n{% asset_img 7.png %}\n\n### 3.6 构建后配置\n构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。\n\n#### 3.6.1 直接执行jar\n修改项目配置：\n{% asset_img 8.png %}\n\n添加成功构建后要执行的脚本：\n{% asset_img 8_1.png %}\n\n> 注意脚本写法，如果是后台执行：\n    `BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`\n\n#### 3.6.2 发布jar到远程服务器，并执行\n - 下载相关插件：\n {% asset_img 10.png %}\n \n- 在系统设置中添加远程服务器：\n {% asset_img 11.png %}\n\n- 在项目中设置，选定远程服务器：\n{% asset_img 12.png %}\n\n*注意：*\n{% asset_img 13.png %}\n\n- 备份，执行远程服务器上的jar包\n\n1. 在远程服务器上设置脚本，放在目录：`server/bin`：\n\n>停止应用脚本`stop.sh`：\n    # 将应用停止\n    #stop.sh\n    #!/bin/bash\n    echo \"Stopping SpringBoot Application\"\n    pid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk '{print $2}'`\n    if [ -n \"$pid\" ]\n    then\n       kill -9 $pid\n    fi\n---    \n> 备份应用脚本`replace.sh`:\n    #replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n    #!/bin/bash\n    # 先判断文件是否存在，如果存在，则备份\n    file=\"/server/java/apps/jenkins-demo.jar\"\n    if [ -f \"$file\" ]\n    then\n       mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\n    fi\n    mv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n---\n> 启动应用包脚本`start.sh`:\n    # startup.sh 启动项目\n    #!/bin/bash\n    echo \"授予当前用户权限\"\n    chmod 777 /server/java/apps/jenkins-demo.jar\n    echo \"执行.....\"\n    java -jar /server/java/apps/jenkins-demo.jar\n   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行`nohub java -jar /server/java/apps/jenkins-demo.jar &`不起作用，所在要在jenkins上这样配置`BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`  \n   如果是远程服务器，就可以改成：\n       # startup.sh 启动项目\n       #!/bin/bash\n       echo \"授予当前用户权限\"\n       chmod 777 /server/java/apps/jenkins-demo.jar\n       echo \"执行.....\"\n       nohup java -jar /server/java/apps/jenkins-demo.jar > jenkins-demo.out 2>& 1 &\n    \n---\n2. 设置远程服务器执行脚本： \n\n{% asset_img 14.png %}   \n\n如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。\n\n{% asset_img 15.png %}   ","source":"_posts/jenkins-java-maven.md","raw":"---\ntitle: jenkins-java-maven持续集成（CentOs7）\ndate: 2017-11-28 09:15:26\ncategories: 持续集成\ntags: jenkins-java-maven\n---\n\n传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。\n\n参考：  \nhttp://www.jianshu.com/p/a7d7df97fe4b\n\n## 1. 安装并运行jenkins-war\n- [下载](https://jenkins.io/download/)\n- 运行 `java -jar jenkins.war --httpPort=8080.`\n- 在浏览器访问 http://localhost:8080. 记得开防火墙。\n\n图一：\n{% asset_img a.png %}\n\n## 2. 初次访问配置\n- 按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。\n- 按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。\n- 创建管理员账号，按照页面设置即可。\n\n这样，下面就可以开始使用jenkins了。\n\n\n## 3. maven，svn,springboot下持续构建java应用\n- 安装maven环境。[下载maven](http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz)\n\n### 3.1 配置jenkins\n\n{% asset_img b.png %}\n\n点击`系统管理`。\n\n{% asset_img c.png %}\n\n配置各种环境：\n\n- maven setting.xml\n\n{% asset_img e.png %}\n\n- jdk,取消自动安装\n\n{% asset_img f.png %}\n\n- maven,取消自动安装\n\n{% asset_img g.png %}\n\n### 3.2 安装maven插件\n\n{% asset_img h.png %}\n\n-------\n\n{% asset_img i.png %}\n\n点击直接安装即可。\n\n### 3.3 创建新项目\n\n{% asset_img 1.png %}\n\n选定。\n\n{% asset_img 2.png %}\n\n点击ok。\n\n### 3.4 配置项目各种信息\n{% asset_img 3.png %}\n\n------------\n{% asset_img 4.png %}\n\n### 3.5 开始构建项目\n\n{% asset_img 5.png %}\n\n查看构建结果\n\n{% asset_img 6.png %}\n\n然后再服务器相关目录下就能看到构建后的jar包:\n{% asset_img 7.png %}\n\n### 3.6 构建后配置\n构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。\n\n#### 3.6.1 直接执行jar\n修改项目配置：\n{% asset_img 8.png %}\n\n添加成功构建后要执行的脚本：\n{% asset_img 8_1.png %}\n\n> 注意脚本写法，如果是后台执行：\n    `BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`\n\n#### 3.6.2 发布jar到远程服务器，并执行\n - 下载相关插件：\n {% asset_img 10.png %}\n \n- 在系统设置中添加远程服务器：\n {% asset_img 11.png %}\n\n- 在项目中设置，选定远程服务器：\n{% asset_img 12.png %}\n\n*注意：*\n{% asset_img 13.png %}\n\n- 备份，执行远程服务器上的jar包\n\n1. 在远程服务器上设置脚本，放在目录：`server/bin`：\n\n>停止应用脚本`stop.sh`：\n    # 将应用停止\n    #stop.sh\n    #!/bin/bash\n    echo \"Stopping SpringBoot Application\"\n    pid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk '{print $2}'`\n    if [ -n \"$pid\" ]\n    then\n       kill -9 $pid\n    fi\n---    \n> 备份应用脚本`replace.sh`:\n    #replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n    #!/bin/bash\n    # 先判断文件是否存在，如果存在，则备份\n    file=\"/server/java/apps/jenkins-demo.jar\"\n    if [ -f \"$file\" ]\n    then\n       mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\n    fi\n    mv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n---\n> 启动应用包脚本`start.sh`:\n    # startup.sh 启动项目\n    #!/bin/bash\n    echo \"授予当前用户权限\"\n    chmod 777 /server/java/apps/jenkins-demo.jar\n    echo \"执行.....\"\n    java -jar /server/java/apps/jenkins-demo.jar\n   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行`nohub java -jar /server/java/apps/jenkins-demo.jar &`不起作用，所在要在jenkins上这样配置`BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`  \n   如果是远程服务器，就可以改成：\n       # startup.sh 启动项目\n       #!/bin/bash\n       echo \"授予当前用户权限\"\n       chmod 777 /server/java/apps/jenkins-demo.jar\n       echo \"执行.....\"\n       nohup java -jar /server/java/apps/jenkins-demo.jar > jenkins-demo.out 2>& 1 &\n    \n---\n2. 设置远程服务器执行脚本： \n\n{% asset_img 14.png %}   \n\n如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。\n\n{% asset_img 15.png %}   ","slug":"jenkins-java-maven","published":1,"updated":"2017-12-31T09:13:45.238Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioke002bd5hscszrscjw","content":"<p>传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。</p>\n<p>参考：<br><a href=\"http://www.jianshu.com/p/a7d7df97fe4b\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/a7d7df97fe4b</a></p>\n<h2 id=\"1-安装并运行jenkins-war\"><a href=\"#1-安装并运行jenkins-war\" class=\"headerlink\" title=\"1. 安装并运行jenkins-war\"></a>1. 安装并运行jenkins-war</h2><ul>\n<li><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li>运行 <code>java -jar jenkins.war --httpPort=8080.</code></li>\n<li>在浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>. 记得开防火墙。</li>\n</ul>\n<p>图一：<br><img src=\"/2017/11/28/jenkins-java-maven/a.png\"></p>\n<h2 id=\"2-初次访问配置\"><a href=\"#2-初次访问配置\" class=\"headerlink\" title=\"2. 初次访问配置\"></a>2. 初次访问配置</h2><ul>\n<li>按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。</li>\n<li>按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。</li>\n<li>创建管理员账号，按照页面设置即可。</li>\n</ul>\n<p>这样，下面就可以开始使用jenkins了。</p>\n<h2 id=\"3-maven，svn-springboot下持续构建java应用\"><a href=\"#3-maven，svn-springboot下持续构建java应用\" class=\"headerlink\" title=\"3. maven，svn,springboot下持续构建java应用\"></a>3. maven，svn,springboot下持续构建java应用</h2><ul>\n<li>安装maven环境。<a href=\"http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">下载maven</a></li>\n</ul>\n<h3 id=\"3-1-配置jenkins\"><a href=\"#3-1-配置jenkins\" class=\"headerlink\" title=\"3.1 配置jenkins\"></a>3.1 配置jenkins</h3><img src=\"/2017/11/28/jenkins-java-maven/b.png\">\n<p>点击<code>系统管理</code>。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/c.png\">\n<p>配置各种环境：</p>\n<ul>\n<li>maven setting.xml</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/e.png\">\n<ul>\n<li>jdk,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/f.png\">\n<ul>\n<li>maven,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/g.png\">\n<h3 id=\"3-2-安装maven插件\"><a href=\"#3-2-安装maven插件\" class=\"headerlink\" title=\"3.2 安装maven插件\"></a>3.2 安装maven插件</h3><img src=\"/2017/11/28/jenkins-java-maven/h.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/i.png\">\n<p>点击直接安装即可。</p>\n<h3 id=\"3-3-创建新项目\"><a href=\"#3-3-创建新项目\" class=\"headerlink\" title=\"3.3 创建新项目\"></a>3.3 创建新项目</h3><img src=\"/2017/11/28/jenkins-java-maven/1.png\">\n<p>选定。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/2.png\">\n<p>点击ok。</p>\n<h3 id=\"3-4-配置项目各种信息\"><a href=\"#3-4-配置项目各种信息\" class=\"headerlink\" title=\"3.4 配置项目各种信息\"></a>3.4 配置项目各种信息</h3><img src=\"/2017/11/28/jenkins-java-maven/3.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/4.png\">\n<h3 id=\"3-5-开始构建项目\"><a href=\"#3-5-开始构建项目\" class=\"headerlink\" title=\"3.5 开始构建项目\"></a>3.5 开始构建项目</h3><img src=\"/2017/11/28/jenkins-java-maven/5.png\">\n<p>查看构建结果</p>\n<img src=\"/2017/11/28/jenkins-java-maven/6.png\">\n<p>然后再服务器相关目录下就能看到构建后的jar包:<br><img src=\"/2017/11/28/jenkins-java-maven/7.png\"></p>\n<h3 id=\"3-6-构建后配置\"><a href=\"#3-6-构建后配置\" class=\"headerlink\" title=\"3.6 构建后配置\"></a>3.6 构建后配置</h3><p>构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。</p>\n<h4 id=\"3-6-1-直接执行jar\"><a href=\"#3-6-1-直接执行jar\" class=\"headerlink\" title=\"3.6.1 直接执行jar\"></a>3.6.1 直接执行jar</h4><p>修改项目配置：<br><img src=\"/2017/11/28/jenkins-java-maven/8.png\"></p>\n<p>添加成功构建后要执行的脚本：<br><img src=\"/2017/11/28/jenkins-java-maven/8_1.png\"></p>\n<blockquote>\n<p>注意脚本写法，如果是后台执行：<br>    <code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code></p>\n</blockquote>\n<h4 id=\"3-6-2-发布jar到远程服务器，并执行\"><a href=\"#3-6-2-发布jar到远程服务器，并执行\" class=\"headerlink\" title=\"3.6.2 发布jar到远程服务器，并执行\"></a>3.6.2 发布jar到远程服务器，并执行</h4><ul>\n<li>下载相关插件：<img src=\"/2017/11/28/jenkins-java-maven/10.png\">\n</li>\n</ul>\n<ul>\n<li><p>在系统设置中添加远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/11.png\">\n</li>\n<li><p>在项目中设置，选定远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/12.png\">\n</li>\n</ul>\n<p><em>注意：</em><br><img src=\"/2017/11/28/jenkins-java-maven/13.png\"></p>\n<ul>\n<li>备份，执行远程服务器上的jar包</li>\n</ul>\n<ol>\n<li>在远程服务器上设置脚本，放在目录：<code>server/bin</code>：</li>\n</ol>\n<blockquote>\n<p>停止应用脚本<code>stop.sh</code>：</p>\n<pre><code># 将应用停止\n#stop.sh\n#!/bin/bash\necho &quot;Stopping SpringBoot Application&quot;\npid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk &apos;{print $2}&apos;`\nif [ -n &quot;$pid&quot; ]\nthen\n   kill -9 $pid\nfi\n</code></pre><hr>\n<p>备份应用脚本<code>replace.sh</code>:</p>\n<pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n#!/bin/bash\n# 先判断文件是否存在，如果存在，则备份\nfile=&quot;/server/java/apps/jenkins-demo.jar&quot;\nif [ -f &quot;$file&quot; ]\nthen\n   mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\nfi\nmv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n</code></pre><hr>\n<p>启动应用包脚本<code>start.sh</code>:</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\njava -jar /server/java/apps/jenkins-demo.jar\n</code></pre><p>   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行<code>nohub java -jar /server/java/apps/jenkins-demo.jar &amp;</code>不起作用，所在要在jenkins上这样配置<code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code><br>   如果是远程服务器，就可以改成：</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\nnohup java -jar /server/java/apps/jenkins-demo.jar &gt; jenkins-demo.out 2&gt;&amp; 1 &amp;\n</code></pre></blockquote>\n<hr>\n<ol>\n<li>设置远程服务器执行脚本： </li>\n</ol>\n<img src=\"/2017/11/28/jenkins-java-maven/14.png\">   \n<p>如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/15.png\">   ","site":{"data":{}},"excerpt":"","more":"<p>传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。</p>\n<p>参考：<br><a href=\"http://www.jianshu.com/p/a7d7df97fe4b\" target=\"_blank\" rel=\"noopener\">http://www.jianshu.com/p/a7d7df97fe4b</a></p>\n<h2 id=\"1-安装并运行jenkins-war\"><a href=\"#1-安装并运行jenkins-war\" class=\"headerlink\" title=\"1. 安装并运行jenkins-war\"></a>1. 安装并运行jenkins-war</h2><ul>\n<li><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"noopener\">下载</a></li>\n<li>运行 <code>java -jar jenkins.war --httpPort=8080.</code></li>\n<li>在浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"noopener\">http://localhost:8080</a>. 记得开防火墙。</li>\n</ul>\n<p>图一：<br><img src=\"/2017/11/28/jenkins-java-maven/a.png\"></p>\n<h2 id=\"2-初次访问配置\"><a href=\"#2-初次访问配置\" class=\"headerlink\" title=\"2. 初次访问配置\"></a>2. 初次访问配置</h2><ul>\n<li>按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。</li>\n<li>按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。</li>\n<li>创建管理员账号，按照页面设置即可。</li>\n</ul>\n<p>这样，下面就可以开始使用jenkins了。</p>\n<h2 id=\"3-maven，svn-springboot下持续构建java应用\"><a href=\"#3-maven，svn-springboot下持续构建java应用\" class=\"headerlink\" title=\"3. maven，svn,springboot下持续构建java应用\"></a>3. maven，svn,springboot下持续构建java应用</h2><ul>\n<li>安装maven环境。<a href=\"http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz\" target=\"_blank\" rel=\"noopener\">下载maven</a></li>\n</ul>\n<h3 id=\"3-1-配置jenkins\"><a href=\"#3-1-配置jenkins\" class=\"headerlink\" title=\"3.1 配置jenkins\"></a>3.1 配置jenkins</h3><img src=\"/2017/11/28/jenkins-java-maven/b.png\">\n<p>点击<code>系统管理</code>。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/c.png\">\n<p>配置各种环境：</p>\n<ul>\n<li>maven setting.xml</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/e.png\">\n<ul>\n<li>jdk,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/f.png\">\n<ul>\n<li>maven,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/g.png\">\n<h3 id=\"3-2-安装maven插件\"><a href=\"#3-2-安装maven插件\" class=\"headerlink\" title=\"3.2 安装maven插件\"></a>3.2 安装maven插件</h3><img src=\"/2017/11/28/jenkins-java-maven/h.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/i.png\">\n<p>点击直接安装即可。</p>\n<h3 id=\"3-3-创建新项目\"><a href=\"#3-3-创建新项目\" class=\"headerlink\" title=\"3.3 创建新项目\"></a>3.3 创建新项目</h3><img src=\"/2017/11/28/jenkins-java-maven/1.png\">\n<p>选定。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/2.png\">\n<p>点击ok。</p>\n<h3 id=\"3-4-配置项目各种信息\"><a href=\"#3-4-配置项目各种信息\" class=\"headerlink\" title=\"3.4 配置项目各种信息\"></a>3.4 配置项目各种信息</h3><img src=\"/2017/11/28/jenkins-java-maven/3.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/4.png\">\n<h3 id=\"3-5-开始构建项目\"><a href=\"#3-5-开始构建项目\" class=\"headerlink\" title=\"3.5 开始构建项目\"></a>3.5 开始构建项目</h3><img src=\"/2017/11/28/jenkins-java-maven/5.png\">\n<p>查看构建结果</p>\n<img src=\"/2017/11/28/jenkins-java-maven/6.png\">\n<p>然后再服务器相关目录下就能看到构建后的jar包:<br><img src=\"/2017/11/28/jenkins-java-maven/7.png\"></p>\n<h3 id=\"3-6-构建后配置\"><a href=\"#3-6-构建后配置\" class=\"headerlink\" title=\"3.6 构建后配置\"></a>3.6 构建后配置</h3><p>构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。</p>\n<h4 id=\"3-6-1-直接执行jar\"><a href=\"#3-6-1-直接执行jar\" class=\"headerlink\" title=\"3.6.1 直接执行jar\"></a>3.6.1 直接执行jar</h4><p>修改项目配置：<br><img src=\"/2017/11/28/jenkins-java-maven/8.png\"></p>\n<p>添加成功构建后要执行的脚本：<br><img src=\"/2017/11/28/jenkins-java-maven/8_1.png\"></p>\n<blockquote>\n<p>注意脚本写法，如果是后台执行：<br>    <code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code></p>\n</blockquote>\n<h4 id=\"3-6-2-发布jar到远程服务器，并执行\"><a href=\"#3-6-2-发布jar到远程服务器，并执行\" class=\"headerlink\" title=\"3.6.2 发布jar到远程服务器，并执行\"></a>3.6.2 发布jar到远程服务器，并执行</h4><ul>\n<li>下载相关插件：<img src=\"/2017/11/28/jenkins-java-maven/10.png\">\n</li>\n</ul>\n<ul>\n<li><p>在系统设置中添加远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/11.png\">\n</li>\n<li><p>在项目中设置，选定远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/12.png\">\n</li>\n</ul>\n<p><em>注意：</em><br><img src=\"/2017/11/28/jenkins-java-maven/13.png\"></p>\n<ul>\n<li>备份，执行远程服务器上的jar包</li>\n</ul>\n<ol>\n<li>在远程服务器上设置脚本，放在目录：<code>server/bin</code>：</li>\n</ol>\n<blockquote>\n<p>停止应用脚本<code>stop.sh</code>：</p>\n<pre><code># 将应用停止\n#stop.sh\n#!/bin/bash\necho &quot;Stopping SpringBoot Application&quot;\npid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk &apos;{print $2}&apos;`\nif [ -n &quot;$pid&quot; ]\nthen\n   kill -9 $pid\nfi\n</code></pre><hr>\n<p>备份应用脚本<code>replace.sh</code>:</p>\n<pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n#!/bin/bash\n# 先判断文件是否存在，如果存在，则备份\nfile=&quot;/server/java/apps/jenkins-demo.jar&quot;\nif [ -f &quot;$file&quot; ]\nthen\n   mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\nfi\nmv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n</code></pre><hr>\n<p>启动应用包脚本<code>start.sh</code>:</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\njava -jar /server/java/apps/jenkins-demo.jar\n</code></pre><p>   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行<code>nohub java -jar /server/java/apps/jenkins-demo.jar &amp;</code>不起作用，所在要在jenkins上这样配置<code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code><br>   如果是远程服务器，就可以改成：</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\nnohup java -jar /server/java/apps/jenkins-demo.jar &gt; jenkins-demo.out 2&gt;&amp; 1 &amp;\n</code></pre></blockquote>\n<hr>\n<ol>\n<li>设置远程服务器执行脚本： </li>\n</ol>\n<img src=\"/2017/11/28/jenkins-java-maven/14.png\">   \n<p>如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/15.png\">   "},{"title":"jvm优化-垃圾回收机制","date":"2017-10-20T04:51:08.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1548866","source":"_posts/jvm-gc.md","raw":"---\ntitle: jvm优化-垃圾回收机制\ndate: 2017-10-20 12:51:08\ncategories: jvm\ntags: gc垃圾回收\n---\n\nhttps://my.oschina.net/u/1859679/blog/1548866","slug":"jvm-gc","published":1,"updated":"2017-12-31T09:13:45.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iokf002cd5hsagwz6ewx","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n"},{"title":"jvm优化-监控工具","date":"2017-10-20T04:52:40.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1552290","source":"_posts/jvm-look-tools.md","raw":"---\ntitle: jvm优化-监控工具\ndate: 2017-10-20 12:52:40\ncategories: jvm\ntags: jvm监控工具\n---\n\nhttps://my.oschina.net/u/1859679/blog/1552290","slug":"jvm-look-tools","published":1,"updated":"2017-12-31T09:13:45.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iokh002hd5hsz4qfk7v4","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n"},{"title":"jwt-study","date":"2018-03-08T08:47:23.000Z","_content":"","source":"_posts/jwt-study.md","raw":"---\ntitle: jwt-study\ndate: 2018-03-08 16:47:23\ncategories:\ntags:\n---\n","slug":"jwt-study","published":1,"updated":"2018-03-08T08:47:23.050Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioki002jd5hsopwneabf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"k8s入门","date":"2018-03-13T00:56:45.000Z","_content":"","source":"_posts/k8s-start.md","raw":"---\ntitle: k8s入门\ndate: 2018-03-13 08:56:45\ncategories: Kubernetes\ntags: k8s\n---\n","slug":"k8s-start","published":1,"updated":"2018-03-13T01:02:59.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iokl002md5hsvivmq5p6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"linux常用命令使用收藏","date":"2017-10-14T03:26:18.000Z","_content":"收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n## 4. 开机启动命令-chkconfig\n\n## 5. 文档操作\n### 5.1 复制文件-cp命令使用\n1. 文件到文件复制\n> 将文档a复制成b（相当于备份并改名）。\ncp -i a b\n或，\ncp a b\n\n2. 文件到目录复制\n>将文档 file1复制到dir1目录下，复制后名称仍未file1\ncp -i file1 dir1\n或，\ncp file1 dir1\n\n3. 目录到目录复制\n>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2\ncp -r dir1 dir2\n将目录dir1下所有文件包括文件夹，都复制到dir2目录下\ncp -r dir1/*.* dir2\n常见错误：\n1、提示cp: omitting directory错误\n复制目录时，使用-r选项即可递归拷贝，如下：\ncp -r dir1 dir2\n\n## 6. 解压/压缩\n### 6.1 压缩\n> 压缩\n  tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n  \n### 6.2 解压\n> 解压\n  tar –xvf file.tar //解压 tar包\n  tar -xzvf file.tar.gz //解压tar.gz\n  tar -xjvf file.tar.bz2   //解压 tar.bz2\n  tar –xZvf file.tar.Z   //解压tar.Z\n  unrar e file.rar //解压rar\n  unzip file.zip //解压zip\n  \n### 6.3 ubuntu 下rar解压工具安装方法：\n \n> 1、压缩功能\n 安装 sudo apt-get install rar\n 卸载 sudo apt-get remove rar\n 2、解压功能\n 安装 sudo apt-get install unrar\n 卸载 sudo apt-get remove unrar\n 压缩解压缩.rar\n 解压：rar x FileName.rar\n 压缩：rar a FileName.rar DirName  \n  \n### 6.4 总结\n> 1、`*.tar` 用 tar –xvf 解压\n  2、`*.gz` 用 gzip -d或者gunzip 解压\n  3、`*.tar.gz`和`*.tgz` 用 tar –xzf 解压\n  4、`*.bz2` 用 bzip2 -d或者用bunzip2 解压\n  5、`*.tar.bz2`用tar –xjf 解压\n  6、`*.Z` 用 uncompress 解压\n  7、`*.tar.Z` 用tar –xZf 解压\n  8、`*.rar` 用 unrar e解压\n  9、`*.zip` 用 unzip 解压    \n\n","source":"_posts/linux-command-use.md","raw":"---\ntitle: linux常用命令使用收藏\ndate: 2017-10-14 11:26:18\ncategories: linux\ntags: linux-command\n---\n收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n## 4. 开机启动命令-chkconfig\n\n## 5. 文档操作\n### 5.1 复制文件-cp命令使用\n1. 文件到文件复制\n> 将文档a复制成b（相当于备份并改名）。\ncp -i a b\n或，\ncp a b\n\n2. 文件到目录复制\n>将文档 file1复制到dir1目录下，复制后名称仍未file1\ncp -i file1 dir1\n或，\ncp file1 dir1\n\n3. 目录到目录复制\n>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2\ncp -r dir1 dir2\n将目录dir1下所有文件包括文件夹，都复制到dir2目录下\ncp -r dir1/*.* dir2\n常见错误：\n1、提示cp: omitting directory错误\n复制目录时，使用-r选项即可递归拷贝，如下：\ncp -r dir1 dir2\n\n## 6. 解压/压缩\n### 6.1 压缩\n> 压缩\n  tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n  \n### 6.2 解压\n> 解压\n  tar –xvf file.tar //解压 tar包\n  tar -xzvf file.tar.gz //解压tar.gz\n  tar -xjvf file.tar.bz2   //解压 tar.bz2\n  tar –xZvf file.tar.Z   //解压tar.Z\n  unrar e file.rar //解压rar\n  unzip file.zip //解压zip\n  \n### 6.3 ubuntu 下rar解压工具安装方法：\n \n> 1、压缩功能\n 安装 sudo apt-get install rar\n 卸载 sudo apt-get remove rar\n 2、解压功能\n 安装 sudo apt-get install unrar\n 卸载 sudo apt-get remove unrar\n 压缩解压缩.rar\n 解压：rar x FileName.rar\n 压缩：rar a FileName.rar DirName  \n  \n### 6.4 总结\n> 1、`*.tar` 用 tar –xvf 解压\n  2、`*.gz` 用 gzip -d或者gunzip 解压\n  3、`*.tar.gz`和`*.tgz` 用 tar –xzf 解压\n  4、`*.bz2` 用 bzip2 -d或者用bunzip2 解压\n  5、`*.tar.bz2`用tar –xjf 解压\n  6、`*.Z` 用 uncompress 解压\n  7、`*.tar.Z` 用tar –xZf 解压\n  8、`*.rar` 用 unrar e解压\n  9、`*.zip` 用 unzip 解压    \n\n","slug":"linux-command-use","published":1,"updated":"2017-12-31T09:13:45.242Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioko002qd5hsoh39cdw8","content":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p><em>警告</em> 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p><em>说明</em> 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2><h2 id=\"4-开机启动命令-chkconfig\"><a href=\"#4-开机启动命令-chkconfig\" class=\"headerlink\" title=\"4. 开机启动命令-chkconfig\"></a>4. 开机启动命令-chkconfig</h2><h2 id=\"5-文档操作\"><a href=\"#5-文档操作\" class=\"headerlink\" title=\"5. 文档操作\"></a>5. 文档操作</h2><h3 id=\"5-1-复制文件-cp命令使用\"><a href=\"#5-1-复制文件-cp命令使用\" class=\"headerlink\" title=\"5.1 复制文件-cp命令使用\"></a>5.1 复制文件-cp命令使用</h3><ol>\n<li><p>文件到文件复制</p>\n<blockquote>\n<p>将文档a复制成b（相当于备份并改名）。<br>cp -i a b<br>或，<br>cp a b</p>\n</blockquote>\n</li>\n<li><p>文件到目录复制</p>\n<blockquote>\n<p>将文档 file1复制到dir1目录下，复制后名称仍未file1<br>cp -i file1 dir1<br>或，<br>cp file1 dir1</p>\n</blockquote>\n</li>\n<li><p>目录到目录复制</p>\n<blockquote>\n<p>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2<br>cp -r dir1 dir2<br>将目录dir1下所有文件包括文件夹，都复制到dir2目录下<br>cp -r dir1/<em>.</em> dir2<br>常见错误：<br>1、提示cp: omitting directory错误<br>复制目录时，使用-r选项即可递归拷贝，如下：<br>cp -r dir1 dir2</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"6-解压-压缩\"><a href=\"#6-解压-压缩\" class=\"headerlink\" title=\"6. 解压/压缩\"></a>6. 解压/压缩</h2><h3 id=\"6-1-压缩\"><a href=\"#6-1-压缩\" class=\"headerlink\" title=\"6.1 压缩\"></a>6.1 压缩</h3><blockquote>\n<p>压缩<br>  tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>  tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>  tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>  tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>  rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for linux<br>  zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>\n</blockquote>\n<h3 id=\"6-2-解压\"><a href=\"#6-2-解压\" class=\"headerlink\" title=\"6.2 解压\"></a>6.2 解压</h3><blockquote>\n<p>解压<br>  tar –xvf file.tar //解压 tar包<br>  tar -xzvf file.tar.gz //解压tar.gz<br>  tar -xjvf file.tar.bz2   //解压 tar.bz2<br>  tar –xZvf file.tar.Z   //解压tar.Z<br>  unrar e file.rar //解压rar<br>  unzip file.zip //解压zip</p>\n</blockquote>\n<h3 id=\"6-3-ubuntu-下rar解压工具安装方法：\"><a href=\"#6-3-ubuntu-下rar解压工具安装方法：\" class=\"headerlink\" title=\"6.3 ubuntu 下rar解压工具安装方法：\"></a>6.3 ubuntu 下rar解压工具安装方法：</h3><blockquote>\n<p>1、压缩功能<br> 安装 sudo apt-get install rar<br> 卸载 sudo apt-get remove rar<br> 2、解压功能<br> 安装 sudo apt-get install unrar<br> 卸载 sudo apt-get remove unrar<br> 压缩解压缩.rar<br> 解压：rar x FileName.rar<br> 压缩：rar a FileName.rar DirName  </p>\n</blockquote>\n<h3 id=\"6-4-总结\"><a href=\"#6-4-总结\" class=\"headerlink\" title=\"6.4 总结\"></a>6.4 总结</h3><blockquote>\n<p>1、<code>*.tar</code> 用 tar –xvf 解压<br>  2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>  3、<code>*.tar.gz</code>和<code>*.tgz</code> 用 tar –xzf 解压<br>  4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>  5、<code>*.tar.bz2</code>用tar –xjf 解压<br>  6、<code>*.Z</code> 用 uncompress 解压<br>  7、<code>*.tar.Z</code> 用tar –xZf 解压<br>  8、<code>*.rar</code> 用 unrar e解压<br>  9、<code>*.zip</code> 用 unzip 解压    </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p><em>警告</em> 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p><em>说明</em> 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2><h2 id=\"4-开机启动命令-chkconfig\"><a href=\"#4-开机启动命令-chkconfig\" class=\"headerlink\" title=\"4. 开机启动命令-chkconfig\"></a>4. 开机启动命令-chkconfig</h2><h2 id=\"5-文档操作\"><a href=\"#5-文档操作\" class=\"headerlink\" title=\"5. 文档操作\"></a>5. 文档操作</h2><h3 id=\"5-1-复制文件-cp命令使用\"><a href=\"#5-1-复制文件-cp命令使用\" class=\"headerlink\" title=\"5.1 复制文件-cp命令使用\"></a>5.1 复制文件-cp命令使用</h3><ol>\n<li><p>文件到文件复制</p>\n<blockquote>\n<p>将文档a复制成b（相当于备份并改名）。<br>cp -i a b<br>或，<br>cp a b</p>\n</blockquote>\n</li>\n<li><p>文件到目录复制</p>\n<blockquote>\n<p>将文档 file1复制到dir1目录下，复制后名称仍未file1<br>cp -i file1 dir1<br>或，<br>cp file1 dir1</p>\n</blockquote>\n</li>\n<li><p>目录到目录复制</p>\n<blockquote>\n<p>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2<br>cp -r dir1 dir2<br>将目录dir1下所有文件包括文件夹，都复制到dir2目录下<br>cp -r dir1/<em>.</em> dir2<br>常见错误：<br>1、提示cp: omitting directory错误<br>复制目录时，使用-r选项即可递归拷贝，如下：<br>cp -r dir1 dir2</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"6-解压-压缩\"><a href=\"#6-解压-压缩\" class=\"headerlink\" title=\"6. 解压/压缩\"></a>6. 解压/压缩</h2><h3 id=\"6-1-压缩\"><a href=\"#6-1-压缩\" class=\"headerlink\" title=\"6.1 压缩\"></a>6.1 压缩</h3><blockquote>\n<p>压缩<br>  tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>  tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>  tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>  tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>  rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for linux<br>  zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>\n</blockquote>\n<h3 id=\"6-2-解压\"><a href=\"#6-2-解压\" class=\"headerlink\" title=\"6.2 解压\"></a>6.2 解压</h3><blockquote>\n<p>解压<br>  tar –xvf file.tar //解压 tar包<br>  tar -xzvf file.tar.gz //解压tar.gz<br>  tar -xjvf file.tar.bz2   //解压 tar.bz2<br>  tar –xZvf file.tar.Z   //解压tar.Z<br>  unrar e file.rar //解压rar<br>  unzip file.zip //解压zip</p>\n</blockquote>\n<h3 id=\"6-3-ubuntu-下rar解压工具安装方法：\"><a href=\"#6-3-ubuntu-下rar解压工具安装方法：\" class=\"headerlink\" title=\"6.3 ubuntu 下rar解压工具安装方法：\"></a>6.3 ubuntu 下rar解压工具安装方法：</h3><blockquote>\n<p>1、压缩功能<br> 安装 sudo apt-get install rar<br> 卸载 sudo apt-get remove rar<br> 2、解压功能<br> 安装 sudo apt-get install unrar<br> 卸载 sudo apt-get remove unrar<br> 压缩解压缩.rar<br> 解压：rar x FileName.rar<br> 压缩：rar a FileName.rar DirName  </p>\n</blockquote>\n<h3 id=\"6-4-总结\"><a href=\"#6-4-总结\" class=\"headerlink\" title=\"6.4 总结\"></a>6.4 总结</h3><blockquote>\n<p>1、<code>*.tar</code> 用 tar –xvf 解压<br>  2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>  3、<code>*.tar.gz</code>和<code>*.tgz</code> 用 tar –xzf 解压<br>  4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>  5、<code>*.tar.bz2</code>用tar –xjf 解压<br>  6、<code>*.Z</code> 用 uncompress 解压<br>  7、<code>*.tar.Z</code> 用tar –xZf 解压<br>  8、<code>*.rar</code> 用 unrar e解压<br>  9、<code>*.zip</code> 用 unzip 解压    </p>\n</blockquote>\n"},{"title":"ubuntu使用常用命令收集","date":"2018-03-01T08:02:21.000Z","_content":"\n记录在使用ubuntu系统过程中常见命令……\n\n## 查看占用端口\n\n`netstat -ln|grep 8388`或者`lsof -i:8388`\n\n## 关闭端口下应用\n\n`kill -9 PID号`\n\n\n## 防火墙\n\n1.安装\n\n`sudo apt-get install ufw` \n\n2.启用\n\n    sudo ufw enable\n    sudo ufw default deny\n    运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n\n3.开启/禁用\n\n    sudo ufw allow|deny [service]\n    打开或关闭某个端口，例如：\n    sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\n    sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\n    sudo ufw allow 53 允许外部访问53端口(tcp/udp)\n    sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\n    sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\n    sudo ufw deny smtp 禁止外部访问smtp服务\n    sudo ufw delete allow smtp 删除上面建立的某条规则\n    \n4.查看防火墙状态\n\n`sudo ufw status`    \n\n开启/关闭防火墙 (默认设置是’disable’)\n\n`# ufw enable|disable`\n\n5.UFW 使用范例：\n\n    允许 53 端口\n    \n    $ sudo ufw allow 53\n    \n    禁用 53 端口\n    \n    $ sudo ufw delete allow 53\n    \n    允许 80 端口\n    \n    $ sudo ufw allow 80/tcp\n    \n    禁用 80 端口\n    \n    $ sudo ufw delete allow 80/tcp\n    \n    允许 smtp 端口\n    \n    $ sudo ufw allow smtp\n    \n    删除 smtp 端口的许可\n    \n    $ sudo ufw delete allow smtp\n    \n    允许某特定 IP\n    \n    $ sudo ufw allow from 192.168.254.254\n    \n    删除上面的规则\n    \n    $ sudo ufw delete allow from 192.168.254.254","source":"_posts/linux-ubuntu-commom.md","raw":"---\ntitle: ubuntu使用常用命令收集\ndate: 2018-03-01 16:02:21\ncategories: ubuntu\ntags:\n---\n\n记录在使用ubuntu系统过程中常见命令……\n\n## 查看占用端口\n\n`netstat -ln|grep 8388`或者`lsof -i:8388`\n\n## 关闭端口下应用\n\n`kill -9 PID号`\n\n\n## 防火墙\n\n1.安装\n\n`sudo apt-get install ufw` \n\n2.启用\n\n    sudo ufw enable\n    sudo ufw default deny\n    运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n\n3.开启/禁用\n\n    sudo ufw allow|deny [service]\n    打开或关闭某个端口，例如：\n    sudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\n    sudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\n    sudo ufw allow 53 允许外部访问53端口(tcp/udp)\n    sudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\n    sudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\n    sudo ufw deny smtp 禁止外部访问smtp服务\n    sudo ufw delete allow smtp 删除上面建立的某条规则\n    \n4.查看防火墙状态\n\n`sudo ufw status`    \n\n开启/关闭防火墙 (默认设置是’disable’)\n\n`# ufw enable|disable`\n\n5.UFW 使用范例：\n\n    允许 53 端口\n    \n    $ sudo ufw allow 53\n    \n    禁用 53 端口\n    \n    $ sudo ufw delete allow 53\n    \n    允许 80 端口\n    \n    $ sudo ufw allow 80/tcp\n    \n    禁用 80 端口\n    \n    $ sudo ufw delete allow 80/tcp\n    \n    允许 smtp 端口\n    \n    $ sudo ufw allow smtp\n    \n    删除 smtp 端口的许可\n    \n    $ sudo ufw delete allow smtp\n    \n    允许某特定 IP\n    \n    $ sudo ufw allow from 192.168.254.254\n    \n    删除上面的规则\n    \n    $ sudo ufw delete allow from 192.168.254.254","slug":"linux-ubuntu-commom","published":1,"updated":"2018-03-01T09:52:53.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iokq002sd5hs52a7200h","content":"<p>记录在使用ubuntu系统过程中常见命令……</p>\n<h2 id=\"查看占用端口\"><a href=\"#查看占用端口\" class=\"headerlink\" title=\"查看占用端口\"></a>查看占用端口</h2><p><code>netstat -ln|grep 8388</code>或者<code>lsof -i:8388</code></p>\n<h2 id=\"关闭端口下应用\"><a href=\"#关闭端口下应用\" class=\"headerlink\" title=\"关闭端口下应用\"></a>关闭端口下应用</h2><p><code>kill -9 PID号</code></p>\n<h2 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h2><p>1.安装</p>\n<p><code>sudo apt-get install ufw</code> </p>\n<p>2.启用</p>\n<pre><code>sudo ufw enable\nsudo ufw default deny\n运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n</code></pre><p>3.开启/禁用</p>\n<pre><code>sudo ufw allow|deny [service]\n打开或关闭某个端口，例如：\nsudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\nsudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\nsudo ufw allow 53 允许外部访问53端口(tcp/udp)\nsudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\nsudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\nsudo ufw deny smtp 禁止外部访问smtp服务\nsudo ufw delete allow smtp 删除上面建立的某条规则\n</code></pre><p>4.查看防火墙状态</p>\n<p><code>sudo ufw status</code>    </p>\n<p>开启/关闭防火墙 (默认设置是’disable’)</p>\n<p><code># ufw enable|disable</code></p>\n<p>5.UFW 使用范例：</p>\n<pre><code>允许 53 端口\n\n$ sudo ufw allow 53\n\n禁用 53 端口\n\n$ sudo ufw delete allow 53\n\n允许 80 端口\n\n$ sudo ufw allow 80/tcp\n\n禁用 80 端口\n\n$ sudo ufw delete allow 80/tcp\n\n允许 smtp 端口\n\n$ sudo ufw allow smtp\n\n删除 smtp 端口的许可\n\n$ sudo ufw delete allow smtp\n\n允许某特定 IP\n\n$ sudo ufw allow from 192.168.254.254\n\n删除上面的规则\n\n$ sudo ufw delete allow from 192.168.254.254\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>记录在使用ubuntu系统过程中常见命令……</p>\n<h2 id=\"查看占用端口\"><a href=\"#查看占用端口\" class=\"headerlink\" title=\"查看占用端口\"></a>查看占用端口</h2><p><code>netstat -ln|grep 8388</code>或者<code>lsof -i:8388</code></p>\n<h2 id=\"关闭端口下应用\"><a href=\"#关闭端口下应用\" class=\"headerlink\" title=\"关闭端口下应用\"></a>关闭端口下应用</h2><p><code>kill -9 PID号</code></p>\n<h2 id=\"防火墙\"><a href=\"#防火墙\" class=\"headerlink\" title=\"防火墙\"></a>防火墙</h2><p>1.安装</p>\n<p><code>sudo apt-get install ufw</code> </p>\n<p>2.启用</p>\n<pre><code>sudo ufw enable\nsudo ufw default deny\n运行以上两条命令后，开启了防火墙，并在系统启动时自动开启。\n</code></pre><p>3.开启/禁用</p>\n<pre><code>sudo ufw allow|deny [service]\n打开或关闭某个端口，例如：\nsudo ufw allow smtp　允许所有的外部IP访问本机的25/tcp (smtp)端口\nsudo ufw allow 22/tcp 允许所有的外部IP访问本机的22/tcp (ssh)端口\nsudo ufw allow 53 允许外部访问53端口(tcp/udp)\nsudo ufw allow from 192.168.1.100 允许此IP访问所有的本机端口\nsudo ufw allow proto udp 192.168.0.1 port 53 to 192.168.0.2 port 53\nsudo ufw deny smtp 禁止外部访问smtp服务\nsudo ufw delete allow smtp 删除上面建立的某条规则\n</code></pre><p>4.查看防火墙状态</p>\n<p><code>sudo ufw status</code>    </p>\n<p>开启/关闭防火墙 (默认设置是’disable’)</p>\n<p><code># ufw enable|disable</code></p>\n<p>5.UFW 使用范例：</p>\n<pre><code>允许 53 端口\n\n$ sudo ufw allow 53\n\n禁用 53 端口\n\n$ sudo ufw delete allow 53\n\n允许 80 端口\n\n$ sudo ufw allow 80/tcp\n\n禁用 80 端口\n\n$ sudo ufw delete allow 80/tcp\n\n允许 smtp 端口\n\n$ sudo ufw allow smtp\n\n删除 smtp 端口的许可\n\n$ sudo ufw delete allow smtp\n\n允许某特定 IP\n\n$ sudo ufw allow from 192.168.254.254\n\n删除上面的规则\n\n$ sudo ufw delete allow from 192.168.254.254\n</code></pre>"},{"title":"maven使用经验记录","date":"2018-02-03T02:00:23.000Z","_content":"\n本文记录在开发过程中经常性使用到的maven特性……\n\n### 导出maven依赖的jar包到目录\n\n方法一：在pom目录下执行命令\t\n`mvn dependency:copy-dependencies`\n\n方法二：eclipse项目下：\n选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行\nmaven项目所依赖的jar包会导出到targed/dependency目录中。\n\n{% asset_img a.jpg %} \n\n{% asset_img b.jpg %} \n\n### maven打包时候跳过test检查\n\n方法一： 在pom目录下执行命令\n`mvn clean install -Dmaven.test.skip=true`\n\n方法二： 在pom中添加插件\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-surefire-plugin</artifactId>\n        <configuration>\n            <skipTests>true</skipTests>\n        </configuration>\n    </plugin>\n\n\n### 打包jar\n\n#### 普通打包\n会把maven依赖包一起打包。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n            <source>1.8</source>\n            <target>1.8</target>\n        </configuration>\n    </plugin>\n\n#### 不打包lib\n在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。 \n让后启动指定main类，并指定依赖包目录lib。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-jar-plugin</artifactId>\n        <configuration>\n            <archive>\n                <manifest>\n                    <mainClass>com.xcsqjr.StartAbsServiceAllApplication</mainClass>\n                    <addClasspath>true</addClasspath>\n                    <classpathPrefix>lib/</classpathPrefix>\n                </manifest>\n                <manifestEntries>\n                    <Class-Path>./</Class-Path>\n                </manifestEntries>\n            </archive>\n        </configuration>\n    </plugin>\n","source":"_posts/maven-ofen.md","raw":"---\ntitle: maven使用经验记录\ndate: 2018-02-03 10:00:23\ncategories: maven\ntags: maven常用功能\n---\n\n本文记录在开发过程中经常性使用到的maven特性……\n\n### 导出maven依赖的jar包到目录\n\n方法一：在pom目录下执行命令\t\n`mvn dependency:copy-dependencies`\n\n方法二：eclipse项目下：\n选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行\nmaven项目所依赖的jar包会导出到targed/dependency目录中。\n\n{% asset_img a.jpg %} \n\n{% asset_img b.jpg %} \n\n### maven打包时候跳过test检查\n\n方法一： 在pom目录下执行命令\n`mvn clean install -Dmaven.test.skip=true`\n\n方法二： 在pom中添加插件\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-surefire-plugin</artifactId>\n        <configuration>\n            <skipTests>true</skipTests>\n        </configuration>\n    </plugin>\n\n\n### 打包jar\n\n#### 普通打包\n会把maven依赖包一起打包。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-compiler-plugin</artifactId>\n        <configuration>\n            <source>1.8</source>\n            <target>1.8</target>\n        </configuration>\n    </plugin>\n\n#### 不打包lib\n在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。 \n让后启动指定main类，并指定依赖包目录lib。\n\n    <plugin>\n        <groupId>org.apache.maven.plugins</groupId>\n        <artifactId>maven-jar-plugin</artifactId>\n        <configuration>\n            <archive>\n                <manifest>\n                    <mainClass>com.xcsqjr.StartAbsServiceAllApplication</mainClass>\n                    <addClasspath>true</addClasspath>\n                    <classpathPrefix>lib/</classpathPrefix>\n                </manifest>\n                <manifestEntries>\n                    <Class-Path>./</Class-Path>\n                </manifestEntries>\n            </archive>\n        </configuration>\n    </plugin>\n","slug":"maven-ofen","published":1,"updated":"2018-02-03T02:21:56.039Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioks002wd5hsr3d77fch","content":"<p>本文记录在开发过程中经常性使用到的maven特性……</p>\n<h3 id=\"导出maven依赖的jar包到目录\"><a href=\"#导出maven依赖的jar包到目录\" class=\"headerlink\" title=\"导出maven依赖的jar包到目录\"></a>导出maven依赖的jar包到目录</h3><p>方法一：在pom目录下执行命令<br><code>mvn dependency:copy-dependencies</code></p>\n<p>方法二：eclipse项目下：<br>选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行<br>maven项目所依赖的jar包会导出到targed/dependency目录中。</p>\n<img src=\"/2018/02/03/maven-ofen/a.jpg\"> \n<img src=\"/2018/02/03/maven-ofen/b.jpg\"> \n<h3 id=\"maven打包时候跳过test检查\"><a href=\"#maven打包时候跳过test检查\" class=\"headerlink\" title=\"maven打包时候跳过test检查\"></a>maven打包时候跳过test检查</h3><p>方法一： 在pom目录下执行命令<br><code>mvn clean install -Dmaven.test.skip=true</code></p>\n<p>方法二： 在pom中添加插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;skipTests&gt;true&lt;/skipTests&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h3 id=\"打包jar\"><a href=\"#打包jar\" class=\"headerlink\" title=\"打包jar\"></a>打包jar</h3><h4 id=\"普通打包\"><a href=\"#普通打包\" class=\"headerlink\" title=\"普通打包\"></a>普通打包</h4><p>会把maven依赖包一起打包。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;/source&gt;\n        &lt;target&gt;1.8&lt;/target&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h4 id=\"不打包lib\"><a href=\"#不打包lib\" class=\"headerlink\" title=\"不打包lib\"></a>不打包lib</h4><p>在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。<br>让后启动指定main类，并指定依赖包目录lib。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;archive&gt;\n            &lt;manifest&gt;\n                &lt;mainClass&gt;com.xcsqjr.StartAbsServiceAllApplication&lt;/mainClass&gt;\n                &lt;addClasspath&gt;true&lt;/addClasspath&gt;\n                &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;\n            &lt;/manifest&gt;\n            &lt;manifestEntries&gt;\n                &lt;Class-Path&gt;./&lt;/Class-Path&gt;\n            &lt;/manifestEntries&gt;\n        &lt;/archive&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文记录在开发过程中经常性使用到的maven特性……</p>\n<h3 id=\"导出maven依赖的jar包到目录\"><a href=\"#导出maven依赖的jar包到目录\" class=\"headerlink\" title=\"导出maven依赖的jar包到目录\"></a>导出maven依赖的jar包到目录</h3><p>方法一：在pom目录下执行命令<br><code>mvn dependency:copy-dependencies</code></p>\n<p>方法二：eclipse项目下：<br>选择项目的pom.xml文件，点击右键菜单中的Run As,见下图红框中，在弹出的Configuration窗口中，输入 dependency:copy-dependencies后，点击运行<br>maven项目所依赖的jar包会导出到targed/dependency目录中。</p>\n<img src=\"/2018/02/03/maven-ofen/a.jpg\"> \n<img src=\"/2018/02/03/maven-ofen/b.jpg\"> \n<h3 id=\"maven打包时候跳过test检查\"><a href=\"#maven打包时候跳过test检查\" class=\"headerlink\" title=\"maven打包时候跳过test检查\"></a>maven打包时候跳过test检查</h3><p>方法一： 在pom目录下执行命令<br><code>mvn clean install -Dmaven.test.skip=true</code></p>\n<p>方法二： 在pom中添加插件</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-surefire-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;skipTests&gt;true&lt;/skipTests&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h3 id=\"打包jar\"><a href=\"#打包jar\" class=\"headerlink\" title=\"打包jar\"></a>打包jar</h3><h4 id=\"普通打包\"><a href=\"#普通打包\" class=\"headerlink\" title=\"普通打包\"></a>普通打包</h4><p>会把maven依赖包一起打包。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-compiler-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;source&gt;1.8&lt;/source&gt;\n        &lt;target&gt;1.8&lt;/target&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre><h4 id=\"不打包lib\"><a href=\"#不打包lib\" class=\"headerlink\" title=\"不打包lib\"></a>不打包lib</h4><p>在spring boot中实践，不打包maven依赖包，减少打包后jar的大小。<br>让后启动指定main类，并指定依赖包目录lib。</p>\n<pre><code>&lt;plugin&gt;\n    &lt;groupId&gt;org.apache.maven.plugins&lt;/groupId&gt;\n    &lt;artifactId&gt;maven-jar-plugin&lt;/artifactId&gt;\n    &lt;configuration&gt;\n        &lt;archive&gt;\n            &lt;manifest&gt;\n                &lt;mainClass&gt;com.xcsqjr.StartAbsServiceAllApplication&lt;/mainClass&gt;\n                &lt;addClasspath&gt;true&lt;/addClasspath&gt;\n                &lt;classpathPrefix&gt;lib/&lt;/classpathPrefix&gt;\n            &lt;/manifest&gt;\n            &lt;manifestEntries&gt;\n                &lt;Class-Path&gt;./&lt;/Class-Path&gt;\n            &lt;/manifestEntries&gt;\n        &lt;/archive&gt;\n    &lt;/configuration&gt;\n&lt;/plugin&gt;\n</code></pre>"},{"title":"maven使用常见错误收集","date":"2017-10-25T06:41:24.000Z","_content":"\n本文收集使用maven过程中的常见错误。\n\n> - 问题：\nmaven继承，使用 *`<relativePath></relativePath>`*，出现找不到指向pom，但是实际上已经正确指向了。 \n- 解决：\n    The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, `the group ID, artifact ID and version are still required,` and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.\n  Default value is: ../pom.xml.\n  *所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。*\n    \n    \n","source":"_posts/maven-use-error-collect.md","raw":"---\ntitle: maven使用常见错误收集\ndate: 2017-10-25 14:41:24\ncategories: maven\ntags: maven-error\n---\n\n本文收集使用maven过程中的常见错误。\n\n> - 问题：\nmaven继承，使用 *`<relativePath></relativePath>`*，出现找不到指向pom，但是实际上已经正确指向了。 \n- 解决：\n    The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, `the group ID, artifact ID and version are still required,` and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.\n  Default value is: ../pom.xml.\n  *所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。*\n    \n    \n","slug":"maven-use-error-collect","published":1,"updated":"2017-12-31T09:13:45.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioku002yd5hsavzbnexw","content":"<p>本文收集使用maven过程中的常见错误。</p>\n<blockquote>\n<ul>\n<li>问题：<br>maven继承，使用 <em><code>&lt;relativePath&gt;&lt;/relativePath&gt;</code></em>，出现找不到指向pom，但是实际上已经正确指向了。 </li>\n<li>解决：<br>  The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, <code>the group ID, artifact ID and version are still required,</code> and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.<br>Default value is: ../pom.xml.<br><em>所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。</em></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>本文收集使用maven过程中的常见错误。</p>\n<blockquote>\n<ul>\n<li>问题：<br>maven继承，使用 <em><code>&lt;relativePath&gt;&lt;/relativePath&gt;</code></em>，出现找不到指向pom，但是实际上已经正确指向了。 </li>\n<li>解决：<br>  The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, <code>the group ID, artifact ID and version are still required,</code> and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.<br>Default value is: ../pom.xml.<br><em>所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。</em></li>\n</ul>\n</blockquote>\n"},{"title":"微服务实践思考","date":"2017-09-26T02:14:45.000Z","_content":"","source":"_posts/microservice-think.md","raw":"---\ntitle: 微服务实践思考\ndate: 2017-09-26 10:14:45\ncategories: micro-service\ntags: 微服务实践总结\n---\n","slug":"microservice-think","published":1,"updated":"2017-12-31T09:13:45.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iokv0032d5hs5bjm5u6b","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"mysql建表规范","date":"2017-11-20T05:51:19.000Z","_content":"\n在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：\n\n## 1. 选择优化的数据类型\n\n原则：\n1. 更小的通常更好\n更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。\n\n2. 简单就好\n简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。\n\n3. 尽量避免NULL\n通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。   \n通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。\n\n### 1.1 整数类型\n整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。  \n整数计算通常使用64位的BIGINT。\n\n### 1.2 实数类型\n实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。  \nDOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。  \n在做高精度计算时，使用DECIMAL，比如财务计算。  \n\n### 1.3 字符串类型\nVARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。\nCHAR 不可变长。少用。\nBINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。\nBLOB 存储很大的数据量的字符串类型，二进制存储。\nTEXT 大文本。字符存储。\n- 使用枚举代替字符串\n可以存储枚举对应整型或者字符串……\n\n## 1.4 日期和时间类型\n\n\n","source":"_posts/mysql-create.md","raw":"---\ntitle: mysql建表规范\ndate: 2017-11-20 13:51:19\ncategories: mysql\ntags: mysql建表规范\n---\n\n在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：\n\n## 1. 选择优化的数据类型\n\n原则：\n1. 更小的通常更好\n更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。\n\n2. 简单就好\n简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。\n\n3. 尽量避免NULL\n通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。   \n通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。\n\n### 1.1 整数类型\n整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。  \n整数计算通常使用64位的BIGINT。\n\n### 1.2 实数类型\n实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。  \nDOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。  \n在做高精度计算时，使用DECIMAL，比如财务计算。  \n\n### 1.3 字符串类型\nVARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。\nCHAR 不可变长。少用。\nBINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。\nBLOB 存储很大的数据量的字符串类型，二进制存储。\nTEXT 大文本。字符存储。\n- 使用枚举代替字符串\n可以存储枚举对应整型或者字符串……\n\n## 1.4 日期和时间类型\n\n\n","slug":"mysql-create","published":1,"updated":"2017-12-31T09:13:45.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iokx0033d5hsixicivo4","content":"<p>在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：</p>\n<h2 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1. 选择优化的数据类型\"></a>1. 选择优化的数据类型</h2><p>原则：</p>\n<ol>\n<li><p>更小的通常更好<br>更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。</p>\n</li>\n<li><p>简单就好<br>简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。</p>\n</li>\n<li><p>尽量避免NULL<br>通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。<br>通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。</p>\n</li>\n</ol>\n<h3 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h3><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。<br>整数计算通常使用64位的BIGINT。</p>\n<h3 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h3><p>实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。<br>DOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。<br>在做高精度计算时，使用DECIMAL，比如财务计算。  </p>\n<h3 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h3><p>VARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。<br>CHAR 不可变长。少用。<br>BINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。<br>BLOB 存储很大的数据量的字符串类型，二进制存储。<br>TEXT 大文本。字符存储。</p>\n<ul>\n<li>使用枚举代替字符串<br>可以存储枚举对应整型或者字符串……</li>\n</ul>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2>","site":{"data":{}},"excerpt":"","more":"<p>在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：</p>\n<h2 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1. 选择优化的数据类型\"></a>1. 选择优化的数据类型</h2><p>原则：</p>\n<ol>\n<li><p>更小的通常更好<br>更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。</p>\n</li>\n<li><p>简单就好<br>简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。</p>\n</li>\n<li><p>尽量避免NULL<br>通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。<br>通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。</p>\n</li>\n</ol>\n<h3 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h3><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。<br>整数计算通常使用64位的BIGINT。</p>\n<h3 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h3><p>实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。<br>DOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。<br>在做高精度计算时，使用DECIMAL，比如财务计算。  </p>\n<h3 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h3><p>VARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。<br>CHAR 不可变长。少用。<br>BINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。<br>BLOB 存储很大的数据量的字符串类型，二进制存储。<br>TEXT 大文本。字符存储。</p>\n<ul>\n<li>使用枚举代替字符串<br>可以存储枚举对应整型或者字符串……</li>\n</ul>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2>"},{"title":"在Pivotal Web Service上发布Spring Boot应用","date":"2017-10-12T07:08:33.000Z","_content":"\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","source":"_posts/pivotal-web-service-start.md","raw":"---\ntitle: 在Pivotal Web Service上发布Spring Boot应用\ndate: 2017-10-12 15:08:33\ncategories: Pivotal Web Service\ntags: pws-push\n---\n\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","slug":"pivotal-web-service-start","published":1,"updated":"2017-12-31T09:13:45.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioky0038d5hs9hvm1h0g","content":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"noopener\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"noopener\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"noopener\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"noopener\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"noopener\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"noopener\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\"></li>\n</ol>\n"},{"title":"mysql性能优化神器explain","date":"2017-11-21T05:36:04.000Z","_content":"\nMySQL 性能优化神器 Explain 使用分析\n\nmysql mysql优化  永顺 1月16日发布\n赞  |   6收藏  |  50\n3.2k 次浏览\n简介\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n\nEXPLAIN SELECT * from user_info WHERE id < 300;\n准备\n为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:\n\n    CREATE TABLE `user_info` (\n      `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `name` VARCHAR(50) NOT NULL DEFAULT '',\n      `age`  INT(11)              DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `name_index` (`name`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO user_info (name, age) VALUES ('xys', 20);\n    INSERT INTO user_info (name, age) VALUES ('a', 21);\n    INSERT INTO user_info (name, age) VALUES ('b', 23);\n    INSERT INTO user_info (name, age) VALUES ('c', 50);\n    INSERT INTO user_info (name, age) VALUES ('d', 15);\n    INSERT INTO user_info (name, age) VALUES ('e', 20);\n    INSERT INTO user_info (name, age) VALUES ('f', 21);\n    INSERT INTO user_info (name, age) VALUES ('g', 23);\n    INSERT INTO user_info (name, age) VALUES ('h', 50);\n    INSERT INTO user_info (name, age) VALUES ('i', 15);\n    CREATE TABLE `order_info` (\n      `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `user_id`      BIGINT(20)           DEFAULT NULL,\n      `product_name` VARCHAR(50) NOT NULL DEFAULT '',\n      `productor`    VARCHAR(30)          DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE');\nEXPLAIN 输出格式\nEXPLAIN 命令的输出内容大致如下:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n各列的含义如下:\n\n- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n- select_type: SELECT 查询的类型.\n- table: 查询的是哪个表\n- partitions: 匹配的分区\n- type: join 类型\n- possible_keys: 此次查询中可能选用的索引\n- key: 此次查询中确切使用到的索引.\n- ref: 哪个字段或常数与 key 一起被使用\n- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n- filtered: 表示此查询条件所过滤的数据的百分比\n- extra: 额外的信息\n接下来我们来重点看一下比较重要的几个字段.\n\nselect_type  \nselect_type 表示了查询的类型, 它的常用取值有:\n\nSIMPLE, 表示此查询不包含 UNION 查询或子查询  \nPRIMARY, 表示此查询是最外层的查询  \nUNION, 表示此查询是 UNION 的第二或随后的查询  \nDEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询  \nUNION RESULT, UNION 的结果  \nSUBQUERY, 子查询中的第一个 SELECT  \nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.   \n最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:\n\n    mysql> EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n        -> UNION\n        -> (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    |  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.00 sec)\n    table\n表示查询涉及的表或衍生表\n\n- type  \ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.   \ntype 常用类型   \ntype 常用的取值有:   \nsystem: 表中只有一条数据. 这个类型是特殊的 const 类型.   \nconst: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.   \n例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   \n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n    \n- eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 314\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using where; Using index\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: eq_ref\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: test.order_info.user_id\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        2 rows in set, 1 warning (0.00 sec)\n        \n- ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. \n例如下面这个例子中, 就使用到了 ref 类型的查询:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: const\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: Using index\n        2 rows in set, 1 warning (0.01 sec)\n\n- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.  \n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\n例如下面的例子就是一个范围查询:  \n\n        mysql> EXPLAIN SELECT *\n            ->         FROM user_info\n            ->         WHERE id BETWEEN 2 AND 8 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: range\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: NULL\n                 rows: 7\n             filtered: 100.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n    \n- index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.  \nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.  \n例如:  \n\n        mysql> EXPLAIN SELECT name FROM  user_info \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: name_index\n              key_len: 152\n                  ref: NULL\n                 rows: 10\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n    \n上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  \n\n- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.   \n下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   \n\n        mysql> EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: ALL\n        possible_keys: NULL\n                  key: NULL\n              key_len: NULL\n                  ref: NULL\n                 rows: 10\n             filtered: 10.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n        \n- type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\nALL < index < range ~ index_merge < ref < eq_ref < const < system\nALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\npossible_keys\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\nkey\n此字段是 MySQL 在当前查询时所真正使用到的索引.\nkey_len\n表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\nkey_len 的计算规则如下:\n字符串\nchar(n): n 字节长度\nvarchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.\n数值类型:\nTINYINT: 1字节\nSMALLINT: 2字节\nMEDIUMINT: 3字节\nINT: 4字节\nBIGINT: 8字节\n时间类型\nDATE: 3字节\nTIMESTAMP: 4字节\nDATETIME: 8字节\n字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n我们来举两个简单的栗子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: range\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: NULL\n                 rows: 5\n             filtered: 11.11\n                Extra: Using where; Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:\n\n- `KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n不过此查询语句 WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT '0', 则 key_length 应该是8.\n\n上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.\n\n接下来我们来看一下下一个例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \\G;\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 161\n                  ref: const,const\n                 rows: 2\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = 'p1' 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161\n\n- rows\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n\n- Extra\nEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:\n\n- Using filesort\n当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n例如下面的例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index; Using filesort\n        1 row in set, 1 warning (0.00 sec)\n        \n我们的索引是\n\n`KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.\n如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n- Using index\n\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n-   Using temporary\n查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","source":"_posts/mysql-explain.md","raw":"---\ntitle: mysql性能优化神器explain\ndate: 2017-11-21 13:36:04\ncategories: mysql\ntags: mysql-expain\n---\n\nMySQL 性能优化神器 Explain 使用分析\n\nmysql mysql优化  永顺 1月16日发布\n赞  |   6收藏  |  50\n3.2k 次浏览\n简介\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n\nEXPLAIN SELECT * from user_info WHERE id < 300;\n准备\n为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:\n\n    CREATE TABLE `user_info` (\n      `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `name` VARCHAR(50) NOT NULL DEFAULT '',\n      `age`  INT(11)              DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `name_index` (`name`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO user_info (name, age) VALUES ('xys', 20);\n    INSERT INTO user_info (name, age) VALUES ('a', 21);\n    INSERT INTO user_info (name, age) VALUES ('b', 23);\n    INSERT INTO user_info (name, age) VALUES ('c', 50);\n    INSERT INTO user_info (name, age) VALUES ('d', 15);\n    INSERT INTO user_info (name, age) VALUES ('e', 20);\n    INSERT INTO user_info (name, age) VALUES ('f', 21);\n    INSERT INTO user_info (name, age) VALUES ('g', 23);\n    INSERT INTO user_info (name, age) VALUES ('h', 50);\n    INSERT INTO user_info (name, age) VALUES ('i', 15);\n    CREATE TABLE `order_info` (\n      `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `user_id`      BIGINT(20)           DEFAULT NULL,\n      `product_name` VARCHAR(50) NOT NULL DEFAULT '',\n      `productor`    VARCHAR(30)          DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE');\nEXPLAIN 输出格式\nEXPLAIN 命令的输出内容大致如下:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n各列的含义如下:\n\n- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n- select_type: SELECT 查询的类型.\n- table: 查询的是哪个表\n- partitions: 匹配的分区\n- type: join 类型\n- possible_keys: 此次查询中可能选用的索引\n- key: 此次查询中确切使用到的索引.\n- ref: 哪个字段或常数与 key 一起被使用\n- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n- filtered: 表示此查询条件所过滤的数据的百分比\n- extra: 额外的信息\n接下来我们来重点看一下比较重要的几个字段.\n\nselect_type  \nselect_type 表示了查询的类型, 它的常用取值有:\n\nSIMPLE, 表示此查询不包含 UNION 查询或子查询  \nPRIMARY, 表示此查询是最外层的查询  \nUNION, 表示此查询是 UNION 的第二或随后的查询  \nDEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询  \nUNION RESULT, UNION 的结果  \nSUBQUERY, 子查询中的第一个 SELECT  \nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.   \n最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:\n\n    mysql> EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n        -> UNION\n        -> (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    |  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.00 sec)\n    table\n表示查询涉及的表或衍生表\n\n- type  \ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.   \ntype 常用类型   \ntype 常用的取值有:   \nsystem: 表中只有一条数据. 这个类型是特殊的 const 类型.   \nconst: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.   \n例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   \n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n    \n- eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 314\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using where; Using index\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: eq_ref\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: test.order_info.user_id\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        2 rows in set, 1 warning (0.00 sec)\n        \n- ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. \n例如下面这个例子中, 就使用到了 ref 类型的查询:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: const\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: Using index\n        2 rows in set, 1 warning (0.01 sec)\n\n- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.  \n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\n例如下面的例子就是一个范围查询:  \n\n        mysql> EXPLAIN SELECT *\n            ->         FROM user_info\n            ->         WHERE id BETWEEN 2 AND 8 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: range\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: NULL\n                 rows: 7\n             filtered: 100.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n    \n- index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.  \nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.  \n例如:  \n\n        mysql> EXPLAIN SELECT name FROM  user_info \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: name_index\n              key_len: 152\n                  ref: NULL\n                 rows: 10\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n    \n上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  \n\n- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.   \n下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   \n\n        mysql> EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: ALL\n        possible_keys: NULL\n                  key: NULL\n              key_len: NULL\n                  ref: NULL\n                 rows: 10\n             filtered: 10.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n        \n- type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\nALL < index < range ~ index_merge < ref < eq_ref < const < system\nALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\npossible_keys\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\nkey\n此字段是 MySQL 在当前查询时所真正使用到的索引.\nkey_len\n表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\nkey_len 的计算规则如下:\n字符串\nchar(n): n 字节长度\nvarchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.\n数值类型:\nTINYINT: 1字节\nSMALLINT: 2字节\nMEDIUMINT: 3字节\nINT: 4字节\nBIGINT: 8字节\n时间类型\nDATE: 3字节\nTIMESTAMP: 4字节\nDATETIME: 8字节\n字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n我们来举两个简单的栗子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: range\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: NULL\n                 rows: 5\n             filtered: 11.11\n                Extra: Using where; Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:\n\n- `KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n不过此查询语句 WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT '0', 则 key_length 应该是8.\n\n上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.\n\n接下来我们来看一下下一个例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \\G;\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 161\n                  ref: const,const\n                 rows: 2\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = 'p1' 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161\n\n- rows\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n\n- Extra\nEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:\n\n- Using filesort\n当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n例如下面的例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index; Using filesort\n        1 row in set, 1 warning (0.00 sec)\n        \n我们的索引是\n\n`KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.\n如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n- Using index\n\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n-   Using temporary\n查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","slug":"mysql-explain","published":1,"updated":"2017-12-31T09:13:45.246Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iokz0039d5hs158e9nw7","content":"<p>MySQL 性能优化神器 Explain 使用分析</p>\n<p>mysql mysql优化  永顺 1月16日发布<br>赞  |   6收藏  |  50<br>3.2k 次浏览<br>简介<br>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>\n<p>EXPLAIN SELECT * from user_info WHERE id &lt; 300;<br>准备<br>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>\n<pre><code>CREATE TABLE `user_info` (\n  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `age`  INT(11)              DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name_index` (`name`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);\nINSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);\nCREATE TABLE `order_info` (\n  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `user_id`      BIGINT(20)           DEFAULT NULL,\n  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `productor`    VARCHAR(30)          DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);\n</code></pre><p>EXPLAIN 输出格式<br>EXPLAIN 命令的输出内容大致如下:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>各列的含义如下:</p>\n<ul>\n<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li>select_type: SELECT 查询的类型.</li>\n<li>table: 查询的是哪个表</li>\n<li>partitions: 匹配的分区</li>\n<li>type: join 类型</li>\n<li>possible_keys: 此次查询中可能选用的索引</li>\n<li>key: 此次查询中确切使用到的索引.</li>\n<li>ref: 哪个字段或常数与 key 一起被使用</li>\n<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>\n<li>filtered: 表示此查询条件所过滤的数据的百分比</li>\n<li>extra: 额外的信息<br>接下来我们来重点看一下比较重要的几个字段.</li>\n</ul>\n<p>select_type<br>select_type 表示了查询的类型, 它的常用取值有:</p>\n<p>SIMPLE, 表示此查询不包含 UNION 查询或子查询<br>PRIMARY, 表示此查询是最外层的查询<br>UNION, 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>SUBQUERY, 子查询中的第一个 SELECT<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.<br>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>\n<pre><code>mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n    -&gt; UNION\n    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n3 rows in set, 1 warning (0.00 sec)\ntable\n</code></pre><p>表示查询涉及的表或衍生表</p>\n<ul>\n<li><p>type<br>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>type 常用类型<br>type 常用的取值有:<br>system: 表中只有一条数据. 这个类型是特殊的 const 类型.<br>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   </p>\n<p>  mysql&gt; explain select <em> from user_info where id = 2\\G<br>  <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></p>\n<pre><code>         id: 1\nselect_type: SIMPLE\n      table: user_info\n partitions: NULL\n       type: const\n</code></pre><p>  possible_keys: PRIMARY</p>\n<pre><code>     key: PRIMARY\n key_len: 8\n     ref: const\n    rows: 1\nfiltered: 100.00\n   Extra: NULL\n</code></pre><p>  1 row in set, 1 warning (0.00 sec)</p>\n</li>\n<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 314\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using where; Using index\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: eq_ref\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: test.order_info.user_id\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n2 rows in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index\n2 rows in set, 1 warning (0.01 sec)\n</code></pre></li>\n<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.<br>例如下面的例子就是一个范围查询:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT *\n    -&gt;         FROM user_info\n    -&gt;         WHERE id BETWEEN 2 AND 8 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 7\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.<br>例如:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT name FROM  user_info \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: name_index\n      key_len: 152\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  </p>\n<ul>\n<li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   </p>\n<pre><code>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 10.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.<br>possible_keys<br>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.<br>key<br>此字段是 MySQL 在当前查询时所真正使用到的索引.<br>key_len<br>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:<br>字符串<br>char(n): n 字节长度<br>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.<br>数值类型:<br>TINYINT: 1字节<br>SMALLINT: 2字节<br>MEDIUMINT: 3字节<br>INT: 4字节<br>BIGINT: 8字节<br>时间类型<br>DATE: 3字节<br>TIMESTAMP: 4字节<br>DATETIME: 8字节<br>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.<br>我们来举两个简单的栗子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: range\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: NULL\n         rows: 5\n     filtered: 11.11\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>\n<ul>\n<li><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</li>\n</ul>\n<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>\n<p>接下来我们来看一下下一个例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 161\n          ref: const,const\n         rows: 2\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>\n<ul>\n<li><p>rows<br>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n</li>\n<li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.<br>例如下面的例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index; Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>我们的索引是</p>\n<p><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><ul>\n<li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>MySQL 性能优化神器 Explain 使用分析</p>\n<p>mysql mysql优化  永顺 1月16日发布<br>赞  |   6收藏  |  50<br>3.2k 次浏览<br>简介<br>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>\n<p>EXPLAIN SELECT * from user_info WHERE id &lt; 300;<br>准备<br>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>\n<pre><code>CREATE TABLE `user_info` (\n  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `age`  INT(11)              DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name_index` (`name`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);\nINSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);\nCREATE TABLE `order_info` (\n  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `user_id`      BIGINT(20)           DEFAULT NULL,\n  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `productor`    VARCHAR(30)          DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);\n</code></pre><p>EXPLAIN 输出格式<br>EXPLAIN 命令的输出内容大致如下:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>各列的含义如下:</p>\n<ul>\n<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li>select_type: SELECT 查询的类型.</li>\n<li>table: 查询的是哪个表</li>\n<li>partitions: 匹配的分区</li>\n<li>type: join 类型</li>\n<li>possible_keys: 此次查询中可能选用的索引</li>\n<li>key: 此次查询中确切使用到的索引.</li>\n<li>ref: 哪个字段或常数与 key 一起被使用</li>\n<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>\n<li>filtered: 表示此查询条件所过滤的数据的百分比</li>\n<li>extra: 额外的信息<br>接下来我们来重点看一下比较重要的几个字段.</li>\n</ul>\n<p>select_type<br>select_type 表示了查询的类型, 它的常用取值有:</p>\n<p>SIMPLE, 表示此查询不包含 UNION 查询或子查询<br>PRIMARY, 表示此查询是最外层的查询<br>UNION, 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>SUBQUERY, 子查询中的第一个 SELECT<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.<br>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>\n<pre><code>mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n    -&gt; UNION\n    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n3 rows in set, 1 warning (0.00 sec)\ntable\n</code></pre><p>表示查询涉及的表或衍生表</p>\n<ul>\n<li><p>type<br>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>type 常用类型<br>type 常用的取值有:<br>system: 表中只有一条数据. 这个类型是特殊的 const 类型.<br>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   </p>\n<p>  mysql&gt; explain select <em> from user_info where id = 2\\G<br>  <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></p>\n<pre><code>         id: 1\nselect_type: SIMPLE\n      table: user_info\n partitions: NULL\n       type: const\n</code></pre><p>  possible_keys: PRIMARY</p>\n<pre><code>     key: PRIMARY\n key_len: 8\n     ref: const\n    rows: 1\nfiltered: 100.00\n   Extra: NULL\n</code></pre><p>  1 row in set, 1 warning (0.00 sec)</p>\n</li>\n<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 314\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using where; Using index\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: eq_ref\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: test.order_info.user_id\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n2 rows in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index\n2 rows in set, 1 warning (0.01 sec)\n</code></pre></li>\n<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.<br>例如下面的例子就是一个范围查询:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT *\n    -&gt;         FROM user_info\n    -&gt;         WHERE id BETWEEN 2 AND 8 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 7\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.<br>例如:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT name FROM  user_info \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: name_index\n      key_len: 152\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  </p>\n<ul>\n<li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   </p>\n<pre><code>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 10.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.<br>possible_keys<br>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.<br>key<br>此字段是 MySQL 在当前查询时所真正使用到的索引.<br>key_len<br>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:<br>字符串<br>char(n): n 字节长度<br>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.<br>数值类型:<br>TINYINT: 1字节<br>SMALLINT: 2字节<br>MEDIUMINT: 3字节<br>INT: 4字节<br>BIGINT: 8字节<br>时间类型<br>DATE: 3字节<br>TIMESTAMP: 4字节<br>DATETIME: 8字节<br>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.<br>我们来举两个简单的栗子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: range\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: NULL\n         rows: 5\n     filtered: 11.11\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>\n<ul>\n<li><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</li>\n</ul>\n<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>\n<p>接下来我们来看一下下一个例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 161\n          ref: const,const\n         rows: 2\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>\n<ul>\n<li><p>rows<br>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n</li>\n<li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.<br>例如下面的例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index; Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>我们的索引是</p>\n<p><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><ul>\n<li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n"},{"title":"rabbitMq实战记录","date":"2018-01-19T04:12:57.000Z","_content":"\nrabbitMq使用记录，好记性不如烂……","source":"_posts/rabbitmq-action.md","raw":"---\ntitle: rabbitMq实战记录\ndate: 2018-01-19 12:12:57\ncategories: rabbitmq\ntags: \n---\n\nrabbitMq使用记录，好记性不如烂……","slug":"rabbitmq-action","published":1,"updated":"2018-01-19T04:15:04.850Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iol1003dd5hsu7ts2ug3","content":"<p>rabbitMq使用记录，好记性不如烂……</p>\n","site":{"data":{}},"excerpt":"","more":"<p>rabbitMq使用记录，好记性不如烂……</p>\n"},{"title":"rabbitmq快速安装","date":"2018-01-02T08:02:01.000Z","_content":"\n本文介绍rabbitmq在各系统平台下的安装……\n\n## 在Centos下的快速安装\n\n一、安装erlang\nsudo yum install erlang\n\n检查是否安装好：\n\n    [root@localhost /]# erl\n    Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n\n二、安装rabbitmq\n\n（1）下载安装包\nwget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\n\n（2）安装\n\n    > rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n    > yum install rabbitmq-server-3.6.0-1.noarch.rpm\n\n（3）启用web管理插件\nrabbitmq-plugins enable rabbitmq_management\n\n三、启动RabbitMQ\nchkconfig rabbitmq-server on  //开机启动设置\nservice rabbitmq-server start\n\n 四、打开对应端口\n        # firewall-cmd --permanent --zone=public --add-port=5672/tcp\n        # firewall-cmd --permanent --zone=public --add-port=15672/tcp\n        # firewall-cmd --reload\n\n五、打开网页\nhttp://119.23.78.160:15672/\n\n## 在Ubuntu下的快速安装\n\n安装最新版，参考网址： \nhttp://www.rabbitmq.com/install-debian.html\n\n注：下面安装的不是最新版本。\n一. 安装对应erlang版本：\nerlang-nox (>= 1:19.3-1) | esl-erlang (>= 1:19.3-1).\n`sudo apt-get install erlang-nox`\n\n二. 安装rabbitMq:\n\n    $ sudo apt-get update\n    $ sudo apt-get install rabbitmq-server\n    \n三. 启用web管理插件：\n\n`sudo rabbitmq-plugins enable rabbitmq_management`  \n\n四. 访问\n打开：http://localhost:15672  \n\n五. 登录（本机）：\n用户：guest\n密码：guest\n\n注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。\n","source":"_posts/rabbitmq-install.md","raw":"---\ntitle: rabbitmq快速安装\ndate: 2018-01-02 16:02:01\ncategories: rabbitmq\ntags: rabbitmq-install\n---\n\n本文介绍rabbitmq在各系统平台下的安装……\n\n## 在Centos下的快速安装\n\n一、安装erlang\nsudo yum install erlang\n\n检查是否安装好：\n\n    [root@localhost /]# erl\n    Erlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n\n二、安装rabbitmq\n\n（1）下载安装包\nwget http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\n\n（2）安装\n\n    > rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n    > yum install rabbitmq-server-3.6.0-1.noarch.rpm\n\n（3）启用web管理插件\nrabbitmq-plugins enable rabbitmq_management\n\n三、启动RabbitMQ\nchkconfig rabbitmq-server on  //开机启动设置\nservice rabbitmq-server start\n\n 四、打开对应端口\n        # firewall-cmd --permanent --zone=public --add-port=5672/tcp\n        # firewall-cmd --permanent --zone=public --add-port=15672/tcp\n        # firewall-cmd --reload\n\n五、打开网页\nhttp://119.23.78.160:15672/\n\n## 在Ubuntu下的快速安装\n\n安装最新版，参考网址： \nhttp://www.rabbitmq.com/install-debian.html\n\n注：下面安装的不是最新版本。\n一. 安装对应erlang版本：\nerlang-nox (>= 1:19.3-1) | esl-erlang (>= 1:19.3-1).\n`sudo apt-get install erlang-nox`\n\n二. 安装rabbitMq:\n\n    $ sudo apt-get update\n    $ sudo apt-get install rabbitmq-server\n    \n三. 启用web管理插件：\n\n`sudo rabbitmq-plugins enable rabbitmq_management`  \n\n四. 访问\n打开：http://localhost:15672  \n\n五. 登录（本机）：\n用户：guest\n密码：guest\n\n注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。\n","slug":"rabbitmq-install","published":1,"updated":"2018-01-19T04:10:22.232Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iol3003fd5hsyfs3e2t9","content":"<p>本文介绍rabbitmq在各系统平台下的安装……</p>\n<h2 id=\"在Centos下的快速安装\"><a href=\"#在Centos下的快速安装\" class=\"headerlink\" title=\"在Centos下的快速安装\"></a>在Centos下的快速安装</h2><p>一、安装erlang<br>sudo yum install erlang</p>\n<p>检查是否安装好：</p>\n<pre><code>[root@localhost /]# erl\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n</code></pre><p>二、安装rabbitmq</p>\n<p>（1）下载安装包<br>wget <a href=\"http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm</a></p>\n<p>（2）安装</p>\n<pre><code>&gt; rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n&gt; yum install rabbitmq-server-3.6.0-1.noarch.rpm\n</code></pre><p>（3）启用web管理插件<br>rabbitmq-plugins enable rabbitmq_management</p>\n<p>三、启动RabbitMQ<br>chkconfig rabbitmq-server on  //开机启动设置<br>service rabbitmq-server start</p>\n<p> 四、打开对应端口</p>\n<pre><code># firewall-cmd --permanent --zone=public --add-port=5672/tcp\n# firewall-cmd --permanent --zone=public --add-port=15672/tcp\n# firewall-cmd --reload\n</code></pre><p>五、打开网页<br><a href=\"http://119.23.78.160:15672/\" target=\"_blank\" rel=\"noopener\">http://119.23.78.160:15672/</a></p>\n<h2 id=\"在Ubuntu下的快速安装\"><a href=\"#在Ubuntu下的快速安装\" class=\"headerlink\" title=\"在Ubuntu下的快速安装\"></a>在Ubuntu下的快速安装</h2><p>安装最新版，参考网址：<br><a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a></p>\n<p>注：下面安装的不是最新版本。<br>一. 安装对应erlang版本：<br>erlang-nox (&gt;= 1:19.3-1) | esl-erlang (&gt;= 1:19.3-1).<br><code>sudo apt-get install erlang-nox</code></p>\n<p>二. 安装rabbitMq:</p>\n<pre><code>$ sudo apt-get update\n$ sudo apt-get install rabbitmq-server\n</code></pre><p>三. 启用web管理插件：</p>\n<p><code>sudo rabbitmq-plugins enable rabbitmq_management</code>  </p>\n<p>四. 访问<br>打开：<a href=\"http://localhost:15672\" target=\"_blank\" rel=\"noopener\">http://localhost:15672</a>  </p>\n<p>五. 登录（本机）：<br>用户：guest<br>密码：guest</p>\n<p>注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍rabbitmq在各系统平台下的安装……</p>\n<h2 id=\"在Centos下的快速安装\"><a href=\"#在Centos下的快速安装\" class=\"headerlink\" title=\"在Centos下的快速安装\"></a>在Centos下的快速安装</h2><p>一、安装erlang<br>sudo yum install erlang</p>\n<p>检查是否安装好：</p>\n<pre><code>[root@localhost /]# erl\nErlang R16B03-1 (erts-5.10.4) [source] [64-bit] [smp:4:4] [async-threads:10] [hipe] [kernel-poll:false]\n</code></pre><p>二、安装rabbitmq</p>\n<p>（1）下载安装包<br>wget <a href=\"http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/releases/rabbitmq-server/v3.6.0/rabbitmq-server-3.6.0-1.noarch.rpm</a></p>\n<p>（2）安装</p>\n<pre><code>&gt; rpm --import https://www.rabbitmq.com/rabbitmq-release-signing-key.asc\n&gt; yum install rabbitmq-server-3.6.0-1.noarch.rpm\n</code></pre><p>（3）启用web管理插件<br>rabbitmq-plugins enable rabbitmq_management</p>\n<p>三、启动RabbitMQ<br>chkconfig rabbitmq-server on  //开机启动设置<br>service rabbitmq-server start</p>\n<p> 四、打开对应端口</p>\n<pre><code># firewall-cmd --permanent --zone=public --add-port=5672/tcp\n# firewall-cmd --permanent --zone=public --add-port=15672/tcp\n# firewall-cmd --reload\n</code></pre><p>五、打开网页<br><a href=\"http://119.23.78.160:15672/\" target=\"_blank\" rel=\"noopener\">http://119.23.78.160:15672/</a></p>\n<h2 id=\"在Ubuntu下的快速安装\"><a href=\"#在Ubuntu下的快速安装\" class=\"headerlink\" title=\"在Ubuntu下的快速安装\"></a>在Ubuntu下的快速安装</h2><p>安装最新版，参考网址：<br><a href=\"http://www.rabbitmq.com/install-debian.html\" target=\"_blank\" rel=\"noopener\">http://www.rabbitmq.com/install-debian.html</a></p>\n<p>注：下面安装的不是最新版本。<br>一. 安装对应erlang版本：<br>erlang-nox (&gt;= 1:19.3-1) | esl-erlang (&gt;= 1:19.3-1).<br><code>sudo apt-get install erlang-nox</code></p>\n<p>二. 安装rabbitMq:</p>\n<pre><code>$ sudo apt-get update\n$ sudo apt-get install rabbitmq-server\n</code></pre><p>三. 启用web管理插件：</p>\n<p><code>sudo rabbitmq-plugins enable rabbitmq_management</code>  </p>\n<p>四. 访问<br>打开：<a href=\"http://localhost:15672\" target=\"_blank\" rel=\"noopener\">http://localhost:15672</a>  </p>\n<p>五. 登录（本机）：<br>用户：guest<br>密码：guest</p>\n<p>注：guest用户是系统用户，默认是不允许远程登录的。如果是在服务器端安装，需要添加用户才能远程登录。</p>\n"},{"title":"redis一主多从集群配置","date":"2017-09-21T05:46:08.000Z","_content":"","source":"_posts/redis-cluster-centos.md","raw":"---\ntitle: redis一主多从集群配置\ndate: 2017-09-21 13:46:08\ncategories: redis\ntags:   redis,主从,集群\n---\n","slug":"redis-cluster-centos","published":1,"updated":"2017-12-31T09:13:45.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iol7003jd5hszrsjybvf","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis配置","date":"2017-12-06T06:13:01.000Z","_content":"","source":"_posts/redis-conf.md","raw":"---\ntitle: redis配置\ndate: 2017-12-06 14:13:01\ncategories: redis\ntags: redis,密码,安全\n---\n","slug":"redis-conf","published":1,"updated":"2017-12-31T09:13:45.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iol9003ld5hssl56pkcq","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"redis命令搜集","date":"2018-03-23T09:36:34.000Z","_content":"\n1.查看所有的key\n\n`> KEYS *`\n\n2.清空所有key和数据\n\n`> flushall`","source":"_posts/redis-common.md","raw":"---\ntitle: redis命令搜集\ndate: 2018-03-23 17:36:34\ncategories: redis\ntags: redis命令\n---\n\n1.查看所有的key\n\n`> KEYS *`\n\n2.清空所有key和数据\n\n`> flushall`","slug":"redis-common","published":1,"updated":"2018-03-23T09:47:51.316Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iolj003od5hsinjds2bo","content":"<p>1.查看所有的key</p>\n<p><code>&gt; KEYS *</code></p>\n<p>2.清空所有key和数据</p>\n<p><code>&gt; flushall</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>1.查看所有的key</p>\n<p><code>&gt; KEYS *</code></p>\n<p>2.清空所有key和数据</p>\n<p><code>&gt; flushall</code></p>\n"},{"title":"redis安装","date":"2018-01-18T12:55:18.000Z","_content":"\n本文介绍在linux系统下redis的安装使用……\n\n## redis在ubuntu系统下的安装\n\n### 一、下载，安装，测试\n\nDownload, extract and compile Redis with:\n\n    $ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n    $ tar xzf redis-3.2.0.tar.gz\n    $ cd redis-3.2.0\n    $ make\n\nThe binaries that are now compiled are available in the src directory. Run Redis with:\n\n    $ src/redis-server\n\nYou can interact with Redis using the built-in client:\n\n    $ src/redis-cli redis> set foo bar OK redis> get foo \"bar\"\n\n### 二、设置直接使用redis的启动，客户端命令\nmake编译redis后，执行命令\n\n       $ cd redis-3.2.0\n       $ sudo make install\n       \nsrc中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：\n\n    xiaocao@xiaocao-pc:~$ redis-cli\n     127.0.0.1:6379> get foo\n     \"123456\"\n     127.0.0.1:6379>\n启动服务：`xiaocao@xiaocao-pc:~$ redis-server`\n\n### 三、src目录下执行文件说明：\n\nredis-check-aof //AOF文件修复工具\nredis-cli //Redis命令行客户端，最常用\nredis-server //Redis服务器，最常用\nredis-benchmark //Redis性能测试工具\nredis-check-rdb //\nredis-sentinel     //Sentinel服务器，2.8版本后\n\n### 四、启动，停止redis服务\n\n1、直接启动：make install后\n执行命令：`$ redis-server`     //默认端口是6379\n自定义端口启动：\n执行命令：`$ redis-server --port 6380`\n2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）\n(1)配置初始化脚本。\n>a. `$ cd ~/java/redis-3.2.0/utils`\n将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，\n客户端连接的端口号。\n\n>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。\n\n（2）建立需要的文件夹：\n>/etc/redis      //存放Redis的配置文件\n/var/redis/端口号     //存放Redis的持久化文件\n\n(3)修改配置文件：\n\n    a、$ cd  ~/java/redis-3.2.0\n    b、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\n    c、修改参数( 6380.conf )：\n    参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n         pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n         port                  端口号                                    设置redis监听的端口号\n         dir                    /var/redis/端口号                设置持久化文件存放位置\n    d、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\n    e、执行下面命令使得redis随系统自动启动：\n    $ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n\n### 3、正确停止redis服务命令：\n$ redis-cli SHUTDOWN /默认的  或者\n$ redis-cli -p 6380 SHUTDOWN\n当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。\n\n### 4、关闭后再启动：\n\nservice redis_6380 -p 6380 start  #启动6380端口实例的redis\n\n$ cd /etc/init.d && ./redis_6380 start  #默认启动6379端口实例的redis","source":"_posts/redis-install.md","raw":"---\ntitle: redis安装\ndate: 2018-01-18 20:55:18\ncategories: redis\ntags: redis-install\n---\n\n本文介绍在linux系统下redis的安装使用……\n\n## redis在ubuntu系统下的安装\n\n### 一、下载，安装，测试\n\nDownload, extract and compile Redis with:\n\n    $ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n    $ tar xzf redis-3.2.0.tar.gz\n    $ cd redis-3.2.0\n    $ make\n\nThe binaries that are now compiled are available in the src directory. Run Redis with:\n\n    $ src/redis-server\n\nYou can interact with Redis using the built-in client:\n\n    $ src/redis-cli redis> set foo bar OK redis> get foo \"bar\"\n\n### 二、设置直接使用redis的启动，客户端命令\nmake编译redis后，执行命令\n\n       $ cd redis-3.2.0\n       $ sudo make install\n       \nsrc中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：\n\n    xiaocao@xiaocao-pc:~$ redis-cli\n     127.0.0.1:6379> get foo\n     \"123456\"\n     127.0.0.1:6379>\n启动服务：`xiaocao@xiaocao-pc:~$ redis-server`\n\n### 三、src目录下执行文件说明：\n\nredis-check-aof //AOF文件修复工具\nredis-cli //Redis命令行客户端，最常用\nredis-server //Redis服务器，最常用\nredis-benchmark //Redis性能测试工具\nredis-check-rdb //\nredis-sentinel     //Sentinel服务器，2.8版本后\n\n### 四、启动，停止redis服务\n\n1、直接启动：make install后\n执行命令：`$ redis-server`     //默认端口是6379\n自定义端口启动：\n执行命令：`$ redis-server --port 6380`\n2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）\n(1)配置初始化脚本。\n>a. `$ cd ~/java/redis-3.2.0/utils`\n将utils目录下的redis_init_script文件复制一份到/etc/init.d目录中。文件名改为redis_端口号。端口号是redis监听的端口号，\n客户端连接的端口号。\n\n>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。\n\n（2）建立需要的文件夹：\n>/etc/redis      //存放Redis的配置文件\n/var/redis/端口号     //存放Redis的持久化文件\n\n(3)修改配置文件：\n\n    a、$ cd  ~/java/redis-3.2.0\n    b、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\n    c、修改参数( 6380.conf )：\n    参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n         pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n         port                  端口号                                    设置redis监听的端口号\n         dir                    /var/redis/端口号                设置持久化文件存放位置\n    d、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\n    e、执行下面命令使得redis随系统自动启动：\n    $ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n\n### 3、正确停止redis服务命令：\n$ redis-cli SHUTDOWN /默认的  或者\n$ redis-cli -p 6380 SHUTDOWN\n当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。\n\n### 4、关闭后再启动：\n\nservice redis_6380 -p 6380 start  #启动6380端口实例的redis\n\n$ cd /etc/init.d && ./redis_6380 start  #默认启动6379端口实例的redis","slug":"redis-install","published":1,"updated":"2018-01-18T13:07:46.365Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iolm003rd5hskqlzs1s9","content":"<p>本文介绍在linux系统下redis的安装使用……</p>\n<h2 id=\"redis在ubuntu系统下的安装\"><a href=\"#redis在ubuntu系统下的安装\" class=\"headerlink\" title=\"redis在ubuntu系统下的安装\"></a>redis在ubuntu系统下的安装</h2><h3 id=\"一、下载，安装，测试\"><a href=\"#一、下载，安装，测试\" class=\"headerlink\" title=\"一、下载，安装，测试\"></a>一、下载，安装，测试</h3><p>Download, extract and compile Redis with:</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n$ tar xzf redis-3.2.0.tar.gz\n$ cd redis-3.2.0\n$ make\n</code></pre><p>The binaries that are now compiled are available in the src directory. Run Redis with:</p>\n<pre><code>$ src/redis-server\n</code></pre><p>You can interact with Redis using the built-in client:</p>\n<pre><code>$ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot;\n</code></pre><h3 id=\"二、设置直接使用redis的启动，客户端命令\"><a href=\"#二、设置直接使用redis的启动，客户端命令\" class=\"headerlink\" title=\"二、设置直接使用redis的启动，客户端命令\"></a>二、设置直接使用redis的启动，客户端命令</h3><p>make编译redis后，执行命令</p>\n<pre><code>$ cd redis-3.2.0\n$ sudo make install\n</code></pre><p>src中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：</p>\n<pre><code>xiaocao@xiaocao-pc:~$ redis-cli\n 127.0.0.1:6379&gt; get foo\n &quot;123456&quot;\n 127.0.0.1:6379&gt;\n</code></pre><p>启动服务：<code>xiaocao@xiaocao-pc:~$ redis-server</code></p>\n<h3 id=\"三、src目录下执行文件说明：\"><a href=\"#三、src目录下执行文件说明：\" class=\"headerlink\" title=\"三、src目录下执行文件说明：\"></a>三、src目录下执行文件说明：</h3><p>redis-check-aof //AOF文件修复工具<br>redis-cli //Redis命令行客户端，最常用<br>redis-server //Redis服务器，最常用<br>redis-benchmark //Redis性能测试工具<br>redis-check-rdb //<br>redis-sentinel     //Sentinel服务器，2.8版本后</p>\n<h3 id=\"四、启动，停止redis服务\"><a href=\"#四、启动，停止redis服务\" class=\"headerlink\" title=\"四、启动，停止redis服务\"></a>四、启动，停止redis服务</h3><p>1、直接启动：make install后<br>执行命令：<code>$ redis-server</code>     //默认端口是6379<br>自定义端口启动：<br>执行命令：<code>$ redis-server --port 6380</code><br>2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）<br>(1)配置初始化脚本。</p>\n<blockquote>\n<p>a. <code>$ cd ~/java/redis-3.2.0/utils</code><br>将utils目录下的redis_init<em>script文件复制一份到/etc/init.d目录中。文件名改为redis</em>端口号。端口号是redis监听的端口号，<br>客户端连接的端口号。</p>\n<p>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。</p>\n</blockquote>\n<p>（2）建立需要的文件夹：</p>\n<blockquote>\n<p>/etc/redis      //存放Redis的配置文件<br>/var/redis/端口号     //存放Redis的持久化文件</p>\n</blockquote>\n<p>(3)修改配置文件：</p>\n<pre><code>a、$ cd  ~/java/redis-3.2.0\nb、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\nc、修改参数( 6380.conf )：\n参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n     pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n     port                  端口号                                    设置redis监听的端口号\n     dir                    /var/redis/端口号                设置持久化文件存放位置\nd、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\ne、执行下面命令使得redis随系统自动启动：\n$ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n</code></pre><h3 id=\"3、正确停止redis服务命令：\"><a href=\"#3、正确停止redis服务命令：\" class=\"headerlink\" title=\"3、正确停止redis服务命令：\"></a>3、正确停止redis服务命令：</h3><p>$ redis-cli SHUTDOWN /默认的  或者<br>$ redis-cli -p 6380 SHUTDOWN<br>当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。</p>\n<h3 id=\"4、关闭后再启动：\"><a href=\"#4、关闭后再启动：\" class=\"headerlink\" title=\"4、关闭后再启动：\"></a>4、关闭后再启动：</h3><p>service redis_6380 -p 6380 start  #启动6380端口实例的redis</p>\n<p>$ cd /etc/init.d &amp;&amp; ./redis_6380 start  #默认启动6379端口实例的redis</p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文介绍在linux系统下redis的安装使用……</p>\n<h2 id=\"redis在ubuntu系统下的安装\"><a href=\"#redis在ubuntu系统下的安装\" class=\"headerlink\" title=\"redis在ubuntu系统下的安装\"></a>redis在ubuntu系统下的安装</h2><h3 id=\"一、下载，安装，测试\"><a href=\"#一、下载，安装，测试\" class=\"headerlink\" title=\"一、下载，安装，测试\"></a>一、下载，安装，测试</h3><p>Download, extract and compile Redis with:</p>\n<pre><code>$ wget http://download.redis.io/releases/redis-3.2.0.tar.gz\n$ tar xzf redis-3.2.0.tar.gz\n$ cd redis-3.2.0\n$ make\n</code></pre><p>The binaries that are now compiled are available in the src directory. Run Redis with:</p>\n<pre><code>$ src/redis-server\n</code></pre><p>You can interact with Redis using the built-in client:</p>\n<pre><code>$ src/redis-cli redis&gt; set foo bar OK redis&gt; get foo &quot;bar&quot;\n</code></pre><h3 id=\"二、设置直接使用redis的启动，客户端命令\"><a href=\"#二、设置直接使用redis的启动，客户端命令\" class=\"headerlink\" title=\"二、设置直接使用redis的启动，客户端命令\"></a>二、设置直接使用redis的启动，客户端命令</h3><p>make编译redis后，执行命令</p>\n<pre><code>$ cd redis-3.2.0\n$ sudo make install\n</code></pre><p>src中的目录会被复制到/usr/local/bin，这样直接就可以使用src下的一些执行命令。然后可以直接在命令行下执行这些redis命令：</p>\n<pre><code>xiaocao@xiaocao-pc:~$ redis-cli\n 127.0.0.1:6379&gt; get foo\n &quot;123456&quot;\n 127.0.0.1:6379&gt;\n</code></pre><p>启动服务：<code>xiaocao@xiaocao-pc:~$ redis-server</code></p>\n<h3 id=\"三、src目录下执行文件说明：\"><a href=\"#三、src目录下执行文件说明：\" class=\"headerlink\" title=\"三、src目录下执行文件说明：\"></a>三、src目录下执行文件说明：</h3><p>redis-check-aof //AOF文件修复工具<br>redis-cli //Redis命令行客户端，最常用<br>redis-server //Redis服务器，最常用<br>redis-benchmark //Redis性能测试工具<br>redis-check-rdb //<br>redis-sentinel     //Sentinel服务器，2.8版本后</p>\n<h3 id=\"四、启动，停止redis服务\"><a href=\"#四、启动，停止redis服务\" class=\"headerlink\" title=\"四、启动，停止redis服务\"></a>四、启动，停止redis服务</h3><p>1、直接启动：make install后<br>执行命令：<code>$ redis-server</code>     //默认端口是6379<br>自定义端口启动：<br>执行命令：<code>$ redis-server --port 6380</code><br>2、通过初始化脚本启动redis，使得redis能随系统自动运行（在生产环境服务器更推荐此方法）<br>(1)配置初始化脚本。</p>\n<blockquote>\n<p>a. <code>$ cd ~/java/redis-3.2.0/utils</code><br>将utils目录下的redis_init<em>script文件复制一份到/etc/init.d目录中。文件名改为redis</em>端口号。端口号是redis监听的端口号，<br>客户端连接的端口号。</p>\n<p>b.修改（redis_端口号） 脚本第6行的REDISPORT变量的值为同样的端口号。</p>\n</blockquote>\n<p>（2）建立需要的文件夹：</p>\n<blockquote>\n<p>/etc/redis      //存放Redis的配置文件<br>/var/redis/端口号     //存放Redis的持久化文件</p>\n</blockquote>\n<p>(3)修改配置文件：</p>\n<pre><code>a、$ cd  ~/java/redis-3.2.0\nb、将配置文件模板redis.conf复制一份到/etc/redis目录中，以端口号命名，如“6380.conf”。\nc、修改参数( 6380.conf )：\n参数：daemonize       值： yes            说明：使redis以守护进程模式运行\n     pidfile              /var/run/redis_端口号.pid         设置redis的PID的文件位置\n     port                  端口号                                    设置redis监听的端口号\n     dir                    /var/redis/端口号                设置持久化文件存放位置\nd、现在可以使用/etc/init.d/redis_端口号start来启动redis了。\ne、执行下面命令使得redis随系统自动启动：\n$ sudo update-rc.d redis_端口号 defaults    //配置随机启动命令  redis_6380为初始化脚本文件\n</code></pre><h3 id=\"3、正确停止redis服务命令：\"><a href=\"#3、正确停止redis服务命令：\" class=\"headerlink\" title=\"3、正确停止redis服务命令：\"></a>3、正确停止redis服务命令：</h3><p>$ redis-cli SHUTDOWN /默认的  或者<br>$ redis-cli -p 6380 SHUTDOWN<br>当redis收到SHUTDOWN命令后，先断开所有客户端连接，然后根据配置执行持久化，最后完成退出。</p>\n<h3 id=\"4、关闭后再启动：\"><a href=\"#4、关闭后再启动：\" class=\"headerlink\" title=\"4、关闭后再启动：\"></a>4、关闭后再启动：</h3><p>service redis_6380 -p 6380 start  #启动6380端口实例的redis</p>\n<p>$ cd /etc/init.d &amp;&amp; ./redis_6380 start  #默认启动6379端口实例的redis</p>\n"},{"title":"restful-api设计摘要","date":"2017-09-29T14:07:54.000Z","_content":"本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","source":"_posts/restful-api-dev.md","raw":"---\ntitle: restful-api设计摘要\ndate: 2017-09-29 22:07:54\ncategories: api-manage\ntags: restful-api\n---\n本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","slug":"restful-api-dev","published":1,"updated":"2017-12-31T09:13:45.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iolo003sd5hsu2rfi2z0","content":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"noopener\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"noopener\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"noopener\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"noopener\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"noopener\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"noopener\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"noopener\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"noopener\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n"},{"title":"spring-boot更改ContextPath方法","date":"2017-09-28T06:03:23.000Z","_content":"在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","source":"_posts/sboot-change-contextpath.md","raw":"---\ntitle: spring-boot更改ContextPath方法\ndate: 2017-09-28 14:03:23\ncategories: spring-boot\ntags: change-contextpath-way\n---\n在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","slug":"sboot-change-contextpath","published":1,"updated":"2017-12-31T09:13:45.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iolq003xd5hsetouiusx","content":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n"},{"title":"Spring cloud微服务：分布式配置中心-加密解密","date":"2018-04-21T14:22:30.000Z","_content":"\n在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。\n但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。\n\n\n## 安装JCE\n\n在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：\n\n    README.txt\n    local_policy.jar\n    US_export_policy.jar\n\n我们需要将local_policy.jar和US_export_policy.jar两个文件复制到`$JAVA_HOME/jre/lib/security`目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。\n\nJCE下载地址：[Java 8 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)\n\n## 查看相关端点\n\n安装后，重启config-server。可以通过浏览器查看一些相关信息：\n\n- /encrypt/status：查看加密功能状态的端点\n- /key：查看密钥的端点\n- /encrypt：对请求的body内容进行加密的端点\n- /decrypt：对请求的body内容进行解密的端点\n\n## 配置密钥\n\n### 对称加解密\n\n暂时不做介绍。推荐直接用下面非对称方式！\n\n### 非对称加解密\n\n使用非对称加解密具有更高安全性……\n\n- 使用JDK工具keytool生成密钥对。\n\n它的位置在： %JAVA_HOME%\\bin\\keytool.exe。\n\n使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：\n\n    keytool -genkeypair -alias config-server -keyalg RSA \\ \n      -dname \"CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china\" \\\n      -keypass 222222 \\\n      -keystore config-server.jks \\\n      -storepass 111111 \\\n      -validity 365 \\\n\n参考：\nhttp://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\n\n## 配置bootstrap.yml\n\n把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：\n\n    encrypt:\n      keyStore:\n        location: classpath:/config-server.jks\n        password: 11111\n        alias: config-server\n        secret: 222222\n\n*注*：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：\n\n    ENCRYPT_KEY_STORE_LOCATION\n    ENCRYPT_KEY_STORE_ALIAS\n    ENCRYPT_KEY_STORE_PASSWORD\n    ENCRYPT_KEY_STORE_SECRET\n    \n重新启动项目，浏览：http://192.168.1.104:3331/encrypt/status  \n\n    {\n        \"status\": \"OK\"\n    }\n    \n说明配置成功了。\n\n## 对配置加密\n\n先在命令窗口对具体配置明文进行加密,如：\n\n对明文zmt加密（认证用户名为admin、密码为123456）\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:ncrypt -d zmt\n    AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n    \n对密文解密：\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\n    zmt   \n    \n在配置文件中配置密文：\n\n通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。`{cipher}`代表是密文，需要解密。\n\n    api:\n      password: '{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io='\n\n调用显示：\n\n    @Value(\"${api.password}\")\n    private String apiPwd;\n\n    @Override\n    public VTestResp test3(@SensitiveFormat String name) {\n        VTestResp testResp = new VTestResp();\n        testResp.setName(name + \">>>>\" + apiPwd);\n        return testResp;\n    }\n    \n    结果：\n    {\n        \"name\": \"abc>>>>ymu123456\",\n        \"sex\": 0\n    }\n    \n## 对特殊字符加密问题\n\n参考：http://blog.didispace.com/spring-cloud-config-sp-char-encryp         ","source":"_posts/scloud-config-server-encrypt-decrypt.md","raw":"---\ntitle: Spring cloud微服务：分布式配置中心-加密解密\ndate: 2018-04-21 22:22:30\ncategories: spring-cloud\ntags: spring-cloud(配置中心加解密)\n---\n\n在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。\n但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。\n\n\n## 安装JCE\n\n在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：\n\n    README.txt\n    local_policy.jar\n    US_export_policy.jar\n\n我们需要将local_policy.jar和US_export_policy.jar两个文件复制到`$JAVA_HOME/jre/lib/security`目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。\n\nJCE下载地址：[Java 8 JCE](http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html)\n\n## 查看相关端点\n\n安装后，重启config-server。可以通过浏览器查看一些相关信息：\n\n- /encrypt/status：查看加密功能状态的端点\n- /key：查看密钥的端点\n- /encrypt：对请求的body内容进行加密的端点\n- /decrypt：对请求的body内容进行解密的端点\n\n## 配置密钥\n\n### 对称加解密\n\n暂时不做介绍。推荐直接用下面非对称方式！\n\n### 非对称加解密\n\n使用非对称加解密具有更高安全性……\n\n- 使用JDK工具keytool生成密钥对。\n\n它的位置在： %JAVA_HOME%\\bin\\keytool.exe。\n\n使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：\n\n    keytool -genkeypair -alias config-server -keyalg RSA \\ \n      -dname \"CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china\" \\\n      -keypass 222222 \\\n      -keystore config-server.jks \\\n      -storepass 111111 \\\n      -validity 365 \\\n\n参考：\nhttp://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\n\n## 配置bootstrap.yml\n\n把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：\n\n    encrypt:\n      keyStore:\n        location: classpath:/config-server.jks\n        password: 11111\n        alias: config-server\n        secret: 222222\n\n*注*：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：\n\n    ENCRYPT_KEY_STORE_LOCATION\n    ENCRYPT_KEY_STORE_ALIAS\n    ENCRYPT_KEY_STORE_PASSWORD\n    ENCRYPT_KEY_STORE_SECRET\n    \n重新启动项目，浏览：http://192.168.1.104:3331/encrypt/status  \n\n    {\n        \"status\": \"OK\"\n    }\n    \n说明配置成功了。\n\n## 对配置加密\n\n先在命令窗口对具体配置明文进行加密,如：\n\n对明文zmt加密（认证用户名为admin、密码为123456）\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:ncrypt -d zmt\n    AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n    \n对密文解密：\n\n    mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\n    zmt   \n    \n在配置文件中配置密文：\n\n通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。`{cipher}`代表是密文，需要解密。\n\n    api:\n      password: '{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io='\n\n调用显示：\n\n    @Value(\"${api.password}\")\n    private String apiPwd;\n\n    @Override\n    public VTestResp test3(@SensitiveFormat String name) {\n        VTestResp testResp = new VTestResp();\n        testResp.setName(name + \">>>>\" + apiPwd);\n        return testResp;\n    }\n    \n    结果：\n    {\n        \"name\": \"abc>>>>ymu123456\",\n        \"sex\": 0\n    }\n    \n## 对特殊字符加密问题\n\n参考：http://blog.didispace.com/spring-cloud-config-sp-char-encryp         ","slug":"scloud-config-server-encrypt-decrypt","published":1,"updated":"2018-05-05T01:46:37.113Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iolr003yd5hsk31v189v","content":"<p>在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。<br>但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。</p>\n<h2 id=\"安装JCE\"><a href=\"#安装JCE\" class=\"headerlink\" title=\"安装JCE\"></a>安装JCE</h2><p>在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：</p>\n<pre><code>README.txt\nlocal_policy.jar\nUS_export_policy.jar\n</code></pre><p>我们需要将local_policy.jar和US_export_policy.jar两个文件复制到<code>$JAVA_HOME/jre/lib/security</code>目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。</p>\n<p>JCE下载地址：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html\" target=\"_blank\" rel=\"noopener\">Java 8 JCE</a></p>\n<h2 id=\"查看相关端点\"><a href=\"#查看相关端点\" class=\"headerlink\" title=\"查看相关端点\"></a>查看相关端点</h2><p>安装后，重启config-server。可以通过浏览器查看一些相关信息：</p>\n<ul>\n<li>/encrypt/status：查看加密功能状态的端点</li>\n<li>/key：查看密钥的端点</li>\n<li>/encrypt：对请求的body内容进行加密的端点</li>\n<li>/decrypt：对请求的body内容进行解密的端点</li>\n</ul>\n<h2 id=\"配置密钥\"><a href=\"#配置密钥\" class=\"headerlink\" title=\"配置密钥\"></a>配置密钥</h2><h3 id=\"对称加解密\"><a href=\"#对称加解密\" class=\"headerlink\" title=\"对称加解密\"></a>对称加解密</h3><p>暂时不做介绍。推荐直接用下面非对称方式！</p>\n<h3 id=\"非对称加解密\"><a href=\"#非对称加解密\" class=\"headerlink\" title=\"非对称加解密\"></a>非对称加解密</h3><p>使用非对称加解密具有更高安全性……</p>\n<ul>\n<li>使用JDK工具keytool生成密钥对。</li>\n</ul>\n<p>它的位置在： %JAVA_HOME%\\bin\\keytool.exe。</p>\n<p>使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：</p>\n<pre><code>keytool -genkeypair -alias config-server -keyalg RSA \\ \n  -dname &quot;CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china&quot; \\\n  -keypass 222222 \\\n  -keystore config-server.jks \\\n  -storepass 111111 \\\n  -validity 365 \\\n</code></pre><p>参考：<br><a href=\"http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\" target=\"_blank\" rel=\"noopener\">http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing</a></p>\n<h2 id=\"配置bootstrap-yml\"><a href=\"#配置bootstrap-yml\" class=\"headerlink\" title=\"配置bootstrap.yml\"></a>配置bootstrap.yml</h2><p>把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：</p>\n<pre><code>encrypt:\n  keyStore:\n    location: classpath:/config-server.jks\n    password: 11111\n    alias: config-server\n    secret: 222222\n</code></pre><p><em>注</em>：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：</p>\n<pre><code>ENCRYPT_KEY_STORE_LOCATION\nENCRYPT_KEY_STORE_ALIAS\nENCRYPT_KEY_STORE_PASSWORD\nENCRYPT_KEY_STORE_SECRET\n</code></pre><p>重新启动项目，浏览：<a href=\"http://192.168.1.104:3331/encrypt/status\" target=\"_blank\" rel=\"noopener\">http://192.168.1.104:3331/encrypt/status</a>  </p>\n<pre><code>{\n    &quot;status&quot;: &quot;OK&quot;\n}\n</code></pre><p>说明配置成功了。</p>\n<h2 id=\"对配置加密\"><a href=\"#对配置加密\" class=\"headerlink\" title=\"对配置加密\"></a>对配置加密</h2><p>先在命令窗口对具体配置明文进行加密,如：</p>\n<p>对明文zmt加密（认证用户名为admin、密码为123456）</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:ncrypt -d zmt\nAQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n</code></pre><p>对密文解密：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\nzmt   \n</code></pre><p>在配置文件中配置密文：</p>\n<p>通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。<code>{cipher}</code>代表是密文，需要解密。</p>\n<pre><code>api:\n  password: &apos;{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io=&apos;\n</code></pre><p>调用显示：</p>\n<pre><code>@Value(&quot;${api.password}&quot;)\nprivate String apiPwd;\n\n@Override\npublic VTestResp test3(@SensitiveFormat String name) {\n    VTestResp testResp = new VTestResp();\n    testResp.setName(name + &quot;&gt;&gt;&gt;&gt;&quot; + apiPwd);\n    return testResp;\n}\n\n结果：\n{\n    &quot;name&quot;: &quot;abc&gt;&gt;&gt;&gt;ymu123456&quot;,\n    &quot;sex&quot;: 0\n}\n</code></pre><h2 id=\"对特殊字符加密问题\"><a href=\"#对特殊字符加密问题\" class=\"headerlink\" title=\"对特殊字符加密问题\"></a>对特殊字符加密问题</h2><p>参考：<a href=\"http://blog.didispace.com/spring-cloud-config-sp-char-encryp\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/spring-cloud-config-sp-char-encryp</a>         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring cloud微服务开发过程中，很多的配置文件需要暴露给相关开发人员来维护。<br>但是，配置文件里面可能涉及到一些敏感的配置信息如数据库，第三方账号等。因此，为了安全，就非常有必要对这些数据加密了。以保护这些信息安全。</p>\n<h2 id=\"安装JCE\"><a href=\"#安装JCE\" class=\"headerlink\" title=\"安装JCE\"></a>安装JCE</h2><p>在使用Spring Cloud Config的加密解密功能时，有一个必要的前提需要我们注意。为了启用该功能，我们需要在配置中心的运行环境中安装不限长度的JCE版本（Unlimited Strength Java Cryptography Extension）。虽然，JCE功能在JRE中自带，但是默认使用的是有长度限制的版本。我们可以从Oracle的官方网站中下载到它，它是一个压缩包，解压后可以看到下面三个文件：</p>\n<pre><code>README.txt\nlocal_policy.jar\nUS_export_policy.jar\n</code></pre><p>我们需要将local_policy.jar和US_export_policy.jar两个文件复制到<code>$JAVA_HOME/jre/lib/security</code>目录下，覆盖原来的默认内容。到这里，加密解密的准备工作就完成了。</p>\n<p>JCE下载地址：<a href=\"http://www.oracle.com/technetwork/java/javase/downloads/jce8-download-2133166.html\" target=\"_blank\" rel=\"noopener\">Java 8 JCE</a></p>\n<h2 id=\"查看相关端点\"><a href=\"#查看相关端点\" class=\"headerlink\" title=\"查看相关端点\"></a>查看相关端点</h2><p>安装后，重启config-server。可以通过浏览器查看一些相关信息：</p>\n<ul>\n<li>/encrypt/status：查看加密功能状态的端点</li>\n<li>/key：查看密钥的端点</li>\n<li>/encrypt：对请求的body内容进行加密的端点</li>\n<li>/decrypt：对请求的body内容进行解密的端点</li>\n</ul>\n<h2 id=\"配置密钥\"><a href=\"#配置密钥\" class=\"headerlink\" title=\"配置密钥\"></a>配置密钥</h2><h3 id=\"对称加解密\"><a href=\"#对称加解密\" class=\"headerlink\" title=\"对称加解密\"></a>对称加解密</h3><p>暂时不做介绍。推荐直接用下面非对称方式！</p>\n<h3 id=\"非对称加解密\"><a href=\"#非对称加解密\" class=\"headerlink\" title=\"非对称加解密\"></a>非对称加解密</h3><p>使用非对称加解密具有更高安全性……</p>\n<ul>\n<li>使用JDK工具keytool生成密钥对。</li>\n</ul>\n<p>它的位置在： %JAVA_HOME%\\bin\\keytool.exe。</p>\n<p>使用下面命令在当前文件夹下生成密钥对(默认有效期90天，这里设置成-validity 365天，一年)：</p>\n<pre><code>keytool -genkeypair -alias config-server -keyalg RSA \\ \n  -dname &quot;CN=zhangmutian, OU=company, O=organization, L=city, ST=province, C=china&quot; \\\n  -keypass 222222 \\\n  -keystore config-server.jks \\\n  -storepass 111111 \\\n  -validity 365 \\\n</code></pre><p>参考：<br><a href=\"http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing\" target=\"_blank\" rel=\"noopener\">http://cloud.spring.io/spring-cloud-static/Edgware.SR3/multi/multi__spring_cloud_config_server.html#_creating_a_key_store_for_testing</a></p>\n<h2 id=\"配置bootstrap-yml\"><a href=\"#配置bootstrap-yml\" class=\"headerlink\" title=\"配置bootstrap.yml\"></a>配置bootstrap.yml</h2><p>把生成的config-server.jks文件放在config-server项目的classpath中。并在bootstrap.yml中添加一下配置：</p>\n<pre><code>encrypt:\n  keyStore:\n    location: classpath:/config-server.jks\n    password: 11111\n    alias: config-server\n    secret: 222222\n</code></pre><p><em>注</em>：另外，以上配置信息也可以在环境变量中配置，它们对应的具体变量名如下：</p>\n<pre><code>ENCRYPT_KEY_STORE_LOCATION\nENCRYPT_KEY_STORE_ALIAS\nENCRYPT_KEY_STORE_PASSWORD\nENCRYPT_KEY_STORE_SECRET\n</code></pre><p>重新启动项目，浏览：<a href=\"http://192.168.1.104:3331/encrypt/status\" target=\"_blank\" rel=\"noopener\">http://192.168.1.104:3331/encrypt/status</a>  </p>\n<pre><code>{\n    &quot;status&quot;: &quot;OK&quot;\n}\n</code></pre><p>说明配置成功了。</p>\n<h2 id=\"对配置加密\"><a href=\"#对配置加密\" class=\"headerlink\" title=\"对配置加密\"></a>对配置加密</h2><p>先在命令窗口对具体配置明文进行加密,如：</p>\n<p>对明文zmt加密（认证用户名为admin、密码为123456）</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:ncrypt -d zmt\nAQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=  \n</code></pre><p>对密文解密：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ curl -u admin:123456 http://192.168.1.104:3331/decrypt -d AQB43S/okputI/v009zUuV/1XYmKSQROyYwWCWMC8phPeQa00/ABmS8QByz4ZWE57buwM1GIQ9lkmh8Yafgy6QUryq/XJk/oIck1zuN6M7IMepAFaJE4J8i4y5/LdH5h6gpfW06MeSiQbjg+393ztnDH37lWakfxEJ5yNtevXbV/LQC6u8bPvd/4riDHmgJYq8d7INJZKh4Y9TX+5a9a2YGivTuhn+qHruOylP43eMiK0EuUkmJF3B2zD6t8CWu5M84vnHjDVLFGmLuK3xfRpmG83ofl+86XjgdE+TlqcId+hRpfD28ELluU4Oc/N7ujNZAmKa2OtK0jve7oz27dQnrMDh5n6qkGAIcjNoeHLa7EgkP9XEargjGLkaXewHME56Q=\nzmt   \n</code></pre><p>在配置文件中配置密文：</p>\n<p>通过上面用curl命令请求把明文加密后，然后如下添加到配置文件中。<code>{cipher}</code>代表是密文，需要解密。</p>\n<pre><code>api:\n  password: &apos;{cipher}AQB0sf3nKuMq6wmRGs1CVDs3Oq+gdkfhX7F4M5txKI0CUpezKl02GI1mWmY4e6Ch/tI0UP9KRLv5VADrF8qESSPrZjD+uQR+op/N1hEZmKOMS/BpgipudiskeuifHPk2ffscN6pJns4VrfRwW3Io9yyOJ0/mAQxD46IcppraE2Z4gwplLvRU0U7pLB2mxpBqhi24ZKUW3MHRRD5rF4AMyXQw9SEyfyXYWpBGxSgMGfeV/TU4d4DVSYy8Y7Ji0Rf41m/59V24bjjYaJL2B77+WLyKlGHlV/hfrCOcz45NgqS00TGjNfieO1DlWHZi/YvYN4UUF0InRFI2gnGzWumEnJSYhHWqO3hdVr9mO+BI8DskngMGapYQrJVc7Pdpo27h3Io=&apos;\n</code></pre><p>调用显示：</p>\n<pre><code>@Value(&quot;${api.password}&quot;)\nprivate String apiPwd;\n\n@Override\npublic VTestResp test3(@SensitiveFormat String name) {\n    VTestResp testResp = new VTestResp();\n    testResp.setName(name + &quot;&gt;&gt;&gt;&gt;&quot; + apiPwd);\n    return testResp;\n}\n\n结果：\n{\n    &quot;name&quot;: &quot;abc&gt;&gt;&gt;&gt;ymu123456&quot;,\n    &quot;sex&quot;: 0\n}\n</code></pre><h2 id=\"对特殊字符加密问题\"><a href=\"#对特殊字符加密问题\" class=\"headerlink\" title=\"对特殊字符加密问题\"></a>对特殊字符加密问题</h2><p>参考：<a href=\"http://blog.didispace.com/spring-cloud-config-sp-char-encryp\" target=\"_blank\" rel=\"noopener\">http://blog.didispace.com/spring-cloud-config-sp-char-encryp</a>         </p>\n"},{"title":"spring-cloud-feign在使用中遇到的一些问题","date":"2017-09-24T13:53:46.000Z","_content":"\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","source":"_posts/scloud-feign-anyquestion.md","raw":"---\ntitle: spring-cloud-feign在使用中遇到的一些问题\ndate: 2017-09-24 21:53:46\ncategories: spring-cloud\ntags: feign使用常见问题\n---\n\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","slug":"scloud-feign-anyquestion","published":1,"updated":"2017-12-31T09:13:45.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iolu0042d5hse0ad8884","content":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n"},{"title":"spring cloud feign自定义","date":"2018-05-08T12:36:02.000Z","_content":"\n参考：https://www.jianshu.com/p/755b15ff0249","source":"_posts/scloud-feign-config.md","raw":"---\ntitle: spring cloud feign自定义\ndate: 2018-05-08 20:36:02\ncategories: spring-cloud\ntags: feign\n---\n\n参考：https://www.jianshu.com/p/755b15ff0249","slug":"scloud-feign-config","published":1,"updated":"2018-05-08T12:36:57.408Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iolx0045d5hsp9821ly0","content":"<p>参考：<a href=\"https://www.jianshu.com/p/755b15ff0249\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/755b15ff0249</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://www.jianshu.com/p/755b15ff0249\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/755b15ff0249</a></p>\n"},{"title":"spring cloud Hystrix监控","date":"2018-05-08T07:30:31.000Z","_content":"\n参考：https://www.jianshu.com/p/b7b20fc09ca9\n\nhttps://blog.csdn.net/liaokailin/article/details/51344281\n\n\n## 单个节点监控\n\n\n## 聚合监控","source":"_posts/scloud-hystrix-dashboard.md","raw":"---\ntitle: spring cloud Hystrix监控\ndate: 2018-05-08 15:30:31\ncategories: spring-cloud\ntags: hystrix,dashboard\n---\n\n参考：https://www.jianshu.com/p/b7b20fc09ca9\n\nhttps://blog.csdn.net/liaokailin/article/details/51344281\n\n\n## 单个节点监控\n\n\n## 聚合监控","slug":"scloud-hystrix-dashboard","published":1,"updated":"2018-05-08T13:37:24.902Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iolz0049d5hscg8mpnir","content":"<p>参考：<a href=\"https://www.jianshu.com/p/b7b20fc09ca9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b7b20fc09ca9</a></p>\n<p><a href=\"https://blog.csdn.net/liaokailin/article/details/51344281\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liaokailin/article/details/51344281</a></p>\n<h2 id=\"单个节点监控\"><a href=\"#单个节点监控\" class=\"headerlink\" title=\"单个节点监控\"></a>单个节点监控</h2><h2 id=\"聚合监控\"><a href=\"#聚合监控\" class=\"headerlink\" title=\"聚合监控\"></a>聚合监控</h2>","site":{"data":{}},"excerpt":"","more":"<p>参考：<a href=\"https://www.jianshu.com/p/b7b20fc09ca9\" target=\"_blank\" rel=\"noopener\">https://www.jianshu.com/p/b7b20fc09ca9</a></p>\n<p><a href=\"https://blog.csdn.net/liaokailin/article/details/51344281\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/liaokailin/article/details/51344281</a></p>\n<h2 id=\"单个节点监控\"><a href=\"#单个节点监控\" class=\"headerlink\" title=\"单个节点监控\"></a>单个节点监控</h2><h2 id=\"聚合监控\"><a href=\"#聚合监控\" class=\"headerlink\" title=\"聚合监控\"></a>聚合监控</h2>"},{"title":"spring cloud 熔断器,服务降级","date":"2018-05-08T03:21:35.000Z","_content":"\n## ","source":"_posts/scloud-hystrix.md","raw":"---\ntitle: spring cloud 熔断器,服务降级\ndate: 2018-05-08 11:21:35\ncategories: spring-cloud\ntags: hystrix\n---\n\n## ","slug":"scloud-hystrix","published":1,"updated":"2018-05-08T12:34:25.849Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iom1004bd5hsskyd58a7","content":"<p>## </p>\n","site":{"data":{}},"excerpt":"","more":"<p>## </p>\n"},{"title":"spring-cloud-zuul网关统一异常处理","date":"2017-09-23T09:48:05.000Z","_content":"","source":"_posts/scloud-zuul-exception.md","raw":"---\ntitle: spring-cloud-zuul网关统一异常处理\ndate: 2017-09-23 17:48:05\ncategories: spring-cloud\ntags: zuul-exception\n---\n","slug":"scloud-zuul-exception","published":1,"updated":"2017-12-31T09:13:45.250Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iom3004fd5hs9saphbde","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"scloud-zuul-filters网关过滤","date":"2017-10-11T08:56:22.000Z","_content":"在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","source":"_posts/scloud-zuul-filters.md","raw":"---\ntitle: scloud-zuul-filters网关过滤\ndate: 2017-10-11 16:56:22\ncategories: spring-cloud\ntags: zuul-filters\n---\n在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","slug":"scloud-zuul-filters","published":1,"updated":"2017-12-31T09:13:45.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iom4004hd5hs8ble8dpf","content":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n"},{"title":"spring-cloud-zuul网关入门","date":"2017-10-11T07:42:53.000Z","_content":"## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","source":"_posts/scloud-zuul-start.md","raw":"---\ntitle: spring-cloud-zuul网关入门\ndate: 2017-10-11 15:42:53\ncategories: spring-cloud\ntags: zuul-start\n---\n## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","slug":"scloud-zuul-start","published":1,"updated":"2017-12-31T09:13:45.254Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iom6004kd5hsulw7xu50","content":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>"},{"title":"shadowsocks-go代理服务器搭建","date":"2017-11-11T09:05:31.000Z","_content":"\n这是用来干嘛的，你懂的。\n\n网址：\n\n[shadowsocks](https://github.com/shadowsocks)\n\n[sadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)\n\n## 服务端\n\n编译好执行文件：{% asset_link server.tar.gz Shadowsocks-server %}  \n放到服务器，更改.json文件配置，解压直接执行.sh文件即可。\n\n1. 首先，买个国外的服务器再说吧……\n   \n2. 在服务器安装golang环境。\n    安装包：{% asset_link go1.9.2.linux-amd64.tar.gz go1.9.2 %}\n    \n    这里不做介绍……\n    \n3. 在服务器安装git环境。\n\n    这里不做介绍……\n    \n4. 下载服务端代码shadowsocks-go.\n\n        # on server\n        go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n    \n    golang环境会自动编译可执行代码到${GOPATH}/bin  \n      \n5.  执行启动\n\n- *创建配置文件*：\n`touch /server/shadowsocks/shadowsocks.json`\n- *编辑shadowsocks.json*：\n    \n        {\t \n            \"server\":\"30.12.6.2\",\n            \"server_port\":8388,\n            \"local_port\":1080,\n            \"password\":\"123456\",\n            \"method\": \"aes-256-cfb\",\n            \"timeout\":600\n        }\n\n> 说明：       \n`server`:服务器ip地址；\n`server_port`:服务器端口；\n`local_port:`客户端代理端口；\n`method`:加密方式； \n\n- *启动*:\n\n\n    shadowsocks-server -c /server/shadowsocks/shadowsocks.json > /server/shadowsocks/log &.   \n    \n> 说明：\n`-c` 指定配置文件。 \n`log`记录日志。\n`&.` 后台执行    \n\n- *查看是否启动*：\n\n        [root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\n        tcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n\n\n---\n\n## 客户端\n\n### linux系统\n编译好执行文件：{% asset_link client.tar.gz Shadowsocks-client %} \n在linux客户端解压，修改.json配置文件中相关参数，启动即可。\n\n### windows系统\n直接下载客户端。[网址](https://github.com/shadowsocks/shadowsocks-windows)\n安装包：{% asset_link Shadowsocks-4.0.6.zip Shadowsocks-win %}\n双击打开：\n{% asset_img a.png %}\n\n把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。\n\n### ubuntu系统    \n\n- go客户端：\n`go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local`\n由于被墙，客户端下载不了。\n所以要在服务端执行，然后再把可执行二进制文件下拉到本地。\n\n*配置客户端文件*\n创建文件：shadowsocks-local.json\n编辑：\n    \n    {\n    \t\"local_port\": 1081,\n    \t\"server_password\": [\n    \t\t[\"127.0.0.1:8387\", \"foobar\"],\n    \t\t[\"127.0.0.1:8388\", \"barfoo\", \"aes-128-cfb\"]\n    \t]\n    }\n\n可以配置多个服务器，单个服务器，则去掉一个。\n\n启动：类似服务端，用`-c`指定配置文件。    \n\n- qt5客户端：\n\n1. 二进制包安装。[安装网址](https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)  \n\n2. 推荐，命令安装：\n    \n        #Ubuntu 14.04及更高版本\n        #添加ppa源\n        sudo add-apt-repository ppa:hzwhuang/ss-qt5\n        sudo apt-get update\n        sudo apt-get install shadowsocks-qt5\n         \n        #启动shadowsocks-qt5\n        \n        可以通过which shadowsocks-qt5找到可执行文件的位置。\n        \n        执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n\n### 移动\n\n- 安卓客户端：\n\n下载：{%asset_link Shadowsocks_v4.2.5_apkpure.com.apk Shadowsocks_v4.2.5_apkpure.com.apk%}\n\n- 苹果客户端：\n\n安装app：FirstWingy\n\n### 修改浏览器代理\n> SOCKS5 127.0.0.1:local_port\n\n如果可以，在chrome中可以安装代理设置插件       \n{% asset_img b.png %}\n\n然后启动，试下访问：[google](https://www.google.com)\n\n\n\n\n","source":"_posts/shadowsocks-go.md","raw":"---\ntitle: shadowsocks-go代理服务器搭建\ndate: 2017-11-11 17:05:31\ncategories: shadowsocks\ntags: shadowsocks-go\n---\n\n这是用来干嘛的，你懂的。\n\n网址：\n\n[shadowsocks](https://github.com/shadowsocks)\n\n[sadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)\n\n## 服务端\n\n编译好执行文件：{% asset_link server.tar.gz Shadowsocks-server %}  \n放到服务器，更改.json文件配置，解压直接执行.sh文件即可。\n\n1. 首先，买个国外的服务器再说吧……\n   \n2. 在服务器安装golang环境。\n    安装包：{% asset_link go1.9.2.linux-amd64.tar.gz go1.9.2 %}\n    \n    这里不做介绍……\n    \n3. 在服务器安装git环境。\n\n    这里不做介绍……\n    \n4. 下载服务端代码shadowsocks-go.\n\n        # on server\n        go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n    \n    golang环境会自动编译可执行代码到${GOPATH}/bin  \n      \n5.  执行启动\n\n- *创建配置文件*：\n`touch /server/shadowsocks/shadowsocks.json`\n- *编辑shadowsocks.json*：\n    \n        {\t \n            \"server\":\"30.12.6.2\",\n            \"server_port\":8388,\n            \"local_port\":1080,\n            \"password\":\"123456\",\n            \"method\": \"aes-256-cfb\",\n            \"timeout\":600\n        }\n\n> 说明：       \n`server`:服务器ip地址；\n`server_port`:服务器端口；\n`local_port:`客户端代理端口；\n`method`:加密方式； \n\n- *启动*:\n\n\n    shadowsocks-server -c /server/shadowsocks/shadowsocks.json > /server/shadowsocks/log &.   \n    \n> 说明：\n`-c` 指定配置文件。 \n`log`记录日志。\n`&.` 后台执行    \n\n- *查看是否启动*：\n\n        [root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\n        tcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n\n\n---\n\n## 客户端\n\n### linux系统\n编译好执行文件：{% asset_link client.tar.gz Shadowsocks-client %} \n在linux客户端解压，修改.json配置文件中相关参数，启动即可。\n\n### windows系统\n直接下载客户端。[网址](https://github.com/shadowsocks/shadowsocks-windows)\n安装包：{% asset_link Shadowsocks-4.0.6.zip Shadowsocks-win %}\n双击打开：\n{% asset_img a.png %}\n\n把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。\n\n### ubuntu系统    \n\n- go客户端：\n`go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local`\n由于被墙，客户端下载不了。\n所以要在服务端执行，然后再把可执行二进制文件下拉到本地。\n\n*配置客户端文件*\n创建文件：shadowsocks-local.json\n编辑：\n    \n    {\n    \t\"local_port\": 1081,\n    \t\"server_password\": [\n    \t\t[\"127.0.0.1:8387\", \"foobar\"],\n    \t\t[\"127.0.0.1:8388\", \"barfoo\", \"aes-128-cfb\"]\n    \t]\n    }\n\n可以配置多个服务器，单个服务器，则去掉一个。\n\n启动：类似服务端，用`-c`指定配置文件。    \n\n- qt5客户端：\n\n1. 二进制包安装。[安装网址](https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)  \n\n2. 推荐，命令安装：\n    \n        #Ubuntu 14.04及更高版本\n        #添加ppa源\n        sudo add-apt-repository ppa:hzwhuang/ss-qt5\n        sudo apt-get update\n        sudo apt-get install shadowsocks-qt5\n         \n        #启动shadowsocks-qt5\n        \n        可以通过which shadowsocks-qt5找到可执行文件的位置。\n        \n        执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n\n### 移动\n\n- 安卓客户端：\n\n下载：{%asset_link Shadowsocks_v4.2.5_apkpure.com.apk Shadowsocks_v4.2.5_apkpure.com.apk%}\n\n- 苹果客户端：\n\n安装app：FirstWingy\n\n### 修改浏览器代理\n> SOCKS5 127.0.0.1:local_port\n\n如果可以，在chrome中可以安装代理设置插件       \n{% asset_img b.png %}\n\n然后启动，试下访问：[google](https://www.google.com)\n\n\n\n\n","slug":"shadowsocks-go","published":1,"updated":"2018-04-21T09:16:30.402Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iom8004nd5hsp177448e","content":"<p>这是用来干嘛的，你懂的。</p>\n<p>网址：</p>\n<p><a href=\"https://github.com/shadowsocks\" target=\"_blank\" rel=\"noopener\">shadowsocks</a></p>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">sadowsocks-go</a></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/server.tar.gz\" title=\"Shadowsocks-server\">Shadowsocks-server</a><br>放到服务器，更改.json文件配置，解压直接执行.sh文件即可。</p>\n<ol>\n<li><p>首先，买个国外的服务器再说吧……</p>\n</li>\n<li><p>在服务器安装golang环境。<br> 安装包：<a href=\"/2017/11/11/shadowsocks-go/go1.9.2.linux-amd64.tar.gz\" title=\"go1.9.2\">go1.9.2</a></p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>在服务器安装git环境。</p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>下载服务端代码shadowsocks-go.</p>\n<pre><code># on server\ngo get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n</code></pre><p> golang环境会自动编译可执行代码到${GOPATH}/bin  </p>\n</li>\n<li><p>执行启动</p>\n</li>\n</ol>\n<ul>\n<li><em>创建配置文件</em>：<br><code>touch /server/shadowsocks/shadowsocks.json</code></li>\n<li><p><em>编辑shadowsocks.json</em>：</p>\n<pre><code>{     \n    &quot;server&quot;:&quot;30.12.6.2&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;method&quot;: &quot;aes-256-cfb&quot;,\n    &quot;timeout&quot;:600\n}\n</code></pre></li>\n</ul>\n<blockquote>\n<p>说明：<br><code>server</code>:服务器ip地址；<br><code>server_port</code>:服务器端口；<br><code>local_port:</code>客户端代理端口；<br><code>method</code>:加密方式； </p>\n</blockquote>\n<ul>\n<li><em>启动</em>:</li>\n</ul>\n<pre><code>shadowsocks-server -c /server/shadowsocks/shadowsocks.json &gt; /server/shadowsocks/log &amp;.   \n</code></pre><blockquote>\n<p>说明：<br><code>-c</code> 指定配置文件。<br><code>log</code>记录日志。<br><code>&amp;.</code> 后台执行    </p>\n</blockquote>\n<ul>\n<li><p><em>查看是否启动</em>：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\ntcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h3><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/client.tar.gz\" title=\"Shadowsocks-client\">Shadowsocks-client</a><br>在linux客户端解压，修改.json配置文件中相关参数，启动即可。</p>\n<h3 id=\"windows系统\"><a href=\"#windows系统\" class=\"headerlink\" title=\"windows系统\"></a>windows系统</h3><p>直接下载客户端。<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">网址</a><br>安装包：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks-4.0.6.zip\" title=\"Shadowsocks-win\">Shadowsocks-win</a><br>双击打开：<br><img src=\"/2017/11/11/shadowsocks-go/a.png\"></p>\n<p>把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。</p>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><ul>\n<li>go客户端：<br><code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</code><br>由于被墙，客户端下载不了。<br>所以要在服务端执行，然后再把可执行二进制文件下拉到本地。</li>\n</ul>\n<p><em>配置客户端文件</em><br>创建文件：shadowsocks-local.json<br>编辑：</p>\n<pre><code>{\n    &quot;local_port&quot;: 1081,\n    &quot;server_password&quot;: [\n        [&quot;127.0.0.1:8387&quot;, &quot;foobar&quot;],\n        [&quot;127.0.0.1:8388&quot;, &quot;barfoo&quot;, &quot;aes-128-cfb&quot;]\n    ]\n}\n</code></pre><p>可以配置多个服务器，单个服务器，则去掉一个。</p>\n<p>启动：类似服务端，用<code>-c</code>指定配置文件。    </p>\n<ul>\n<li>qt5客户端：</li>\n</ul>\n<ol>\n<li><p>二进制包安装。<a href=\"https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"noopener\">安装网址</a>  </p>\n</li>\n<li><p>推荐，命令安装：</p>\n<pre><code>#Ubuntu 14.04及更高版本\n#添加ppa源\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n\n#启动shadowsocks-qt5\n\n可以通过which shadowsocks-qt5找到可执行文件的位置。\n\n执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n</code></pre></li>\n</ol>\n<h3 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h3><ul>\n<li>安卓客户端：</li>\n</ul>\n<p>下载：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk\" title=\"Shadowsocks_v4.2.5_apkpure.com.apk\">Shadowsocks_v4.2.5_apkpure.com.apk</a></p>\n<ul>\n<li>苹果客户端：</li>\n</ul>\n<p>安装app：FirstWingy</p>\n<h3 id=\"修改浏览器代理\"><a href=\"#修改浏览器代理\" class=\"headerlink\" title=\"修改浏览器代理\"></a>修改浏览器代理</h3><blockquote>\n<p>SOCKS5 127.0.0.1:local_port</p>\n</blockquote>\n<p>如果可以，在chrome中可以安装代理设置插件<br><img src=\"/2017/11/11/shadowsocks-go/b.png\"></p>\n<p>然后启动，试下访问：<a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">google</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是用来干嘛的，你懂的。</p>\n<p>网址：</p>\n<p><a href=\"https://github.com/shadowsocks\" target=\"_blank\" rel=\"noopener\">shadowsocks</a></p>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"noopener\">sadowsocks-go</a></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/server.tar.gz\" title=\"Shadowsocks-server\">Shadowsocks-server</a><br>放到服务器，更改.json文件配置，解压直接执行.sh文件即可。</p>\n<ol>\n<li><p>首先，买个国外的服务器再说吧……</p>\n</li>\n<li><p>在服务器安装golang环境。<br> 安装包：<a href=\"/2017/11/11/shadowsocks-go/go1.9.2.linux-amd64.tar.gz\" title=\"go1.9.2\">go1.9.2</a></p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>在服务器安装git环境。</p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>下载服务端代码shadowsocks-go.</p>\n<pre><code># on server\ngo get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n</code></pre><p> golang环境会自动编译可执行代码到${GOPATH}/bin  </p>\n</li>\n<li><p>执行启动</p>\n</li>\n</ol>\n<ul>\n<li><em>创建配置文件</em>：<br><code>touch /server/shadowsocks/shadowsocks.json</code></li>\n<li><p><em>编辑shadowsocks.json</em>：</p>\n<pre><code>{     \n    &quot;server&quot;:&quot;30.12.6.2&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;method&quot;: &quot;aes-256-cfb&quot;,\n    &quot;timeout&quot;:600\n}\n</code></pre></li>\n</ul>\n<blockquote>\n<p>说明：<br><code>server</code>:服务器ip地址；<br><code>server_port</code>:服务器端口；<br><code>local_port:</code>客户端代理端口；<br><code>method</code>:加密方式； </p>\n</blockquote>\n<ul>\n<li><em>启动</em>:</li>\n</ul>\n<pre><code>shadowsocks-server -c /server/shadowsocks/shadowsocks.json &gt; /server/shadowsocks/log &amp;.   \n</code></pre><blockquote>\n<p>说明：<br><code>-c</code> 指定配置文件。<br><code>log</code>记录日志。<br><code>&amp;.</code> 后台执行    </p>\n</blockquote>\n<ul>\n<li><p><em>查看是否启动</em>：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\ntcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"linux系统\"><a href=\"#linux系统\" class=\"headerlink\" title=\"linux系统\"></a>linux系统</h3><p>编译好执行文件：<a href=\"/2017/11/11/shadowsocks-go/client.tar.gz\" title=\"Shadowsocks-client\">Shadowsocks-client</a><br>在linux客户端解压，修改.json配置文件中相关参数，启动即可。</p>\n<h3 id=\"windows系统\"><a href=\"#windows系统\" class=\"headerlink\" title=\"windows系统\"></a>windows系统</h3><p>直接下载客户端。<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"noopener\">网址</a><br>安装包：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks-4.0.6.zip\" title=\"Shadowsocks-win\">Shadowsocks-win</a><br>双击打开：<br><img src=\"/2017/11/11/shadowsocks-go/a.png\"></p>\n<p>把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。</p>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><ul>\n<li>go客户端：<br><code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</code><br>由于被墙，客户端下载不了。<br>所以要在服务端执行，然后再把可执行二进制文件下拉到本地。</li>\n</ul>\n<p><em>配置客户端文件</em><br>创建文件：shadowsocks-local.json<br>编辑：</p>\n<pre><code>{\n    &quot;local_port&quot;: 1081,\n    &quot;server_password&quot;: [\n        [&quot;127.0.0.1:8387&quot;, &quot;foobar&quot;],\n        [&quot;127.0.0.1:8388&quot;, &quot;barfoo&quot;, &quot;aes-128-cfb&quot;]\n    ]\n}\n</code></pre><p>可以配置多个服务器，单个服务器，则去掉一个。</p>\n<p>启动：类似服务端，用<code>-c</code>指定配置文件。    </p>\n<ul>\n<li>qt5客户端：</li>\n</ul>\n<ol>\n<li><p>二进制包安装。<a href=\"https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"noopener\">安装网址</a>  </p>\n</li>\n<li><p>推荐，命令安装：</p>\n<pre><code>#Ubuntu 14.04及更高版本\n#添加ppa源\nsudo add-apt-repository ppa:hzwhuang/ss-qt5\nsudo apt-get update\nsudo apt-get install shadowsocks-qt5\n\n#启动shadowsocks-qt5\n\n可以通过which shadowsocks-qt5找到可执行文件的位置。\n\n执行 ./shadowsocks-qt5(桌面板，可以通过搜索已安装的shadowsocks-qt5，点击图标启动) \n</code></pre></li>\n</ol>\n<h3 id=\"移动\"><a href=\"#移动\" class=\"headerlink\" title=\"移动\"></a>移动</h3><ul>\n<li>安卓客户端：</li>\n</ul>\n<p>下载：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk\" title=\"Shadowsocks_v4.2.5_apkpure.com.apk\">Shadowsocks_v4.2.5_apkpure.com.apk</a></p>\n<ul>\n<li>苹果客户端：</li>\n</ul>\n<p>安装app：FirstWingy</p>\n<h3 id=\"修改浏览器代理\"><a href=\"#修改浏览器代理\" class=\"headerlink\" title=\"修改浏览器代理\"></a>修改浏览器代理</h3><blockquote>\n<p>SOCKS5 127.0.0.1:local_port</p>\n</blockquote>\n<p>如果可以，在chrome中可以安装代理设置插件<br><img src=\"/2017/11/11/shadowsocks-go/b.png\"></p>\n<p>然后启动，试下访问：<a href=\"https://www.google.com\" target=\"_blank\" rel=\"noopener\">google</a></p>\n"},{"title":"springboot跨域请求解决","date":"2017-11-15T01:43:12.000Z","_content":"先推荐三篇文章\n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[同源策略和跨域访问](http://blog.csdn.net/shimiso/article/details/21830313)\n[详解js跨域问题](https://segmentfault.com/a/1190000000718840)\n[springboot前后端分离跨域](https://my.oschina.net/u/3677020/blog/1573162)\n\n## 什么是跨域\n\n要想了解跨域，就先要知道什么是同源策略。\n\n同源策略，它是由Netscape提出的一个著名的安全策略。\n\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\n\n域：协议+地址(域名或IP)+端口\n\n## 为什么要有同源策略\n\n可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。\n\n## 为什么要有跨域\n\n最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。\n\n## 如何解决跨域\n\n*JSONP*\n\n只能实现GET请求，但是被一些老浏览器支持。\n\n*代理*\n\n在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。\n\n*CORS*\n\n2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。\n\n出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 http://example.com 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 http://hello-world.example，就需要使用该标准。http://hello-world.example 在HTTP的响应头部中定义 Access-Control-Allow-Origin: http://example.org，通知浏览器允许 http://example.org 跨源从 http://hello-world.example上获取资源。\n\n## springboot跨域\n\n### 设置全局跨域\n- 方法一：\n    \n        @Configuration\n        public class WebConfig extends WebMvcConfigurationSupport {\n            /**\n             * 全局跨域设置\n             *\n             * @param registry\n             */\n            @Override\n            protected void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\");\n        //                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n        //                .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        \n        }\n\n### 局部跨域\n","source":"_posts/spring-boot-cors.md","raw":"---\ntitle: springboot跨域请求解决\ndate: 2017-11-15 09:43:12\ncategories: spring-boot\ntags: spring-cors\n---\n先推荐三篇文章\n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[同源策略和跨域访问](http://blog.csdn.net/shimiso/article/details/21830313)\n[详解js跨域问题](https://segmentfault.com/a/1190000000718840)\n[springboot前后端分离跨域](https://my.oschina.net/u/3677020/blog/1573162)\n\n## 什么是跨域\n\n要想了解跨域，就先要知道什么是同源策略。\n\n同源策略，它是由Netscape提出的一个著名的安全策略。\n\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\n\n域：协议+地址(域名或IP)+端口\n\n## 为什么要有同源策略\n\n可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。\n\n## 为什么要有跨域\n\n最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。\n\n## 如何解决跨域\n\n*JSONP*\n\n只能实现GET请求，但是被一些老浏览器支持。\n\n*代理*\n\n在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。\n\n*CORS*\n\n2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。\n\n出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 http://example.com 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 http://hello-world.example，就需要使用该标准。http://hello-world.example 在HTTP的响应头部中定义 Access-Control-Allow-Origin: http://example.org，通知浏览器允许 http://example.org 跨源从 http://hello-world.example上获取资源。\n\n## springboot跨域\n\n### 设置全局跨域\n- 方法一：\n    \n        @Configuration\n        public class WebConfig extends WebMvcConfigurationSupport {\n            /**\n             * 全局跨域设置\n             *\n             * @param registry\n             */\n            @Override\n            protected void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\");\n        //                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n        //                .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        \n        }\n\n### 局部跨域\n","slug":"spring-boot-cors","published":1,"updated":"2017-12-31T09:13:45.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioma004pd5hs18fh0vzy","content":"<p>先推荐三篇文章<br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a><br><a href=\"http://blog.csdn.net/shimiso/article/details/21830313\" target=\"_blank\" rel=\"noopener\">同源策略和跨域访问</a><br><a href=\"https://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"noopener\">详解js跨域问题</a><br><a href=\"https://my.oschina.net/u/3677020/blog/1573162\" target=\"_blank\" rel=\"noopener\">springboot前后端分离跨域</a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>要想了解跨域，就先要知道什么是同源策略。</p>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略。</p>\n<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>\n<p>域：协议+地址(域名或IP)+端口</p>\n<h2 id=\"为什么要有同源策略\"><a href=\"#为什么要有同源策略\" class=\"headerlink\" title=\"为什么要有同源策略\"></a>为什么要有同源策略</h2><p>可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。</p>\n<h2 id=\"为什么要有跨域\"><a href=\"#为什么要有跨域\" class=\"headerlink\" title=\"为什么要有跨域\"></a>为什么要有跨域</h2><p>最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。</p>\n<h2 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h2><p><em>JSONP</em></p>\n<p>只能实现GET请求，但是被一些老浏览器支持。</p>\n<p><em>代理</em></p>\n<p>在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。</p>\n<p><em>CORS</em></p>\n<p>2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。</p>\n<p>出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 <a href=\"http://hello-world.example，就需要使用该标准。http://hello-world.example\" target=\"_blank\" rel=\"noopener\">http://hello-world.example，就需要使用该标准。http://hello-world.example</a> 在HTTP的响应头部中定义 Access-Control-Allow-Origin: <a href=\"http://example.org，通知浏览器允许\" target=\"_blank\" rel=\"noopener\">http://example.org，通知浏览器允许</a> <a href=\"http://example.org\" target=\"_blank\" rel=\"noopener\">http://example.org</a> 跨源从 <a href=\"http://hello-world.example上获取资源。\" target=\"_blank\" rel=\"noopener\">http://hello-world.example上获取资源。</a></p>\n<h2 id=\"springboot跨域\"><a href=\"#springboot跨域\" class=\"headerlink\" title=\"springboot跨域\"></a>springboot跨域</h2><h3 id=\"设置全局跨域\"><a href=\"#设置全局跨域\" class=\"headerlink\" title=\"设置全局跨域\"></a>设置全局跨域</h3><ul>\n<li><p>方法一：</p>\n<pre><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n    /**\n     * 全局跨域设置\n     *\n     * @param registry\n     */\n    @Override\n    protected void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;)\n                //放行哪些原始域\n                .allowedOrigins(&quot;*&quot;)\n                //是否发送Cookie信息\n                .allowCredentials(true)\n                //放行哪些原始域(请求方式)\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)\n                //放行哪些原始域(头部信息)\n                .allowedHeaders(&quot;*&quot;);\n//                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n//                .exposedHeaders(&quot;Header1&quot;, &quot;Header2&quot;);\n    }\n\n}\n</code></pre></li>\n</ul>\n<h3 id=\"局部跨域\"><a href=\"#局部跨域\" class=\"headerlink\" title=\"局部跨域\"></a>局部跨域</h3>","site":{"data":{}},"excerpt":"","more":"<p>先推荐三篇文章<br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"noopener\">跨域资源共享 CORS 详解</a><br><a href=\"http://blog.csdn.net/shimiso/article/details/21830313\" target=\"_blank\" rel=\"noopener\">同源策略和跨域访问</a><br><a href=\"https://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"noopener\">详解js跨域问题</a><br><a href=\"https://my.oschina.net/u/3677020/blog/1573162\" target=\"_blank\" rel=\"noopener\">springboot前后端分离跨域</a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>要想了解跨域，就先要知道什么是同源策略。</p>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略。</p>\n<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>\n<p>域：协议+地址(域名或IP)+端口</p>\n<h2 id=\"为什么要有同源策略\"><a href=\"#为什么要有同源策略\" class=\"headerlink\" title=\"为什么要有同源策略\"></a>为什么要有同源策略</h2><p>可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。</p>\n<h2 id=\"为什么要有跨域\"><a href=\"#为什么要有跨域\" class=\"headerlink\" title=\"为什么要有跨域\"></a>为什么要有跨域</h2><p>最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。</p>\n<h2 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h2><p><em>JSONP</em></p>\n<p>只能实现GET请求，但是被一些老浏览器支持。</p>\n<p><em>代理</em></p>\n<p>在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。</p>\n<p><em>CORS</em></p>\n<p>2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。</p>\n<p>出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"noopener\">http://example.com</a> 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 <a href=\"http://hello-world.example，就需要使用该标准。http://hello-world.example\" target=\"_blank\" rel=\"noopener\">http://hello-world.example，就需要使用该标准。http://hello-world.example</a> 在HTTP的响应头部中定义 Access-Control-Allow-Origin: <a href=\"http://example.org，通知浏览器允许\" target=\"_blank\" rel=\"noopener\">http://example.org，通知浏览器允许</a> <a href=\"http://example.org\" target=\"_blank\" rel=\"noopener\">http://example.org</a> 跨源从 <a href=\"http://hello-world.example上获取资源。\" target=\"_blank\" rel=\"noopener\">http://hello-world.example上获取资源。</a></p>\n<h2 id=\"springboot跨域\"><a href=\"#springboot跨域\" class=\"headerlink\" title=\"springboot跨域\"></a>springboot跨域</h2><h3 id=\"设置全局跨域\"><a href=\"#设置全局跨域\" class=\"headerlink\" title=\"设置全局跨域\"></a>设置全局跨域</h3><ul>\n<li><p>方法一：</p>\n<pre><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n    /**\n     * 全局跨域设置\n     *\n     * @param registry\n     */\n    @Override\n    protected void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;)\n                //放行哪些原始域\n                .allowedOrigins(&quot;*&quot;)\n                //是否发送Cookie信息\n                .allowCredentials(true)\n                //放行哪些原始域(请求方式)\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)\n                //放行哪些原始域(头部信息)\n                .allowedHeaders(&quot;*&quot;);\n//                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n//                .exposedHeaders(&quot;Header1&quot;, &quot;Header2&quot;);\n    }\n\n}\n</code></pre></li>\n</ul>\n<h3 id=\"局部跨域\"><a href=\"#局部跨域\" class=\"headerlink\" title=\"局部跨域\"></a>局部跨域</h3>"},{"title":"spring-boot开发常见异常收录","date":"2017-09-28T16:31:25.000Z","_content":"\n## jpa篇\n\n### 1 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n#### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n#### 1.2 不传递依赖\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n#### 1.3 在@SpringBootApplication中排除其注入\n\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n### 2 自动创建表指定Mysql搜索引擎类型\n\n解决方法，只需要在配置文件添加如下代码:\n    \n    # 指定生成表名的存储引擎为InneoDB\n    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n\n## 启动类配置\n\n1.让一个类型不被ComponentScan扫描\n\n    @ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n            value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\n    public class ServiceFileclientApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ServiceFileclientApplication.class, args);\n        }\n    }\n    \n    ----\n    \n    package com.ymu.servicefileclient.config;\n    \n    public @interface ExcludeComponent {\n    }\n    \n    -------\n    /**\n     * 该类为Feign的配置类\n     * 注意：该类不应该在主应用程序上下文的@CompantScan中\n     */\n    @ExcludeComponent\n    @Configuration\n    public class FeignConfiguration {\n    \n        /**\n         * 用feign.Contract.Default替换SpringMvcContract契约\n         *\n         * @return\n         */\n        @Bean\n        public Contract feignContract() {\n            return new feign.Contract.Default();\n        }\n    \n    }\n","source":"_posts/spring-boot-dev-error-show.md","raw":"---\ntitle: spring-boot开发常见异常收录\ndate: 2017-09-29 00:31:25\ncategories: spring-boot\ntags: spring-boot使用经验\n---\n\n## jpa篇\n\n### 1 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n#### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n#### 1.2 不传递依赖\n\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n#### 1.3 在@SpringBootApplication中排除其注入\n\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n### 2 自动创建表指定Mysql搜索引擎类型\n\n解决方法，只需要在配置文件添加如下代码:\n    \n    # 指定生成表名的存储引擎为InneoDB\n    spring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n\n## 启动类配置\n\n1.让一个类型不被ComponentScan扫描\n\n    @ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n            value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\n    public class ServiceFileclientApplication {\n    \n        public static void main(String[] args) {\n            SpringApplication.run(ServiceFileclientApplication.class, args);\n        }\n    }\n    \n    ----\n    \n    package com.ymu.servicefileclient.config;\n    \n    public @interface ExcludeComponent {\n    }\n    \n    -------\n    /**\n     * 该类为Feign的配置类\n     * 注意：该类不应该在主应用程序上下文的@CompantScan中\n     */\n    @ExcludeComponent\n    @Configuration\n    public class FeignConfiguration {\n    \n        /**\n         * 用feign.Contract.Default替换SpringMvcContract契约\n         *\n         * @return\n         */\n        @Bean\n        public Contract feignContract() {\n            return new feign.Contract.Default();\n        }\n    \n    }\n","slug":"spring-boot-dev-error-show","published":1,"updated":"2018-05-07T07:42:16.571Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iomb004sd5hsmmn6dyl7","content":"<h2 id=\"jpa篇\"><a href=\"#jpa篇\" class=\"headerlink\" title=\"jpa篇\"></a>jpa篇</h2><h3 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1 异常一：缺少jpa数据源配置\"></a>1 异常一：缺少jpa数据源配置</h3><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h4 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h4><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2 不传递依赖\"></a>1.2 不传递依赖</h4><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h4 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h4><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre><h3 id=\"2-自动创建表指定Mysql搜索引擎类型\"><a href=\"#2-自动创建表指定Mysql搜索引擎类型\" class=\"headerlink\" title=\"2 自动创建表指定Mysql搜索引擎类型\"></a>2 自动创建表指定Mysql搜索引擎类型</h3><p>解决方法，只需要在配置文件添加如下代码:</p>\n<pre><code># 指定生成表名的存储引擎为InneoDB\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n</code></pre><h2 id=\"启动类配置\"><a href=\"#启动类配置\" class=\"headerlink\" title=\"启动类配置\"></a>启动类配置</h2><p>1.让一个类型不被ComponentScan扫描</p>\n<pre><code>@ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n        value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\npublic class ServiceFileclientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceFileclientApplication.class, args);\n    }\n}\n\n----\n\npackage com.ymu.servicefileclient.config;\n\npublic @interface ExcludeComponent {\n}\n\n-------\n/**\n * 该类为Feign的配置类\n * 注意：该类不应该在主应用程序上下文的@CompantScan中\n */\n@ExcludeComponent\n@Configuration\npublic class FeignConfiguration {\n\n    /**\n     * 用feign.Contract.Default替换SpringMvcContract契约\n     *\n     * @return\n     */\n    @Bean\n    public Contract feignContract() {\n        return new feign.Contract.Default();\n    }\n\n}\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"jpa篇\"><a href=\"#jpa篇\" class=\"headerlink\" title=\"jpa篇\"></a>jpa篇</h2><h3 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1 异常一：缺少jpa数据源配置\"></a>1 异常一：缺少jpa数据源配置</h3><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h4 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h4><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h4 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2 不传递依赖\"></a>1.2 不传递依赖</h4><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h4 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h4><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre><h3 id=\"2-自动创建表指定Mysql搜索引擎类型\"><a href=\"#2-自动创建表指定Mysql搜索引擎类型\" class=\"headerlink\" title=\"2 自动创建表指定Mysql搜索引擎类型\"></a>2 自动创建表指定Mysql搜索引擎类型</h3><p>解决方法，只需要在配置文件添加如下代码:</p>\n<pre><code># 指定生成表名的存储引擎为InneoDB\nspring.jpa.properties.hibernate.dialect=org.hibernate.dialect.MySQL5InnoDBDialect\n</code></pre><h2 id=\"启动类配置\"><a href=\"#启动类配置\" class=\"headerlink\" title=\"启动类配置\"></a>启动类配置</h2><p>1.让一个类型不被ComponentScan扫描</p>\n<pre><code>@ComponentScan(excludeFilters = @ComponentScan.Filter(type = FilterType.ANNOTATION,\n        value = {ExcludeComponent.class})) //添加了@ExcludeComponent注解的类将不会被ComponentScan扫描\npublic class ServiceFileclientApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(ServiceFileclientApplication.class, args);\n    }\n}\n\n----\n\npackage com.ymu.servicefileclient.config;\n\npublic @interface ExcludeComponent {\n}\n\n-------\n/**\n * 该类为Feign的配置类\n * 注意：该类不应该在主应用程序上下文的@CompantScan中\n */\n@ExcludeComponent\n@Configuration\npublic class FeignConfiguration {\n\n    /**\n     * 用feign.Contract.Default替换SpringMvcContract契约\n     *\n     * @return\n     */\n    @Bean\n    public Contract feignContract() {\n        return new feign.Contract.Default();\n    }\n\n}\n</code></pre>"},{"title":"Spring-Cache使用","date":"2018-03-23T09:29:57.000Z","_content":"","source":"_posts/spring-boot-cache.md","raw":"---\ntitle: Spring-Cache使用\ndate: 2018-03-23 17:29:57\ncategories: spring-boot\ntags: spring cache\n---\n","slug":"spring-boot-cache","published":1,"updated":"2018-03-23T09:30:50.363Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iomc004ud5hswe9ehqi1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"spring-boot异步调用","date":"2017-11-10T08:22:18.000Z","_content":"\n在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。\n在spring-boot中，通过简单的注解 `@Async` 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：\n\n参考：\n- http://blog.csdn.net/blueheart20/article/details/44648667\n- http://blog.csdn.net/liuchuanhong1/article/details/64132520\n\n## 1. 启用异步操作功能\n很简单，只需要在主类中添加注解`@EnableAsync` 即可。\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.scheduling.annotation.EnableAsync;\n    \n    @EnableAsync\n    @SpringBootApplication\n    public class SpringBootAsyncApplication {\n    \n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(SpringBootAsyncApplication.class, args);\n    \t}\n    }\n\n## 2. 定义处理类，并添加方法\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.scheduling.annotation.Async;\n    import org.springframework.scheduling.annotation.AsyncResult;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Random;\n    import java.util.concurrent.Future;\n    \n    @Component\n    public class Task {\n    \n        public static Random random =new Random();\n    \n        @Async\n        public void webTest() throws Exception {\n            System.out.println(\"开始测试异步\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成测试异步，耗时：\" + (end - start) + \"毫秒\");\n        }\n    \n        @Async\n        public Future<String> doTaskOne() throws Exception {\n            System.out.println(\"开始做任务一\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务一，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务一完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskTwo() throws Exception {\n            System.out.println(\"开始做任务二\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务二，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务二完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskThree() throws Exception {\n            System.out.println(\"开始做任务三\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务三，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务三完成\");\n        }\n    }\n\n只需要在方法上添加注解`@Async`。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。\n\n## 3. 测试\n\n    package com.ymu.demo.async;\n    \n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import java.util.concurrent.Future;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class SpringBootAsyncApplicationTests {\n    \n        @Autowired\n        private Task task;\n    \n        @Test\n        public void contextLoads() {\n    \n            System.out.println(\"===============load context\");\n        }\n    \n        @Test\n        public void test() throws Exception {\n    \n            long start = System.currentTimeMillis();\n    \n            Future<String> task1 = task.doTaskOne();\n            Future<String> task2 = task.doTaskTwo();\n            Future<String> task3 = task.doTaskThree();\n    \n            while(true) {\n                if(task1.isDone() && task2.isDone() && task3.isDone()) {\n                    // 三个任务都调用完成，退出循环等待\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n    \n            long end = System.currentTimeMillis();\n    \n            System.out.println(\"任务全部完成，总耗时：\" + (end - start) + \"毫秒\");\n    \n        }\n    \n    }\n\n---\n    package com.ymu.demo.async;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    public class IndexController {\n    \n        @Autowired\n        Task task;\n    \n        @GetMapping(\"/index\")\n        public String index() throws Exception {\n            task.webTest();\n            return \"index\";\n        }\n    }\n    \n## 4. 基于@Async调用中的异常处理机制\n   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：\n   \n1. 自定义实现AsyncTaskExecutor的任务执行器。\n2. 配置由自定义的TaskExecutor替代内置的任务执行器。      \n\n自定义的TaskExecutor\n\n    \n","source":"_posts/spring-boot-async.md","raw":"---\ntitle: spring-boot异步调用\ndate: 2017-11-10 16:22:18\ncategories: spring-boot\ntags: spring-boot-async\n---\n\n在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。\n在spring-boot中，通过简单的注解 `@Async` 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：\n\n参考：\n- http://blog.csdn.net/blueheart20/article/details/44648667\n- http://blog.csdn.net/liuchuanhong1/article/details/64132520\n\n## 1. 启用异步操作功能\n很简单，只需要在主类中添加注解`@EnableAsync` 即可。\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.scheduling.annotation.EnableAsync;\n    \n    @EnableAsync\n    @SpringBootApplication\n    public class SpringBootAsyncApplication {\n    \n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(SpringBootAsyncApplication.class, args);\n    \t}\n    }\n\n## 2. 定义处理类，并添加方法\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.scheduling.annotation.Async;\n    import org.springframework.scheduling.annotation.AsyncResult;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Random;\n    import java.util.concurrent.Future;\n    \n    @Component\n    public class Task {\n    \n        public static Random random =new Random();\n    \n        @Async\n        public void webTest() throws Exception {\n            System.out.println(\"开始测试异步\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成测试异步，耗时：\" + (end - start) + \"毫秒\");\n        }\n    \n        @Async\n        public Future<String> doTaskOne() throws Exception {\n            System.out.println(\"开始做任务一\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务一，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务一完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskTwo() throws Exception {\n            System.out.println(\"开始做任务二\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务二，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务二完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskThree() throws Exception {\n            System.out.println(\"开始做任务三\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务三，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务三完成\");\n        }\n    }\n\n只需要在方法上添加注解`@Async`。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。\n\n## 3. 测试\n\n    package com.ymu.demo.async;\n    \n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import java.util.concurrent.Future;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class SpringBootAsyncApplicationTests {\n    \n        @Autowired\n        private Task task;\n    \n        @Test\n        public void contextLoads() {\n    \n            System.out.println(\"===============load context\");\n        }\n    \n        @Test\n        public void test() throws Exception {\n    \n            long start = System.currentTimeMillis();\n    \n            Future<String> task1 = task.doTaskOne();\n            Future<String> task2 = task.doTaskTwo();\n            Future<String> task3 = task.doTaskThree();\n    \n            while(true) {\n                if(task1.isDone() && task2.isDone() && task3.isDone()) {\n                    // 三个任务都调用完成，退出循环等待\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n    \n            long end = System.currentTimeMillis();\n    \n            System.out.println(\"任务全部完成，总耗时：\" + (end - start) + \"毫秒\");\n    \n        }\n    \n    }\n\n---\n    package com.ymu.demo.async;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    public class IndexController {\n    \n        @Autowired\n        Task task;\n    \n        @GetMapping(\"/index\")\n        public String index() throws Exception {\n            task.webTest();\n            return \"index\";\n        }\n    }\n    \n## 4. 基于@Async调用中的异常处理机制\n   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：\n   \n1. 自定义实现AsyncTaskExecutor的任务执行器。\n2. 配置由自定义的TaskExecutor替代内置的任务执行器。      \n\n自定义的TaskExecutor\n\n    \n","slug":"spring-boot-async","published":1,"updated":"2017-12-31T09:13:45.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iomf004yd5hshpcfjaid","content":"<p>在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。<br>在spring-boot中，通过简单的注解 <code>@Async</code> 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/blueheart20/article/details/44648667\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/blueheart20/article/details/44648667</a></li>\n<li><a href=\"http://blog.csdn.net/liuchuanhong1/article/details/64132520\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/liuchuanhong1/article/details/64132520</a></li>\n</ul>\n<h2 id=\"1-启用异步操作功能\"><a href=\"#1-启用异步操作功能\" class=\"headerlink\" title=\"1. 启用异步操作功能\"></a>1. 启用异步操作功能</h2><p>很简单，只需要在主类中添加注解<code>@EnableAsync</code> 即可。</p>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootAsyncApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAsyncApplication.class, args);\n    }\n}\n</code></pre><h2 id=\"2-定义处理类，并添加方法\"><a href=\"#2-定义处理类，并添加方法\" class=\"headerlink\" title=\"2. 定义处理类，并添加方法\"></a>2. 定义处理类，并添加方法</h2><pre><code>package com.ymu.demo.async;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.AsyncResult;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Random;\nimport java.util.concurrent.Future;\n\n@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    @Async\n    public void webTest() throws Exception {\n        System.out.println(&quot;开始测试异步&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成测试异步，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskOne() throws Exception {\n        System.out.println(&quot;开始做任务一&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskTwo() throws Exception {\n        System.out.println(&quot;开始做任务二&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务二完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskThree() throws Exception {\n        System.out.println(&quot;开始做任务三&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务三完成&quot;);\n    }\n}\n</code></pre><p>只需要在方法上添加注解<code>@Async</code>。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。</p>\n<h2 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h2><pre><code>package com.ymu.demo.async;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.concurrent.Future;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootAsyncApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void contextLoads() {\n\n        System.out.println(&quot;===============load context&quot;);\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        Future&lt;String&gt; task1 = task.doTaskOne();\n        Future&lt;String&gt; task2 = task.doTaskTwo();\n        Future&lt;String&gt; task3 = task.doTaskThree();\n\n        while(true) {\n            if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {\n                // 三个任务都调用完成，退出循环等待\n                break;\n            }\n            Thread.sleep(1000);\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n\n    }\n\n}\n</code></pre><hr>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class IndexController {\n\n    @Autowired\n    Task task;\n\n    @GetMapping(&quot;/index&quot;)\n    public String index() throws Exception {\n        task.webTest();\n        return &quot;index&quot;;\n    }\n}\n</code></pre><h2 id=\"4-基于-Async调用中的异常处理机制\"><a href=\"#4-基于-Async调用中的异常处理机制\" class=\"headerlink\" title=\"4. 基于@Async调用中的异常处理机制\"></a>4. 基于@Async调用中的异常处理机制</h2><p>   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：</p>\n<ol>\n<li>自定义实现AsyncTaskExecutor的任务执行器。</li>\n<li>配置由自定义的TaskExecutor替代内置的任务执行器。      </li>\n</ol>\n<p>自定义的TaskExecutor</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。<br>在spring-boot中，通过简单的注解 <code>@Async</code> 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/blueheart20/article/details/44648667\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/blueheart20/article/details/44648667</a></li>\n<li><a href=\"http://blog.csdn.net/liuchuanhong1/article/details/64132520\" target=\"_blank\" rel=\"noopener\">http://blog.csdn.net/liuchuanhong1/article/details/64132520</a></li>\n</ul>\n<h2 id=\"1-启用异步操作功能\"><a href=\"#1-启用异步操作功能\" class=\"headerlink\" title=\"1. 启用异步操作功能\"></a>1. 启用异步操作功能</h2><p>很简单，只需要在主类中添加注解<code>@EnableAsync</code> 即可。</p>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootAsyncApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAsyncApplication.class, args);\n    }\n}\n</code></pre><h2 id=\"2-定义处理类，并添加方法\"><a href=\"#2-定义处理类，并添加方法\" class=\"headerlink\" title=\"2. 定义处理类，并添加方法\"></a>2. 定义处理类，并添加方法</h2><pre><code>package com.ymu.demo.async;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.AsyncResult;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Random;\nimport java.util.concurrent.Future;\n\n@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    @Async\n    public void webTest() throws Exception {\n        System.out.println(&quot;开始测试异步&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成测试异步，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskOne() throws Exception {\n        System.out.println(&quot;开始做任务一&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskTwo() throws Exception {\n        System.out.println(&quot;开始做任务二&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务二完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskThree() throws Exception {\n        System.out.println(&quot;开始做任务三&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务三完成&quot;);\n    }\n}\n</code></pre><p>只需要在方法上添加注解<code>@Async</code>。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。</p>\n<h2 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h2><pre><code>package com.ymu.demo.async;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.concurrent.Future;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootAsyncApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void contextLoads() {\n\n        System.out.println(&quot;===============load context&quot;);\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        Future&lt;String&gt; task1 = task.doTaskOne();\n        Future&lt;String&gt; task2 = task.doTaskTwo();\n        Future&lt;String&gt; task3 = task.doTaskThree();\n\n        while(true) {\n            if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {\n                // 三个任务都调用完成，退出循环等待\n                break;\n            }\n            Thread.sleep(1000);\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n\n    }\n\n}\n</code></pre><hr>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class IndexController {\n\n    @Autowired\n    Task task;\n\n    @GetMapping(&quot;/index&quot;)\n    public String index() throws Exception {\n        task.webTest();\n        return &quot;index&quot;;\n    }\n}\n</code></pre><h2 id=\"4-基于-Async调用中的异常处理机制\"><a href=\"#4-基于-Async调用中的异常处理机制\" class=\"headerlink\" title=\"4. 基于@Async调用中的异常处理机制\"></a>4. 基于@Async调用中的异常处理机制</h2><p>   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：</p>\n<ol>\n<li>自定义实现AsyncTaskExecutor的任务执行器。</li>\n<li>配置由自定义的TaskExecutor替代内置的任务执行器。      </li>\n</ol>\n<p>自定义的TaskExecutor</p>\n"},{"title":"spring-data-jpa动态数据源读写分离","date":"2017-11-08T15:02:49.000Z","_content":"\n在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。\n\n## 1. 配置数据源\n\n采用阿里druid数据源配置连接池。\n\n具体配置如下：\n\n    package service.basic.user.config.ds;\n    \n    import com.alibaba.druid.filter.Filter;\n    import com.alibaba.druid.filter.logging.Log4j2Filter;\n    import com.alibaba.druid.filter.stat.StatFilter;\n    import com.alibaba.druid.pool.DruidDataSource;\n    import com.alibaba.druid.wall.WallConfig;\n    import com.alibaba.druid.wall.WallFilter;\n    import com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.context.annotation.*;\n    import org.springframework.core.env.Environment;\n    \n    import javax.sql.DataSource;\n    import java.sql.SQLException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    \n    \n    /**\n     * 配置数据源\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        /**\n         * druid监控filter配置。\n         * @return\n         */\n        @Bean\n        public StatFilter statFilter() {\n            StatFilter statFilter = new StatFilter();\n            statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n            statFilter.setLogSlowSql(true); //日志记录慢sql\n            statFilter.setMergeSql(true); //相同sql合并\n            return statFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 start ---------//\n    \n        @Bean\n        public WallConfig wallConfig() {\n            WallConfig wallConfig = new WallConfig();\n            wallConfig.setDir(\"classpath:druid/wall/mysql\"); //sql过滤规则装载位置。\n            return wallConfig;\n        }\n    \n        @Bean\n        public WallFilter wallFilter() {\n            WallFilter wallFilter = new WallFilter();\n            wallFilter.setDbType(\"mysql\"); //指定数据库类型。\n            wallFilter.setConfig(wallConfig());\n            return wallFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 end ---------//\n    \n    \n        /**\n         * 打印sql语句。\n         * @return\n         */\n        @Bean(name = \"log4j2Filter\")\n        public Log4j2Filter log4j2Filter() {\n            Log4j2Filter log4j2Filter = new Log4j2Filter();\n            log4j2Filter.setConnectionLogEnabled(false);\n            log4j2Filter.setResultSetLogEnabled(true); //显示sql\n            log4j2Filter.setDataSourceLogEnabled(false);\n            log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n            log4j2Filter.setStatementLogEnabled(false);\n            return log4j2Filter;\n        }\n    \n    \n    \n        //-------------- 数据源配置 start ---------------//\n    \n        /**\n         * 会员主库（spcs_user）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceWrite\")\n        @Qualifier(\"spcsUserDataSourceWrite\")\n        public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n        /**\n         * 会员从库（spcs_user_slave）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceRead_0\")\n        @Qualifier(\"spcsUserDataSourceRead_0\")\n        public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"spcsUserDataSourceWrite\",\"spcsUserDataSourceRead_0\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"spcsUserDataSourceWrite\") DataSource spcsUserDataSource,\n                                              @Qualifier(\"spcsUserDataSourceRead_0\") DataSource spcsUserSlaveDataSource) {\n            // 配置多数据源\n            Map<Object, Object> dsMap = new HashMap<>(5);\n            dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n            dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n    \n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            // 默认数据源\n            dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n            dynamicDataSource.setTargetDataSources(dsMap);\n            return dynamicDataSource;\n        }\n    \n    }\n\n> *注意*：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。\n\n## 2. 实现自己的数据源路由（关键）\n\n相当于多数据源的路由功能。\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n    \n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            log.debug(\"数据源为{}\", DataSourceContextHolder.getDS());\n            //可以做一个简单的负载均衡策略\n            return DataSourceContextHolder.getDS();\n        }\n    \n    }\n    \n## 3. 持有数据源\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    public class DataSourceContextHolder {\n    \n        private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n    \n        private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n    \n        /**\n         * 设置数据源名。\n         * @param dbType\n         */\n        public static void setDS(String dbType) {\n            if (dbType == null) {\n                throw new NullPointerException(\"数据源不能null\");\n            }\n            LOGGER.debug(\"切换到{}数据源\", dbType);\n            contextHolder.set(dbType);\n        }\n    \n        /**\n         * 获取数据源名。\n         * @return\n         */\n        public static String getDS() {\n            return (contextHolder.get());\n        }\n    \n        /**\n         * 清除数据源名。\n         */\n        public static void clearDS() {\n            contextHolder.remove();\n        }\n    }\n    \n## 4. 通过aop，注解方式持有数据源\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.ds.DSInject;\n    import com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.annotation.After;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.aspectj.lang.annotation.Before;\n    import org.aspectj.lang.reflect.MethodSignature;\n    import org.springframework.stereotype.Component;\n    \n    import java.lang.reflect.Method;\n    \n    /**\n     *  解析注入的数据源。\n     */\n    @Aspect\n    @Component\n    public class DynamicDataSourceAspect {\n    \n    \t@Before(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void beforeSwitchDS(JoinPoint point) {\n    \n    \t\t// 获得当前访问的class\n    \t\tClass<?> className = point.getTarget().getClass();\n    \n    \t\t// 获得访问的方法名\n    \t\tString methodName = point.getSignature().getName();\n    \t\t// 得到方法的参数的类型\n    \t\tClass[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n    \t\tString dataSource = DSType.SPCS_USER.name(); //默认主库\n    \t\ttry {\n    \t\t\t// 得到访问的方法对象\n    \t\t\tMethod method = className.getMethod(methodName, argClass);\n    \n    \t\t\t// 判断是否存在@DBInject注解\n    \t\t\tif (method.isAnnotationPresent(DSInject.class)) {\n    \t\t\t\tDSInject annotation = method.getAnnotation(DSInject.class);\n    \t\t\t\t// 取出注解中的数据源名\n    \t\t\t\tdataSource = annotation.value();\n    \t\t\t}\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t}\n    \n    \t\t// 切换数据源\n    \t\tDataSourceContextHolder.setDS(dataSource);\n    \n    \t}\n    \n    \t@After(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void afterSwitchDS(JoinPoint point) {\n    \t\tDataSourceContextHolder.clearDS();\n    \t}\n    }\n\n---\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Target({ ElementType.PARAMETER, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface DSInject {\n    \tString value() default \"\";\n    }\n\n## 5. 配置jpa\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\n    import net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\n    import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.core.env.Environment;\n    import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n    import org.springframework.orm.jpa.JpaTransactionManager;\n    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n    import org.springframework.transaction.PlatformTransactionManager;\n    import org.springframework.transaction.annotation.EnableTransactionManagement;\n    import service.basic.user.common.Constants;\n    \n    import javax.persistence.EntityManager;\n    import javax.sql.DataSource;\n    import java.util.Map;\n    \n    @Configuration\n    @EnableTransactionManagement\n    @EnableJpaRepositories(entityManagerFactoryRef = \"entityManagerFactorySpcsUserDB\", transactionManagerRef = \"transactionManagerSpcsUserDB\", basePackages = {\n            Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\n    public class SpcsUserDBConfig {\n    \n        @Autowired\n        Environment ev;\n    \n        @Autowired\n        @Qualifier(\"dataSource\")\n        private DataSource dataSource; // 数据源\n    \n        @Primary\n        @Bean(name = \"entityManagerSpcsUser\")\n        public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n            return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n        }\n    \n        @Primary\n        @Bean(name = \"entityManagerFactorySpcsUserDB\")\n        public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n            if (ev.acceptsProfiles(\"dev\") || ev.acceptsProfiles(\"test\")\n                    || ev.acceptsProfiles(\"update\")) {\n                dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n            }\n            return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                    .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                    .persistenceUnit(\"spcsUserUnit\").build(); //实体管理器别名,多数据元要设置。\n        }\n    \n        private Map<String, String> getVendorProperties(DataSource dataSource) {\n            JpaProperties jpaProperties = new JpaProperties();\n            return jpaProperties.getHibernateProperties(dataSource);\n        }\n    \n        /**\n         * 开启事务。\n         *\n         * @param builder\n         * @return\n         */\n        @Primary\n        @Bean(name = \"transactionManagerSpcsUserDB\")\n        public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n            return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n        }\n    \n    }\n    \n> *注意*: 注入的数据源为上面配置的动态数据源。\n@Autowired\n@Qualifier(\"dataSource\")\nprivate DataSource dataSource; // 数据源    \n\n\n## 6. 配置spring jdbcTemplate\n\n    package service.basic.user.config.ds;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import javax.sql.DataSource;\n    \n    @Configuration\n    @AutoConfigureAfter(DataSourceConfig.class)\n    public class JdbcTemplateConfig {\n    \n        @Autowired\n        @Qualifier(value = \"dataSource\")\n        private DataSource dataSource;\n    \n        /**\n         * spring jdbc。\n         *\n         * @return\n         */\n        @Bean(name = \"jdbcTemplate\")\n        @Qualifier(\"jdbcTemplate\")\n        public JdbcTemplate jdbcTemplate() {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n\n## 7. 使用\n\n- 方式一：\n可在service层，也可在dao层做。\n在开始操作数据库前调用：\n\n\n    DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n    \n    //查询数据\n    \n    DataSourceContextHolder.clearDS();\n    \n- 方式二：\n通过注解，可在service层，也可在dao层做。\n\n\n    @DSInject(value = Constants.SPCS_USER_SLAVE)\n    @Override\n    public User getUserByMobile(String mobile) {\n        return userDao.findUserByMobile(mobile);\n    }    ","source":"_posts/spring-jpa-multiple-datasource.md","raw":"---\ntitle: spring-data-jpa动态数据源读写分离\ndate: 2017-11-08 23:02:49\ncategories: spring-boot\ntags: jpa读写分离配置\n---\n\n在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。\n\n## 1. 配置数据源\n\n采用阿里druid数据源配置连接池。\n\n具体配置如下：\n\n    package service.basic.user.config.ds;\n    \n    import com.alibaba.druid.filter.Filter;\n    import com.alibaba.druid.filter.logging.Log4j2Filter;\n    import com.alibaba.druid.filter.stat.StatFilter;\n    import com.alibaba.druid.pool.DruidDataSource;\n    import com.alibaba.druid.wall.WallConfig;\n    import com.alibaba.druid.wall.WallFilter;\n    import com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.context.annotation.*;\n    import org.springframework.core.env.Environment;\n    \n    import javax.sql.DataSource;\n    import java.sql.SQLException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    \n    \n    /**\n     * 配置数据源\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        /**\n         * druid监控filter配置。\n         * @return\n         */\n        @Bean\n        public StatFilter statFilter() {\n            StatFilter statFilter = new StatFilter();\n            statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n            statFilter.setLogSlowSql(true); //日志记录慢sql\n            statFilter.setMergeSql(true); //相同sql合并\n            return statFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 start ---------//\n    \n        @Bean\n        public WallConfig wallConfig() {\n            WallConfig wallConfig = new WallConfig();\n            wallConfig.setDir(\"classpath:druid/wall/mysql\"); //sql过滤规则装载位置。\n            return wallConfig;\n        }\n    \n        @Bean\n        public WallFilter wallFilter() {\n            WallFilter wallFilter = new WallFilter();\n            wallFilter.setDbType(\"mysql\"); //指定数据库类型。\n            wallFilter.setConfig(wallConfig());\n            return wallFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 end ---------//\n    \n    \n        /**\n         * 打印sql语句。\n         * @return\n         */\n        @Bean(name = \"log4j2Filter\")\n        public Log4j2Filter log4j2Filter() {\n            Log4j2Filter log4j2Filter = new Log4j2Filter();\n            log4j2Filter.setConnectionLogEnabled(false);\n            log4j2Filter.setResultSetLogEnabled(true); //显示sql\n            log4j2Filter.setDataSourceLogEnabled(false);\n            log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n            log4j2Filter.setStatementLogEnabled(false);\n            return log4j2Filter;\n        }\n    \n    \n    \n        //-------------- 数据源配置 start ---------------//\n    \n        /**\n         * 会员主库（spcs_user）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceWrite\")\n        @Qualifier(\"spcsUserDataSourceWrite\")\n        public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n        /**\n         * 会员从库（spcs_user_slave）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceRead_0\")\n        @Qualifier(\"spcsUserDataSourceRead_0\")\n        public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"spcsUserDataSourceWrite\",\"spcsUserDataSourceRead_0\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"spcsUserDataSourceWrite\") DataSource spcsUserDataSource,\n                                              @Qualifier(\"spcsUserDataSourceRead_0\") DataSource spcsUserSlaveDataSource) {\n            // 配置多数据源\n            Map<Object, Object> dsMap = new HashMap<>(5);\n            dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n            dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n    \n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            // 默认数据源\n            dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n            dynamicDataSource.setTargetDataSources(dsMap);\n            return dynamicDataSource;\n        }\n    \n    }\n\n> *注意*：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。\n\n## 2. 实现自己的数据源路由（关键）\n\n相当于多数据源的路由功能。\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n    \n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            log.debug(\"数据源为{}\", DataSourceContextHolder.getDS());\n            //可以做一个简单的负载均衡策略\n            return DataSourceContextHolder.getDS();\n        }\n    \n    }\n    \n## 3. 持有数据源\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    public class DataSourceContextHolder {\n    \n        private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n    \n        private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n    \n        /**\n         * 设置数据源名。\n         * @param dbType\n         */\n        public static void setDS(String dbType) {\n            if (dbType == null) {\n                throw new NullPointerException(\"数据源不能null\");\n            }\n            LOGGER.debug(\"切换到{}数据源\", dbType);\n            contextHolder.set(dbType);\n        }\n    \n        /**\n         * 获取数据源名。\n         * @return\n         */\n        public static String getDS() {\n            return (contextHolder.get());\n        }\n    \n        /**\n         * 清除数据源名。\n         */\n        public static void clearDS() {\n            contextHolder.remove();\n        }\n    }\n    \n## 4. 通过aop，注解方式持有数据源\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.ds.DSInject;\n    import com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.annotation.After;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.aspectj.lang.annotation.Before;\n    import org.aspectj.lang.reflect.MethodSignature;\n    import org.springframework.stereotype.Component;\n    \n    import java.lang.reflect.Method;\n    \n    /**\n     *  解析注入的数据源。\n     */\n    @Aspect\n    @Component\n    public class DynamicDataSourceAspect {\n    \n    \t@Before(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void beforeSwitchDS(JoinPoint point) {\n    \n    \t\t// 获得当前访问的class\n    \t\tClass<?> className = point.getTarget().getClass();\n    \n    \t\t// 获得访问的方法名\n    \t\tString methodName = point.getSignature().getName();\n    \t\t// 得到方法的参数的类型\n    \t\tClass[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n    \t\tString dataSource = DSType.SPCS_USER.name(); //默认主库\n    \t\ttry {\n    \t\t\t// 得到访问的方法对象\n    \t\t\tMethod method = className.getMethod(methodName, argClass);\n    \n    \t\t\t// 判断是否存在@DBInject注解\n    \t\t\tif (method.isAnnotationPresent(DSInject.class)) {\n    \t\t\t\tDSInject annotation = method.getAnnotation(DSInject.class);\n    \t\t\t\t// 取出注解中的数据源名\n    \t\t\t\tdataSource = annotation.value();\n    \t\t\t}\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t}\n    \n    \t\t// 切换数据源\n    \t\tDataSourceContextHolder.setDS(dataSource);\n    \n    \t}\n    \n    \t@After(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void afterSwitchDS(JoinPoint point) {\n    \t\tDataSourceContextHolder.clearDS();\n    \t}\n    }\n\n---\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Target({ ElementType.PARAMETER, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface DSInject {\n    \tString value() default \"\";\n    }\n\n## 5. 配置jpa\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\n    import net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\n    import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.core.env.Environment;\n    import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n    import org.springframework.orm.jpa.JpaTransactionManager;\n    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n    import org.springframework.transaction.PlatformTransactionManager;\n    import org.springframework.transaction.annotation.EnableTransactionManagement;\n    import service.basic.user.common.Constants;\n    \n    import javax.persistence.EntityManager;\n    import javax.sql.DataSource;\n    import java.util.Map;\n    \n    @Configuration\n    @EnableTransactionManagement\n    @EnableJpaRepositories(entityManagerFactoryRef = \"entityManagerFactorySpcsUserDB\", transactionManagerRef = \"transactionManagerSpcsUserDB\", basePackages = {\n            Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\n    public class SpcsUserDBConfig {\n    \n        @Autowired\n        Environment ev;\n    \n        @Autowired\n        @Qualifier(\"dataSource\")\n        private DataSource dataSource; // 数据源\n    \n        @Primary\n        @Bean(name = \"entityManagerSpcsUser\")\n        public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n            return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n        }\n    \n        @Primary\n        @Bean(name = \"entityManagerFactorySpcsUserDB\")\n        public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n            if (ev.acceptsProfiles(\"dev\") || ev.acceptsProfiles(\"test\")\n                    || ev.acceptsProfiles(\"update\")) {\n                dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n            }\n            return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                    .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                    .persistenceUnit(\"spcsUserUnit\").build(); //实体管理器别名,多数据元要设置。\n        }\n    \n        private Map<String, String> getVendorProperties(DataSource dataSource) {\n            JpaProperties jpaProperties = new JpaProperties();\n            return jpaProperties.getHibernateProperties(dataSource);\n        }\n    \n        /**\n         * 开启事务。\n         *\n         * @param builder\n         * @return\n         */\n        @Primary\n        @Bean(name = \"transactionManagerSpcsUserDB\")\n        public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n            return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n        }\n    \n    }\n    \n> *注意*: 注入的数据源为上面配置的动态数据源。\n@Autowired\n@Qualifier(\"dataSource\")\nprivate DataSource dataSource; // 数据源    \n\n\n## 6. 配置spring jdbcTemplate\n\n    package service.basic.user.config.ds;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import javax.sql.DataSource;\n    \n    @Configuration\n    @AutoConfigureAfter(DataSourceConfig.class)\n    public class JdbcTemplateConfig {\n    \n        @Autowired\n        @Qualifier(value = \"dataSource\")\n        private DataSource dataSource;\n    \n        /**\n         * spring jdbc。\n         *\n         * @return\n         */\n        @Bean(name = \"jdbcTemplate\")\n        @Qualifier(\"jdbcTemplate\")\n        public JdbcTemplate jdbcTemplate() {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n\n## 7. 使用\n\n- 方式一：\n可在service层，也可在dao层做。\n在开始操作数据库前调用：\n\n\n    DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n    \n    //查询数据\n    \n    DataSourceContextHolder.clearDS();\n    \n- 方式二：\n通过注解，可在service层，也可在dao层做。\n\n\n    @DSInject(value = Constants.SPCS_USER_SLAVE)\n    @Override\n    public User getUserByMobile(String mobile) {\n        return userDao.findUserByMobile(mobile);\n    }    ","slug":"spring-jpa-multiple-datasource","published":1,"updated":"2017-12-31T09:13:45.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iomg0050d5hso30har4a","content":"<p>在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。</p>\n<h2 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h2><p>采用阿里druid数据源配置连接池。</p>\n<p>具体配置如下：</p>\n<pre><code>package service.basic.user.config.ds;\n\nimport com.alibaba.druid.filter.Filter;\nimport com.alibaba.druid.filter.logging.Log4j2Filter;\nimport com.alibaba.druid.filter.stat.StatFilter;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.wall.WallConfig;\nimport com.alibaba.druid.wall.WallFilter;\nimport com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.*;\nimport org.springframework.core.env.Environment;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * 配置数据源\n */\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * druid监控filter配置。\n     * @return\n     */\n    @Bean\n    public StatFilter statFilter() {\n        StatFilter statFilter = new StatFilter();\n        statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n        statFilter.setLogSlowSql(true); //日志记录慢sql\n        statFilter.setMergeSql(true); //相同sql合并\n        return statFilter;\n    }\n\n    //----------- sql注入攻击防御配置 start ---------//\n\n    @Bean\n    public WallConfig wallConfig() {\n        WallConfig wallConfig = new WallConfig();\n        wallConfig.setDir(&quot;classpath:druid/wall/mysql&quot;); //sql过滤规则装载位置。\n        return wallConfig;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n        WallFilter wallFilter = new WallFilter();\n        wallFilter.setDbType(&quot;mysql&quot;); //指定数据库类型。\n        wallFilter.setConfig(wallConfig());\n        return wallFilter;\n    }\n\n    //----------- sql注入攻击防御配置 end ---------//\n\n\n    /**\n     * 打印sql语句。\n     * @return\n     */\n    @Bean(name = &quot;log4j2Filter&quot;)\n    public Log4j2Filter log4j2Filter() {\n        Log4j2Filter log4j2Filter = new Log4j2Filter();\n        log4j2Filter.setConnectionLogEnabled(false);\n        log4j2Filter.setResultSetLogEnabled(true); //显示sql\n        log4j2Filter.setDataSourceLogEnabled(false);\n        log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n        log4j2Filter.setStatementLogEnabled(false);\n        return log4j2Filter;\n    }\n\n\n\n    //-------------- 数据源配置 start ---------------//\n\n    /**\n     * 会员主库（spcs_user）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceWrite&quot;)\n    @Qualifier(&quot;spcsUserDataSourceWrite&quot;)\n    public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n    /**\n     * 会员从库（spcs_user_slave）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceRead_0&quot;)\n    @Qualifier(&quot;spcsUserDataSourceRead_0&quot;)\n    public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;spcsUserDataSourceWrite&quot;,&quot;spcsUserDataSourceRead_0&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;spcsUserDataSourceWrite&quot;) DataSource spcsUserDataSource,\n                                          @Qualifier(&quot;spcsUserDataSourceRead_0&quot;) DataSource spcsUserSlaveDataSource) {\n        // 配置多数据源\n        Map&lt;Object, Object&gt; dsMap = new HashMap&lt;&gt;(5);\n        dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n        dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        // 默认数据源\n        dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n        dynamicDataSource.setTargetDataSources(dsMap);\n        return dynamicDataSource;\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。</p>\n</blockquote>\n<h2 id=\"2-实现自己的数据源路由（关键）\"><a href=\"#2-实现自己的数据源路由（关键）\" class=\"headerlink\" title=\"2. 实现自己的数据源路由（关键）\"></a>2. 实现自己的数据源路由（关键）</h2><p>相当于多数据源的路由功能。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.debug(&quot;数据源为{}&quot;, DataSourceContextHolder.getDS());\n        //可以做一个简单的负载均衡策略\n        return DataSourceContextHolder.getDS();\n    }\n\n}\n</code></pre><h2 id=\"3-持有数据源\"><a href=\"#3-持有数据源\" class=\"headerlink\" title=\"3. 持有数据源\"></a>3. 持有数据源</h2><pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class DataSourceContextHolder {\n\n    private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n\n    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();\n\n    /**\n     * 设置数据源名。\n     * @param dbType\n     */\n    public static void setDS(String dbType) {\n        if (dbType == null) {\n            throw new NullPointerException(&quot;数据源不能null&quot;);\n        }\n        LOGGER.debug(&quot;切换到{}数据源&quot;, dbType);\n        contextHolder.set(dbType);\n    }\n\n    /**\n     * 获取数据源名。\n     * @return\n     */\n    public static String getDS() {\n        return (contextHolder.get());\n    }\n\n    /**\n     * 清除数据源名。\n     */\n    public static void clearDS() {\n        contextHolder.remove();\n    }\n}\n</code></pre><h2 id=\"4-通过aop，注解方式持有数据源\"><a href=\"#4-通过aop，注解方式持有数据源\" class=\"headerlink\" title=\"4. 通过aop，注解方式持有数据源\"></a>4. 通过aop，注解方式持有数据源</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.ds.DSInject;\nimport com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n *  解析注入的数据源。\n */\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    @Before(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void beforeSwitchDS(JoinPoint point) {\n\n        // 获得当前访问的class\n        Class&lt;?&gt; className = point.getTarget().getClass();\n\n        // 获得访问的方法名\n        String methodName = point.getSignature().getName();\n        // 得到方法的参数的类型\n        Class[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n        String dataSource = DSType.SPCS_USER.name(); //默认主库\n        try {\n            // 得到访问的方法对象\n            Method method = className.getMethod(methodName, argClass);\n\n            // 判断是否存在@DBInject注解\n            if (method.isAnnotationPresent(DSInject.class)) {\n                DSInject annotation = method.getAnnotation(DSInject.class);\n                // 取出注解中的数据源名\n                dataSource = annotation.value();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 切换数据源\n        DataSourceContextHolder.setDS(dataSource);\n\n    }\n\n    @After(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void afterSwitchDS(JoinPoint point) {\n        DataSourceContextHolder.clearDS();\n    }\n}\n</code></pre><hr>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface DSInject {\n    String value() default &quot;&quot;;\n}\n</code></pre><h2 id=\"5-配置jpa\"><a href=\"#5-配置jpa\" class=\"headerlink\" title=\"5. 配置jpa\"></a>5. 配置jpa</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\nimport net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport service.basic.user.common.Constants;\n\nimport javax.persistence.EntityManager;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactorySpcsUserDB&quot;, transactionManagerRef = &quot;transactionManagerSpcsUserDB&quot;, basePackages = {\n        Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\npublic class SpcsUserDBConfig {\n\n    @Autowired\n    Environment ev;\n\n    @Autowired\n    @Qualifier(&quot;dataSource&quot;)\n    private DataSource dataSource; // 数据源\n\n    @Primary\n    @Bean(name = &quot;entityManagerSpcsUser&quot;)\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = &quot;entityManagerFactorySpcsUserDB&quot;)\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n        if (ev.acceptsProfiles(&quot;dev&quot;) || ev.acceptsProfiles(&quot;test&quot;)\n                || ev.acceptsProfiles(&quot;update&quot;)) {\n            dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n        }\n        return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                .persistenceUnit(&quot;spcsUserUnit&quot;).build(); //实体管理器别名,多数据元要设置。\n    }\n\n    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {\n        JpaProperties jpaProperties = new JpaProperties();\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    /**\n     * 开启事务。\n     *\n     * @param builder\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;transactionManagerSpcsUserDB&quot;)\n    public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>: 注入的数据源为上面配置的动态数据源。<br>@Autowired<br>@Qualifier(“dataSource”)<br>private DataSource dataSource; // 数据源    </p>\n</blockquote>\n<h2 id=\"6-配置spring-jdbcTemplate\"><a href=\"#6-配置spring-jdbcTemplate\" class=\"headerlink\" title=\"6. 配置spring jdbcTemplate\"></a>6. 配置spring jdbcTemplate</h2><pre><code>package service.basic.user.config.ds;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@AutoConfigureAfter(DataSourceConfig.class)\npublic class JdbcTemplateConfig {\n\n    @Autowired\n    @Qualifier(value = &quot;dataSource&quot;)\n    private DataSource dataSource;\n\n    /**\n     * spring jdbc。\n     *\n     * @return\n     */\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    @Qualifier(&quot;jdbcTemplate&quot;)\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource);\n    }\n}\n</code></pre><h2 id=\"7-使用\"><a href=\"#7-使用\" class=\"headerlink\" title=\"7. 使用\"></a>7. 使用</h2><ul>\n<li>方式一：<br>可在service层，也可在dao层做。<br>在开始操作数据库前调用：</li>\n</ul>\n<pre><code>DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n\n//查询数据\n\nDataSourceContextHolder.clearDS();\n</code></pre><ul>\n<li>方式二：<br>通过注解，可在service层，也可在dao层做。</li>\n</ul>\n<pre><code>@DSInject(value = Constants.SPCS_USER_SLAVE)\n@Override\npublic User getUserByMobile(String mobile) {\n    return userDao.findUserByMobile(mobile);\n}    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。</p>\n<h2 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h2><p>采用阿里druid数据源配置连接池。</p>\n<p>具体配置如下：</p>\n<pre><code>package service.basic.user.config.ds;\n\nimport com.alibaba.druid.filter.Filter;\nimport com.alibaba.druid.filter.logging.Log4j2Filter;\nimport com.alibaba.druid.filter.stat.StatFilter;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.wall.WallConfig;\nimport com.alibaba.druid.wall.WallFilter;\nimport com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.*;\nimport org.springframework.core.env.Environment;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * 配置数据源\n */\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * druid监控filter配置。\n     * @return\n     */\n    @Bean\n    public StatFilter statFilter() {\n        StatFilter statFilter = new StatFilter();\n        statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n        statFilter.setLogSlowSql(true); //日志记录慢sql\n        statFilter.setMergeSql(true); //相同sql合并\n        return statFilter;\n    }\n\n    //----------- sql注入攻击防御配置 start ---------//\n\n    @Bean\n    public WallConfig wallConfig() {\n        WallConfig wallConfig = new WallConfig();\n        wallConfig.setDir(&quot;classpath:druid/wall/mysql&quot;); //sql过滤规则装载位置。\n        return wallConfig;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n        WallFilter wallFilter = new WallFilter();\n        wallFilter.setDbType(&quot;mysql&quot;); //指定数据库类型。\n        wallFilter.setConfig(wallConfig());\n        return wallFilter;\n    }\n\n    //----------- sql注入攻击防御配置 end ---------//\n\n\n    /**\n     * 打印sql语句。\n     * @return\n     */\n    @Bean(name = &quot;log4j2Filter&quot;)\n    public Log4j2Filter log4j2Filter() {\n        Log4j2Filter log4j2Filter = new Log4j2Filter();\n        log4j2Filter.setConnectionLogEnabled(false);\n        log4j2Filter.setResultSetLogEnabled(true); //显示sql\n        log4j2Filter.setDataSourceLogEnabled(false);\n        log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n        log4j2Filter.setStatementLogEnabled(false);\n        return log4j2Filter;\n    }\n\n\n\n    //-------------- 数据源配置 start ---------------//\n\n    /**\n     * 会员主库（spcs_user）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceWrite&quot;)\n    @Qualifier(&quot;spcsUserDataSourceWrite&quot;)\n    public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n    /**\n     * 会员从库（spcs_user_slave）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceRead_0&quot;)\n    @Qualifier(&quot;spcsUserDataSourceRead_0&quot;)\n    public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;spcsUserDataSourceWrite&quot;,&quot;spcsUserDataSourceRead_0&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;spcsUserDataSourceWrite&quot;) DataSource spcsUserDataSource,\n                                          @Qualifier(&quot;spcsUserDataSourceRead_0&quot;) DataSource spcsUserSlaveDataSource) {\n        // 配置多数据源\n        Map&lt;Object, Object&gt; dsMap = new HashMap&lt;&gt;(5);\n        dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n        dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        // 默认数据源\n        dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n        dynamicDataSource.setTargetDataSources(dsMap);\n        return dynamicDataSource;\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。</p>\n</blockquote>\n<h2 id=\"2-实现自己的数据源路由（关键）\"><a href=\"#2-实现自己的数据源路由（关键）\" class=\"headerlink\" title=\"2. 实现自己的数据源路由（关键）\"></a>2. 实现自己的数据源路由（关键）</h2><p>相当于多数据源的路由功能。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.debug(&quot;数据源为{}&quot;, DataSourceContextHolder.getDS());\n        //可以做一个简单的负载均衡策略\n        return DataSourceContextHolder.getDS();\n    }\n\n}\n</code></pre><h2 id=\"3-持有数据源\"><a href=\"#3-持有数据源\" class=\"headerlink\" title=\"3. 持有数据源\"></a>3. 持有数据源</h2><pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class DataSourceContextHolder {\n\n    private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n\n    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();\n\n    /**\n     * 设置数据源名。\n     * @param dbType\n     */\n    public static void setDS(String dbType) {\n        if (dbType == null) {\n            throw new NullPointerException(&quot;数据源不能null&quot;);\n        }\n        LOGGER.debug(&quot;切换到{}数据源&quot;, dbType);\n        contextHolder.set(dbType);\n    }\n\n    /**\n     * 获取数据源名。\n     * @return\n     */\n    public static String getDS() {\n        return (contextHolder.get());\n    }\n\n    /**\n     * 清除数据源名。\n     */\n    public static void clearDS() {\n        contextHolder.remove();\n    }\n}\n</code></pre><h2 id=\"4-通过aop，注解方式持有数据源\"><a href=\"#4-通过aop，注解方式持有数据源\" class=\"headerlink\" title=\"4. 通过aop，注解方式持有数据源\"></a>4. 通过aop，注解方式持有数据源</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.ds.DSInject;\nimport com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n *  解析注入的数据源。\n */\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    @Before(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void beforeSwitchDS(JoinPoint point) {\n\n        // 获得当前访问的class\n        Class&lt;?&gt; className = point.getTarget().getClass();\n\n        // 获得访问的方法名\n        String methodName = point.getSignature().getName();\n        // 得到方法的参数的类型\n        Class[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n        String dataSource = DSType.SPCS_USER.name(); //默认主库\n        try {\n            // 得到访问的方法对象\n            Method method = className.getMethod(methodName, argClass);\n\n            // 判断是否存在@DBInject注解\n            if (method.isAnnotationPresent(DSInject.class)) {\n                DSInject annotation = method.getAnnotation(DSInject.class);\n                // 取出注解中的数据源名\n                dataSource = annotation.value();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 切换数据源\n        DataSourceContextHolder.setDS(dataSource);\n\n    }\n\n    @After(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void afterSwitchDS(JoinPoint point) {\n        DataSourceContextHolder.clearDS();\n    }\n}\n</code></pre><hr>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface DSInject {\n    String value() default &quot;&quot;;\n}\n</code></pre><h2 id=\"5-配置jpa\"><a href=\"#5-配置jpa\" class=\"headerlink\" title=\"5. 配置jpa\"></a>5. 配置jpa</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\nimport net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport service.basic.user.common.Constants;\n\nimport javax.persistence.EntityManager;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactorySpcsUserDB&quot;, transactionManagerRef = &quot;transactionManagerSpcsUserDB&quot;, basePackages = {\n        Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\npublic class SpcsUserDBConfig {\n\n    @Autowired\n    Environment ev;\n\n    @Autowired\n    @Qualifier(&quot;dataSource&quot;)\n    private DataSource dataSource; // 数据源\n\n    @Primary\n    @Bean(name = &quot;entityManagerSpcsUser&quot;)\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = &quot;entityManagerFactorySpcsUserDB&quot;)\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n        if (ev.acceptsProfiles(&quot;dev&quot;) || ev.acceptsProfiles(&quot;test&quot;)\n                || ev.acceptsProfiles(&quot;update&quot;)) {\n            dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n        }\n        return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                .persistenceUnit(&quot;spcsUserUnit&quot;).build(); //实体管理器别名,多数据元要设置。\n    }\n\n    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {\n        JpaProperties jpaProperties = new JpaProperties();\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    /**\n     * 开启事务。\n     *\n     * @param builder\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;transactionManagerSpcsUserDB&quot;)\n    public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>: 注入的数据源为上面配置的动态数据源。<br>@Autowired<br>@Qualifier(“dataSource”)<br>private DataSource dataSource; // 数据源    </p>\n</blockquote>\n<h2 id=\"6-配置spring-jdbcTemplate\"><a href=\"#6-配置spring-jdbcTemplate\" class=\"headerlink\" title=\"6. 配置spring jdbcTemplate\"></a>6. 配置spring jdbcTemplate</h2><pre><code>package service.basic.user.config.ds;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@AutoConfigureAfter(DataSourceConfig.class)\npublic class JdbcTemplateConfig {\n\n    @Autowired\n    @Qualifier(value = &quot;dataSource&quot;)\n    private DataSource dataSource;\n\n    /**\n     * spring jdbc。\n     *\n     * @return\n     */\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    @Qualifier(&quot;jdbcTemplate&quot;)\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource);\n    }\n}\n</code></pre><h2 id=\"7-使用\"><a href=\"#7-使用\" class=\"headerlink\" title=\"7. 使用\"></a>7. 使用</h2><ul>\n<li>方式一：<br>可在service层，也可在dao层做。<br>在开始操作数据库前调用：</li>\n</ul>\n<pre><code>DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n\n//查询数据\n\nDataSourceContextHolder.clearDS();\n</code></pre><ul>\n<li>方式二：<br>通过注解，可在service层，也可在dao层做。</li>\n</ul>\n<pre><code>@DSInject(value = Constants.SPCS_USER_SLAVE)\n@Override\npublic User getUserByMobile(String mobile) {\n    return userDao.findUserByMobile(mobile);\n}    \n</code></pre>"},{"title":"spring-boot过滤器篇","date":"2018-04-26T06:40:54.000Z","_content":"\n本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……\n\n## 在spring-boot项目中添加过滤器\n\n### 方式一\n\n1.创建类TestFilter,并实现Filter接口\n\n    package com.ymu.servicecommon.filter;\n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    import javax.servlet.*;\n    import java.io.IOException;\n    \n    /**\n     * 功能简述:<br>\n     *     过滤器配置测试。\n     *\n     * @author zmt\n     * @create 2018-04-26 下午5:15\n     * @updateTime\n     * @since 1.0.0\n     */\n    public class TestFilter implements Filter {\n    \n        protected final Logger logger = LogManager.getLogger(this.getClass());\n    \n        @Override\n        public void init(FilterConfig filterConfig) throws ServletException {\n            logger.debug(\">>>>testFilter init\");\n        }\n    \n        @Override\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n            logger.debug(\">>>>testFilter doFilter\");\n            filterChain.doFilter(servletRequest,servletResponse);\n        }\n    \n        @Override\n        public void destroy() {\n            logger.debug(\">>>>testFilter destroy\");\n        }\n    }\n\n2.注解bean\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean indexFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            return registration;\n        }\n    \n    }\n\n\n### 方式二\n\n1.创建过滤器IndexFilter2\n\n    package com.example.filter;\n    import java.io.IOException;\n    import javax.servlet.Filter;\n    import javax.servlet.FilterChain;\n    import javax.servlet.FilterConfig;\n    import javax.servlet.ServletException;\n    import javax.servlet.ServletRequest;\n    import javax.servlet.ServletResponse;\n    import javax.servlet.annotation.WebFilter;\n    \n    @WebFilter(urlPatterns = \"/*\", filterName = \"indexFilter2\")\n    public class IndexFilter2 implements Filter{\n      @Override\n      public void destroy() {\n        System.out.println(\"filter2 destroy method\");\n      }\n      @Override\n      public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n          throws IOException, ServletException {\n        System.out.println(\"filter2 doFilter method\");\n      }\n      @Override\n      public void init(FilterConfig arg0) throws ServletException {\n        System.out.println(\"filter2 init method\");\n      }\n    }\n\n2.在程序启动入库加入注解`ServletComponentScan`\n\n    @SpringBootApplication\n    @ServletComponentScan\n    public class SpringBootSimpleApplication {\n      public static void main(String[] args) {\n        SpringApplication.run(SpringBootSimpleApplication.class, args);\n      }\n    }\n\n## 多个过滤器调用顺序\n\n在spring-boot中通过注解`@Order`来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。\n\n1.代码设置\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.Test2Filter;\n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean testFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n        @Bean\n        public FilterRegistrationBean test2FilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"test2Filter\");\n            registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n    }\n    \n----------------------------------------------------    \n\n- 启动程序，观察执行顺序。\n\n{% asset_img a.png %} \n\n- 请求接口，观察执行顺序。\n\n{% asset_img b.png %}\n\n\n## 在过滤器中为请求添加http请求头信息\n\n1.定义类ModifyHttpServletRequestWrapper.java\n\n    package com.ymu.framework.web;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import javax.servlet.http.HttpServletRequestWrapper;\n    import java.util.*;\n    \n    public class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n     \n        private Map<String, String> customHeaders;\n     \n        public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n            super(request);\n            this.customHeaders = new HashMap<>();\n        }\n     \n        public void putHeader(String name, String value) {\n            this.customHeaders.put(name, value);\n        }\n     \n        public String getHeader(String name) {\n            String value = this.customHeaders.get(name);\n            if (value != null) {\n                return value;\n            }\n            return ((HttpServletRequest) getRequest()).getHeader(name);\n        }\n     \n        public Enumeration<String> getHeaderNames() {\n            Set<String> set = new HashSet<>(customHeaders.keySet());\n            Enumeration<String> enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n            while (enumeration.hasMoreElements()) {\n                String name = enumeration.nextElement();\n                set.add(name);\n            }\n            return Collections.enumeration(set);\n        }\n     \n    }\n    \n2.定义过滤器，编辑\n    \n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(\">>>>indexFilter doFilter\");\n\n        //添加或者更改header信息\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        String apiVersion = request.getHeader(\"Content-Version\");\n        if (null == apiVersion || \"\".equals(apiVersion)) {\n            ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n            requestWrapper.putHeader(\"Content-Version\",\"-1\");\n            filterChain.doFilter(requestWrapper,servletResponse);\n        } else {\n            filterChain.doFilter(request,servletResponse);\n        }\n    }   \n\n    重点代码：\n    ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n    requestWrapper.putHeader(\"Content-Version\",\"-1\");\n    filterChain.doFilter(requestWrapper,servletResponse);","source":"_posts/spring-boot-filter.md","raw":"---\ntitle: spring-boot过滤器篇\ndate: 2018-04-26 14:40:54\ncategories: spring-boot\ntags: spring-boot-filter\n---\n\n本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……\n\n## 在spring-boot项目中添加过滤器\n\n### 方式一\n\n1.创建类TestFilter,并实现Filter接口\n\n    package com.ymu.servicecommon.filter;\n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    import javax.servlet.*;\n    import java.io.IOException;\n    \n    /**\n     * 功能简述:<br>\n     *     过滤器配置测试。\n     *\n     * @author zmt\n     * @create 2018-04-26 下午5:15\n     * @updateTime\n     * @since 1.0.0\n     */\n    public class TestFilter implements Filter {\n    \n        protected final Logger logger = LogManager.getLogger(this.getClass());\n    \n        @Override\n        public void init(FilterConfig filterConfig) throws ServletException {\n            logger.debug(\">>>>testFilter init\");\n        }\n    \n        @Override\n        public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n            logger.debug(\">>>>testFilter doFilter\");\n            filterChain.doFilter(servletRequest,servletResponse);\n        }\n    \n        @Override\n        public void destroy() {\n            logger.debug(\">>>>testFilter destroy\");\n        }\n    }\n\n2.注解bean\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean indexFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            return registration;\n        }\n    \n    }\n\n\n### 方式二\n\n1.创建过滤器IndexFilter2\n\n    package com.example.filter;\n    import java.io.IOException;\n    import javax.servlet.Filter;\n    import javax.servlet.FilterChain;\n    import javax.servlet.FilterConfig;\n    import javax.servlet.ServletException;\n    import javax.servlet.ServletRequest;\n    import javax.servlet.ServletResponse;\n    import javax.servlet.annotation.WebFilter;\n    \n    @WebFilter(urlPatterns = \"/*\", filterName = \"indexFilter2\")\n    public class IndexFilter2 implements Filter{\n      @Override\n      public void destroy() {\n        System.out.println(\"filter2 destroy method\");\n      }\n      @Override\n      public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n          throws IOException, ServletException {\n        System.out.println(\"filter2 doFilter method\");\n      }\n      @Override\n      public void init(FilterConfig arg0) throws ServletException {\n        System.out.println(\"filter2 init method\");\n      }\n    }\n\n2.在程序启动入库加入注解`ServletComponentScan`\n\n    @SpringBootApplication\n    @ServletComponentScan\n    public class SpringBootSimpleApplication {\n      public static void main(String[] args) {\n        SpringApplication.run(SpringBootSimpleApplication.class, args);\n      }\n    }\n\n## 多个过滤器调用顺序\n\n在spring-boot中通过注解`@Order`来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。\n\n1.代码设置\n\n    package com.ymu.servicecommon.config;\n    \n    import com.ymu.servicecommon.filter.Test2Filter;\n    import com.ymu.servicecommon.filter.TestFilter;\n    import org.springframework.boot.web.servlet.FilterRegistrationBean;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    \n    @Configuration\n    public class MainConfig {\n    \n        /**\n         * 配置过滤器\n         * @return\n         */\n        @Bean\n        public FilterRegistrationBean testFilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"testFilter\");\n            registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n        @Bean\n        public FilterRegistrationBean test2FilterRegistration() {\n            FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n            registration.addUrlPatterns(\"/*\");\n    //        registration.addInitParameter(\"abc\", \"abc-value\");\n            registration.setName(\"test2Filter\");\n            registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n            return registration;\n        }\n    \n    }\n    \n----------------------------------------------------    \n\n- 启动程序，观察执行顺序。\n\n{% asset_img a.png %} \n\n- 请求接口，观察执行顺序。\n\n{% asset_img b.png %}\n\n\n## 在过滤器中为请求添加http请求头信息\n\n1.定义类ModifyHttpServletRequestWrapper.java\n\n    package com.ymu.framework.web;\n    \n    import javax.servlet.http.HttpServletRequest;\n    import javax.servlet.http.HttpServletRequestWrapper;\n    import java.util.*;\n    \n    public class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n     \n        private Map<String, String> customHeaders;\n     \n        public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n            super(request);\n            this.customHeaders = new HashMap<>();\n        }\n     \n        public void putHeader(String name, String value) {\n            this.customHeaders.put(name, value);\n        }\n     \n        public String getHeader(String name) {\n            String value = this.customHeaders.get(name);\n            if (value != null) {\n                return value;\n            }\n            return ((HttpServletRequest) getRequest()).getHeader(name);\n        }\n     \n        public Enumeration<String> getHeaderNames() {\n            Set<String> set = new HashSet<>(customHeaders.keySet());\n            Enumeration<String> enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n            while (enumeration.hasMoreElements()) {\n                String name = enumeration.nextElement();\n                set.add(name);\n            }\n            return Collections.enumeration(set);\n        }\n     \n    }\n    \n2.定义过滤器，编辑\n    \n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(\">>>>indexFilter doFilter\");\n\n        //添加或者更改header信息\n        HttpServletRequest request = (HttpServletRequest) servletRequest;\n        String apiVersion = request.getHeader(\"Content-Version\");\n        if (null == apiVersion || \"\".equals(apiVersion)) {\n            ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n            requestWrapper.putHeader(\"Content-Version\",\"-1\");\n            filterChain.doFilter(requestWrapper,servletResponse);\n        } else {\n            filterChain.doFilter(request,servletResponse);\n        }\n    }   \n\n    重点代码：\n    ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n    requestWrapper.putHeader(\"Content-Version\",\"-1\");\n    filterChain.doFilter(requestWrapper,servletResponse);","slug":"spring-boot-filter","published":1,"updated":"2018-04-27T08:34:53.285Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iomj0054d5hslymddbti","content":"<p>本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……</p>\n<h2 id=\"在spring-boot项目中添加过滤器\"><a href=\"#在spring-boot项目中添加过滤器\" class=\"headerlink\" title=\"在spring-boot项目中添加过滤器\"></a>在spring-boot项目中添加过滤器</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>1.创建类TestFilter,并实现Filter接口</p>\n<pre><code>package com.ymu.servicecommon.filter;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\n/**\n * 功能简述:&lt;br&gt;\n *     过滤器配置测试。\n *\n * @author zmt\n * @create 2018-04-26 下午5:15\n * @updateTime\n * @since 1.0.0\n */\npublic class TestFilter implements Filter {\n\n    protected final Logger logger = LogManager.getLogger(this.getClass());\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter init&quot;);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter doFilter&quot;);\n        filterChain.doFilter(servletRequest,servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter destroy&quot;);\n    }\n}\n</code></pre><p>2.注解bean</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean indexFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        return registration;\n    }\n\n}\n</code></pre><h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>1.创建过滤器IndexFilter2</p>\n<pre><code>package com.example.filter;\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\n\n@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;indexFilter2&quot;)\npublic class IndexFilter2 implements Filter{\n  @Override\n  public void destroy() {\n    System.out.println(&quot;filter2 destroy method&quot;);\n  }\n  @Override\n  public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n      throws IOException, ServletException {\n    System.out.println(&quot;filter2 doFilter method&quot;);\n  }\n  @Override\n  public void init(FilterConfig arg0) throws ServletException {\n    System.out.println(&quot;filter2 init method&quot;);\n  }\n}\n</code></pre><p>2.在程序启动入库加入注解<code>ServletComponentScan</code></p>\n<pre><code>@SpringBootApplication\n@ServletComponentScan\npublic class SpringBootSimpleApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(SpringBootSimpleApplication.class, args);\n  }\n}\n</code></pre><h2 id=\"多个过滤器调用顺序\"><a href=\"#多个过滤器调用顺序\" class=\"headerlink\" title=\"多个过滤器调用顺序\"></a>多个过滤器调用顺序</h2><p>在spring-boot中通过注解<code>@Order</code>来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。</p>\n<p>1.代码设置</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.Test2Filter;\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n    @Bean\n    public FilterRegistrationBean test2FilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;test2Filter&quot;);\n        registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n}\n</code></pre><hr>\n<ul>\n<li>启动程序，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/a.png\"> \n<ul>\n<li>请求接口，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/b.png\">\n<h2 id=\"在过滤器中为请求添加http请求头信息\"><a href=\"#在过滤器中为请求添加http请求头信息\" class=\"headerlink\" title=\"在过滤器中为请求添加http请求头信息\"></a>在过滤器中为请求添加http请求头信息</h2><p>1.定义类ModifyHttpServletRequestWrapper.java</p>\n<pre><code>package com.ymu.framework.web;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.util.*;\n\npublic class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n\n    private Map&lt;String, String&gt; customHeaders;\n\n    public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n        super(request);\n        this.customHeaders = new HashMap&lt;&gt;();\n    }\n\n    public void putHeader(String name, String value) {\n        this.customHeaders.put(name, value);\n    }\n\n    public String getHeader(String name) {\n        String value = this.customHeaders.get(name);\n        if (value != null) {\n            return value;\n        }\n        return ((HttpServletRequest) getRequest()).getHeader(name);\n    }\n\n    public Enumeration&lt;String&gt; getHeaderNames() {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;(customHeaders.keySet());\n        Enumeration&lt;String&gt; enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n        while (enumeration.hasMoreElements()) {\n            String name = enumeration.nextElement();\n            set.add(name);\n        }\n        return Collections.enumeration(set);\n    }\n\n}\n</code></pre><p>2.定义过滤器，编辑</p>\n<pre><code>@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    logger.debug(&quot;&gt;&gt;&gt;&gt;indexFilter doFilter&quot;);\n\n    //添加或者更改header信息\n    HttpServletRequest request = (HttpServletRequest) servletRequest;\n    String apiVersion = request.getHeader(&quot;Content-Version&quot;);\n    if (null == apiVersion || &quot;&quot;.equals(apiVersion)) {\n        ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n        requestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\n        filterChain.doFilter(requestWrapper,servletResponse);\n    } else {\n        filterChain.doFilter(request,servletResponse);\n    }\n}   \n\n重点代码：\nModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\nrequestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\nfilterChain.doFilter(requestWrapper,servletResponse);\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文记录在spring-boot环境下，添加配置过滤器。以及过滤器的一些常见使用……</p>\n<h2 id=\"在spring-boot项目中添加过滤器\"><a href=\"#在spring-boot项目中添加过滤器\" class=\"headerlink\" title=\"在spring-boot项目中添加过滤器\"></a>在spring-boot项目中添加过滤器</h2><h3 id=\"方式一\"><a href=\"#方式一\" class=\"headerlink\" title=\"方式一\"></a>方式一</h3><p>1.创建类TestFilter,并实现Filter接口</p>\n<pre><code>package com.ymu.servicecommon.filter;\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\nimport javax.servlet.*;\nimport java.io.IOException;\n\n/**\n * 功能简述:&lt;br&gt;\n *     过滤器配置测试。\n *\n * @author zmt\n * @create 2018-04-26 下午5:15\n * @updateTime\n * @since 1.0.0\n */\npublic class TestFilter implements Filter {\n\n    protected final Logger logger = LogManager.getLogger(this.getClass());\n\n    @Override\n    public void init(FilterConfig filterConfig) throws ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter init&quot;);\n    }\n\n    @Override\n    public void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter doFilter&quot;);\n        filterChain.doFilter(servletRequest,servletResponse);\n    }\n\n    @Override\n    public void destroy() {\n        logger.debug(&quot;&gt;&gt;&gt;&gt;testFilter destroy&quot;);\n    }\n}\n</code></pre><p>2.注解bean</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean indexFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        return registration;\n    }\n\n}\n</code></pre><h3 id=\"方式二\"><a href=\"#方式二\" class=\"headerlink\" title=\"方式二\"></a>方式二</h3><p>1.创建过滤器IndexFilter2</p>\n<pre><code>package com.example.filter;\nimport java.io.IOException;\nimport javax.servlet.Filter;\nimport javax.servlet.FilterChain;\nimport javax.servlet.FilterConfig;\nimport javax.servlet.ServletException;\nimport javax.servlet.ServletRequest;\nimport javax.servlet.ServletResponse;\nimport javax.servlet.annotation.WebFilter;\n\n@WebFilter(urlPatterns = &quot;/*&quot;, filterName = &quot;indexFilter2&quot;)\npublic class IndexFilter2 implements Filter{\n  @Override\n  public void destroy() {\n    System.out.println(&quot;filter2 destroy method&quot;);\n  }\n  @Override\n  public void doFilter(ServletRequest arg0, ServletResponse arg1, FilterChain arg2)\n      throws IOException, ServletException {\n    System.out.println(&quot;filter2 doFilter method&quot;);\n  }\n  @Override\n  public void init(FilterConfig arg0) throws ServletException {\n    System.out.println(&quot;filter2 init method&quot;);\n  }\n}\n</code></pre><p>2.在程序启动入库加入注解<code>ServletComponentScan</code></p>\n<pre><code>@SpringBootApplication\n@ServletComponentScan\npublic class SpringBootSimpleApplication {\n  public static void main(String[] args) {\n    SpringApplication.run(SpringBootSimpleApplication.class, args);\n  }\n}\n</code></pre><h2 id=\"多个过滤器调用顺序\"><a href=\"#多个过滤器调用顺序\" class=\"headerlink\" title=\"多个过滤器调用顺序\"></a>多个过滤器调用顺序</h2><p>在spring-boot中通过注解<code>@Order</code>来标识。这个order的默认值是Integer.MAX_VALUE 也就是int的最大值。多个过滤器会按照order属性的大小从小到大执行。</p>\n<p>1.代码设置</p>\n<pre><code>package com.ymu.servicecommon.config;\n\nimport com.ymu.servicecommon.filter.Test2Filter;\nimport com.ymu.servicecommon.filter.TestFilter;\nimport org.springframework.boot.web.servlet.FilterRegistrationBean;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\n\n@Configuration\npublic class MainConfig {\n\n    /**\n     * 配置过滤器\n     * @return\n     */\n    @Bean\n    public FilterRegistrationBean testFilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new TestFilter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;testFilter&quot;);\n        registration.setOrder(Integer.MAX_VALUE); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n    @Bean\n    public FilterRegistrationBean test2FilterRegistration() {\n        FilterRegistrationBean registration = new FilterRegistrationBean(new Test2Filter());\n        registration.addUrlPatterns(&quot;/*&quot;);\n//        registration.addInitParameter(&quot;abc&quot;, &quot;abc-value&quot;);\n        registration.setName(&quot;test2Filter&quot;);\n        registration.setOrder(Integer.MAX_VALUE-1); //设置过滤器执行先后顺序，多个按从小到大执行\n        return registration;\n    }\n\n}\n</code></pre><hr>\n<ul>\n<li>启动程序，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/a.png\"> \n<ul>\n<li>请求接口，观察执行顺序。</li>\n</ul>\n<img src=\"/2018/04/26/spring-boot-filter/b.png\">\n<h2 id=\"在过滤器中为请求添加http请求头信息\"><a href=\"#在过滤器中为请求添加http请求头信息\" class=\"headerlink\" title=\"在过滤器中为请求添加http请求头信息\"></a>在过滤器中为请求添加http请求头信息</h2><p>1.定义类ModifyHttpServletRequestWrapper.java</p>\n<pre><code>package com.ymu.framework.web;\n\nimport javax.servlet.http.HttpServletRequest;\nimport javax.servlet.http.HttpServletRequestWrapper;\nimport java.util.*;\n\npublic class ModifyHttpServletRequestWrapper extends HttpServletRequestWrapper {\n\n    private Map&lt;String, String&gt; customHeaders;\n\n    public ModifyHttpServletRequestWrapper(HttpServletRequest request) {\n        super(request);\n        this.customHeaders = new HashMap&lt;&gt;();\n    }\n\n    public void putHeader(String name, String value) {\n        this.customHeaders.put(name, value);\n    }\n\n    public String getHeader(String name) {\n        String value = this.customHeaders.get(name);\n        if (value != null) {\n            return value;\n        }\n        return ((HttpServletRequest) getRequest()).getHeader(name);\n    }\n\n    public Enumeration&lt;String&gt; getHeaderNames() {\n        Set&lt;String&gt; set = new HashSet&lt;&gt;(customHeaders.keySet());\n        Enumeration&lt;String&gt; enumeration = ((HttpServletRequest) getRequest()).getHeaderNames();\n        while (enumeration.hasMoreElements()) {\n            String name = enumeration.nextElement();\n            set.add(name);\n        }\n        return Collections.enumeration(set);\n    }\n\n}\n</code></pre><p>2.定义过滤器，编辑</p>\n<pre><code>@Override\npublic void doFilter(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain) throws IOException, ServletException {\n    logger.debug(&quot;&gt;&gt;&gt;&gt;indexFilter doFilter&quot;);\n\n    //添加或者更改header信息\n    HttpServletRequest request = (HttpServletRequest) servletRequest;\n    String apiVersion = request.getHeader(&quot;Content-Version&quot;);\n    if (null == apiVersion || &quot;&quot;.equals(apiVersion)) {\n        ModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\n        requestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\n        filterChain.doFilter(requestWrapper,servletResponse);\n    } else {\n        filterChain.doFilter(request,servletResponse);\n    }\n}   \n\n重点代码：\nModifyHttpServletRequestWrapper requestWrapper = new ModifyHttpServletRequestWrapper(request);\nrequestWrapper.putHeader(&quot;Content-Version&quot;,&quot;-1&quot;);\nfilterChain.doFilter(requestWrapper,servletResponse);\n</code></pre>"},{"title":"teamcity持续集成使用","date":"2017-10-30T01:18:57.000Z","_content":"","source":"_posts/teamcity-use-start.md","raw":"---\ntitle: teamcity持续集成使用\ndate: 2017-10-30 09:18:57\ncategories: teamcity\ntags: teamcity-start\n---\n","slug":"teamcity-use-start","published":1,"updated":"2017-12-31T09:13:45.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioml0056d5hswgsexojh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"TypeScript学习(一)","date":"2017-10-13T15:33:23.000Z","_content":"","source":"_posts/tslang-study-one.md","raw":"---\ntitle: TypeScript学习(一)\ndate: 2017-10-13 23:33:23\ncategories: TypeScript\ntags: \n---\n","slug":"tslang-study-one","published":1,"updated":"2017-12-31T09:13:45.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iomo0059d5hs04v56qn3","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"虚拟开发环境-Vagrant","date":"2018-01-23T02:04:27.000Z","_content":"\n告别“在我的机子上运行没问题的……”\n\n官网网址：https://www.vagrantup.com/\n\n## vagrant安装\n\n\n\n## 学习资源\n\n- http://www.imooc.com/learn/805","source":"_posts/vagrant-start.md","raw":"---\ntitle: 虚拟开发环境-Vagrant\ndate: 2018-01-23 10:04:27\ncategories: vagrant\ntags: vagrant-start\n---\n\n告别“在我的机子上运行没问题的……”\n\n官网网址：https://www.vagrantup.com/\n\n## vagrant安装\n\n\n\n## 学习资源\n\n- http://www.imooc.com/learn/805","slug":"vagrant-start","published":1,"updated":"2018-04-27T06:27:55.023Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iomq005cd5hsc85skwcr","content":"<p>告别“在我的机子上运行没问题的……”</p>\n<p>官网网址：<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a></p>\n<h2 id=\"vagrant安装\"><a href=\"#vagrant安装\" class=\"headerlink\" title=\"vagrant安装\"></a>vagrant安装</h2><h2 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h2><ul>\n<li><a href=\"http://www.imooc.com/learn/805\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/learn/805</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>告别“在我的机子上运行没问题的……”</p>\n<p>官网网址：<a href=\"https://www.vagrantup.com/\" target=\"_blank\" rel=\"noopener\">https://www.vagrantup.com/</a></p>\n<h2 id=\"vagrant安装\"><a href=\"#vagrant安装\" class=\"headerlink\" title=\"vagrant安装\"></a>vagrant安装</h2><h2 id=\"学习资源\"><a href=\"#学习资源\" class=\"headerlink\" title=\"学习资源\"></a>学习资源</h2><ul>\n<li><a href=\"http://www.imooc.com/learn/805\" target=\"_blank\" rel=\"noopener\">http://www.imooc.com/learn/805</a></li>\n</ul>\n"},{"title":"Vault学习","date":"2018-03-09T02:11:17.000Z","_content":"\nValut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……\n\n特性：\n\n1.安全的私密信息存储 \n\n2.动态的私密信息支持\n\n3.提供对于私密信息的更新，延长有效时间的功能\n\n4.灵活的权限控制\n\n5.多种客户端登录验证方式\n\n参考：\nhttps://www.vaultproject.io/intro/index.html\n\n## 安装Valut\n\n1.下载地址：https://www.vaultproject.io/downloads.html\n\n2.解压\n解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。\n\n配置环境变量，把vault可执行文件所在目录添加到环境变量：\n\n`export PATH=$PATH:/home/mutian/dev/bin`\n\n检验是否成功：\n    \n    mutian@mutian-ThinkPad-T440p:~$ vault \n    Usage: vault <command> [args]\n    \n    Common commands:\n        read        Read data and retrieves secrets\n        write       Write data, configuration, and secrets\n        delete      Delete secrets and configuration\n        list        List data or secrets\n        login       Authenticate locally\n        server      Start a Vault server\n        status      Print seal and HA status\n        unwrap      Unwrap a wrapped secret\n    \n    Other commands:\n        audit          Interact with audit devices\n        auth           Interact with auth methods\n        lease          Interact with leases\n        operator       Perform operator-specific tasks\n        path-help      Retrieve API help for paths\n        policy         Interact with policies\n        secrets        Interact with secrets engines\n        ssh            Initiate an SSH session\n        token          Interact with tokens\n\n表示环境变量添加准确，已经安装成功。\n\n\n3.install completions\n\n    $ vault -autocomplete-install\n    \n然后重新启动shell窗口，输入命令`vault`，然后按Tab键，将出现命令参数提示。如下：    \n\n    mutian@mutian-ThinkPad-T440p:~$ vault \n    audit      lease      operator   read       ssh        unwrap     \n    auth       list       path-help  secrets    status     write      \n    delete     login      policy     server     token      \n    mutian@mutian-ThinkPad-T440p:~$ vault \n\n##　启动服务\n\n#### 启动开发环境\n\n开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n    ==> Vault server configuration:\n    \n                         Cgo: disabled\n             Cluster Address: https://127.0.0.1:8201\n                  Listener 1: tcp (addr: \"127.0.0.1:8200\", cluster address: \"127.0.0.1:8201\", tls: \"disabled\")\n                   Log Level: info\n                       Mlock: supported: true, enabled: false\n            Redirect Address: http://127.0.0.1:8200\n                     Storage: inmem\n                     Version: Vault v0.9.5\n                 Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n    \n    WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\n    and starts unsealed with a single unseal key. The root token is already\n    authenticated to the CLI, so you can immediately begin using Vault.\n    \n    You may need to set the following environment variable:\n    \n        $ export VAULT_ADDR='http://127.0.0.1:8200'\n    \n    The unseal key and root token are displayed below in case you want to\n    seal/unseal the Vault or re-authenticate.\n    \n    Unseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\n    Root Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n    \n    Development mode should NOT be used in production installations!\n    \n    ==> Vault server started! Log data will stream in below:\n\n看到上面内容说明已经启动成功，在前台运行的。\n\n验证服务是否在成功运行：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status \n    Error checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\n    mutian@mutian-ThinkPad-T440p:~$ \n\n看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：\n\n     export VAULT_ADDR=http://127.0.0.1:8200\n     \n再次查看vault服务运行状态:\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status\n    Key             Value\n    ---             -----\n    Seal Type       shamir\n    Sealed          false\n    Total Shares    1\n    Threshold       1\n    Version         0.9.5\n    Cluster Name    vault-cluster-bcf3f2f8\n    Cluster ID      c2649684-fe35-3820-983b-f324a51b115c\n    HA Enabled      false\n         \n看到了上面的内容，则证明服务启动成功。\n\n为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效， \n命令：\n\n| 功能      | 命令    |  说明  |\n| --------   | -----   | :---- |\n| 设置vault访问地址       | export VAULT_ADDR=http://127.0.0.1:8200     |   vault命令作用的vault服务的地址    |\n| 设置Vault PATH        | export PATH=$PATH:< vault install path >      |   vault install path：vault安装路径    |\n| 设置访问token        | \texport VAULT_TOKEN=< token >      |   token：登录vault时的token，首次登录可使用root token    |\n| 设置是否跳过核查        | \texport VAULT_SKIP_VERIFY=false      |    使用TSL访问时需要设置，未使用证书忽略此项    |\n| 设置访问证书        | \texport VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem      |   使用TSL访问时需要设置，未使用证书忽略此项    |\n\n     \n- 保存私密信息\n\n下面是简单的写入信息命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\n    Success! Data written to: secret/hello\n\n这会把键值对信息写入到路劲`secret/hello`中。　键为value,值为world。\n\n也可以一次性写入多个键值保存：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n\n- 读取私密信息\n    \n显示该路径下所有保存键值对：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \n    Key                 Value\n    ---                 -----\n    refresh_interval    768h\n    excited             yes\n    value               world    \n\n获取单个的值：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\n    world\n\n- 删除路径下键值\n\n删除所有：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \n    Success! Data deleted (if it existed) at: secret/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\n    No value found at secret/hello\n\n看上面命令，说明已经把保存到路径`secret/hello`下的键值信息全部删除。\n\n## 秘密引擎\n\n上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径`secret/hello`下面，这个是默认的。当你试图保存到其他路径下时候，将报错。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\n    Error writing data to home/mutian/dev: Error making API request.\n    \n    URL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\n    Code: 404. Errors:\n    \n    * no handler for route 'home/mutian/dev'\n\n默认下，在路劲`secret/.`Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    \n\n- 开启一个新的kv私密引擎\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv\n    Success! Enabled the kv secrets engine at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    abs/          kv           n/a\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n\n通过命令`vault secrets list`可以看到，第一个就是就是我们刚才开启的新私密引擎。\n\n往该新建私密引擎保存私密信息：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\n    Success! Data written to: abs/my-secret\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\n    Success! Data written to: abs/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\n    Success! Data written to: abs/airplane\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n查看该私密引擎下所有key\n\n    mutian@mutian-ThinkPad-T440p:~$ vault list abs\n    Keys\n    ----\n    airplane\n    hello\n    my-secret\n\n- 关闭私密引擎\n\n当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　\n当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\n    Success! Disabled the secrets engine (if it existed) at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n    \n上面结果中，已经再看不到私密引擎`abs/`\n\n- 什么是私密引擎（Secrets Engine）\n\n上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？\n\n实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　\n这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　\n\n\n## 动态私密信息保存\n\n\n\n    \n","source":"_posts/vault-study.md","raw":"---\ntitle: Vault学习\ndate: 2018-03-09 10:11:17\ncategories: 密码\ntags: vault\n---\n\nValut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……\n\n特性：\n\n1.安全的私密信息存储 \n\n2.动态的私密信息支持\n\n3.提供对于私密信息的更新，延长有效时间的功能\n\n4.灵活的权限控制\n\n5.多种客户端登录验证方式\n\n参考：\nhttps://www.vaultproject.io/intro/index.html\n\n## 安装Valut\n\n1.下载地址：https://www.vaultproject.io/downloads.html\n\n2.解压\n解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。\n\n配置环境变量，把vault可执行文件所在目录添加到环境变量：\n\n`export PATH=$PATH:/home/mutian/dev/bin`\n\n检验是否成功：\n    \n    mutian@mutian-ThinkPad-T440p:~$ vault \n    Usage: vault <command> [args]\n    \n    Common commands:\n        read        Read data and retrieves secrets\n        write       Write data, configuration, and secrets\n        delete      Delete secrets and configuration\n        list        List data or secrets\n        login       Authenticate locally\n        server      Start a Vault server\n        status      Print seal and HA status\n        unwrap      Unwrap a wrapped secret\n    \n    Other commands:\n        audit          Interact with audit devices\n        auth           Interact with auth methods\n        lease          Interact with leases\n        operator       Perform operator-specific tasks\n        path-help      Retrieve API help for paths\n        policy         Interact with policies\n        secrets        Interact with secrets engines\n        ssh            Initiate an SSH session\n        token          Interact with tokens\n\n表示环境变量添加准确，已经安装成功。\n\n\n3.install completions\n\n    $ vault -autocomplete-install\n    \n然后重新启动shell窗口，输入命令`vault`，然后按Tab键，将出现命令参数提示。如下：    \n\n    mutian@mutian-ThinkPad-T440p:~$ vault \n    audit      lease      operator   read       ssh        unwrap     \n    auth       list       path-help  secrets    status     write      \n    delete     login      policy     server     token      \n    mutian@mutian-ThinkPad-T440p:~$ vault \n\n##　启动服务\n\n#### 启动开发环境\n\n开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n    ==> Vault server configuration:\n    \n                         Cgo: disabled\n             Cluster Address: https://127.0.0.1:8201\n                  Listener 1: tcp (addr: \"127.0.0.1:8200\", cluster address: \"127.0.0.1:8201\", tls: \"disabled\")\n                   Log Level: info\n                       Mlock: supported: true, enabled: false\n            Redirect Address: http://127.0.0.1:8200\n                     Storage: inmem\n                     Version: Vault v0.9.5\n                 Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n    \n    WARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\n    and starts unsealed with a single unseal key. The root token is already\n    authenticated to the CLI, so you can immediately begin using Vault.\n    \n    You may need to set the following environment variable:\n    \n        $ export VAULT_ADDR='http://127.0.0.1:8200'\n    \n    The unseal key and root token are displayed below in case you want to\n    seal/unseal the Vault or re-authenticate.\n    \n    Unseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\n    Root Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n    \n    Development mode should NOT be used in production installations!\n    \n    ==> Vault server started! Log data will stream in below:\n\n看到上面内容说明已经启动成功，在前台运行的。\n\n验证服务是否在成功运行：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status \n    Error checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\n    mutian@mutian-ThinkPad-T440p:~$ \n\n看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：\n\n     export VAULT_ADDR=http://127.0.0.1:8200\n     \n再次查看vault服务运行状态:\n\n    mutian@mutian-ThinkPad-T440p:~$ vault status\n    Key             Value\n    ---             -----\n    Seal Type       shamir\n    Sealed          false\n    Total Shares    1\n    Threshold       1\n    Version         0.9.5\n    Cluster Name    vault-cluster-bcf3f2f8\n    Cluster ID      c2649684-fe35-3820-983b-f324a51b115c\n    HA Enabled      false\n         \n看到了上面的内容，则证明服务启动成功。\n\n为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效， \n命令：\n\n| 功能      | 命令    |  说明  |\n| --------   | -----   | :---- |\n| 设置vault访问地址       | export VAULT_ADDR=http://127.0.0.1:8200     |   vault命令作用的vault服务的地址    |\n| 设置Vault PATH        | export PATH=$PATH:< vault install path >      |   vault install path：vault安装路径    |\n| 设置访问token        | \texport VAULT_TOKEN=< token >      |   token：登录vault时的token，首次登录可使用root token    |\n| 设置是否跳过核查        | \texport VAULT_SKIP_VERIFY=false      |    使用TSL访问时需要设置，未使用证书忽略此项    |\n| 设置访问证书        | \texport VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem      |   使用TSL访问时需要设置，未使用证书忽略此项    |\n\n     \n- 保存私密信息\n\n下面是简单的写入信息命令：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\n    Success! Data written to: secret/hello\n\n这会把键值对信息写入到路劲`secret/hello`中。　键为value,值为world。\n\n也可以一次性写入多个键值保存：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n\n- 读取私密信息\n    \n显示该路径下所有保存键值对：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \n    Key                 Value\n    ---                 -----\n    refresh_interval    768h\n    excited             yes\n    value               world    \n\n获取单个的值：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\n    world\n\n- 删除路径下键值\n\n删除所有：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \n    Success! Data deleted (if it existed) at: secret/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\n    No value found at secret/hello\n\n看上面命令，说明已经把保存到路径`secret/hello`下的键值信息全部删除。\n\n## 秘密引擎\n\n上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径`secret/hello`下面，这个是默认的。当你试图保存到其他路径下时候，将报错。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\n    Error writing data to home/mutian/dev: Error making API request.\n    \n    URL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\n    Code: 404. Errors:\n    \n    * no handler for route 'home/mutian/dev'\n\n默认下，在路劲`secret/.`Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    \n\n- 开启一个新的kv私密引擎\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv\n    Success! Enabled the kv secrets engine at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    abs/          kv           n/a\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n\n通过命令`vault secrets list`可以看到，第一个就是就是我们刚才开启的新私密引擎。\n\n往该新建私密引擎保存私密信息：\n\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\n    Success! Data written to: abs/my-secret\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\n    Success! Data written to: abs/hello\n    mutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\n    Success! Data written to: abs/airplane\n    mutian@mutian-ThinkPad-T440p:~$ \n    \n查看该私密引擎下所有key\n\n    mutian@mutian-ThinkPad-T440p:~$ vault list abs\n    Keys\n    ----\n    airplane\n    hello\n    my-secret\n\n- 关闭私密引擎\n\n当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　\n当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。\n\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\n    Success! Disabled the secrets engine (if it existed) at: abs/\n    mutian@mutian-ThinkPad-T440p:~$ vault secrets list\n    Path          Type         Description\n    ----          ----         -----------\n    cubbyhole/    cubbyhole    per-token private secret storage\n    identity/     identity     identity store\n    secret/       kv           key/value secret storage\n    sys/          system       system endpoints used for control, policy and debugging\n    \n上面结果中，已经再看不到私密引擎`abs/`\n\n- 什么是私密引擎（Secrets Engine）\n\n上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？\n\n实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　\n这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　\n\n\n## 动态私密信息保存\n\n\n\n    \n","slug":"vault-study","published":1,"updated":"2018-03-13T01:45:20.782Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5ioms005fd5hs70773f6q","content":"<p>Valut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……</p>\n<p>特性：</p>\n<p>1.安全的私密信息存储 </p>\n<p>2.动态的私密信息支持</p>\n<p>3.提供对于私密信息的更新，延长有效时间的功能</p>\n<p>4.灵活的权限控制</p>\n<p>5.多种客户端登录验证方式</p>\n<p>参考：<br><a href=\"https://www.vaultproject.io/intro/index.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/intro/index.html</a></p>\n<h2 id=\"安装Valut\"><a href=\"#安装Valut\" class=\"headerlink\" title=\"安装Valut\"></a>安装Valut</h2><p>1.下载地址：<a href=\"https://www.vaultproject.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/downloads.html</a></p>\n<p>2.解压<br>解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。</p>\n<p>配置环境变量，把vault可执行文件所在目录添加到环境变量：</p>\n<p><code>export PATH=$PATH:/home/mutian/dev/bin</code></p>\n<p>检验是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \nUsage: vault &lt;command&gt; [args]\n\nCommon commands:\n    read        Read data and retrieves secrets\n    write       Write data, configuration, and secrets\n    delete      Delete secrets and configuration\n    list        List data or secrets\n    login       Authenticate locally\n    server      Start a Vault server\n    status      Print seal and HA status\n    unwrap      Unwrap a wrapped secret\n\nOther commands:\n    audit          Interact with audit devices\n    auth           Interact with auth methods\n    lease          Interact with leases\n    operator       Perform operator-specific tasks\n    path-help      Retrieve API help for paths\n    policy         Interact with policies\n    secrets        Interact with secrets engines\n    ssh            Initiate an SSH session\n    token          Interact with tokens\n</code></pre><p>表示环境变量添加准确，已经安装成功。</p>\n<p>3.install completions</p>\n<pre><code>$ vault -autocomplete-install\n</code></pre><p>然后重新启动shell窗口，输入命令<code>vault</code>，然后按Tab键，将出现命令参数提示。如下：    </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \naudit      lease      operator   read       ssh        unwrap     \nauth       list       path-help  secrets    status     write      \ndelete     login      policy     server     token      \nmutian@mutian-ThinkPad-T440p:~$ vault \n</code></pre><p>##　启动服务</p>\n<h4 id=\"启动开发环境\"><a href=\"#启动开发环境\" class=\"headerlink\" title=\"启动开发环境\"></a>启动开发环境</h4><p>开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n==&gt; Vault server configuration:\n\n                     Cgo: disabled\n         Cluster Address: https://127.0.0.1:8201\n              Listener 1: tcp (addr: &quot;127.0.0.1:8200&quot;, cluster address: &quot;127.0.0.1:8201&quot;, tls: &quot;disabled&quot;)\n               Log Level: info\n                   Mlock: supported: true, enabled: false\n        Redirect Address: http://127.0.0.1:8200\n                 Storage: inmem\n                 Version: Vault v0.9.5\n             Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\nand starts unsealed with a single unseal key. The root token is already\nauthenticated to the CLI, so you can immediately begin using Vault.\n\nYou may need to set the following environment variable:\n\n    $ export VAULT_ADDR=&apos;http://127.0.0.1:8200&apos;\n\nThe unseal key and root token are displayed below in case you want to\nseal/unseal the Vault or re-authenticate.\n\nUnseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\nRoot Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n\nDevelopment mode should NOT be used in production installations!\n\n==&gt; Vault server started! Log data will stream in below:\n</code></pre><p>看到上面内容说明已经启动成功，在前台运行的。</p>\n<p>验证服务是否在成功运行：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status \nError checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：</p>\n<pre><code>export VAULT_ADDR=http://127.0.0.1:8200\n</code></pre><p>再次查看vault服务运行状态:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status\nKey             Value\n---             -----\nSeal Type       shamir\nSealed          false\nTotal Shares    1\nThreshold       1\nVersion         0.9.5\nCluster Name    vault-cluster-bcf3f2f8\nCluster ID      c2649684-fe35-3820-983b-f324a51b115c\nHA Enabled      false\n</code></pre><p>看到了上面的内容，则证明服务启动成功。</p>\n<p>为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效，<br>命令：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置vault访问地址</td>\n<td>export VAULT_ADDR=<a href=\"http://127.0.0.1:8200\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8200</a></td>\n<td style=\"text-align:left\">vault命令作用的vault服务的地址</td>\n</tr>\n<tr>\n<td>设置Vault PATH</td>\n<td>export PATH=$PATH:&lt; vault install path &gt;</td>\n<td style=\"text-align:left\">vault install path：vault安装路径</td>\n</tr>\n<tr>\n<td>设置访问token</td>\n<td>export VAULT_TOKEN=&lt; token &gt;</td>\n<td style=\"text-align:left\">token：登录vault时的token，首次登录可使用root token</td>\n</tr>\n<tr>\n<td>设置是否跳过核查</td>\n<td>export VAULT_SKIP_VERIFY=false</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n<tr>\n<td>设置访问证书</td>\n<td>export VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>保存私密信息</li>\n</ul>\n<p>下面是简单的写入信息命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\nSuccess! Data written to: secret/hello\n</code></pre><p>这会把键值对信息写入到路劲<code>secret/hello</code>中。　键为value,值为world。</p>\n<p>也可以一次性写入多个键值保存：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n</code></pre><ul>\n<li>读取私密信息</li>\n</ul>\n<p>显示该路径下所有保存键值对：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \nKey                 Value\n---                 -----\nrefresh_interval    768h\nexcited             yes\nvalue               world    \n</code></pre><p>获取单个的值：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\nworld\n</code></pre><ul>\n<li>删除路径下键值</li>\n</ul>\n<p>删除所有：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \nSuccess! Data deleted (if it existed) at: secret/hello\nmutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\nNo value found at secret/hello\n</code></pre><p>看上面命令，说明已经把保存到路径<code>secret/hello</code>下的键值信息全部删除。</p>\n<h2 id=\"秘密引擎\"><a href=\"#秘密引擎\" class=\"headerlink\" title=\"秘密引擎\"></a>秘密引擎</h2><p>上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径<code>secret/hello</code>下面，这个是默认的。当你试图保存到其他路径下时候，将报错。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\nError writing data to home/mutian/dev: Error making API request.\n\nURL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\nCode: 404. Errors:\n\n* no handler for route &apos;home/mutian/dev&apos;\n</code></pre><p>默认下，在路劲<code>secret/.</code>Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    </p>\n<ul>\n<li><p>开启一个新的kv私密引擎</p>\n<p>  mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv<br>  Success! Enabled the kv secrets engine at: abs/<br>  mutian@mutian-ThinkPad-T440p:~$ vault secrets list<br>  Path          Type         Description</p>\n<hr>\n<p>  abs/          kv           n/a<br>  cubbyhole/    cubbyhole    per-token private secret storage<br>  identity/     identity     identity store<br>  secret/       kv           key/value secret storage<br>  sys/          system       system endpoints used for control, policy and debugging</p>\n</li>\n</ul>\n<p>通过命令<code>vault secrets list</code>可以看到，第一个就是就是我们刚才开启的新私密引擎。</p>\n<p>往该新建私密引擎保存私密信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\nSuccess! Data written to: abs/my-secret\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\nSuccess! Data written to: abs/hello\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\nSuccess! Data written to: abs/airplane\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>查看该私密引擎下所有key</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault list abs\nKeys\n----\nairplane\nhello\nmy-secret\n</code></pre><ul>\n<li>关闭私密引擎</li>\n</ul>\n<p>当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　<br>当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\nSuccess! Disabled the secrets engine (if it existed) at: abs/\nmutian@mutian-ThinkPad-T440p:~$ vault secrets list\nPath          Type         Description\n----          ----         -----------\ncubbyhole/    cubbyhole    per-token private secret storage\nidentity/     identity     identity store\nsecret/       kv           key/value secret storage\nsys/          system       system endpoints used for control, policy and debugging\n</code></pre><p>上面结果中，已经再看不到私密引擎<code>abs/</code></p>\n<ul>\n<li>什么是私密引擎（Secrets Engine）</li>\n</ul>\n<p>上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？</p>\n<p>实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　<br>这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　</p>\n<h2 id=\"动态私密信息保存\"><a href=\"#动态私密信息保存\" class=\"headerlink\" title=\"动态私密信息保存\"></a>动态私密信息保存</h2>","site":{"data":{}},"excerpt":"","more":"<p>Valut是个密码管理工具，用来安全的管理例如数据库、应用程序api等等等的密码……</p>\n<p>特性：</p>\n<p>1.安全的私密信息存储 </p>\n<p>2.动态的私密信息支持</p>\n<p>3.提供对于私密信息的更新，延长有效时间的功能</p>\n<p>4.灵活的权限控制</p>\n<p>5.多种客户端登录验证方式</p>\n<p>参考：<br><a href=\"https://www.vaultproject.io/intro/index.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/intro/index.html</a></p>\n<h2 id=\"安装Valut\"><a href=\"#安装Valut\" class=\"headerlink\" title=\"安装Valut\"></a>安装Valut</h2><p>1.下载地址：<a href=\"https://www.vaultproject.io/downloads.html\" target=\"_blank\" rel=\"noopener\">https://www.vaultproject.io/downloads.html</a></p>\n<p>2.解压<br>解压后只有一个名为vualt的可执行文件。该文件可以安全的移动位置。</p>\n<p>配置环境变量，把vault可执行文件所在目录添加到环境变量：</p>\n<p><code>export PATH=$PATH:/home/mutian/dev/bin</code></p>\n<p>检验是否成功：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \nUsage: vault &lt;command&gt; [args]\n\nCommon commands:\n    read        Read data and retrieves secrets\n    write       Write data, configuration, and secrets\n    delete      Delete secrets and configuration\n    list        List data or secrets\n    login       Authenticate locally\n    server      Start a Vault server\n    status      Print seal and HA status\n    unwrap      Unwrap a wrapped secret\n\nOther commands:\n    audit          Interact with audit devices\n    auth           Interact with auth methods\n    lease          Interact with leases\n    operator       Perform operator-specific tasks\n    path-help      Retrieve API help for paths\n    policy         Interact with policies\n    secrets        Interact with secrets engines\n    ssh            Initiate an SSH session\n    token          Interact with tokens\n</code></pre><p>表示环境变量添加准确，已经安装成功。</p>\n<p>3.install completions</p>\n<pre><code>$ vault -autocomplete-install\n</code></pre><p>然后重新启动shell窗口，输入命令<code>vault</code>，然后按Tab键，将出现命令参数提示。如下：    </p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault \naudit      lease      operator   read       ssh        unwrap     \nauth       list       path-help  secrets    status     write      \ndelete     login      policy     server     token      \nmutian@mutian-ThinkPad-T440p:~$ vault \n</code></pre><p>##　启动服务</p>\n<h4 id=\"启动开发环境\"><a href=\"#启动开发环境\" class=\"headerlink\" title=\"启动开发环境\"></a>启动开发环境</h4><p>开发环境只用来在本机做开发使用，数据保存在内存，所以千万不能在生产环境使用。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault server -dev\n==&gt; Vault server configuration:\n\n                     Cgo: disabled\n         Cluster Address: https://127.0.0.1:8201\n              Listener 1: tcp (addr: &quot;127.0.0.1:8200&quot;, cluster address: &quot;127.0.0.1:8201&quot;, tls: &quot;disabled&quot;)\n               Log Level: info\n                   Mlock: supported: true, enabled: false\n        Redirect Address: http://127.0.0.1:8200\n                 Storage: inmem\n                 Version: Vault v0.9.5\n             Version Sha: 36edb4d42380d89a897e7f633046423240b710d9\n\nWARNING! dev mode is enabled! In this mode, Vault runs entirely in-memory\nand starts unsealed with a single unseal key. The root token is already\nauthenticated to the CLI, so you can immediately begin using Vault.\n\nYou may need to set the following environment variable:\n\n    $ export VAULT_ADDR=&apos;http://127.0.0.1:8200&apos;\n\nThe unseal key and root token are displayed below in case you want to\nseal/unseal the Vault or re-authenticate.\n\nUnseal Key: CHZrUesD0FeIHV/5lzkeKehzYh+pNjd0GH5wzG0VjSE=\nRoot Token: 182a4bb0-1165-a049-6e7a-e0dbef229a28\n\nDevelopment mode should NOT be used in production installations!\n\n==&gt; Vault server started! Log data will stream in below:\n</code></pre><p>看到上面内容说明已经启动成功，在前台运行的。</p>\n<p>验证服务是否在成功运行：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status \nError checking seal status: Get https://127.0.0.1:8200/v1/sys/seal-status: http: server gave HTTP response to HTTPS client\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>看到以上提示：错误，所以启动没成功。因为没配置回环访问。执行如下命令：</p>\n<pre><code>export VAULT_ADDR=http://127.0.0.1:8200\n</code></pre><p>再次查看vault服务运行状态:</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault status\nKey             Value\n---             -----\nSeal Type       shamir\nSealed          false\nTotal Shares    1\nThreshold       1\nVersion         0.9.5\nCluster Name    vault-cluster-bcf3f2f8\nCluster ID      c2649684-fe35-3820-983b-f324a51b115c\nHA Enabled      false\n</code></pre><p>看到了上面的内容，则证明服务启动成功。</p>\n<p>为了方便CLI使用vault命令，建议配置环境变量；安全起见，建议设置环境变量只在当前客户端生效，<br>命令：</p>\n<table>\n<thead>\n<tr>\n<th>功能</th>\n<th>命令</th>\n<th style=\"text-align:left\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>设置vault访问地址</td>\n<td>export VAULT_ADDR=<a href=\"http://127.0.0.1:8200\" target=\"_blank\" rel=\"noopener\">http://127.0.0.1:8200</a></td>\n<td style=\"text-align:left\">vault命令作用的vault服务的地址</td>\n</tr>\n<tr>\n<td>设置Vault PATH</td>\n<td>export PATH=$PATH:&lt; vault install path &gt;</td>\n<td style=\"text-align:left\">vault install path：vault安装路径</td>\n</tr>\n<tr>\n<td>设置访问token</td>\n<td>export VAULT_TOKEN=&lt; token &gt;</td>\n<td style=\"text-align:left\">token：登录vault时的token，首次登录可使用root token</td>\n</tr>\n<tr>\n<td>设置是否跳过核查</td>\n<td>export VAULT_SKIP_VERIFY=false</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n<tr>\n<td>设置访问证书</td>\n<td>export VAULT_CAPATH=/usr/local/vault/work/ca/certs/ca.cert.pem</td>\n<td style=\"text-align:left\">使用TSL访问时需要设置，未使用证书忽略此项</td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>保存私密信息</li>\n</ul>\n<p>下面是简单的写入信息命令：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world\nSuccess! Data written to: secret/hello\n</code></pre><p>这会把键值对信息写入到路劲<code>secret/hello</code>中。　键为value,值为world。</p>\n<p>也可以一次性写入多个键值保存：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write secret/hello value=world excited=yesSuccess! Data written to: secret/hello\n</code></pre><ul>\n<li>读取私密信息</li>\n</ul>\n<p>显示该路径下所有保存键值对：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read secret/hello \nKey                 Value\n---                 -----\nrefresh_interval    768h\nexcited             yes\nvalue               world    \n</code></pre><p>获取单个的值：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault read -field value secret/hello\nworld\n</code></pre><ul>\n<li>删除路径下键值</li>\n</ul>\n<p>删除所有：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault delete secret/hello \nSuccess! Data deleted (if it existed) at: secret/hello\nmutian@mutian-ThinkPad-T440p:~$ vault read secret/hello\nNo value found at secret/hello\n</code></pre><p>看上面命令，说明已经把保存到路径<code>secret/hello</code>下的键值信息全部删除。</p>\n<h2 id=\"秘密引擎\"><a href=\"#秘密引擎\" class=\"headerlink\" title=\"秘密引擎\"></a>秘密引擎</h2><p>上面内容中，我们知道怎么保存信息，读取信息，删除信息，但是注意到没，只能保存到路径<code>secret/hello</code>下面，这个是默认的。当你试图保存到其他路径下时候，将报错。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write ~/dev name=zmt\nError writing data to home/mutian/dev: Error making API request.\n\nURL: PUT http://127.0.0.1:8200/v1/home/mutian/dev\nCode: 404. Errors:\n\n* no handler for route &apos;home/mutian/dev&apos;\n</code></pre><p>默认下，在路劲<code>secret/.</code>Vault开启一个ｋｖ引擎。这个ｋｖ引擎可写入，读取数据到后台存储。    </p>\n<ul>\n<li><p>开启一个新的kv私密引擎</p>\n<p>  mutian@mutian-ThinkPad-T440p:~$ vault secrets enable -path=abs kv<br>  Success! Enabled the kv secrets engine at: abs/<br>  mutian@mutian-ThinkPad-T440p:~$ vault secrets list<br>  Path          Type         Description</p>\n<hr>\n<p>  abs/          kv           n/a<br>  cubbyhole/    cubbyhole    per-token private secret storage<br>  identity/     identity     identity store<br>  secret/       kv           key/value secret storage<br>  sys/          system       system endpoints used for control, policy and debugging</p>\n</li>\n</ul>\n<p>通过命令<code>vault secrets list</code>可以看到，第一个就是就是我们刚才开启的新私密引擎。</p>\n<p>往该新建私密引擎保存私密信息：</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault write abs/my-secret name=zmt\nSuccess! Data written to: abs/my-secret\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/hello target=world\nSuccess! Data written to: abs/hello\nmutian@mutian-ThinkPad-T440p:~$ vault write abs/airplane type=boeing class=787\nSuccess! Data written to: abs/airplane\nmutian@mutian-ThinkPad-T440p:~$ \n</code></pre><p>查看该私密引擎下所有key</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault list abs\nKeys\n----\nairplane\nhello\nmy-secret\n</code></pre><ul>\n<li>关闭私密引擎</li>\n</ul>\n<p>当一个私密引擎不再使用的话，我们就可以调用命令来停用它。　　<br>当停用一个私密引擎的时候，该私密引擎将撤销，对应的保存的私密信息将会被移除。</p>\n<pre><code>mutian@mutian-ThinkPad-T440p:~$ vault secrets disable abs/\nSuccess! Disabled the secrets engine (if it existed) at: abs/\nmutian@mutian-ThinkPad-T440p:~$ vault secrets list\nPath          Type         Description\n----          ----         -----------\ncubbyhole/    cubbyhole    per-token private secret storage\nidentity/     identity     identity store\nsecret/       kv           key/value secret storage\nsys/          system       system endpoints used for control, policy and debugging\n</code></pre><p>上面结果中，已经再看不到私密引擎<code>abs/</code></p>\n<ul>\n<li>什么是私密引擎（Secrets Engine）</li>\n</ul>\n<p>上面我们学会了如何启动停止一个私密引擎，那私密引擎到底是个什么东西呢？</p>\n<p>实际上，私密引擎就类似一个虚拟文件系统，所有的read/write/delete/list操作都在它下面进行，然后私密引擎自己决定如何来响应请求。　<br>这是一种抽象，这种抽象具有强大的作用，它提供统一的接口，直接面对物理系统、数据库等，除此之外，一些独特的环境如AWS IAM、动态sql等，都可以统一使用增删改查这些操作接口。　</p>\n<h2 id=\"动态私密信息保存\"><a href=\"#动态私密信息保存\" class=\"headerlink\" title=\"动态私密信息保存\"></a>动态私密信息保存</h2>"},{"title":"网站的高性能","date":"2017-10-13T02:33:45.000Z","_content":"_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","source":"_posts/website-high-performance.md","raw":"---\ntitle: 网站的高性能\ndate: 2017-10-13 10:33:45\ncategories: 架构\ntags: website-high-performance\n---\n_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","slug":"website-high-performance","published":1,"updated":"2017-12-31T09:13:45.514Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjgz5iomu005hd5hs6m5ai3le","content":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n</blockquote>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol>\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol>\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol>\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol>\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>","site":{"data":{}},"excerpt":"","more":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n</blockquote>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol>\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol>\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol>\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol>\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>"}],"PostAsset":[{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","post":"cjgz5ioi20002d5hsvootadju","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/apidoc-java/a.png","post":"cjgz5ioig0006d5hsper78l2o","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/distributed-id-snowflake/a.png","post":"cjgz5ioiz000jd5hsiklu902w","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-install-centos7/a.png","post":"cjgz5ioj2000nd5hsc3np1na9","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-install-ubuntu16/a.png","post":"cjgz5ioj8000td5hshrd3mb5s","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","post":"cjgz5iojj001cd5hsejdsslrs","slug":"favicon.ico","modified":1,"renderable":1},{"_id":"source/_posts/hashicorp-vault/a.png","post":"cjgz5iojl001ed5hslddgnmv4","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/microservice-think/a.png","post":"cjgz5iokv0032d5hs5bjm5u6b","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/redis-cluster-centos/a.png","post":"cjgz5iol7003jd5hszrsjybvf","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/restful-api-dev/a.png","post":"cjgz5iolo003sd5hsu2rfi2z0","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/sboot-change-contextpath/a.png","post":"cjgz5iolq003xd5hsetouiusx","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","post":"cjgz5iolu0042d5hse0ad8884","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-exception/a.png","post":"cjgz5iom3004fd5hs9saphbde","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-filters/a.png","post":"cjgz5iom4004hd5hs8ble8dpf","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-start/a.png","post":"cjgz5iom6004kd5hsulw7xu50","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/spring-boot-dev-error-show/a.png","post":"cjgz5iomb004sd5hsmmn6dyl7","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/website-high-performance/favicon.ico","post":"cjgz5iomu005hd5hs6m5ai3le","slug":"favicon.ico","modified":1,"renderable":1},{"_id":"source/_posts/http-protocol-overview/a.png","post":"cjgz5iojs001kd5hsn4x434xd","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/http-protocol-overview/b.png","post":"cjgz5iojs001kd5hsn4x434xd","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/javapoet-apt-annotation/a.png","post":"cjgz5iok70021d5hsbz728c5d","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/javapoet-apt-annotation/b.png","post":"cjgz5iok70021d5hsbz728c5d","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/linux-command-use/a.png","post":"cjgz5ioko002qd5hsoh39cdw8","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/linux-command-use/b.png","post":"cjgz5ioko002qd5hsoh39cdw8","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/maven-ofen/a.jpg","post":"cjgz5ioks002wd5hsr3d77fch","slug":"a.jpg","modified":1,"renderable":1},{"_id":"source/_posts/maven-ofen/b.jpg","post":"cjgz5ioks002wd5hsr3d77fch","slug":"b.jpg","modified":1,"renderable":1},{"_id":"source/_posts/spring-boot-filter/a.png","post":"cjgz5iomj0054d5hslymddbti","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/spring-boot-filter/b.png","post":"cjgz5iomj0054d5hslymddbti","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3/a.png","post":"cjgz5iojb000yd5hs0cd4zdwu","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3/b.png","post":"cjgz5iojb000yd5hs0cd4zdwu","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-lesson3/c.png","post":"cjgz5iojb000yd5hs0cd4zdwu","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/a.png","post":"cjgz5ioky0038d5hs9hvm1h0g","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/b.png","slug":"b.png","post":"cjgz5ioky0038d5hs9hvm1h0g","modified":1,"renderable":0},{"_id":"source/_posts/pivotal-web-service-start/c.png","post":"cjgz5ioky0038d5hs9hvm1h0g","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/d.png","post":"cjgz5ioky0038d5hs9hvm1h0g","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/a.png","post":"cjgz5iohs0000d5hsdhuvyf75","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/b.png","post":"cjgz5iohs0000d5hsdhuvyf75","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/c.png","post":"cjgz5iohs0000d5hsdhuvyf75","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/d.png","post":"cjgz5iohs0000d5hsdhuvyf75","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/api-version/e.png","post":"cjgz5iohs0000d5hsdhuvyf75","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/Shadowsocks-4.0.6.zip","slug":"Shadowsocks-4.0.6.zip","post":"cjgz5iom8004nd5hsp177448e","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/Shadowsocks_v4.2.5_apkpure.com.apk","slug":"Shadowsocks_v4.2.5_apkpure.com.apk","post":"cjgz5iom8004nd5hsp177448e","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/a.png","post":"cjgz5iom8004nd5hsp177448e","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/b.png","post":"cjgz5iom8004nd5hsp177448e","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/client.tar.gz","slug":"client.tar.gz","post":"cjgz5iom8004nd5hsp177448e","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/go1.9.2.linux-amd64.tar.gz","slug":"go1.9.2.linux-amd64.tar.gz","post":"cjgz5iom8004nd5hsp177448e","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/server.tar.gz","slug":"server.tar.gz","post":"cjgz5iom8004nd5hsp177448e","modified":1,"renderable":0},{"_id":"source/_posts/idea-file-template/a.png","post":"cjgz5iojz001qd5hs1s7k68p6","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/b.png","post":"cjgz5iojz001qd5hs1s7k68p6","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/c.png","post":"cjgz5iojz001qd5hs1s7k68p6","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/d.png","post":"cjgz5iojz001qd5hs1s7k68p6","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/e.png","post":"cjgz5iojz001qd5hs1s7k68p6","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/f.png","post":"cjgz5iojz001qd5hs1s7k68p6","slug":"f.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/g.png","post":"cjgz5iojz001qd5hs1s7k68p6","slug":"g.png","modified":1,"renderable":1},{"_id":"source/_posts/idea-file-template/j.png","post":"cjgz5iojz001qd5hs1s7k68p6","slug":"j.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/a.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/b.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/c.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/d.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/e.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/f.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"f.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/g.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"g.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/h.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"h.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/i.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"i.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/j.png","post":"cjgz5ioip000bd5hskszbrp04","slug":"j.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/1.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/10.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/11.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/12.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/13.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/14.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/15.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"15.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/2.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/3.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/4.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/5.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/6.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/7.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/8.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/8_1.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"8_1.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/9.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"9.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/a.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/b.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/c.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/e.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/f.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"f.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/g.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"g.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/h.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"h.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/i.png","post":"cjgz5ioke002bd5hscszrscjw","slug":"i.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjgz5ioig0006d5hsper78l2o","category_id":"cjgz5ioi50003d5hsi2f3sua3","_id":"cjgz5ioix000dd5hs3wj71q7p"},{"post_id":"cjgz5iohs0000d5hsdhuvyf75","category_id":"cjgz5ioi50003d5hsi2f3sua3","_id":"cjgz5ioiz000hd5hsuhamrpir"},{"post_id":"cjgz5ioi20002d5hsvootadju","category_id":"cjgz5ioil0008d5hs8iof58re","_id":"cjgz5ioj1000kd5hs9q77m5ov"},{"post_id":"cjgz5ioi80005d5hsr3sg5wb7","category_id":"cjgz5ioix000ed5hsyuvqxigz","_id":"cjgz5ioj7000rd5hsamx95jb0"},{"post_id":"cjgz5ioik0007d5hszih6pgms","category_id":"cjgz5ioix000ed5hsyuvqxigz","_id":"cjgz5ioja000xd5hszjrx3eht"},{"post_id":"cjgz5ioip000bd5hskszbrp04","category_id":"cjgz5ioix000ed5hsyuvqxigz","_id":"cjgz5iojd0012d5hsh4iekbfk"},{"post_id":"cjgz5ioiv000cd5hs004sfanh","category_id":"cjgz5ioja000wd5hsw5r95dpj","_id":"cjgz5iojh0018d5hsdg527vsa"},{"post_id":"cjgz5ioiy000gd5hsbpo3msdm","category_id":"cjgz5iojd0013d5hs2efk1xu7","_id":"cjgz5iojn001gd5hsrqm1w08z"},{"post_id":"cjgz5ioiz000jd5hsiklu902w","category_id":"cjgz5iojd0013d5hs2efk1xu7","_id":"cjgz5iojv001ld5hsld4dtnlp"},{"post_id":"cjgz5ioj2000nd5hsc3np1na9","category_id":"cjgz5iojn001fd5hswcs90oyd","_id":"cjgz5iok0001rd5hsnttor6qy"},{"post_id":"cjgz5ioj4000pd5hsl3nkzhz4","category_id":"cjgz5iojw001md5hsvzpgg6bp","_id":"cjgz5iok5001yd5hs95vvbocw"},{"post_id":"cjgz5ioj8000td5hshrd3mb5s","category_id":"cjgz5iojn001fd5hswcs90oyd","_id":"cjgz5iok90024d5hsz86ganbf"},{"post_id":"cjgz5ioj9000vd5hsk4a9ogzv","category_id":"cjgz5iojn001fd5hswcs90oyd","_id":"cjgz5ioke0029d5hsatstihj9"},{"post_id":"cjgz5ioka0025d5hs9zl0fhwh","category_id":"cjgz5ioja000wd5hsw5r95dpj","_id":"cjgz5iokg002dd5hs7ue9wot5"},{"post_id":"cjgz5iojb000yd5hs0cd4zdwu","category_id":"cjgz5iojn001fd5hswcs90oyd","_id":"cjgz5ioki002id5hskph767v4"},{"post_id":"cjgz5iokc0027d5hs2kn2c83j","category_id":"cjgz5ioja000wd5hsw5r95dpj","_id":"cjgz5iokk002kd5hsytr9074r"},{"post_id":"cjgz5iojc0011d5hscnuylg8l","category_id":"cjgz5iokd0028d5hs0oo23m03","_id":"cjgz5iokn002nd5hsq9hjl4ub"},{"post_id":"cjgz5ioje0014d5hs4a9z3to6","category_id":"cjgz5iokh002fd5hs10k64e62","_id":"cjgz5ioks002ud5hs3l37yenl"},{"post_id":"cjgz5iojg0016d5hsypx5goxp","category_id":"cjgz5iojn001fd5hswcs90oyd","_id":"cjgz5iokv0030d5hsczqh8t9q"},{"post_id":"cjgz5iojh0019d5hs9qurwwee","category_id":"cjgz5iokh002fd5hs10k64e62","_id":"cjgz5iokx0034d5hs051uxeal"},{"post_id":"cjgz5iojj001cd5hsejdsslrs","category_id":"cjgz5iokv002zd5hsw66fyvm3","_id":"cjgz5iol0003ad5hse4o9zafq"},{"post_id":"cjgz5iojl001ed5hslddgnmv4","category_id":"cjgz5ioky0036d5hs3wt203qn","_id":"cjgz5iol6003gd5hsouow5vxv"},{"post_id":"cjgz5iojp001id5hs8i3y4dhf","category_id":"cjgz5iol1003cd5hsan8rdjq1","_id":"cjgz5ioli003md5hslzxbgdhk"},{"post_id":"cjgz5iojs001kd5hsn4x434xd","category_id":"cjgz5iol7003id5hspfui0dde","_id":"cjgz5iolp003td5hs7557mjkt"},{"post_id":"cjgz5iojx001nd5hs6q7fs4ye","category_id":"cjgz5iolm003pd5hsbfrgibwq","_id":"cjgz5iols0040d5hsls4xy03n"},{"post_id":"cjgz5iolo003sd5hsu2rfi2z0","category_id":"cjgz5ioi50003d5hsi2f3sua3","_id":"cjgz5iolx0044d5hs7p2gue5h"},{"post_id":"cjgz5iojz001qd5hs1s7k68p6","category_id":"cjgz5iolm003pd5hsbfrgibwq","_id":"cjgz5ioly0047d5hs38931x72"},{"post_id":"cjgz5iok1001td5hsnchgs9g8","category_id":"cjgz5iolm003pd5hsbfrgibwq","_id":"cjgz5iom2004cd5hszigyakdv"},{"post_id":"cjgz5iok3001vd5hs6sw3jl0o","category_id":"cjgz5ioly0046d5hs55v4loxe","_id":"cjgz5iom5004id5hs34adiddi"},{"post_id":"cjgz5iok5001zd5hsrp5fcrs2","category_id":"cjgz5iom3004dd5hsv7o826h0","_id":"cjgz5ioma004od5hsazj0khby"},{"post_id":"cjgz5iok70021d5hsbz728c5d","category_id":"cjgz5iom5004jd5hscgv4rkoz","_id":"cjgz5iome004vd5hsqa5lg916"},{"post_id":"cjgz5ioke002bd5hscszrscjw","category_id":"cjgz5iomb004qd5hs7i387ux2","_id":"cjgz5iomj0051d5hssz6fgc8m"},{"post_id":"cjgz5iokf002cd5hsagwz6ewx","category_id":"cjgz5iome004wd5hsz43wi7lq","_id":"cjgz5iomo0058d5hsepuwyf7i"},{"post_id":"cjgz5iokh002hd5hsz4qfk7v4","category_id":"cjgz5iome004wd5hsz43wi7lq","_id":"cjgz5iomr005dd5hs8r7q496t"},{"post_id":"cjgz5iokl002md5hsvivmq5p6","category_id":"cjgz5iomn0057d5hsb6hr0end","_id":"cjgz5iomv005jd5hsyrrual8z"},{"post_id":"cjgz5ioko002qd5hsoh39cdw8","category_id":"cjgz5iomr005ed5hshghghif6","_id":"cjgz5iomw005nd5hs6sl0ue87"},{"post_id":"cjgz5iokq002sd5hs52a7200h","category_id":"cjgz5iomv005kd5hsamoqolpu","_id":"cjgz5iomw005rd5hsn28eoll7"},{"post_id":"cjgz5ioks002wd5hsr3d77fch","category_id":"cjgz5iomw005od5hsjwab1z58","_id":"cjgz5iomx005wd5hsxk2q5v8r"},{"post_id":"cjgz5ioku002yd5hsavzbnexw","category_id":"cjgz5iomw005od5hsjwab1z58","_id":"cjgz5iomx005zd5hs6uy3vmfn"},{"post_id":"cjgz5iokv0032d5hs5bjm5u6b","category_id":"cjgz5iomx005vd5hs2x7shkta","_id":"cjgz5iomz0063d5hs30qkt06e"},{"post_id":"cjgz5iokx0033d5hsixicivo4","category_id":"cjgz5iomx0060d5hsgqyzzvqt","_id":"cjgz5ion00067d5hsv9otpi1l"},{"post_id":"cjgz5ioky0038d5hs9hvm1h0g","category_id":"cjgz5iomz0064d5hsn5vq6g7c","_id":"cjgz5ion1006cd5hsmfr8ys34"},{"post_id":"cjgz5iokz0039d5hs158e9nw7","category_id":"cjgz5iomx0060d5hsgqyzzvqt","_id":"cjgz5ion1006fd5hs5ch2xd4x"},{"post_id":"cjgz5iol1003dd5hsu7ts2ug3","category_id":"cjgz5ion1006bd5hs0286wv4q","_id":"cjgz5ion2006kd5hslvbb1rv9"},{"post_id":"cjgz5iol3003fd5hsyfs3e2t9","category_id":"cjgz5ion1006bd5hs0286wv4q","_id":"cjgz5ion2006md5hskyot9p7h"},{"post_id":"cjgz5iol7003jd5hszrsjybvf","category_id":"cjgz5ion2006jd5hsuleklzzw","_id":"cjgz5ion3006rd5hsrapm1vwv"},{"post_id":"cjgz5iol9003ld5hssl56pkcq","category_id":"cjgz5ion2006jd5hsuleklzzw","_id":"cjgz5ion4006vd5hsb3d416l0"},{"post_id":"cjgz5iolj003od5hsinjds2bo","category_id":"cjgz5ion2006jd5hsuleklzzw","_id":"cjgz5ion5006zd5hs9p6is74u"},{"post_id":"cjgz5iolm003rd5hskqlzs1s9","category_id":"cjgz5ion2006jd5hsuleklzzw","_id":"cjgz5ion50071d5hseau5o57o"},{"post_id":"cjgz5iolq003xd5hsetouiusx","category_id":"cjgz5ion5006yd5hsj1i9zobf","_id":"cjgz5ion70075d5hs8q3k1yk6"},{"post_id":"cjgz5iolr003yd5hsk31v189v","category_id":"cjgz5ion60073d5hsajv7jygz","_id":"cjgz5ion8007ad5hsgtdd0nht"},{"post_id":"cjgz5iolu0042d5hse0ad8884","category_id":"cjgz5ion60073d5hsajv7jygz","_id":"cjgz5ion9007ed5hshn09a5ti"},{"post_id":"cjgz5iolx0045d5hsp9821ly0","category_id":"cjgz5ion60073d5hsajv7jygz","_id":"cjgz5ion9007id5hs6r6c7ujy"},{"post_id":"cjgz5iolz0049d5hscg8mpnir","category_id":"cjgz5ion60073d5hsajv7jygz","_id":"cjgz5ionb007md5hsw0vkul78"},{"post_id":"cjgz5iom1004bd5hsskyd58a7","category_id":"cjgz5ion60073d5hsajv7jygz","_id":"cjgz5ionc007qd5hsoqvteavl"},{"post_id":"cjgz5iom3004fd5hs9saphbde","category_id":"cjgz5ion60073d5hsajv7jygz","_id":"cjgz5iond007ud5hso77c0axj"},{"post_id":"cjgz5iom4004hd5hs8ble8dpf","category_id":"cjgz5ion60073d5hsajv7jygz","_id":"cjgz5iond007xd5hs09f65njr"},{"post_id":"cjgz5iom6004kd5hsulw7xu50","category_id":"cjgz5ion60073d5hsajv7jygz","_id":"cjgz5ione0080d5hsixebptiy"},{"post_id":"cjgz5iom8004nd5hsp177448e","category_id":"cjgz5iond007wd5hszveywkwt","_id":"cjgz5ionf0085d5hsinf33nqh"},{"post_id":"cjgz5ioma004pd5hs18fh0vzy","category_id":"cjgz5ion5006yd5hsj1i9zobf","_id":"cjgz5ionf0089d5hs4prrhp8m"},{"post_id":"cjgz5iomb004sd5hsmmn6dyl7","category_id":"cjgz5ion5006yd5hsj1i9zobf","_id":"cjgz5iong008cd5hsllsmosey"},{"post_id":"cjgz5iomc004ud5hswe9ehqi1","category_id":"cjgz5ion5006yd5hsj1i9zobf","_id":"cjgz5ionh008gd5hss1dfkjcg"},{"post_id":"cjgz5iomf004yd5hshpcfjaid","category_id":"cjgz5ion5006yd5hsj1i9zobf","_id":"cjgz5ioni008kd5hsn03rb03k"},{"post_id":"cjgz5iomg0050d5hso30har4a","category_id":"cjgz5ion5006yd5hsj1i9zobf","_id":"cjgz5ioni008od5hstxqzgrad"},{"post_id":"cjgz5iomj0054d5hslymddbti","category_id":"cjgz5ion5006yd5hsj1i9zobf","_id":"cjgz5ionj008rd5hsjr2rnyud"},{"post_id":"cjgz5ioml0056d5hswgsexojh","category_id":"cjgz5ioni008nd5hs1l3gwuut","_id":"cjgz5ionj008vd5hsu8a4e829"},{"post_id":"cjgz5iomo0059d5hs04v56qn3","category_id":"cjgz5ionj008sd5hsiiefim0l","_id":"cjgz5ionk008zd5hs2i02ibse"},{"post_id":"cjgz5iomq005cd5hsc85skwcr","category_id":"cjgz5ionj008wd5hsontxer7d","_id":"cjgz5ionl0093d5hs8les33fb"},{"post_id":"cjgz5ioms005fd5hs70773f6q","category_id":"cjgz5ionk0090d5hs541jwkfk","_id":"cjgz5ionl0097d5hs0zjw9a2i"},{"post_id":"cjgz5iomu005hd5hs6m5ai3le","category_id":"cjgz5ionl0094d5hs1ze4e2gm","_id":"cjgz5ionm009ad5hsga81hbiu"}],"PostTag":[{"post_id":"cjgz5iohs0000d5hsdhuvyf75","tag_id":"cjgz5ioi80004d5hsdhayu1kw","_id":"cjgz5ioip000ad5hs77z1ylkn"},{"post_id":"cjgz5ioi20002d5hsvootadju","tag_id":"cjgz5ioil0009d5hskj20njwa","_id":"cjgz5ioiz000id5hsg4jj97ej"},{"post_id":"cjgz5ioi80005d5hsr3sg5wb7","tag_id":"cjgz5ioix000fd5hsancy4g2w","_id":"cjgz5ioj4000od5hs5vxegv1z"},{"post_id":"cjgz5ioig0006d5hsper78l2o","tag_id":"cjgz5ioj1000md5hssf09rk9k","_id":"cjgz5ioj9000ud5hs1ebnkh36"},{"post_id":"cjgz5ioik0007d5hszih6pgms","tag_id":"cjgz5ioj7000sd5hsumeutxyn","_id":"cjgz5iojc0010d5hsj9ygbvww"},{"post_id":"cjgz5ioip000bd5hskszbrp04","tag_id":"cjgz5iojc000zd5hsx7vjdlyq","_id":"cjgz5iojh0017d5hsg8pxds2t"},{"post_id":"cjgz5ioiv000cd5hs004sfanh","tag_id":"cjgz5iojf0015d5hsup9h0zz7","_id":"cjgz5iojl001dd5hs2l5ddlw9"},{"post_id":"cjgz5ioiy000gd5hsbpo3msdm","tag_id":"cjgz5ioji001bd5hsnpk2dexm","_id":"cjgz5iojr001jd5hsn8oyxhfc"},{"post_id":"cjgz5ioiz000jd5hsiklu902w","tag_id":"cjgz5iojo001hd5hsl6cnzwfk","_id":"cjgz5iojz001pd5hsybhdpuh7"},{"post_id":"cjgz5ioj2000nd5hsc3np1na9","tag_id":"cjgz5iojy001od5hschpiivn2","_id":"cjgz5iok4001wd5hs8nnctlh4"},{"post_id":"cjgz5ioj4000pd5hsl3nkzhz4","tag_id":"cjgz5iok3001ud5hsozw9xpll","_id":"cjgz5iok90022d5hsz83ltz4r"},{"post_id":"cjgz5ioj8000td5hshrd3mb5s","tag_id":"cjgz5iok70020d5hs8b3au1ei","_id":"cjgz5ioke002ad5hs1uau1em8"},{"post_id":"cjgz5ioj9000vd5hsk4a9ogzv","tag_id":"cjgz5iokc0026d5hsgqvt5jty","_id":"cjgz5iokh002gd5hs8gydavi9"},{"post_id":"cjgz5iojb000yd5hs0cd4zdwu","tag_id":"cjgz5iokg002ed5hslxwrqy5q","_id":"cjgz5iokn002pd5hsseue10jq"},{"post_id":"cjgz5iojc0011d5hscnuylg8l","tag_id":"cjgz5iokl002ld5hsab9wf9dr","_id":"cjgz5ioks002vd5hsyqhtmiy6"},{"post_id":"cjgz5ioje0014d5hs4a9z3to6","tag_id":"cjgz5iokq002rd5hsup52vt3z","_id":"cjgz5iokv0031d5hs0y5sl8hz"},{"post_id":"cjgz5iojg0016d5hsypx5goxp","tag_id":"cjgz5iokt002xd5hs8afzy4eg","_id":"cjgz5ioky0037d5hsalw4vvq5"},{"post_id":"cjgz5iojh0019d5hs9qurwwee","tag_id":"cjgz5ioky0035d5hsejktnvi8","_id":"cjgz5iol3003ed5hs19w4sjri"},{"post_id":"cjgz5iojj001cd5hsejdsslrs","tag_id":"cjgz5iol1003bd5hsb5jjj39t","_id":"cjgz5iol8003kd5hsvoplzjx1"},{"post_id":"cjgz5iojl001ed5hslddgnmv4","tag_id":"cjgz5iol6003hd5hsziy79wi7","_id":"cjgz5iolm003qd5hsp6gtk50p"},{"post_id":"cjgz5iojp001id5hs8i3y4dhf","tag_id":"cjgz5iolj003nd5hslqxm3a5s","_id":"cjgz5iolp003wd5hscv6smvmp"},{"post_id":"cjgz5iojs001kd5hsn4x434xd","tag_id":"cjgz5iolp003ud5hs58sfjqme","_id":"cjgz5iolw0043d5hssq28ds5j"},{"post_id":"cjgz5iojx001nd5hs6q7fs4ye","tag_id":"cjgz5iols0041d5hsdh6xtf0x","_id":"cjgz5iom0004ad5hs132huy8k"},{"post_id":"cjgz5iojz001qd5hs1s7k68p6","tag_id":"cjgz5ioly0048d5hsoynft5lc","_id":"cjgz5iom4004gd5hsqs6gyzh7"},{"post_id":"cjgz5iok1001td5hsnchgs9g8","tag_id":"cjgz5iom3004ed5hs6mnuz534","_id":"cjgz5iom8004md5hswn6jfaqi"},{"post_id":"cjgz5iok3001vd5hs6sw3jl0o","tag_id":"cjgz5iom8004ld5hsqqqhxlti","_id":"cjgz5iomc004td5hsl38t3hqk"},{"post_id":"cjgz5iok5001zd5hsrp5fcrs2","tag_id":"cjgz5iomb004rd5hszkk1nybb","_id":"cjgz5iomg004zd5hs4qvboa8b"},{"post_id":"cjgz5iok70021d5hsbz728c5d","tag_id":"cjgz5iome004xd5hsdt02gjiz","_id":"cjgz5ioml0055d5hsmx8li7lu"},{"post_id":"cjgz5ioka0025d5hs9zl0fhwh","tag_id":"cjgz5iomj0053d5hsula3ktzu","_id":"cjgz5iomq005bd5hs5nu1n581"},{"post_id":"cjgz5iokc0027d5hs2kn2c83j","tag_id":"cjgz5iomq005ad5hsp9bnd7fy","_id":"cjgz5iomv005id5hsa413gww1"},{"post_id":"cjgz5ioke002bd5hscszrscjw","tag_id":"cjgz5iomt005gd5hskoqahvii","_id":"cjgz5iomv005md5hspi220na6"},{"post_id":"cjgz5iokf002cd5hsagwz6ewx","tag_id":"cjgz5iomv005ld5hsqcev0dui","_id":"cjgz5iomw005qd5hsyafqxbse"},{"post_id":"cjgz5iokh002hd5hsz4qfk7v4","tag_id":"cjgz5iomw005pd5hs84sefdzl","_id":"cjgz5iomw005ud5hs9je0uzap"},{"post_id":"cjgz5iokl002md5hsvivmq5p6","tag_id":"cjgz5iomw005td5hsq01cbmga","_id":"cjgz5iomx005yd5hs7v3bfaua"},{"post_id":"cjgz5ioko002qd5hsoh39cdw8","tag_id":"cjgz5iomx005xd5hsmot30aza","_id":"cjgz5iomz0062d5hs5c13m77u"},{"post_id":"cjgz5ioks002wd5hsr3d77fch","tag_id":"cjgz5iomy0061d5hsnyguy1b0","_id":"cjgz5ion00066d5hsp8rki084"},{"post_id":"cjgz5ioku002yd5hsavzbnexw","tag_id":"cjgz5iomz0065d5hs5cpuvpjt","_id":"cjgz5ion1006ad5hst587tb4l"},{"post_id":"cjgz5iokv0032d5hs5bjm5u6b","tag_id":"cjgz5ion00069d5hs80pohlku","_id":"cjgz5ion1006ed5hs755ahn8r"},{"post_id":"cjgz5iokx0033d5hsixicivo4","tag_id":"cjgz5ion1006dd5hsqe2v9s4b","_id":"cjgz5ion2006id5hsq9xeva47"},{"post_id":"cjgz5ioky0038d5hs9hvm1h0g","tag_id":"cjgz5ion2006hd5hsm4xno4xc","_id":"cjgz5ion3006nd5hs8grtbxxh"},{"post_id":"cjgz5iokz0039d5hs158e9nw7","tag_id":"cjgz5ion2006ld5hsg84c1n7c","_id":"cjgz5ion3006sd5hsiy6f2w2f"},{"post_id":"cjgz5iol3003fd5hsyfs3e2t9","tag_id":"cjgz5ion3006pd5hs9fpu5nn8","_id":"cjgz5ion4006wd5hsw28ic0hr"},{"post_id":"cjgz5iol7003jd5hszrsjybvf","tag_id":"cjgz5ion3006td5hsltm6eht2","_id":"cjgz5ion50070d5hst3kyoqe5"},{"post_id":"cjgz5iol9003ld5hssl56pkcq","tag_id":"cjgz5ion5006xd5hs5h0d0ozs","_id":"cjgz5ion70074d5hstc4w0dav"},{"post_id":"cjgz5iolj003od5hsinjds2bo","tag_id":"cjgz5ion50072d5hskftstdku","_id":"cjgz5ion80078d5hs4b2y4sbl"},{"post_id":"cjgz5iolm003rd5hskqlzs1s9","tag_id":"cjgz5ion70076d5hsov63sqvt","_id":"cjgz5ion8007cd5hs8lra7plj"},{"post_id":"cjgz5iolo003sd5hsu2rfi2z0","tag_id":"cjgz5ion8007bd5hs71nz9get","_id":"cjgz5ion9007gd5hs3rzhea6n"},{"post_id":"cjgz5iolq003xd5hsetouiusx","tag_id":"cjgz5ion9007fd5hs4o4kcg2n","_id":"cjgz5ionb007kd5hsl0eta4bf"},{"post_id":"cjgz5iolr003yd5hsk31v189v","tag_id":"cjgz5ion9007jd5hs7dp1c9vf","_id":"cjgz5ionc007od5hsesi5pu1n"},{"post_id":"cjgz5iolu0042d5hse0ad8884","tag_id":"cjgz5ionc007nd5hslebxo614","_id":"cjgz5iond007sd5hsc23yddu7"},{"post_id":"cjgz5iolx0045d5hsp9821ly0","tag_id":"cjgz5ionc007rd5hsxs72556l","_id":"cjgz5iond007yd5hsduynqck7"},{"post_id":"cjgz5iolz0049d5hscg8mpnir","tag_id":"cjgz5iond007vd5hsngwyebnc","_id":"cjgz5ione0082d5hsoko4enfb"},{"post_id":"cjgz5iom1004bd5hsskyd58a7","tag_id":"cjgz5ione007zd5hsussr0wfo","_id":"cjgz5ionf0086d5hsyzgnjl68"},{"post_id":"cjgz5iom3004fd5hs9saphbde","tag_id":"cjgz5ione0083d5hsp5o13xna","_id":"cjgz5ionf008ad5hsea769k5d"},{"post_id":"cjgz5iom4004hd5hs8ble8dpf","tag_id":"cjgz5ionf0087d5hsxswd9jb5","_id":"cjgz5iong008ed5hstmvmvjhv"},{"post_id":"cjgz5iom6004kd5hsulw7xu50","tag_id":"cjgz5iong008dd5hsfi9xqfy5","_id":"cjgz5ionh008id5hsmjr2hljd"},{"post_id":"cjgz5iom8004nd5hsp177448e","tag_id":"cjgz5ionh008hd5hssbmrm5le","_id":"cjgz5ioni008md5hsvuvo0ydf"},{"post_id":"cjgz5ioma004pd5hs18fh0vzy","tag_id":"cjgz5ioni008ld5hsvn8h8d7o","_id":"cjgz5ionj008qd5hsbzbf5wkp"},{"post_id":"cjgz5iomb004sd5hsmmn6dyl7","tag_id":"cjgz5ioni008pd5hsoygrrpn6","_id":"cjgz5ionj008ud5hs162h98rc"},{"post_id":"cjgz5iomc004ud5hswe9ehqi1","tag_id":"cjgz5ionj008td5hsuui2bq73","_id":"cjgz5ionk008yd5hslzwi2e0c"},{"post_id":"cjgz5iomf004yd5hshpcfjaid","tag_id":"cjgz5ionj008xd5hsc57jidtp","_id":"cjgz5ionl0092d5hsiop266gd"},{"post_id":"cjgz5iomg0050d5hso30har4a","tag_id":"cjgz5ionk0091d5hsozbl155a","_id":"cjgz5ionl0096d5hsyxoee4pu"},{"post_id":"cjgz5iomj0054d5hslymddbti","tag_id":"cjgz5ionl0095d5hsk8hok0xk","_id":"cjgz5ionm0099d5hsgciyla3m"},{"post_id":"cjgz5ioml0056d5hswgsexojh","tag_id":"cjgz5ionl0098d5hs9v7e5tu5","_id":"cjgz5ionm009cd5hsjeeuk6d1"},{"post_id":"cjgz5iomq005cd5hsc85skwcr","tag_id":"cjgz5ionm009bd5hs55ljsqxf","_id":"cjgz5ionn009ed5hs4dbaup8h"},{"post_id":"cjgz5ioms005fd5hs70773f6q","tag_id":"cjgz5ionm009dd5hsi9aj9lcm","_id":"cjgz5ionn009gd5hszkofpt4d"},{"post_id":"cjgz5iomu005hd5hs6m5ai3le","tag_id":"cjgz5ionn009fd5hs22nobw69","_id":"cjgz5ionn009hd5hsj4vehvvq"}],"Tag":[{"name":"api-version-manage,spring-boot中API版本迭代管理","_id":"cjgz5ioi80004d5hsdhayu1kw"},{"name":"nginx负载均衡","_id":"cjgz5ioil0009d5hskj20njwa"},{"name":"centos-jdk8-install","_id":"cjgz5ioix000fd5hsancy4g2w"},{"name":"apidoc","_id":"cjgz5ioj1000md5hssf09rk9k"},{"name":"centos登录","_id":"cjgz5ioj7000sd5hsumeutxyn"},{"name":"centos-nexus","_id":"cjgz5iojc000zd5hsx7vjdlyq"},{"name":"cron-grammar","_id":"cjgz5iojf0015d5hsup9h0zz7"},{"name":"distributed-difficulty","_id":"cjgz5ioji001bd5hsnpk2dexm"},{"name":"snowflake算法","_id":"cjgz5iojo001hd5hsl6cnzwfk"},{"name":"centos-docker-install","_id":"cjgz5iojy001od5hschpiivn2"},{"name":"持续集成交付","_id":"cjgz5iok3001ud5hsozw9xpll"},{"name":"docker ce安装","_id":"cjgz5iok70020d5hs8b3au1ei"},{"name":"基础概念","_id":"cjgz5iokc0026d5hsgqvt5jty"},{"name":"docker镜像","_id":"cjgz5iokg002ed5hslxwrqy5q"},{"name":"fastdfs-安装使用","_id":"cjgz5iokl002ld5hsab9wf9dr"},{"name":"git-install-in-centos","_id":"cjgz5iokq002rd5hsup52vt3z"},{"name":"docker镜像创建、docker容器启动、docker发布web应用","_id":"cjgz5iokt002xd5hs8afzy4eg"},{"name":"git-server-build","_id":"cjgz5ioky0035d5hsejktnvi8"},{"name":"github-fork-repo-update","_id":"cjgz5iol1003bd5hsb5jjj39t"},{"name":"hashicorp-vault","_id":"cjgz5iol6003hd5hsziy79wi7"},{"name":"hibernate-relation","_id":"cjgz5iolj003nd5hslqxm3a5s"},{"name":"http-overview","_id":"cjgz5iolp003ud5hs58sfjqme"},{"name":"XRebel","_id":"cjgz5iols0041d5hsdh6xtf0x"},{"name":"idea注解模板","_id":"cjgz5ioly0048d5hsoynft5lc"},{"name":"idea插件利器","_id":"cjgz5iom3004ed5hs6mnuz534"},{"name":"istio","_id":"cjgz5iom8004ld5hsqqqhxlti"},{"name":"jackson","_id":"cjgz5iomb004rd5hszkk1nybb"},{"name":"javapoet-apt-annotation","_id":"cjgz5iome004xd5hsdt02gjiz"},{"name":"cglib","_id":"cjgz5iomj0053d5hsula3ktzu"},{"name":"java-nio-buffer","_id":"cjgz5iomq005ad5hsp9bnd7fy"},{"name":"jenkins-java-maven","_id":"cjgz5iomt005gd5hskoqahvii"},{"name":"gc垃圾回收","_id":"cjgz5iomv005ld5hsqcev0dui"},{"name":"jvm监控工具","_id":"cjgz5iomw005pd5hs84sefdzl"},{"name":"k8s","_id":"cjgz5iomw005td5hsq01cbmga"},{"name":"linux-command","_id":"cjgz5iomx005xd5hsmot30aza"},{"name":"maven常用功能","_id":"cjgz5iomy0061d5hsnyguy1b0"},{"name":"maven-error","_id":"cjgz5iomz0065d5hs5cpuvpjt"},{"name":"微服务实践总结","_id":"cjgz5ion00069d5hs80pohlku"},{"name":"mysql建表规范","_id":"cjgz5ion1006dd5hsqe2v9s4b"},{"name":"pws-push","_id":"cjgz5ion2006hd5hsm4xno4xc"},{"name":"mysql-expain","_id":"cjgz5ion2006ld5hsg84c1n7c"},{"name":"rabbitmq-install","_id":"cjgz5ion3006pd5hs9fpu5nn8"},{"name":"redis,主从,集群","_id":"cjgz5ion3006td5hsltm6eht2"},{"name":"redis,密码,安全","_id":"cjgz5ion5006xd5hs5h0d0ozs"},{"name":"redis命令","_id":"cjgz5ion50072d5hskftstdku"},{"name":"redis-install","_id":"cjgz5ion70076d5hsov63sqvt"},{"name":"restful-api","_id":"cjgz5ion8007bd5hs71nz9get"},{"name":"change-contextpath-way","_id":"cjgz5ion9007fd5hs4o4kcg2n"},{"name":"spring-cloud(配置中心加解密)","_id":"cjgz5ion9007jd5hs7dp1c9vf"},{"name":"feign使用常见问题","_id":"cjgz5ionc007nd5hslebxo614"},{"name":"feign","_id":"cjgz5ionc007rd5hsxs72556l"},{"name":"hystrix,dashboard","_id":"cjgz5iond007vd5hsngwyebnc"},{"name":"hystrix","_id":"cjgz5ione007zd5hsussr0wfo"},{"name":"zuul-exception","_id":"cjgz5ione0083d5hsp5o13xna"},{"name":"zuul-filters","_id":"cjgz5ionf0087d5hsxswd9jb5"},{"name":"zuul-start","_id":"cjgz5iong008dd5hsfi9xqfy5"},{"name":"shadowsocks-go","_id":"cjgz5ionh008hd5hssbmrm5le"},{"name":"spring-cors","_id":"cjgz5ioni008ld5hsvn8h8d7o"},{"name":"spring-boot使用经验","_id":"cjgz5ioni008pd5hsoygrrpn6"},{"name":"spring cache","_id":"cjgz5ionj008td5hsuui2bq73"},{"name":"spring-boot-async","_id":"cjgz5ionj008xd5hsc57jidtp"},{"name":"jpa读写分离配置","_id":"cjgz5ionk0091d5hsozbl155a"},{"name":"spring-boot-filter","_id":"cjgz5ionl0095d5hsk8hok0xk"},{"name":"teamcity-start","_id":"cjgz5ionl0098d5hs9v7e5tu5"},{"name":"vagrant-start","_id":"cjgz5ionm009bd5hs55ljsqxf"},{"name":"vault","_id":"cjgz5ionm009dd5hsi9aj9lcm"},{"name":"website-high-performance","_id":"cjgz5ionn009fd5hs22nobw69"}]}}