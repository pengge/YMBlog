{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/BlueLake/source/apple-touch-icon.png","path":"apple-touch-icon.png","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon-1.ico","path":"favicon-1.ico","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/favicon.ico","path":"favicon.ico","modified":1,"renderable":1},{"_id":"source/about/index/a.png","path":"about/index/a.png","modified":1,"renderable":0},{"_id":"themes/BlueLake/source/css/style.styl","path":"css/style.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/css/highlight.styl","path":"css/highlight.styl","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","path":"iconfont/iconfont.eot","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","path":"iconfont/iconfont.svg","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","path":"iconfont/iconfont.woff","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","path":"iconfont/iconfont.ttf","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/toctotop.js","path":"js/toctotop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/search.json.js","path":"js/search.json.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/js/totop.js","path":"js/totop.js","modified":1,"renderable":1},{"_id":"themes/BlueLake/source/img/bg.jpg","path":"img/bg.jpg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/BlueLake/LICENSE","hash":"4c3927c82d0aa4fac5cdf945e07afe5e24335891","modified":1510648211865},{"_id":"themes/BlueLake/README.en.md","hash":"6cc6e346635bf26dd71030b9c3c6443507cd4108","modified":1510648211866},{"_id":"themes/BlueLake/README.md","hash":"66c3ef7a779b6d65bad90daa2e03bcb7a1bb742f","modified":1510648211868},{"_id":"themes/BlueLake/_config.yml","hash":"24db390c0f8b8fff1b1727a4e9122ca8fca8d6d0","modified":1510648211869},{"_id":"themes/BlueLake/package.json","hash":"cdef382c442618b24305fd3e38ac7a3accf87aa9","modified":1510648211926},{"_id":"source/about/index.md","hash":"57df7860368f7ef928574c367758944a951c7c4d","modified":1510648211860},{"_id":"source/_posts/Keepalived-LVS-Nginx.md","hash":"58e4f6a4616d9762e74834dfb7ead98430cff2ae","modified":1510648211143},{"_id":"source/_posts/api-version.md","hash":"c86644463d46f931857cb684cb75dd6e16164895","modified":1510648211146},{"_id":"source/_posts/apidoc-java.md","hash":"3275ea6be4e1be2434129de9ca159bca92af2ea2","modified":1510648211151},{"_id":"source/_posts/centos-jdk8-install.md","hash":"e563c23d5ba2f32d0bb949a240afeb64ca0bf080","modified":1510648211154},{"_id":"source/_posts/centos-login-without-pwd.md","hash":"48b2594246f7df1f2e3c115a04547b7ed89c77ad","modified":1512025172613},{"_id":"source/_posts/centos-maven-nexus.md","hash":"35b43aba1708b21637fcce440327bc583eb21106","modified":1510648211156},{"_id":"source/_posts/cron-grammar.md","hash":"9b289b5f18187aa124447c81a583b91421c0f8fa","modified":1510648211179},{"_id":"source/_posts/distributed-difficulty.md","hash":"e3da47867669ce17645f4f4654b74eeff6c5865e","modified":1510648211180},{"_id":"source/_posts/distributed-id-snowflake.md","hash":"bc0fcf9cb5d5cb67f40e8ddb36ba83e1fcdffbae","modified":1510648211181},{"_id":"source/_posts/docker-install-centos7.md","hash":"d248bb63ea89ffeeb858da676e0ca9b82796fb9d","modified":1510732078786},{"_id":"source/_posts/git-install-in-centos7.md","hash":"34c1a5cc6da39385ce6794ab0959b0f3f9126120","modified":1510648211185},{"_id":"source/_posts/git-server-build.md","hash":"60a8320bca9568edd56fee8fb299ae1a44556ad9","modified":1510648211186},{"_id":"source/_posts/github-fork-repo-update.md","hash":"307a47abe89bac62b0ce2b6347832481049898ad","modified":1510648211187},{"_id":"source/_posts/hashicorp-vault.md","hash":"9174738ccc5a18381ed89e0e775168e2622f0ae9","modified":1510648211190},{"_id":"source/_posts/hibernate-relation-mapping.md","hash":"f5afc163cf2e5269217320c41d43eda3c4e9a836","modified":1510648211194},{"_id":"source/_posts/idea-XRebel.md","hash":"c45fe7a056bb3be87e510d9052b4f5a6325012fa","modified":1512373848068},{"_id":"source/_posts/http-protocol-overview.md","hash":"a6c6882fb2c1ab271401a482fc3b6177b3552888","modified":1510648211195},{"_id":"source/_posts/idea-good-plug.md","hash":"465ad61519b5e955295b556f518f631b6f31abb6","modified":1510648211200},{"_id":"source/_posts/jackson-show-time.md","hash":"f83b7c2899b17d623137555968f6ec3f017f4bf6","modified":1510648211201},{"_id":"source/_posts/javase-cglib.md","hash":"36d206936281ba5365b47510244c489d200cc0c5","modified":1510648211202},{"_id":"source/_posts/javase-nio-buffer.md","hash":"2b2af405ff739b06e59675ebcab5dd0b5401dc9f","modified":1510648211203},{"_id":"source/_posts/jenkins-java-maven.md","hash":"55b37da48618eb533e5951810a356afccae2fbc1","modified":1512370882911},{"_id":"source/_posts/jvm-gc.md","hash":"50d8908e1924d2d9699d0c5eeefae4005f5d1d12","modified":1510648211205},{"_id":"source/_posts/jvm-look-tools.md","hash":"f3cf120a60f85ecabb87410bb7957965c8c56c52","modified":1510648211206},{"_id":"source/_posts/linux-command-use.md","hash":"05147e0583318c7a0fe6e4648666f564f028c486","modified":1510648211207},{"_id":"source/_posts/maven-use-error-collect.md","hash":"1dc0e66221ae0ba38361831e83600b3817c0a88e","modified":1510648211212},{"_id":"source/_posts/microservice-think.md","hash":"857847b7b3953ddea45418c6383d2dc095b104fd","modified":1510648211213},{"_id":"source/_posts/mysql-create.md","hash":"3d91c19b96b817c7cd19e57d5b9af92167e7a053","modified":1511164255119},{"_id":"source/_posts/pivotal-web-service-start.md","hash":"b49bff609df5b2995516d5a81048282229f84d96","modified":1510648211216},{"_id":"source/_posts/mysql-explain.md","hash":"302bbe78c4ddfdc93582220bb703894e9372ac32","modified":1511243449432},{"_id":"source/_posts/redis-cluster-centos.md","hash":"1af79c5853fa5c4d8b8166786ca74f1833de4c14","modified":1510648211230},{"_id":"source/_posts/restful-api-dev.md","hash":"2801e8a7e037d0b3992adc795ca8b1b11fcb8b21","modified":1510648211233},{"_id":"source/_posts/sboot-change-contextpath.md","hash":"6c9153ebaac81b554dd7086f80b744e5e022438d","modified":1510648211237},{"_id":"source/_posts/sboot-dev-error-show.md","hash":"2bf16856d86c9860166ca598148eed7595772447","modified":1510648211241},{"_id":"source/_posts/scloud-feign-anyquestion.md","hash":"97cccd89fe7a037ac6d9a680492371cf25ea4323","modified":1510648211245},{"_id":"source/_posts/scloud-zuul-exception.md","hash":"338d5bdac28f1b324b0fbb4e60ccfd9861bf8f49","modified":1510648211249},{"_id":"source/_posts/scloud-zuul-filters.md","hash":"519299e5a981ecdfaa17930051f0511d7025165f","modified":1510648211253},{"_id":"source/_posts/scloud-zuul-start.md","hash":"b5c62dc5de4f85a221caffef1c258d4e996755c4","modified":1510648211257},{"_id":"source/_posts/shadowsocks-go.md","hash":"ed3f66cd19b5cfac019d004b026f1b0dd80e0271","modified":1510648211261},{"_id":"source/_posts/spring-boot-async.md","hash":"66637910cd5cc592a1bf0eebdc649d486aa2dd06","modified":1510710126528},{"_id":"source/_posts/spring-boot-cors.md","hash":"b3ecf6b7b5468674ab31163acd0f2b22d3be46ac","modified":1510734826400},{"_id":"source/_posts/spring-jpa-multiple-datasource.md","hash":"bb6d61d0d3af82505a37fa2a08141847b34dd17d","modified":1510648211851},{"_id":"source/_posts/tslang-study-one.md","hash":"b81c8d6bdde2067462944f49647bbd6e00246e5d","modified":1510648211854},{"_id":"source/_posts/website-high-performance.md","hash":"f94d8e78434734bcf3e8e270cae6af3b74fe5bc1","modified":1510648211856},{"_id":"source/_posts/teamcity-use-start.md","hash":"78c25c1da41ec9d3087a036ef3204447f768fb32","modified":1510648211853},{"_id":"themes/BlueLake/languages/de-DE.yml","hash":"a127deb32d1df69bbe50a3824a5f90472513c9c3","modified":1510648211871},{"_id":"themes/BlueLake/languages/tr.yml","hash":"5f13d55fdd5bdd1115075736e3e26a1ea1dd1dea","modified":1510648211878},{"_id":"themes/BlueLake/languages/ko.yml","hash":"fc8826724f570136d9a2d3ec2705b7b7000e0f14","modified":1510648211876},{"_id":"themes/BlueLake/languages/fr-FR.yml","hash":"bd97d5e4b39d30da1644b90256dfc4e6b1d76988","modified":1510648211875},{"_id":"themes/BlueLake/languages/es-ES.yml","hash":"baa68725feeec6643f875a532a9d55ba8aacdb2c","modified":1510648211874},{"_id":"themes/BlueLake/languages/zh-CN.yml","hash":"d7f5842295509746f878e627c4c7e298f3f1613a","modified":1510648211880},{"_id":"themes/BlueLake/languages/zh-TW.yml","hash":"d4d587ba81864910715c0c3879605cc6a9362e09","modified":1510648211881},{"_id":"themes/BlueLake/languages/en.yml","hash":"95bac2c366505d016b5defc47370679b9f5f3c4b","modified":1510648211872},{"_id":"themes/BlueLake/layout/archive.jade","hash":"98d9fb812edbc180878fdadb65bc38499eef2cc4","modified":1510648211912},{"_id":"themes/BlueLake/layout/base.jade","hash":"3805aaa6e96916e810b22d6a20d995f1fd3bf365","modified":1510648211913},{"_id":"themes/BlueLake/layout/category.jade","hash":"9f3a9f1d6f0bbad258b308ad8d49128c05b422cf","modified":1510648211915},{"_id":"themes/BlueLake/layout/index.jade","hash":"dd81d9f7a6b388de2ab731b17b3ba55f70df4a5f","modified":1510648211917},{"_id":"themes/BlueLake/layout/post.jade","hash":"0305258c33e4d02f977ee1aaf7f2429b993fda17","modified":1510648211921},{"_id":"themes/BlueLake/layout/tag.jade","hash":"50c7af7565751db5d7672beb434768885fb224cb","modified":1510648211924},{"_id":"themes/BlueLake/layout/page.jade","hash":"415404398931d98db28bff723886b07dcb8bbbc3","modified":1510648211919},{"_id":"themes/BlueLake/source/apple-touch-icon.png","hash":"98f0ecbdcdc1a0e8e52f4d786cbc011e5e06fa65","modified":1510648211929},{"_id":"themes/BlueLake/source/favicon-1.ico","hash":"94e5d25d942bff5479470322454c951f2ddebac6","modified":1510648211935},{"_id":"themes/BlueLake/source/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1510648211938},{"_id":"source/about/index/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211862},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","hash":"e91f2139090c702ae554fa2a62f492bc2e175941","modified":1510648211145},{"_id":"source/_posts/api-version/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211149},{"_id":"source/_posts/apidoc-java/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211153},{"_id":"source/_posts/centos-maven-nexus/a.png","hash":"5ae80ce14b4f22a0c5f4d79e1189800e1d98d85d","modified":1510648211158},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1510648211189},{"_id":"source/_posts/distributed-id-snowflake/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211184},{"_id":"source/_posts/docker-install-centos7/a.png","hash":"53319885ee2b62298a8dd0bbf97e66e075d63c33","modified":1510732015951},{"_id":"source/_posts/hashicorp-vault/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211193},{"_id":"source/_posts/http-protocol-overview/a.png","hash":"cdc1232c447bc61a7c3df4fd8ecf4c7947b7c739","modified":1510648211198},{"_id":"source/_posts/http-protocol-overview/b.png","hash":"d2158e4cc7c3129a86163fc087f3fdc70cc3f570","modified":1510648211199},{"_id":"source/_posts/jenkins-java-maven/1.png","hash":"c89c3f8f039bb7e3c7b1c8ba19aa421ae5857aba","modified":1512030911531},{"_id":"source/_posts/jenkins-java-maven/11.png","hash":"3d4d301aeb6a173b5681f47dbdefde4f3d91fc38","modified":1512108438339},{"_id":"source/_posts/jenkins-java-maven/14.png","hash":"5eb1accc639b0941b54e6e1c2ec81bcd4133b873","modified":1512121638194},{"_id":"source/_posts/jenkins-java-maven/13.png","hash":"17b95987316f24f5a4aaa69703b05fbfb52b3872","modified":1512120423103},{"_id":"source/_posts/jenkins-java-maven/15.png","hash":"9bdbf1d30b1e1f50df5148d71c69f78a584b522a","modified":1512370844493},{"_id":"source/_posts/jenkins-java-maven/4.png","hash":"7476872c0a08be7fbeda0ae5a52ebde940cfc0f6","modified":1512031419549},{"_id":"source/_posts/jenkins-java-maven/3.png","hash":"6070bc84371a9ef3d9dbfc50767e9c47759815b3","modified":1512031196278},{"_id":"source/_posts/jenkins-java-maven/6.png","hash":"00ff2355e8986eb0014b5894230b6fd79462eeeb","modified":1512031746744},{"_id":"source/_posts/jenkins-java-maven/7.png","hash":"e16f5020b6038b856ea2a01301f03f305e5a5399","modified":1512031925134},{"_id":"source/_posts/jenkins-java-maven/5.png","hash":"64a8107a2748e6ac2fe9d1a42287b53a7dafd314","modified":1512031701972},{"_id":"source/_posts/jenkins-java-maven/8.png","hash":"08b0b19249e2c677b6fc774655b586cbd8be8664","modified":1512033978710},{"_id":"source/_posts/jenkins-java-maven/8_1.png","hash":"3b6647cdf713816d9f60deced0a25f59a55798e5","modified":1512121340668},{"_id":"source/_posts/jenkins-java-maven/9.png","hash":"dc3d500c3de6fc1c7c0d17c05628042f244c264b","modified":1512034117142},{"_id":"source/_posts/jenkins-java-maven/e.png","hash":"038c511df2eaaf6a578ed59860a4fba5f99c560f","modified":1512030244232},{"_id":"source/_posts/jenkins-java-maven/b.png","hash":"4dd65c11f708e2e1feaf1c84b2f2a97c6baffb58","modified":1512029128800},{"_id":"source/_posts/jenkins-java-maven/g.png","hash":"e8b5ab0bc4de16515059f0d854fca3455713aa40","modified":1512030378556},{"_id":"source/_posts/jenkins-java-maven/f.png","hash":"bcdfa5c4be7b749d533d2f78aeba07576a33e010","modified":1512030306569},{"_id":"source/_posts/linux-command-use/a.png","hash":"dc9aa307fe9221d90f71dfa95841ea3acbab18cc","modified":1510648211210},{"_id":"source/_posts/linux-command-use/b.png","hash":"12fb8951ab9e7361d775a1b0ceb7546cfae5c7fe","modified":1510648211211},{"_id":"source/_posts/microservice-think/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211215},{"_id":"source/_posts/pivotal-web-service-start/d.png","hash":"70fedd27e98b3d0b83af6ad4f9538a3fc8a83c05","modified":1510648211228},{"_id":"source/_posts/redis-cluster-centos/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211232},{"_id":"source/_posts/restful-api-dev/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211236},{"_id":"source/_posts/sboot-change-contextpath/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211239},{"_id":"source/_posts/sboot-dev-error-show/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211244},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211248},{"_id":"source/_posts/scloud-zuul-exception/a.png","hash":"4adf531cb2a79c9926ffda5f0adc9cf10780dac4","modified":1510648211252},{"_id":"source/_posts/shadowsocks-go/b.png","hash":"a0dac0425805a400c38eeb20cdd920fb806d4fa0","modified":1510648211272},{"_id":"source/_posts/shadowsocks-go/a.png","hash":"85d77fc8a4bcd6f9bb73eaaaed4a69fbc171b1fa","modified":1510648211271},{"_id":"source/_posts/website-high-performance/favicon.ico","hash":"c3950458e49881d440fcb00d8e42a4c318e58e7a","modified":1510648211858},{"_id":"themes/BlueLake/layout/_partial/comments.jade","hash":"c1f1955d12aee22a931a3f4ad9d0e9a408e80f3c","modified":1510648211885},{"_id":"themes/BlueLake/layout/_partial/comment_count.jade","hash":"21d05990aa5a19632f9ed51085ef7727adeea17a","modified":1510648211884},{"_id":"themes/BlueLake/layout/_partial/footer.jade","hash":"e0aa5d7adc1218a324a484abe3513e9545f89067","modified":1510648211888},{"_id":"themes/BlueLake/layout/_partial/helpers.jade","hash":"9e44f6d32f2449b4109c33118f8285fa2fc7b023","modified":1510648211889},{"_id":"themes/BlueLake/layout/_partial/mathjax.jade","hash":"ac6e3a92bf18ab6bbd0e041b6796b295bae963ee","modified":1510648211890},{"_id":"themes/BlueLake/layout/_partial/paginator.jade","hash":"03ad0c49ae6f8a999ae35b38d08e25775f51f52a","modified":1510648211892},{"_id":"themes/BlueLake/layout/_partial/post_nav.jade","hash":"b11d9e6000449838b17f508429f29ffb60f53096","modified":1510648211893},{"_id":"themes/BlueLake/layout/_partial/share.jade","hash":"ba0839518db2cb9dafee67ca5e471219bfba2e90","modified":1510648211896},{"_id":"themes/BlueLake/layout/_partial/mathjax2.jade","hash":"234a792e64ba208fa97d2f99772ece23056a53ec","modified":1510648211891},{"_id":"themes/BlueLake/layout/_partial/search.jade","hash":"4f2fba7fcb39a6bf70ff04dad9a3dab2563b21e7","modified":1510648211894},{"_id":"themes/BlueLake/layout/_partial/tag.jade","hash":"6145b483b271bba05ad1db7c039fe352a768215b","modified":1510648211897},{"_id":"themes/BlueLake/layout/_partial/totop.jade","hash":"c632919f04194dcf6e0e8ccc572554a859aa922b","modified":1510648211898},{"_id":"themes/BlueLake/layout/_partial/comments_js.jade","hash":"d970c81b5cdbd7c0348ee28e93bcbb006d613b6d","modified":1510648211887},{"_id":"themes/BlueLake/layout/_widget/archive.jade","hash":"6e587b7d254d0d92b959ba58262f5e81b618eba2","modified":1510648211899},{"_id":"themes/BlueLake/layout/_widget/category.jade","hash":"0107affa0c6b22e09546fcf82a6f71ba2dd1e315","modified":1510648211900},{"_id":"themes/BlueLake/layout/_widget/recent_posts.jade","hash":"c6f778d5d2f13bacbd83a56a9e9faaeac0dda0ed","modified":1510648211905},{"_id":"themes/BlueLake/layout/_widget/links.jade","hash":"9af40206a525db1cb9761fa6facb36332057acf3","modified":1510648211902},{"_id":"themes/BlueLake/layout/_widget/recent_comments.jade","hash":"164a83faaf92ec19d268fd303bf6e30348ddef5c","modified":1510648211903},{"_id":"themes/BlueLake/layout/_widget/weibo.jade","hash":"4e90378aa88c5694126dc8ea5bed3bb2f8642e53","modified":1510648211910},{"_id":"themes/BlueLake/layout/_widget/tag.jade","hash":"c75308c2b72456cfb98cb80f280c66e58f171705","modified":1510648211908},{"_id":"themes/BlueLake/layout/_partial/after_footer.jade","hash":"3f11d2b5a4c647bf2b37c4d00bdc250cda80b770","modified":1510648211883},{"_id":"themes/BlueLake/source/css/style.styl","hash":"45776bc176bc8ed0d664e953e23d6a0a9a030929","modified":1510648211934},{"_id":"themes/BlueLake/source/css/highlight.styl","hash":"92b5c306f276f8ea6a134e303b1b63612d25ecfe","modified":1510648211931},{"_id":"themes/BlueLake/source/iconfont/iconfont.eot","hash":"e664dd848ca65fe3aca4acfc234ff9c18ffd4c33","modified":1510648211940},{"_id":"themes/BlueLake/source/iconfont/iconfont.svg","hash":"a910f5840f8e25b7a6e5c47b9a04ae49b9db8c32","modified":1510648211942},{"_id":"themes/BlueLake/source/iconfont/iconfont.woff","hash":"df2bd849134cbd02beb385e5061a30b923c99058","modified":1510648211946},{"_id":"themes/BlueLake/source/iconfont/iconfont.ttf","hash":"5770696cc0d19d9c9479912a5cf54c9dd4ab24c4","modified":1510648211944},{"_id":"themes/BlueLake/source/js/toctotop.js","hash":"9e68d688f2f12ec193ce9496beb0fd42e1de2288","modified":1510648211955},{"_id":"themes/BlueLake/source/js/search.json.js","hash":"7ce826f7b678ff3c524fce8bbd480c188e50c7ee","modified":1510648211953},{"_id":"themes/BlueLake/source/js/totop.js","hash":"d9367c6fa3e973bc5f32ce38d951858455726a02","modified":1510648211957},{"_id":"source/_posts/centos-maven-nexus/c.png","hash":"0721cae59a5622f3dfcb6259c018f433598ae858","modified":1510648211163},{"_id":"source/_posts/centos-maven-nexus/d.png","hash":"4837ba62f9c498d52f0d516c33555909ff890419","modified":1510648211165},{"_id":"source/_posts/centos-maven-nexus/e.png","hash":"42bf2cfd4787980d2fd0105ad3dd89afc0cf36fb","modified":1510648211166},{"_id":"source/_posts/centos-maven-nexus/f.png","hash":"696a68fdcf708980f808d0e09b604a71b774a37f","modified":1510648211169},{"_id":"source/_posts/centos-maven-nexus/g.png","hash":"c0177448d5f462df7e3d759f29d14c3faf75eb1b","modified":1510648211171},{"_id":"source/_posts/centos-maven-nexus/i.png","hash":"47e4f15afff60b872071c95fb23eaf5452e6329a","modified":1510648211174},{"_id":"source/_posts/centos-maven-nexus/j.png","hash":"4c3771a7c674c70043a68f478bce1bdb18cb1844","modified":1510648211177},{"_id":"source/_posts/centos-maven-nexus/h.png","hash":"119b973e074ab4069e934112e6daa5557023b704","modified":1510648211173},{"_id":"source/_posts/jenkins-java-maven/10.png","hash":"29788dae623aaa45c8b30658d1c56bdab7fb0279","modified":1512035569138},{"_id":"source/_posts/jenkins-java-maven/12.png","hash":"d6626668fc9a71cf602657cd5170b17f6ad8d85e","modified":1512120646746},{"_id":"source/_posts/jenkins-java-maven/2.png","hash":"90cfb0af72732942f35b3455716b6ddd939f636a","modified":1512030990929},{"_id":"source/_posts/jenkins-java-maven/a.png","hash":"4aedb54123fd8918579a04102486d34a85762a0b","modified":1512028243952},{"_id":"source/_posts/jenkins-java-maven/c.png","hash":"c0c740a0b1e6cd4cad1e8aa96cef96eabac51fcc","modified":1512030040361},{"_id":"source/_posts/jenkins-java-maven/h.png","hash":"c6a10c564bcd131aa20b15cfd5c46411e3a42ceb","modified":1512030725707},{"_id":"source/_posts/jenkins-java-maven/i.png","hash":"1cd3776d2fe4e8a2782c71895bff5254cfb3296b","modified":1512030795660},{"_id":"source/_posts/pivotal-web-service-start/a.png","hash":"d6731486aa76a72a980706fda1735e5b7bc05942","modified":1510648211219},{"_id":"source/_posts/scloud-zuul-filters/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1510648211256},{"_id":"source/_posts/scloud-zuul-start/a.png","hash":"0178dda26afe952cec2fcc7b963cb52cbabacc43","modified":1510648211260},{"_id":"themes/BlueLake/source/img/bg.jpg","hash":"d23d92484e98adcbea7266ebfdfef7fb3fc42ee0","modified":1510648211950},{"_id":"source/_posts/centos-maven-nexus/b.png","hash":"b83a6edfb7e719a3f530c544111dcd93914a648b","modified":1510648211161},{"_id":"source/_posts/pivotal-web-service-start/c.png","hash":"222f2f53d4d37628d4d926c5da817e3a76f14458","modified":1510648211227},{"_id":"source/_posts/pivotal-web-service-start/b.png","hash":"2e35d944a620506caa3ab18f337d71c92fd391e0","modified":1510648211224},{"_id":"source/_posts/shadowsocks-go/Shadowsocks-4.0.6.zip","hash":"bde73f5175fe3eb5127651e4602f78dbd5a5aed9","modified":1510648211269},{"_id":"source/_posts/shadowsocks-go/go1.9.2.linux-amd64.tar.gz","hash":"94c889e039e3d2e94ed95e8f8cb747c5bc1c2b58","modified":1510648211837}],"Category":[{"name":"api-manage","_id":"cjarwckmr00038ora05zst9a1"},{"name":"Nginx","_id":"cjarwckne000d8ora6bi6zwyn"},{"name":"CentOs","_id":"cjarwckni000k8oraap36ou42"},{"name":"java","_id":"cjarwcknr000v8oraij6sgifb"},{"name":"分布式系统","_id":"cjarwcknv00128ora42bd423s"},{"name":"docker","_id":"cjarwcko8001k8oraf4tusfs5"},{"name":"git","_id":"cjarwckoh001s8ora3zanetxh"},{"name":"github","_id":"cjarwckom001z8oralclfjab7"},{"name":"security","_id":"cjarwckox002a8ora1pj392yy"},{"name":"jpa/hibernate","_id":"cjarwckp2002i8oracvypewrn"},{"name":"http协议","_id":"cjarwckp6002p8oraoa4hqj4m"},{"name":"idea","_id":"cjarwckpa002v8ora1n1xcz1i"},{"name":"json","_id":"cjarwckpe00318oragegbh4ja"},{"name":"持续集成","_id":"cjarwckpi00388ora0few5aq7"},{"name":"jvm","_id":"cjarwckpq003e8orazftocqqs"},{"name":"linux","_id":"cjarwckpw003l8ora8b7ysufs"},{"name":"maven","_id":"cjarwckq0003q8oraei4eih4w"},{"name":"mysql","_id":"cjarwckq1003u8orad2j6l5r0"},{"name":"Pivotal Web Service","_id":"cjarwckq2003y8oraqruga49u"},{"name":"数据库","_id":"cjarwckq600458oraoslmqz0b"},{"name":"spring-boot","_id":"cjarwckq7004a8oradz8ta34j"},{"name":"spring-cloud","_id":"cjarwckqa004h8orautgd4mi1"},{"name":"shadowsocks","_id":"cjarwckqd004s8ora8wkrht4i"},{"name":"micro-service","_id":"cjarwckqf004x8ora9y0p7zrr"},{"name":"TypeScript","_id":"cjarwckqm005g8orajk05vshs"},{"name":"架构","_id":"cjarwckqo005l8oraok4p4fkv"},{"name":"teamcity","_id":"cjarwckqp005p8ora7eepyvay"}],"Data":[],"Page":[{"title":"关于","date":"2017-09-20T03:52:09.000Z","_content":"","source":"about/index.md","raw":"---\ntitle: 关于\ndate: 2017-09-20 11:52:09\n---\n","updated":"2017-11-14T08:30:11.860Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjarwckmh00008ora8dejpkld","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"rest-api版本迭代管理实践","date":"2017-09-26T06:23:44.000Z","_content":"","source":"_posts/api-version.md","raw":"---\ntitle: rest-api版本迭代管理实践\ndate: 2017-09-26 14:23:44\ncategories: api-manage\ntags: api-version-manage\n---\n","slug":"api-version","published":1,"updated":"2017-11-14T08:30:11.146Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckmj00018orai2p9ei1k","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"apidoc在spring-mvc中实践","date":"2017-09-24T15:01:49.000Z","_content":"\n官网：http://apidocjs.com/\n","source":"_posts/apidoc-java.md","raw":"---\ntitle: apidoc在spring-mvc中实践\ndate: 2017-09-24 23:01:49\ncategories: api-manage\ntags: apidoc\n---\n\n官网：http://apidocjs.com/\n","slug":"apidoc-java","published":1,"updated":"2017-11-14T08:30:11.151Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckmo00028ora63i21kbo","content":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"external\">http://apidocjs.com/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>官网：<a href=\"http://apidocjs.com/\" target=\"_blank\" rel=\"external\">http://apidocjs.com/</a></p>\n"},{"title":"Keepalived+LVS+Nginx负载均衡之高可用","date":"2017-09-23T01:48:19.000Z","_content":"### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","source":"_posts/Keepalived-LVS-Nginx.md","raw":"---\ntitle: Keepalived+LVS+Nginx负载均衡之高可用\ndate: 2017-09-23 09:48:19\ncategories: Nginx\ntags: nginx负载均衡\n---\n### 为什么要使用LVS+Nginx\n在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。\n而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时*断开与客户端连接*，服务端处理完毕直接将结果返回给客户端，不再经过LVS。\n所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。\n同时，使用Keepalived对LVC做双热备，避免单点故障。\n\n[参考](http://www.linuxvirtualserver.org/zh/lvs1.html) [官网](http://www.linuxvirtualserver.org/)\n\n### Keepalived介绍\nKeepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。\nkeepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。\n\n### Keepalived+LVS+Nginx实现系统高可用\n#### 1. 架构图\n{% asset_img a.png %} \n \n|  服务器   | IP地址 | 说明 |\n| :------: | :------:|:-----:|\n| 虚拟IP | 192.168.1.120:80 | - |\n| 主机 | 192.168.1.104:80 | - |\n| 备机 | 192.168.1.103:80 | - |\n| Web站点A | 192.168.1.101:8081 | 不同端口 |\n| Web站点B | 192.168.1.101:8082\t | 不同端口 |\n\n#### 2. 安装LVS\n##### 2.1  安装ipvsadm，实现系统支持LVS\n`yum install ipvsadm`\n#### 3. 安装Keepalived\n`yum install Keepalived`\n将keepalived设置开机启动\n`systemctl enable keepalived`\n##### 3.1   配置keepalived\n\n","slug":"Keepalived-LVS-Nginx","published":1,"updated":"2017-11-14T08:30:11.143Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckmu00058ora7i0lua8v","content":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"external\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"external\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>","site":{"data":{}},"excerpt":"","more":"<h3 id=\"为什么要使用LVS-Nginx\"><a href=\"#为什么要使用LVS-Nginx\" class=\"headerlink\" title=\"为什么要使用LVS+Nginx\"></a>为什么要使用LVS+Nginx</h3><p>在用nginx+tomcat做负载均衡时，接收到客户端请求后，nginx会将请求负载转发到tomcat服务端，同时保持和客户端连接，当服务端处理完毕后nginx再将结果返回给客户端。那么就是说，客户端所有的流量都是要经过nginx的，这就造成了一个问题，系统架构中nginx出现了单机性能瓶颈。<br>而LVS做负载的时候，LVS接到客户端请求,将请求负载转发出去，同时<em>断开与客户端连接</em>，服务端处理完毕直接将结果返回给客户端，不再经过LVS。<br>所以，结合两者优缺点，在nginx前在加多一层LVS为nginx做负载均衡，避免nginx单机性能瓶颈，使系统高可用。<br>同时，使用Keepalived对LVC做双热备，避免单点故障。</p>\n<p><a href=\"http://www.linuxvirtualserver.org/zh/lvs1.html\" target=\"_blank\" rel=\"external\">参考</a> <a href=\"http://www.linuxvirtualserver.org/\" target=\"_blank\" rel=\"external\">官网</a></p>\n<h3 id=\"Keepalived介绍\"><a href=\"#Keepalived介绍\" class=\"headerlink\" title=\"Keepalived介绍\"></a>Keepalived介绍</h3><p>Keepalived是分布式部署系统解决系统高可用的软件，结合LVS（Linux Virtual Server）使用，其功能类似于heartbeat，解决单机宕机的问题。<br>keepalived是以VRRP协议为实现基础的，VRRP全称Virtual Router Redundancy Protocol，即虚拟路由冗余协议。通过VRRP协议结合LVS，对组群服务器监控情况，若master出现宕机情况，则将VIP漂移到backup机上。实现了分布式系统高可用。可以理解为：keepalived是LVS的管理软件，根据监控情况，将宕机服务器从ipvsadm移除掉。</p>\n<h3 id=\"Keepalived-LVS-Nginx实现系统高可用\"><a href=\"#Keepalived-LVS-Nginx实现系统高可用\" class=\"headerlink\" title=\"Keepalived+LVS+Nginx实现系统高可用\"></a>Keepalived+LVS+Nginx实现系统高可用</h3><h4 id=\"1-架构图\"><a href=\"#1-架构图\" class=\"headerlink\" title=\"1. 架构图\"></a>1. 架构图</h4><img src=\"/2017/09/23/Keepalived-LVS-Nginx/a.png\"> \n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">服务器</th>\n<th style=\"text-align:center\">IP地址</th>\n<th style=\"text-align:center\">说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">虚拟IP</td>\n<td style=\"text-align:center\">192.168.1.120:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">主机</td>\n<td style=\"text-align:center\">192.168.1.104:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">备机</td>\n<td style=\"text-align:center\">192.168.1.103:80</td>\n<td style=\"text-align:center\">-</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点A</td>\n<td style=\"text-align:center\">192.168.1.101:8081</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">Web站点B</td>\n<td style=\"text-align:center\">192.168.1.101:8082</td>\n<td style=\"text-align:center\">不同端口</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"2-安装LVS\"><a href=\"#2-安装LVS\" class=\"headerlink\" title=\"2. 安装LVS\"></a>2. 安装LVS</h4><h5 id=\"2-1-安装ipvsadm，实现系统支持LVS\"><a href=\"#2-1-安装ipvsadm，实现系统支持LVS\" class=\"headerlink\" title=\"2.1  安装ipvsadm，实现系统支持LVS\"></a>2.1  安装ipvsadm，实现系统支持LVS</h5><p><code>yum install ipvsadm</code></p>\n<h4 id=\"3-安装Keepalived\"><a href=\"#3-安装Keepalived\" class=\"headerlink\" title=\"3. 安装Keepalived\"></a>3. 安装Keepalived</h4><p><code>yum install Keepalived</code><br>将keepalived设置开机启动<br><code>systemctl enable keepalived</code></p>\n<h5 id=\"3-1-配置keepalived\"><a href=\"#3-1-配置keepalived\" class=\"headerlink\" title=\"3.1   配置keepalived\"></a>3.1   配置keepalived</h5>"},{"title":"centos7下jdk8安装","date":"2017-11-12T06:32:34.000Z","_content":"1、下载jdk(在官网找)\n如果还没安装axel，先安装axel：> yum -y install axel\n\n    > axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n\n2、新建安装目录\n\n    >  mkdir /usr/lib/jvm\n\n3、解压jdk到安装目录下\n\n    > tar xf jdk-8u131-linux-x64.tar.gz\n    > cd /usr/lib/jvm\n    > mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n    > mv jdk1.8.0_131/ jdk8 #更改名字\n\n4、配置环境变量\n\n    > vim /etc/profile\n    \n键盘按a键进入编辑模式，在末尾添加：\n#jdk\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n\n按Esc退出编辑模式\n按Shift+:,然后输入wq保存退出。\n\n5、使环境变量生效\n\n    > source /etc/profile\n\n6、验证安装是否成功\n\n    > java -version\n\n如果安装成功会看到：\n\n    java version \"1.8.0_131\"\n    Java(TM) SE Runtime Environment (build 1.8.0_131-b11)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)","source":"_posts/centos-jdk8-install.md","raw":"---\ntitle: centos7下jdk8安装\ndate: 2017-11-12 14:32:34\ncategories: CentOs\ntags: centos-jdk8-install\n---\n1、下载jdk(在官网找)\n如果还没安装axel，先安装axel：> yum -y install axel\n\n    > axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n\n2、新建安装目录\n\n    >  mkdir /usr/lib/jvm\n\n3、解压jdk到安装目录下\n\n    > tar xf jdk-8u131-linux-x64.tar.gz\n    > cd /usr/lib/jvm\n    > mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n    > mv jdk1.8.0_131/ jdk8 #更改名字\n\n4、配置环境变量\n\n    > vim /etc/profile\n    \n键盘按a键进入编辑模式，在末尾添加：\n#jdk\nexport JAVA_HOME=/usr/lib/jvm/jdk8\nexport JRE_HOME=${JAVA_HOME}/jre\nexport CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib\nexport PATH=${JAVA_HOME}/bin:$PATH\n\n按Esc退出编辑模式\n按Shift+:,然后输入wq保存退出。\n\n5、使环境变量生效\n\n    > source /etc/profile\n\n6、验证安装是否成功\n\n    > java -version\n\n如果安装成功会看到：\n\n    java version \"1.8.0_131\"\n    Java(TM) SE Runtime Environment (build 1.8.0_131-b11)\n    Java HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)","slug":"centos-jdk8-install","published":1,"updated":"2017-11-14T08:30:11.154Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckmx00068orav8f6qoor","content":"<p>1、下载jdk(在官网找)<br>如果还没安装axel，先安装axel：&gt; yum -y install axel</p>\n<pre><code>&gt; axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n</code></pre><p>2、新建安装目录</p>\n<pre><code>&gt;  mkdir /usr/lib/jvm\n</code></pre><p>3、解压jdk到安装目录下</p>\n<pre><code>&gt; tar xf jdk-8u131-linux-x64.tar.gz\n&gt; cd /usr/lib/jvm\n&gt; mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n&gt; mv jdk1.8.0_131/ jdk8 #更改名字\n</code></pre><p>4、配置环境变量</p>\n<pre><code>&gt; vim /etc/profile\n</code></pre><p>键盘按a键进入编辑模式，在末尾添加：</p>\n<p>#jdk<br>export JAVA_HOME=/usr/lib/jvm/jdk8<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>\n<p>按Esc退出编辑模式<br>按Shift+:,然后输入wq保存退出。</p>\n<p>5、使环境变量生效</p>\n<pre><code>&gt; source /etc/profile\n</code></pre><p>6、验证安装是否成功</p>\n<pre><code>&gt; java -version\n</code></pre><p>如果安装成功会看到：</p>\n<pre><code>java version &quot;1.8.0_131&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>1、下载jdk(在官网找)<br>如果还没安装axel，先安装axel：&gt; yum -y install axel</p>\n<pre><code>&gt; axel -n 10 http://download.oracle.com/otn-pub/java/jdk/8u131-b11/d54c1d3a095b4ff2b6607d096fa80163/jdk-8u131-linux-x64.tar.gz?AuthParam=1500085329_9680fa6b22ed9ee487ee7730707b5039\n</code></pre><p>2、新建安装目录</p>\n<pre><code>&gt;  mkdir /usr/lib/jvm\n</code></pre><p>3、解压jdk到安装目录下</p>\n<pre><code>&gt; tar xf jdk-8u131-linux-x64.tar.gz\n&gt; cd /usr/lib/jvm\n&gt; mv /server/tools/jdk1.8.0_131/ /usr/lib/jvm/\n&gt; mv jdk1.8.0_131/ jdk8 #更改名字\n</code></pre><p>4、配置环境变量</p>\n<pre><code>&gt; vim /etc/profile\n</code></pre><p>键盘按a键进入编辑模式，在末尾添加：</p>\n<p>#jdk<br>export JAVA_HOME=/usr/lib/jvm/jdk8<br>export JRE_HOME=${JAVA_HOME}/jre<br>export CLASSPATH=.:${JAVA_HOME}/lib:${JRE_HOME}/lib<br>export PATH=${JAVA_HOME}/bin:$PATH</p>\n<p>按Esc退出编辑模式<br>按Shift+:,然后输入wq保存退出。</p>\n<p>5、使环境变量生效</p>\n<pre><code>&gt; source /etc/profile\n</code></pre><p>6、验证安装是否成功</p>\n<pre><code>&gt; java -version\n</code></pre><p>如果安装成功会看到：</p>\n<pre><code>java version &quot;1.8.0_131&quot;\nJava(TM) SE Runtime Environment (build 1.8.0_131-b11)\nJava HotSpot(TM) 64-Bit Server VM (build 25.131-b11, mixed mode)\n</code></pre>"},{"title":"centos免密码登录","date":"2017-11-30T06:53:47.000Z","_content":"\n配置免密码登录服务器。不用每次都要输入密码。\n\n## 环境说明\n\n客户机:Mac OS X\n服务器:CentOS 7\n客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.\n\n## 客户机配置\n\n1. 查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  \n2. 生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.\n\n## 服务器配置\n\n1.修改sshd配置文件(/etc/ssh/sshd_config).  \n找到以下内容，并去掉注释符”#“\n\n> RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)\nPubkeyAuthentication yes\nAuthorizedKeysFile  .ssh/authorized_keys\n\n2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:\n\n    cat ~/.ssh/id_rsa.pub | ssh user@host “cat - >> ~/.ssh/authorized_keys”\n    \n>注意:\n1 .ssh目录的权限必须是700\n2 .ssh/authorized_keys文件权限必须是600\n\n重启ssh： service sshd restart   \n然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.\n\n\n","source":"_posts/centos-login-without-pwd.md","raw":"---\ntitle: centos免密码登录\ndate: 2017-11-30 14:53:47\ncategories: CentOs\ntags: centos登录\n---\n\n配置免密码登录服务器。不用每次都要输入密码。\n\n## 环境说明\n\n客户机:Mac OS X\n服务器:CentOS 7\n客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.\n\n## 客户机配置\n\n1. 查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  \n2. 生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.\n\n## 服务器配置\n\n1.修改sshd配置文件(/etc/ssh/sshd_config).  \n找到以下内容，并去掉注释符”#“\n\n> RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)\nPubkeyAuthentication yes\nAuthorizedKeysFile  .ssh/authorized_keys\n\n2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:\n\n    cat ~/.ssh/id_rsa.pub | ssh user@host “cat - >> ~/.ssh/authorized_keys”\n    \n>注意:\n1 .ssh目录的权限必须是700\n2 .ssh/authorized_keys文件权限必须是600\n\n重启ssh： service sshd restart   \n然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.\n\n\n","slug":"centos-login-without-pwd","published":1,"updated":"2017-11-30T06:59:32.613Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckn200078ora8mv48y8e","content":"<p>配置免密码登录服务器。不用每次都要输入密码。</p>\n<h2 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h2><p>客户机:Mac OS X<br>服务器:CentOS 7<br>客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.</p>\n<h2 id=\"客户机配置\"><a href=\"#客户机配置\" class=\"headerlink\" title=\"客户机配置\"></a>客户机配置</h2><ol>\n<li>查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  </li>\n<li>生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.</li>\n</ol>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>1.修改sshd配置文件(/etc/ssh/sshd_config).<br>找到以下内容，并去掉注释符”#“</p>\n<blockquote>\n<p>RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys</p>\n</blockquote>\n<p>2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:</p>\n<pre><code>cat ~/.ssh/id_rsa.pub | ssh user@host “cat - &gt;&gt; ~/.ssh/authorized_keys”\n</code></pre><blockquote>\n<p>注意:<br>1 .ssh目录的权限必须是700<br>2 .ssh/authorized_keys文件权限必须是600</p>\n</blockquote>\n<p>重启ssh： service sshd restart<br>然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>配置免密码登录服务器。不用每次都要输入密码。</p>\n<h2 id=\"环境说明\"><a href=\"#环境说明\" class=\"headerlink\" title=\"环境说明\"></a>环境说明</h2><p>客户机:Mac OS X<br>服务器:CentOS 7<br>客户端:OpenSSH,OS X及大多数Linux都内置了OpenSSH.’ssh -v’命令可以查看版本.</p>\n<h2 id=\"客户机配置\"><a href=\"#客户机配置\" class=\"headerlink\" title=\"客户机配置\"></a>客户机配置</h2><ol>\n<li>查看~/.ssh文件夹,若已经存在有公钥文件(id_rsa.pub),私钥文件(id_rsa),则可以跳过客户端配置.  </li>\n<li>生成密钥文件.$ ssh-keygen 然后一路回车.然后~/.ssh下会生成id_rsa.pub和id_rsa, 其中id_rsa文件起到唯一标识你的客户机的作用.注意:不要改这两个文件的文件名,ssh登陆时会读取id_rsa文件.</li>\n</ol>\n<h2 id=\"服务器配置\"><a href=\"#服务器配置\" class=\"headerlink\" title=\"服务器配置\"></a>服务器配置</h2><p>1.修改sshd配置文件(/etc/ssh/sshd_config).<br>找到以下内容，并去掉注释符”#“</p>\n<blockquote>\n<p>RSAAuthentication yes (我新购的机器Centos7.4的，无需配置这句)<br>PubkeyAuthentication yes<br>AuthorizedKeysFile  .ssh/authorized_keys</p>\n</blockquote>\n<p>2.配置authorized_keys文件.若’~/.ssh/authorized_keys’不存在,则建立.ssh文件夹和authorized_keys文件.将上文中客户机id_rsa.pub的内容拷贝到authorized_keys中.PS:可以在客户机中执行命令来拷贝:</p>\n<pre><code>cat ~/.ssh/id_rsa.pub | ssh user@host “cat - &gt;&gt; ~/.ssh/authorized_keys”\n</code></pre><blockquote>\n<p>注意:<br>1 .ssh目录的权限必须是700<br>2 .ssh/authorized_keys文件权限必须是600</p>\n</blockquote>\n<p>重启ssh： service sshd restart<br>然后客户先先执行：ssh -v user@host (-v 调试模式)会显示一些登陆信息.若登陆失败,或者仍然要输入密码,可以在服务器查看日志文件:/var/log/secure.若登陆成功,则以后就可以用’ssh user@host’ 直接登陆了,不用输入密码.</p>\n"},{"title":"Cron 语法","date":"2017-10-24T02:23:19.000Z","_content":"\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]   \ncron语法主要用在定时任务上。linux系统有个类似的crontab。\n\n|   序号   |\t说明\t|是否必填|\t允许填写的值\t|允许的符号|\n|:---|:---|:---|:---|:---|\n|1\t|秒   |是\t|0－59\t|, - * /|\n |2\t|分\t    |是 |0－59\t|, - * /|\n |3\t|小时   |是\t |0－23 |\t, - * / |\n |4\t|日\t    |是\t |1－31\t|, - * ? / L W |\n |5\t|月\t    |是\t |1－12 or JAN-DEC\t|, - * /|\n |6\t|星期\t|是\t |1-7 or SUN-SAT\t|, - * ? / L #  |\n |7\t|年\t     |否\t|1970-2099\t|, - * / |\n \n> 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。\n\n_详细说明_\n\n“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。 \n“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。 \n“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。\n\n`*`表示所有值. 如在“分”上设置“`*`”，表示每分钟触发。 \n“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”\n\n“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同\n\n“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。 \n“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。 \n如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四\n\n> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n\nW表示离指定日期的最近那个工作日(周一至周五). \n例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。 \n如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。 \n如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。 \n如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。\n\n> 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；\n\n_常用示例_\n\n0 0 12 * * ? 每天12点触发\n\n0 15 10 ? * * 每天10点15分触发\n\n0 15 10 * * ? 每天10点15分触发\n\n0 15 10 * * ? * 每天10点15分触发\n\n0 15 10 * * ? 2005 2005年每天10点15分触发\n\n0 * 14 * * ? 每天14点到14点59分之间，每分钟触发一次\n\n0 0/5 14 * * ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）\n\n0 0/5 14，18 * * ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）\n\n0 0-5 14 * * ? 每天14点到14点05分之间，每分钟触发\n\n0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发\n\n0 15 10 ? * MON-FRI 周一到周五每天10点15分触发\n\n0 15 10 15 * ? 每月15号10点15分触发\n\n0 15 10 L * ? 每月最后一天的10点15分触发\n\n0 15 10 ? * 6L 每月最后一个周五的10点15分触发\n\n0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发\n\n0 15 10 ? * 6#3 每月第三个周五的10点15分触发\n\n0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次\n\n\n\n\n\n\n","source":"_posts/cron-grammar.md","raw":"---\ntitle:  Cron 语法\ndate: 2017-10-24 10:23:19\ncategories: java\ntags: cron-grammar\n---\n\n一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]   \ncron语法主要用在定时任务上。linux系统有个类似的crontab。\n\n|   序号   |\t说明\t|是否必填|\t允许填写的值\t|允许的符号|\n|:---|:---|:---|:---|:---|\n|1\t|秒   |是\t|0－59\t|, - * /|\n |2\t|分\t    |是 |0－59\t|, - * /|\n |3\t|小时   |是\t |0－23 |\t, - * / |\n |4\t|日\t    |是\t |1－31\t|, - * ? / L W |\n |5\t|月\t    |是\t |1－12 or JAN-DEC\t|, - * /|\n |6\t|星期\t|是\t |1-7 or SUN-SAT\t|, - * ? / L #  |\n |7\t|年\t     |否\t|1970-2099\t|, - * / |\n \n> 其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。\n\n_详细说明_\n\n“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。 \n“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。 \n“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。\n\n`*`表示所有值. 如在“分”上设置“`*`”，表示每分钟触发。 \n“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”\n\n“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同\n\n“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。 \n“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。 \n如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四\n\n> 注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题\n\nW表示离指定日期的最近那个工作日(周一至周五). \n例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。 \n如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。 \n如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。 \n如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。\n\n> 小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；\n\n_常用示例_\n\n0 0 12 * * ? 每天12点触发\n\n0 15 10 ? * * 每天10点15分触发\n\n0 15 10 * * ? 每天10点15分触发\n\n0 15 10 * * ? * 每天10点15分触发\n\n0 15 10 * * ? 2005 2005年每天10点15分触发\n\n0 * 14 * * ? 每天14点到14点59分之间，每分钟触发一次\n\n0 0/5 14 * * ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）\n\n0 0/5 14，18 * * ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）\n\n0 0-5 14 * * ? 每天14点到14点05分之间，每分钟触发\n\n0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发\n\n0 15 10 ? * MON-FRI 周一到周五每天10点15分触发\n\n0 15 10 15 * ? 每月15号10点15分触发\n\n0 15 10 L * ? 每月最后一天的10点15分触发\n\n0 15 10 ? * 6L 每月最后一个周五的10点15分触发\n\n0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发\n\n0 15 10 ? * 6#3 每月第三个周五的10点15分触发\n\n0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次\n\n\n\n\n\n\n","slug":"cron-grammar","published":1,"updated":"2017-11-14T08:30:11.179Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckn9000b8orapvg8hqqr","content":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]<br>cron语法主要用在定时任务上。linux系统有个类似的crontab。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">允许填写的值</th>\n<th style=\"text-align:left\">允许的符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">秒</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">分</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">小时</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－23</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">日</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－31</td>\n<td style=\"text-align:left\">, - * ? / L W</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">月</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－12 or JAN-DEC</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">星期</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1-7 or SUN-SAT</td>\n<td style=\"text-align:left\">, - * ? / L #</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">1970-2099</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。</p>\n</blockquote>\n<p><em>详细说明</em></p>\n<p>“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。<br>“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。<br>“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。</p>\n<p><code>*</code>表示所有值. 如在“分”上设置“<code>*</code>”，表示每分钟触发。<br>“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”</p>\n<p>“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同</p>\n<p>“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。<br>“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。<br>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四</p>\n<blockquote>\n<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>\n</blockquote>\n<p>W表示离指定日期的最近那个工作日(周一至周五).<br>例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。<br>如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。<br>如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。<br>如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。</p>\n<blockquote>\n<p>小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；</p>\n</blockquote>\n<p><em>常用示例</em></p>\n<p>0 0 12 <em> </em> ? 每天12点触发</p>\n<p>0 15 10 ? <em> </em> 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? * 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 2005 2005年每天10点15分触发</p>\n<p>0 <em> 14 </em> * ? 每天14点到14点59分之间，每分钟触发一次</p>\n<p>0 0/5 14 <em> </em> ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）</p>\n<p>0 0/5 14，18 <em> </em> ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）</p>\n<p>0 0-5 14 <em> </em> ? 每天14点到14点05分之间，每分钟触发</p>\n<p>0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发</p>\n<p>0 15 10 ? * MON-FRI 周一到周五每天10点15分触发</p>\n<p>0 15 10 15 * ? 每月15号10点15分触发</p>\n<p>0 15 10 L * ? 每月最后一天的10点15分触发</p>\n<p>0 15 10 ? * 6L 每月最后一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6#3 每月第三个周五的10点15分触发</p>\n<p>0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次</p>\n","site":{"data":{}},"excerpt":"","more":"<p>一个cron表达式由6或7个时间元素组成。它们之间用空格分隔，依次为：[秒] [分] [小时] [日] [月] [星期] [年]<br>cron语法主要用在定时任务上。linux系统有个类似的crontab。</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:left\">序号</th>\n<th style=\"text-align:left\">说明</th>\n<th style=\"text-align:left\">是否必填</th>\n<th style=\"text-align:left\">允许填写的值</th>\n<th style=\"text-align:left\">允许的符号</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:left\">1</td>\n<td style=\"text-align:left\">秒</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">2</td>\n<td style=\"text-align:left\">分</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－59</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">3</td>\n<td style=\"text-align:left\">小时</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">0－23</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">4</td>\n<td style=\"text-align:left\">日</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－31</td>\n<td style=\"text-align:left\">, - * ? / L W</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">5</td>\n<td style=\"text-align:left\">月</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1－12 or JAN-DEC</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">6</td>\n<td style=\"text-align:left\">星期</td>\n<td style=\"text-align:left\">是</td>\n<td style=\"text-align:left\">1-7 or SUN-SAT</td>\n<td style=\"text-align:left\">, - * ? / L #</td>\n</tr>\n<tr>\n<td style=\"text-align:left\">7</td>\n<td style=\"text-align:left\">年</td>\n<td style=\"text-align:left\">否</td>\n<td style=\"text-align:left\">1970-2099</td>\n<td style=\"text-align:left\">, - * /</td>\n</tr>\n</tbody>\n</table>\n<blockquote>\n<p>其中每个元素值可以是一个确定值(6)，一个连续区间(9-12)，一个间隔时间(0/5)，一个列表(1，3，5)或通配符。</p>\n</blockquote>\n<p><em>详细说明</em></p>\n<p>“-”表示可选值范围，如在“小时”上设置“10-12”，表示10点、11点和12点触发。<br>“，”表示可选的多个值，例如在“星期”上设置“MON，WED，FRI”，表示周一，周三和周五触发。<br>“/”用于递增触发，如在“秒”上面设置“5/15”表示从第5秒开始，每15秒触发一次(5，20，35，50)；在“日”上设置“1/3”表示每月1号开始，每三天触发一次。</p>\n<p><code>*</code>表示所有值. 如在“分”上设置“<code>*</code>”，表示每分钟触发。<br>“？”字符仅出现在“日”和“星期”两个元素上，表示不指定值。当这两个元素之一被指定了值以后，为了避免冲突，需要将另一个元素的值设为“？”</p>\n<p>“月”和“星期”元素上若使用英文字母是不区分大小写的，即MON与mon相同</p>\n<p>“L” 字符仅出现在“日”和“星期”两个元素上，它是单词“last”的缩写。<br>“L”在“日”元素上出现，表示每个月的最后一天；在“星期”元素上出现，表示每个月最后一个星期六。<br>如果在“L”前有具体的内容，它就具有其他的含义了。例如：“6L”在“日”上出现，表示每月的倒数第６天；“5L”在“星期”上出现，表示每月的最后一个星期四</p>\n<blockquote>\n<p>注意：在使用“L”参数时，不要指定列表或范围，因为这会导致问题</p>\n</blockquote>\n<p>W表示离指定日期的最近那个工作日(周一至周五).<br>例如在日字段上设置“15W”，表示离每月15号最近的那个工作日触发。<br>如果15号正好是周六，则找最近的周五(14号)触发；如果15号是周未，则找最近的下周一(16号)触发；如果15号正好在工作日(周一至周五)，则就在该天触发。<br>如果指定格式为“1W”，它则表示每月1号往后最近的工作日触发。<br>如果1号正是周六，则将在3号下周一触发。(注，“W”前只能设置具体的数字，不允许区间“-”)。</p>\n<blockquote>\n<p>小提示：“L”和 “W”可以一组合使用。如果在“日”上设置“LW”，则表示在本月的最后一个工作日触发；</p>\n</blockquote>\n<p><em>常用示例</em></p>\n<p>0 0 12 <em> </em> ? 每天12点触发</p>\n<p>0 15 10 ? <em> </em> 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? * 每天10点15分触发</p>\n<p>0 15 10 <em> </em> ? 2005 2005年每天10点15分触发</p>\n<p>0 <em> 14 </em> * ? 每天14点到14点59分之间，每分钟触发一次</p>\n<p>0 0/5 14 <em> </em> ? 每天14点到14点59分之间，每5分钟触发一次（从14点开始触发）</p>\n<p>0 0/5 14，18 <em> </em> ? 每天14点到14点59分及18点到18点59分，每5分钟触发一次（分别从14点、18点开始触发）</p>\n<p>0 0-5 14 <em> </em> ? 每天14点到14点05分之间，每分钟触发</p>\n<p>0 10，44 14 ? 3 WED 3月份每周三14点10分和14点44分触发</p>\n<p>0 15 10 ? * MON-FRI 周一到周五每天10点15分触发</p>\n<p>0 15 10 15 * ? 每月15号10点15分触发</p>\n<p>0 15 10 L * ? 每月最后一天的10点15分触发</p>\n<p>0 15 10 ? * 6L 每月最后一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6L 2002-2005 从2002年到2005年每月一个周五的10点15分触发</p>\n<p>0 15 10 ? * 6#3 每月第三个周五的10点15分触发</p>\n<p>0 0 12 1/5 * ? 每月1号的12点开始触发，每隔5天触发一次</p>\n"},{"title":"分布式系统几大难点","date":"2017-11-08T06:57:10.000Z","_content":"\n## 1. 分布式ID\n\n## 2. 分布式事务\n\n## 3. 分布式缓存以及缓存与数据库的同步\n\n## 4. 数据库集群同步延迟问题\n\n## 5. 分布式跨库连表查询\n\n## 6. 分布式定时任务","source":"_posts/distributed-difficulty.md","raw":"---\ntitle: 分布式系统几大难点\ndate: 2017-11-08 14:57:10\ncategories: 分布式系统\ntags: distributed-difficulty\n---\n\n## 1. 分布式ID\n\n## 2. 分布式事务\n\n## 3. 分布式缓存以及缓存与数据库的同步\n\n## 4. 数据库集群同步延迟问题\n\n## 5. 分布式跨库连表查询\n\n## 6. 分布式定时任务","slug":"distributed-difficulty","published":1,"updated":"2017-11-14T08:30:11.180Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknc000c8oraerw7f488","content":"<h2 id=\"1-分布式ID\"><a href=\"#1-分布式ID\" class=\"headerlink\" title=\"1. 分布式ID\"></a>1. 分布式ID</h2><h2 id=\"2-分布式事务\"><a href=\"#2-分布式事务\" class=\"headerlink\" title=\"2. 分布式事务\"></a>2. 分布式事务</h2><h2 id=\"3-分布式缓存以及缓存与数据库的同步\"><a href=\"#3-分布式缓存以及缓存与数据库的同步\" class=\"headerlink\" title=\"3. 分布式缓存以及缓存与数据库的同步\"></a>3. 分布式缓存以及缓存与数据库的同步</h2><h2 id=\"4-数据库集群同步延迟问题\"><a href=\"#4-数据库集群同步延迟问题\" class=\"headerlink\" title=\"4. 数据库集群同步延迟问题\"></a>4. 数据库集群同步延迟问题</h2><h2 id=\"5-分布式跨库连表查询\"><a href=\"#5-分布式跨库连表查询\" class=\"headerlink\" title=\"5. 分布式跨库连表查询\"></a>5. 分布式跨库连表查询</h2><h2 id=\"6-分布式定时任务\"><a href=\"#6-分布式定时任务\" class=\"headerlink\" title=\"6. 分布式定时任务\"></a>6. 分布式定时任务</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-分布式ID\"><a href=\"#1-分布式ID\" class=\"headerlink\" title=\"1. 分布式ID\"></a>1. 分布式ID</h2><h2 id=\"2-分布式事务\"><a href=\"#2-分布式事务\" class=\"headerlink\" title=\"2. 分布式事务\"></a>2. 分布式事务</h2><h2 id=\"3-分布式缓存以及缓存与数据库的同步\"><a href=\"#3-分布式缓存以及缓存与数据库的同步\" class=\"headerlink\" title=\"3. 分布式缓存以及缓存与数据库的同步\"></a>3. 分布式缓存以及缓存与数据库的同步</h2><h2 id=\"4-数据库集群同步延迟问题\"><a href=\"#4-数据库集群同步延迟问题\" class=\"headerlink\" title=\"4. 数据库集群同步延迟问题\"></a>4. 数据库集群同步延迟问题</h2><h2 id=\"5-分布式跨库连表查询\"><a href=\"#5-分布式跨库连表查询\" class=\"headerlink\" title=\"5. 分布式跨库连表查询\"></a>5. 分布式跨库连表查询</h2><h2 id=\"6-分布式定时任务\"><a href=\"#6-分布式定时任务\" class=\"headerlink\" title=\"6. 分布式定时任务\"></a>6. 分布式定时任务</h2>"},{"title":"分布式ID生成-snowflake算法","date":"2017-09-20T03:06:57.000Z","_content":"## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","source":"_posts/distributed-id-snowflake.md","raw":"---\ntitle: 分布式ID生成-snowflake算法\ndate: 2017-09-20 11:06:57\ncategories: 分布式系统\ntags: snowflake算法\n---\n## 应用场景\nsnowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。\n借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。\n#### 举例，假设某公司ID生成器服务的需求如下：\n（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W\n（2）有2个机房，预计未来5年机房数量小于4个\n（3）每个机房机器数小于100台\n（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个\n（5）…\n分析过程如下：\n（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年*365天*24小时*3600秒*1000毫秒=320*10^9，差不多预留39bit给毫秒数\n（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号\n（3）5年内机房数小于4个，预留2bit给机房标识\n（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识\n（5）业务线小于10个，预留4bit给业务线标识\n {% asset_img a.png %}   \n 这样设计的64bit标识，可以保证：\n （1）每个业务线、每个机房、每个机器生成的ID都是不同的\n （2）同一个机器，每个毫秒内生成的ID都是不同的\n （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的\n （4）将毫秒数放在最高位，保证生成的ID是趋势递增的\n 缺点：\n （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）\n 最后一个容易忽略的问题：\n 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。\n 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。\n \n    package com.ymu.spcselling.infrastructure.idgenerator;\n    \n    import lombok.extern.slf4j.Slf4j;\n    \n    /**\n     * <p>\n     * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n     * <p>\n     * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n     * 10位的机器标识（10位的长度最多支持部署1024个节点）\n     * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n     * <p>\n     * 结构如下(每部分用-分开):<br>\n     * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 <br>\n     * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n     * Author:frankwoo(吴峻申) <br>\n     * Date:2017/8/29 <br>\n     * Time:下午6:32 <br>\n     * Mail:frank_wjs@hotmail.com <br>\n     */\n    @Slf4j\n    public class SnowflakeIdWorker {\n        //开始时间截 (从2015-01-01起)\n        private static final long START_TIME = 1420041600000L;\n        // 机器ID所占位数\n        private static final long ID_BITS = 5L;\n        //数据中心ID所占位数\n        private static final long DATA_CENTER_ID_BITS = 5L;\n        // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n        private static final long MAX_ID = ~(-1L << ID_BITS);\n        // 数据中心ID最大值31\n        private static final long MAX_DATA_CENTER_ID = ~(-1L << DATA_CENTER_ID_BITS);\n        //Sequence所占位数\n        private static final long SEQUENCE_BITS = 12L;\n        //机器ID偏移量12\n        private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n        //数据中心ID偏移量12+5=17\n        private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n        //时间戳的偏移量12+5+5=22\n        private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n        // Sequence掩码4095\n        private static final long SEQUENCE_MASK = ~(-1L << SEQUENCE_BITS);\n        // 上一毫秒数\n        private static long lastTimestamp = -1L;\n        //毫秒内Sequence(0~4095)\n        private static long sequence = 0L;\n        //机器ID(0-31)\n        private final long workerId;\n        //数据中心ID(0-31)\n        private final long dataCenterId;\n    \n        /**\n         * 构造\n         *\n         * @param workerId     机器ID(0-31)\n         * @param dataCenterId 数据中心ID(0-31)\n         */\n        public SnowflakeIdWorker(long workerId, long dataCenterId) {\n            if (workerId > MAX_ID || workerId < 0) {\n                throw new IllegalArgumentException(String.format(\"worker Id can't be greater than %d or less than 0\", MAX_ID));\n            }\n            if (dataCenterId > MAX_DATA_CENTER_ID || dataCenterId < 0) {\n                throw new IllegalArgumentException(String.format(\"datacenter Id can't be greater than %d or less than 0\", MAX_DATA_CENTER_ID));\n            }\n            this.workerId = workerId;\n            this.dataCenterId = dataCenterId;\n            log.info(String.format(\"worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d\", TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n        }\n    \n        /**\n         * 生成ID（线程安全）\n         *\n         * @return id\n         */\n        public synchronized long nextId() {\n            long timestamp = timeGen();\n    \n            //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n            if (timestamp < lastTimestamp) {\n                log.error(String.format(\"clock is moving backwards.  Rejecting requests until %d.\", lastTimestamp));\n                throw new IllegalStateException(String.format(\"Clock moved backwards.  Refusing to generate id for %d milliseconds\", lastTimestamp - timestamp));\n            }\n    \n            //如果是同一时间生成的，则进行毫秒内sequence生成\n            if (lastTimestamp == timestamp) {\n                sequence = (sequence + 1) & SEQUENCE_MASK;\n                //溢出处理\n                if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                    timestamp = tilNextMillis(lastTimestamp);\n                }\n            } else {//时间戳改变，毫秒内sequence重置\n                sequence = 0L;\n            }\n            //上次生成ID时间截\n            lastTimestamp = timestamp;\n    \n            //移位并通过或运算组成64位ID\n            return ((timestamp - START_TIME) << TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId << DATA_CENTER_ID_SHIFT_BITS) | (workerId << ID_SHIFT_BITS) | sequence;\n        }\n    \n        /**\n         * 阻塞到下一毫秒,获得新时间戳\n         *\n         * @param lastTimestamp 上次生成ID时间截\n         * @return 当前时间戳\n         */\n        private long tilNextMillis(long lastTimestamp) {\n            long timestamp = timeGen();\n            while (timestamp <= lastTimestamp) {\n                timestamp = timeGen();\n            }\n            return timestamp;\n        }\n    \n        /**\n         * 获取以毫秒为单位的当前时间\n         *\n         * @return 当前时间(毫秒)\n         */\n        private long timeGen() {\n            return System.currentTimeMillis();\n        }\n    \n        //==============================Test=============================================\n        /** 测试 */\n        /*public static void main(String[] args) {\n            SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n            for (int i = 0; i < 1000; i++) {\n                long id = idWorker.nextId();\n                System.out.println(Long.toBinaryString(id));\n                System.out.println(id);\n            }\n        }*/\n    } \n","slug":"distributed-id-snowflake","published":1,"updated":"2017-11-14T08:30:11.181Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknf000g8orajotthrmu","content":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"应用场景\"><a href=\"#应用场景\" class=\"headerlink\" title=\"应用场景\"></a>应用场景</h2><p>snowflake是twitter开源的分布式ID生成算法，其核心思想是：一个long型的ID，使用其中41bit作为毫秒数，10bit作为机器编号，12bit作为毫秒内序列号。这个算法单机每秒内理论上最多可以生成1000*(2^12)，也就是400W的ID，完全能满足业务的需求。<br>借鉴snowflake的思想，结合各公司的业务逻辑和并发量，可以实现自己的分布式ID生成算法。</p>\n<h4 id=\"举例，假设某公司ID生成器服务的需求如下：\"><a href=\"#举例，假设某公司ID生成器服务的需求如下：\" class=\"headerlink\" title=\"举例，假设某公司ID生成器服务的需求如下：\"></a>举例，假设某公司ID生成器服务的需求如下：</h4><p>（1）单机高峰并发量小于1W，预计未来5年单机高峰并发量小于10W<br>（2）有2个机房，预计未来5年机房数量小于4个<br>（3）每个机房机器数小于100台<br>（4）目前有5个业务线有ID生成需求，预计未来业务线数量小于10个<br>（5）…<br>分析过程如下：<br>（1）高位取从2016年1月1日到现在的毫秒数（假设系统ID生成器服务在这个时间之后上线），假设系统至少运行10年，那至少需要10年<em>365天</em>24小时<em>3600秒</em>1000毫秒=320*10^9，差不多预留39bit给毫秒数<br>（2）每秒的单机高峰并发量小于10W，即平均每毫秒的单机高峰并发量小于100，差不多预留7bit给每毫秒内序列号<br>（3）5年内机房数小于4个，预留2bit给机房标识<br>（4）每个机房小于100台机器，预留7bit给每个机房内的服务器标识<br>（5）业务线小于10个，预留4bit给业务线标识<br> <img src=\"/2017/09/20/distributed-id-snowflake/a.png\"><br> 这样设计的64bit标识，可以保证：<br> （1）每个业务线、每个机房、每个机器生成的ID都是不同的<br> （2）同一个机器，每个毫秒内生成的ID都是不同的<br> （3）同一个机器，同一个毫秒内，以序列号区区分保证生成的ID是不同的<br> （4）将毫秒数放在最高位，保证生成的ID是趋势递增的<br> 缺点：<br> （1）由于“没有一个全局时钟”，每台服务器分配的ID是绝对递增的，但从全局看，生成的ID只是趋势递增的（有些服务器的时间早，有些服务器的时间晚）<br> 最后一个容易忽略的问题：<br> 生成的ID，例如message-id/ order-id/ tiezi-id，在数据量大时往往需要分库分表，这些ID经常作为取模分库分表的依据，为了分库分表后数据均匀，ID生成往往有“取模随机性”的需求，所以我们通常把每秒内的序列号放在ID的最末位，保证生成的ID是随机的。<br> 又如果，我们在跨毫秒时，序列号总是归0，会使得序列号为0的ID比较多，导致生成的ID取模后不均匀。解决方法是，序列号不是每次都归0，而是归一个0到9的随机数，这个地方。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.idgenerator;\n\nimport lombok.extern.slf4j.Slf4j;\n\n/**\n * &lt;p&gt;\n * Snowflake算法是带有时间戳的全局唯一ID生成算法。它有一套固定的ID格式，如下：\n * &lt;p&gt;\n * 41位的时间序列（精确到毫秒，41位的长度可以使用69年）\n * 10位的机器标识（10位的长度最多支持部署1024个节点）\n * 12位的Sequence序列号（12位的Sequence序列号支持每个节点每毫秒产生4096个ID序号）\n * &lt;p&gt;\n * 结构如下(每部分用-分开):&lt;br&gt;\n * 0 - 0000000000 0000000000 0000000000 0000000000 0 - 00000 - 00000 - 000000000000 &lt;br&gt;\n * 优点是：整体上按照时间自增排序，且整个分布式系统内不会产生ID碰撞(由数据中心ID和机器ID作区分)\n * Author:frankwoo(吴峻申) &lt;br&gt;\n * Date:2017/8/29 &lt;br&gt;\n * Time:下午6:32 &lt;br&gt;\n * Mail:frank_wjs@hotmail.com &lt;br&gt;\n */\n@Slf4j\npublic class SnowflakeIdWorker {\n    //开始时间截 (从2015-01-01起)\n    private static final long START_TIME = 1420041600000L;\n    // 机器ID所占位数\n    private static final long ID_BITS = 5L;\n    //数据中心ID所占位数\n    private static final long DATA_CENTER_ID_BITS = 5L;\n    // 机器ID最大值31 (此移位算法可很快计算出n位二进制数所能表示的最大十进制数)\n    private static final long MAX_ID = ~(-1L &lt;&lt; ID_BITS);\n    // 数据中心ID最大值31\n    private static final long MAX_DATA_CENTER_ID = ~(-1L &lt;&lt; DATA_CENTER_ID_BITS);\n    //Sequence所占位数\n    private static final long SEQUENCE_BITS = 12L;\n    //机器ID偏移量12\n    private static final long ID_SHIFT_BITS = SEQUENCE_BITS;\n    //数据中心ID偏移量12+5=17\n    private static final long DATA_CENTER_ID_SHIFT_BITS = SEQUENCE_BITS + ID_BITS;\n    //时间戳的偏移量12+5+5=22\n    private static final long TIMESTAMP_LEFT_SHIFT_BITS = SEQUENCE_BITS + ID_BITS + DATA_CENTER_ID_BITS;\n    // Sequence掩码4095\n    private static final long SEQUENCE_MASK = ~(-1L &lt;&lt; SEQUENCE_BITS);\n    // 上一毫秒数\n    private static long lastTimestamp = -1L;\n    //毫秒内Sequence(0~4095)\n    private static long sequence = 0L;\n    //机器ID(0-31)\n    private final long workerId;\n    //数据中心ID(0-31)\n    private final long dataCenterId;\n\n    /**\n     * 构造\n     *\n     * @param workerId     机器ID(0-31)\n     * @param dataCenterId 数据中心ID(0-31)\n     */\n    public SnowflakeIdWorker(long workerId, long dataCenterId) {\n        if (workerId &gt; MAX_ID || workerId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;worker Id can&apos;t be greater than %d or less than 0&quot;, MAX_ID));\n        }\n        if (dataCenterId &gt; MAX_DATA_CENTER_ID || dataCenterId &lt; 0) {\n            throw new IllegalArgumentException(String.format(&quot;datacenter Id can&apos;t be greater than %d or less than 0&quot;, MAX_DATA_CENTER_ID));\n        }\n        this.workerId = workerId;\n        this.dataCenterId = dataCenterId;\n        log.info(String.format(&quot;worker starting. timestamp left shift %d, datacenter id bits %d, worker id bits %d, sequence bits %d, workerid %d&quot;, TIMESTAMP_LEFT_SHIFT_BITS, DATA_CENTER_ID_BITS, ID_BITS, SEQUENCE_BITS, workerId));\n    }\n\n    /**\n     * 生成ID（线程安全）\n     *\n     * @return id\n     */\n    public synchronized long nextId() {\n        long timestamp = timeGen();\n\n        //如果当前时间小于上一次ID生成的时间戳，说明系统时钟被修改过，回退在上一次ID生成时间之前应当抛出异常！！！\n        if (timestamp &lt; lastTimestamp) {\n            log.error(String.format(&quot;clock is moving backwards.  Rejecting requests until %d.&quot;, lastTimestamp));\n            throw new IllegalStateException(String.format(&quot;Clock moved backwards.  Refusing to generate id for %d milliseconds&quot;, lastTimestamp - timestamp));\n        }\n\n        //如果是同一时间生成的，则进行毫秒内sequence生成\n        if (lastTimestamp == timestamp) {\n            sequence = (sequence + 1) &amp; SEQUENCE_MASK;\n            //溢出处理\n            if (sequence == 0) {//阻塞到下一毫秒,获得新时间戳\n                timestamp = tilNextMillis(lastTimestamp);\n            }\n        } else {//时间戳改变，毫秒内sequence重置\n            sequence = 0L;\n        }\n        //上次生成ID时间截\n        lastTimestamp = timestamp;\n\n        //移位并通过或运算组成64位ID\n        return ((timestamp - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT_BITS) | (dataCenterId &lt;&lt; DATA_CENTER_ID_SHIFT_BITS) | (workerId &lt;&lt; ID_SHIFT_BITS) | sequence;\n    }\n\n    /**\n     * 阻塞到下一毫秒,获得新时间戳\n     *\n     * @param lastTimestamp 上次生成ID时间截\n     * @return 当前时间戳\n     */\n    private long tilNextMillis(long lastTimestamp) {\n        long timestamp = timeGen();\n        while (timestamp &lt;= lastTimestamp) {\n            timestamp = timeGen();\n        }\n        return timestamp;\n    }\n\n    /**\n     * 获取以毫秒为单位的当前时间\n     *\n     * @return 当前时间(毫秒)\n     */\n    private long timeGen() {\n        return System.currentTimeMillis();\n    }\n\n    //==============================Test=============================================\n    /** 测试 */\n    /*public static void main(String[] args) {\n        SnowflakeIdWorker idWorker = new SnowflakeIdWorker(0, 0);\n        for (int i = 0; i &lt; 1000; i++) {\n            long id = idWorker.nextId();\n            System.out.println(Long.toBinaryString(id));\n            System.out.println(id);\n        }\n    }*/\n} \n</code></pre>"},{"title":"centos7下搭建maven私仓Nexus","date":"2017-11-12T06:47:38.000Z","_content":"\n项目组件化，共用jar包，统一获取墙外jar包…… \n\n官方文档 [sonatype](https://www.sonatype.com/)\n\n## 安装jdk\n参考其他文章……\n\n\n## 下载Nexus Repository OSS\n> 下载地址：http://www.sonatype.com/download-oss-sonatype\n\n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n\n解压：\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n    \n## 启动\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n    [root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n\n如果启动成功，可以看到：\n > Started Sonatype Nexus OSS 3.6.0-02\n\n防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。\n\n在浏览器访问：http://47.52.236.72:8081/，可以看到：\n\n{% asset_img a.png %}\n\n## 配置为Linux Service\n\n1. 编辑`bin/nexus.rc`：\n\n`[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc`\n\n添加： \n> run_as_user=\"root\"\n\n2. 在`/etc/init.d`放nexus软连接\n\n` ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus`\n\n3. 设置服务随系统自启\n命令：*chkconfig*\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n    [root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n\n5. 启动\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\n    WARNING: ************************************************************\n    WARNING: Detected execution as \"root\" user.  This is NOT recommended!\n    WARNING: ************************************************************\n    Starting nexus\n\n## 界面操作\n\n*1. 登录*\n\n默认账号密码：\nusername: admin\npwd: admin123\n\n{% asset_img b.png %} \n\n*2. 修改admin密码*\n\n{% asset_img c.png %}\n\n点击`More`\n\n{% asset_img d.png %}\n    \n## 创建maven仓库\n\n{% asset_img e.png %}\n\n简单介绍下几种repository的类型:\n\n> - hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。\n> - proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。\n> - group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。\n\n这里我们选择创建本地仓库：\n{% asset_img f.png %}\n\n填写内容：\n{% asset_img g.png %}\n\n> version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。\n\n创建成功：\n{% asset_img h.png %}\n\n添加到maven-public仓库组：\n{% asset_img j.png %}\n\n## 查看仓库\n如果上传了项目，在Nexus用户界面，选择components -> xiaoming-host\n\n{% asset_img i.png %}\n\n\n\n\n    \n","source":"_posts/centos-maven-nexus.md","raw":"---\ntitle: centos7下搭建maven私仓Nexus\ndate: 2017-11-12 14:47:38\ncategories: CentOs\ntags: centos-nexus\n---\n\n项目组件化，共用jar包，统一获取墙外jar包…… \n\n官方文档 [sonatype](https://www.sonatype.com/)\n\n## 安装jdk\n参考其他文章……\n\n\n## 下载Nexus Repository OSS\n> 下载地址：http://www.sonatype.com/download-oss-sonatype\n\n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n\n解压：\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n    \n## 启动\n    \n    [root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n    [root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n\n如果启动成功，可以看到：\n > Started Sonatype Nexus OSS 3.6.0-02\n\n防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。\n\n在浏览器访问：http://47.52.236.72:8081/，可以看到：\n\n{% asset_img a.png %}\n\n## 配置为Linux Service\n\n1. 编辑`bin/nexus.rc`：\n\n`[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc`\n\n添加： \n> run_as_user=\"root\"\n\n2. 在`/etc/init.d`放nexus软连接\n\n` ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus`\n\n3. 设置服务随系统自启\n命令：*chkconfig*\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n    [root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n\n5. 启动\n\n\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\n    WARNING: ************************************************************\n    WARNING: Detected execution as \"root\" user.  This is NOT recommended!\n    WARNING: ************************************************************\n    Starting nexus\n\n## 界面操作\n\n*1. 登录*\n\n默认账号密码：\nusername: admin\npwd: admin123\n\n{% asset_img b.png %} \n\n*2. 修改admin密码*\n\n{% asset_img c.png %}\n\n点击`More`\n\n{% asset_img d.png %}\n    \n## 创建maven仓库\n\n{% asset_img e.png %}\n\n简单介绍下几种repository的类型:\n\n> - hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。\n> - proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。\n> - group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。\n\n这里我们选择创建本地仓库：\n{% asset_img f.png %}\n\n填写内容：\n{% asset_img g.png %}\n\n> version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。\n\n创建成功：\n{% asset_img h.png %}\n\n添加到maven-public仓库组：\n{% asset_img j.png %}\n\n## 查看仓库\n如果上传了项目，在Nexus用户界面，选择components -> xiaoming-host\n\n{% asset_img i.png %}\n\n\n\n\n    \n","slug":"centos-maven-nexus","published":1,"updated":"2017-11-14T08:30:11.156Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknh000i8oraqq0qkxy2","content":"<p>项目组件化，共用jar包，统一获取墙外jar包…… </p>\n<p>官方文档 <a href=\"https://www.sonatype.com/\" target=\"_blank\" rel=\"external\">sonatype</a></p>\n<h2 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h2><p>参考其他文章……</p>\n<h2 id=\"下载Nexus-Repository-OSS\"><a href=\"#下载Nexus-Repository-OSS\" class=\"headerlink\" title=\"下载Nexus Repository OSS\"></a>下载Nexus Repository OSS</h2><blockquote>\n<p>下载地址：<a href=\"http://www.sonatype.com/download-oss-sonatype\" target=\"_blank\" rel=\"external\">http://www.sonatype.com/download-oss-sonatype</a></p>\n</blockquote>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n</code></pre><p>解压：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n[root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n</code></pre><p>如果启动成功，可以看到：</p>\n<blockquote>\n<p>Started Sonatype Nexus OSS 3.6.0-02</p>\n</blockquote>\n<p>防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。</p>\n<p>在浏览器访问：<a href=\"http://47.52.236.72:8081/，可以看到：\" target=\"_blank\" rel=\"external\">http://47.52.236.72:8081/，可以看到：</a></p>\n<img src=\"/2017/11/12/centos-maven-nexus/a.png\">\n<h2 id=\"配置为Linux-Service\"><a href=\"#配置为Linux-Service\" class=\"headerlink\" title=\"配置为Linux Service\"></a>配置为Linux Service</h2><ol>\n<li>编辑<code>bin/nexus.rc</code>：</li>\n</ol>\n<p><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc</code></p>\n<p>添加： </p>\n<blockquote>\n<p>run_as_user=”root”</p>\n</blockquote>\n<ol>\n<li>在<code>/etc/init.d</code>放nexus软连接</li>\n</ol>\n<p><code>ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus</code></p>\n<ol>\n<li>设置服务随系统自启<br>命令：<em>chkconfig</em></li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n[root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n</code></pre><ol>\n<li>启动</li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\nWARNING: ************************************************************\nWARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!\nWARNING: ************************************************************\nStarting nexus\n</code></pre><h2 id=\"界面操作\"><a href=\"#界面操作\" class=\"headerlink\" title=\"界面操作\"></a>界面操作</h2><p><em>1. 登录</em></p>\n<p>默认账号密码：<br>username: admin<br>pwd: admin123</p>\n<img src=\"/2017/11/12/centos-maven-nexus/b.png\"> \n<p><em>2. 修改admin密码</em></p>\n<img src=\"/2017/11/12/centos-maven-nexus/c.png\">\n<p>点击<code>More</code></p>\n<img src=\"/2017/11/12/centos-maven-nexus/d.png\">\n<h2 id=\"创建maven仓库\"><a href=\"#创建maven仓库\" class=\"headerlink\" title=\"创建maven仓库\"></a>创建maven仓库</h2><img src=\"/2017/11/12/centos-maven-nexus/e.png\">\n<p>简单介绍下几种repository的类型:</p>\n<blockquote>\n<ul>\n<li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>\n<li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li>\n<li>group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li>\n</ul>\n</blockquote>\n<p>这里我们选择创建本地仓库：<br><img src=\"/2017/11/12/centos-maven-nexus/f.png\"></p>\n<p>填写内容：<br><img src=\"/2017/11/12/centos-maven-nexus/g.png\"></p>\n<blockquote>\n<p>version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。</p>\n</blockquote>\n<p>创建成功：<br><img src=\"/2017/11/12/centos-maven-nexus/h.png\"></p>\n<p>添加到maven-public仓库组：<br><img src=\"/2017/11/12/centos-maven-nexus/j.png\"></p>\n<h2 id=\"查看仓库\"><a href=\"#查看仓库\" class=\"headerlink\" title=\"查看仓库\"></a>查看仓库</h2><p>如果上传了项目，在Nexus用户界面，选择components -&gt; xiaoming-host</p>\n<img src=\"/2017/11/12/centos-maven-nexus/i.png\">\n","site":{"data":{}},"excerpt":"","more":"<p>项目组件化，共用jar包，统一获取墙外jar包…… </p>\n<p>官方文档 <a href=\"https://www.sonatype.com/\" target=\"_blank\" rel=\"external\">sonatype</a></p>\n<h2 id=\"安装jdk\"><a href=\"#安装jdk\" class=\"headerlink\" title=\"安装jdk\"></a>安装jdk</h2><p>参考其他文章……</p>\n<h2 id=\"下载Nexus-Repository-OSS\"><a href=\"#下载Nexus-Repository-OSS\" class=\"headerlink\" title=\"下载Nexus Repository OSS\"></a>下载Nexus Repository OSS</h2><blockquote>\n<p>下载地址：<a href=\"http://www.sonatype.com/download-oss-sonatype\" target=\"_blank\" rel=\"external\">http://www.sonatype.com/download-oss-sonatype</a></p>\n</blockquote>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# axel -n 10 https://sonatype-download.global.ssl.fastly.net/nexus/3/nexus-3.6.0-02-unix.tar.gz\n</code></pre><p>解压：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# tar -zxvf nexus-3.6.0-02-unix.tar.gz\n</code></pre><h2 id=\"启动\"><a href=\"#启动\" class=\"headerlink\" title=\"启动\"></a>启动</h2><pre><code>[root@iZj6ca50pk1lwxqo14jss8Z nexus]# cd nexus-3.6.0-02/bin/\n[root@iZj6ca50pk1lwxqo14jss8Z bin]# ./nexus run\n</code></pre><p>如果启动成功，可以看到：</p>\n<blockquote>\n<p>Started Sonatype Nexus OSS 3.6.0-02</p>\n</blockquote>\n<p>防火墙开启8081端口。注意还要在阿里云控制后台安全组开启端口。</p>\n<p>在浏览器访问：<a href=\"http://47.52.236.72:8081/，可以看到：\" target=\"_blank\" rel=\"external\">http://47.52.236.72:8081/，可以看到：</a></p>\n<img src=\"/2017/11/12/centos-maven-nexus/a.png\">\n<h2 id=\"配置为Linux-Service\"><a href=\"#配置为Linux-Service\" class=\"headerlink\" title=\"配置为Linux Service\"></a>配置为Linux Service</h2><ol>\n<li>编辑<code>bin/nexus.rc</code>：</li>\n</ol>\n<p><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# vim /server/java/nexus/nexus-3.6.0-02/bin/nexus.rc</code></p>\n<p>添加： </p>\n<blockquote>\n<p>run_as_user=”root”</p>\n</blockquote>\n<ol>\n<li>在<code>/etc/init.d</code>放nexus软连接</li>\n</ol>\n<p><code>ln -s /server/java/nexus/nexus-3.6.0-02/bin/nexus /etc/init.d/nexus</code></p>\n<ol>\n<li>设置服务随系统自启<br>命令：<em>chkconfig</em></li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# cd /etc/init.d/\n[root@iZj6ca50pk1lwxqo14jss8Z init.d]# chkconfig nexus on\n</code></pre><ol>\n<li>启动</li>\n</ol>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# service nexus start\nWARNING: ************************************************************\nWARNING: Detected execution as &quot;root&quot; user.  This is NOT recommended!\nWARNING: ************************************************************\nStarting nexus\n</code></pre><h2 id=\"界面操作\"><a href=\"#界面操作\" class=\"headerlink\" title=\"界面操作\"></a>界面操作</h2><p><em>1. 登录</em></p>\n<p>默认账号密码：<br>username: admin<br>pwd: admin123</p>\n<img src=\"/2017/11/12/centos-maven-nexus/b.png\"> \n<p><em>2. 修改admin密码</em></p>\n<img src=\"/2017/11/12/centos-maven-nexus/c.png\">\n<p>点击<code>More</code></p>\n<img src=\"/2017/11/12/centos-maven-nexus/d.png\">\n<h2 id=\"创建maven仓库\"><a href=\"#创建maven仓库\" class=\"headerlink\" title=\"创建maven仓库\"></a>创建maven仓库</h2><img src=\"/2017/11/12/centos-maven-nexus/e.png\">\n<p>简单介绍下几种repository的类型:</p>\n<blockquote>\n<ul>\n<li>hosted，本地仓库，通常我们会部署自己的构件到这一类型的仓库。比如公司的第二方库。</li>\n<li>proxy，代理仓库，它们被用来代理远程的公共仓库，如maven中央仓库。</li>\n<li>group，仓库组，用来合并多个hosted/proxy仓库，当你的项目希望在多个repository使用资源时就不需要多次引用了，只需要引用一个group即可。</li>\n</ul>\n</blockquote>\n<p>这里我们选择创建本地仓库：<br><img src=\"/2017/11/12/centos-maven-nexus/f.png\"></p>\n<p>填写内容：<br><img src=\"/2017/11/12/centos-maven-nexus/g.png\"></p>\n<blockquote>\n<p>version policy，可以选Release或Snapshot，如果仓库开放给所有人，那选Release比较好，如果公司内部或自己用，其中一个就可以。</p>\n</blockquote>\n<p>创建成功：<br><img src=\"/2017/11/12/centos-maven-nexus/h.png\"></p>\n<p>添加到maven-public仓库组：<br><img src=\"/2017/11/12/centos-maven-nexus/j.png\"></p>\n<h2 id=\"查看仓库\"><a href=\"#查看仓库\" class=\"headerlink\" title=\"查看仓库\"></a>查看仓库</h2><p>如果上传了项目，在Nexus用户界面，选择components -&gt; xiaoming-host</p>\n<img src=\"/2017/11/12/centos-maven-nexus/i.png\">\n"},{"title":"centos7安装docker-ce","date":"2017-11-15T05:55:39.000Z","_content":"\n本文介绍docker在centos7系统上的安装。\n参考：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\n\n## 1. 卸载旧版本docker\n\n    $ sudo yum remove docker \\\n                      docker-common \\\n                      docker-selinux \\\n                      docker-engine\n\n---\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n    >                   docker-common \\\n    >                   docker-selinux \\\n    >                   docker-engine\n    Loaded plugins: fastestmirror\n    No Match for argument: docker\n    No Match for argument: docker-common\n    No Match for argument: docker-selinux\n    No Match for argument: docker-engine\n    No Packages marked for removal\n    \n    ---\n    表明没有旧版本\n    \n旧版本的会安装在`/var/lib/docker/`，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。\n \n## 2. 安装docker-ce\n\n共有三种方式安装,根据自己喜欢方式选择一种安装：\n- 配置安装源，从安装源拉取安装。推荐，但是网络要好\n- 下载安装包，执行安装。网络不好，采用。\n- 下载脚本执行安装。开发环境这种方式方便。\n\n### 2.1 repository方式安装，推荐\n第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。\n1. 安装依赖包\n\n\n    $ sudo yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n\n\n2. 安装源\n        \n        \n    $ sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo                   \n                      \n3. 可选: 开启edge和test源\n\n\n    $ sudo yum-config-manager --enable docker-ce-edge\n    $ sudo yum-config-manager --enable docker-ce-test                     \n    -----\n    关闭：\n    $ sudo yum-config-manager --disable docker-ce-edge    \n    \n4. 安装docker\n\n4.1 安装最新版本\n\n    $ sudo yum install docker-ce\n    \n> Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.\n\n4.2 安装指定版本\n在生成环境，有时候要安装指定版本。\n\n- 查看所有可用版本\n\n        $ yum list docker-ce --showduplicates | sort -r\n        \n        docker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n        \nThe contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).\n> Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.\n\n    $ sudo yum install <FULLY-QUALIFIED-PACKAGE-NAME>\n    \n4.3 启动docker                 \n    \n    $ sudo systemctl start docker                      \n\n4.4 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n会下载docker镜像，然后执行，打印信息。\n\n4.5 更新docker\n根据上面安装过程，重新安装即可。\n\n### 2.2 安装包方式（更喜欢方式）\n\n如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。\n\n1. 下载安装包：\n\n打开网址 *https://download.docker.com/linux/centos/7/x86_64/stable/Packages/*，下载`.rpm`合适版本下载。\n\n> Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.\n\n2. 安装docker\n指向包所在路径，如果是更新，把`install`改成`update`\n\n\n    $ sudo yum install /path/to/package.rpm\n      \n      \n3. 启动docker\n\n    $ sudo systemctl start docker\n    \n4. 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n{% asset_img a.png %}\n\n看到红色标注部分说明安装成功。    \n    \n5. 更新docker-ce\n下载新的安装包，用`yum -y upgrade`替换`yum -y install`,指向新的安装包。    \n\n## 3. 卸载docker-ce\n\n1. 卸载docker安装包：\n\n\n    $ sudo yum remove docker-ce\n    \n2. 卸载docker安装包不会自动删除相关资源，要手动删除：\n\n\n    $ sudo rm -rf /var/lib/docker\n                                      ","source":"_posts/docker-install-centos7.md","raw":"---\ntitle: centos7安装docker-ce\ndate: 2017-11-15 13:55:39\ncategories: docker\ntags: centos-docker-install\n---\n\n本文介绍docker在centos7系统上的安装。\n参考：https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\n\n## 1. 卸载旧版本docker\n\n    $ sudo yum remove docker \\\n                      docker-common \\\n                      docker-selinux \\\n                      docker-engine\n\n---\n    [root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n    >                   docker-common \\\n    >                   docker-selinux \\\n    >                   docker-engine\n    Loaded plugins: fastestmirror\n    No Match for argument: docker\n    No Match for argument: docker-common\n    No Match for argument: docker-selinux\n    No Match for argument: docker-engine\n    No Packages marked for removal\n    \n    ---\n    表明没有旧版本\n    \n旧版本的会安装在`/var/lib/docker/`，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。\n \n## 2. 安装docker-ce\n\n共有三种方式安装,根据自己喜欢方式选择一种安装：\n- 配置安装源，从安装源拉取安装。推荐，但是网络要好\n- 下载安装包，执行安装。网络不好，采用。\n- 下载脚本执行安装。开发环境这种方式方便。\n\n### 2.1 repository方式安装，推荐\n第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。\n1. 安装依赖包\n\n\n    $ sudo yum install -y yum-utils \\\n      device-mapper-persistent-data \\\n      lvm2\n\n\n2. 安装源\n        \n        \n    $ sudo yum-config-manager \\\n        --add-repo \\\n        https://download.docker.com/linux/centos/docker-ce.repo                   \n                      \n3. 可选: 开启edge和test源\n\n\n    $ sudo yum-config-manager --enable docker-ce-edge\n    $ sudo yum-config-manager --enable docker-ce-test                     \n    -----\n    关闭：\n    $ sudo yum-config-manager --disable docker-ce-edge    \n    \n4. 安装docker\n\n4.1 安装最新版本\n\n    $ sudo yum install docker-ce\n    \n> Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.\n\n4.2 安装指定版本\n在生成环境，有时候要安装指定版本。\n\n- 查看所有可用版本\n\n        $ yum list docker-ce --showduplicates | sort -r\n        \n        docker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n        \nThe contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).\n> Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.\n\n    $ sudo yum install <FULLY-QUALIFIED-PACKAGE-NAME>\n    \n4.3 启动docker                 \n    \n    $ sudo systemctl start docker                      \n\n4.4 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n会下载docker镜像，然后执行，打印信息。\n\n4.5 更新docker\n根据上面安装过程，重新安装即可。\n\n### 2.2 安装包方式（更喜欢方式）\n\n如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。\n\n1. 下载安装包：\n\n打开网址 *https://download.docker.com/linux/centos/7/x86_64/stable/Packages/*，下载`.rpm`合适版本下载。\n\n> Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.\n\n2. 安装docker\n指向包所在路径，如果是更新，把`install`改成`update`\n\n\n    $ sudo yum install /path/to/package.rpm\n      \n      \n3. 启动docker\n\n    $ sudo systemctl start docker\n    \n4. 验证是否安装成功\n\n    $ sudo docker run hello-world\n    \n{% asset_img a.png %}\n\n看到红色标注部分说明安装成功。    \n    \n5. 更新docker-ce\n下载新的安装包，用`yum -y upgrade`替换`yum -y install`,指向新的安装包。    \n\n## 3. 卸载docker-ce\n\n1. 卸载docker安装包：\n\n\n    $ sudo yum remove docker-ce\n    \n2. 卸载docker安装包不会自动删除相关资源，要手动删除：\n\n\n    $ sudo rm -rf /var/lib/docker\n                                      ","slug":"docker-install-centos7","published":1,"updated":"2017-11-15T07:47:58.786Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknj000m8orak8qj1nn3","content":"<p>本文介绍docker在centos7系统上的安装。<br>参考：<a href=\"https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\" target=\"_blank\" rel=\"external\">https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions</a></p>\n<h2 id=\"1-卸载旧版本docker\"><a href=\"#1-卸载旧版本docker\" class=\"headerlink\" title=\"1. 卸载旧版本docker\"></a>1. 卸载旧版本docker</h2><pre><code>$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n</code></pre><hr>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n&gt;                   docker-common \\\n&gt;                   docker-selinux \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror\nNo Match for argument: docker\nNo Match for argument: docker-common\nNo Match for argument: docker-selinux\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n---\n表明没有旧版本\n</code></pre><p>旧版本的会安装在<code>/var/lib/docker/</code>，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。</p>\n<h2 id=\"2-安装docker-ce\"><a href=\"#2-安装docker-ce\" class=\"headerlink\" title=\"2. 安装docker-ce\"></a>2. 安装docker-ce</h2><p>共有三种方式安装,根据自己喜欢方式选择一种安装：</p>\n<ul>\n<li>配置安装源，从安装源拉取安装。推荐，但是网络要好</li>\n<li>下载安装包，执行安装。网络不好，采用。</li>\n<li>下载脚本执行安装。开发环境这种方式方便。</li>\n</ul>\n<h3 id=\"2-1-repository方式安装，推荐\"><a href=\"#2-1-repository方式安装，推荐\" class=\"headerlink\" title=\"2.1 repository方式安装，推荐\"></a>2.1 repository方式安装，推荐</h3><p>第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。</p>\n<ol>\n<li>安装依赖包</li>\n</ol>\n<pre><code>$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre><ol>\n<li>安装源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo                   \n</code></pre><ol>\n<li>可选: 开启edge和test源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager --enable docker-ce-edge\n$ sudo yum-config-manager --enable docker-ce-test                     \n-----\n关闭：\n$ sudo yum-config-manager --disable docker-ce-edge    \n</code></pre><ol>\n<li>安装docker</li>\n</ol>\n<p>4.1 安装最新版本</p>\n<pre><code>$ sudo yum install docker-ce\n</code></pre><blockquote>\n<p>Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.</p>\n</blockquote>\n<p>4.2 安装指定版本<br>在生成环境，有时候要安装指定版本。</p>\n<ul>\n<li><p>查看所有可用版本</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n</code></pre></li>\n</ul>\n<p>The contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).</p>\n<blockquote>\n<p>Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.</p>\n</blockquote>\n<pre><code>$ sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt;\n</code></pre><p>4.3 启动docker                 </p>\n<pre><code>$ sudo systemctl start docker                      \n</code></pre><p>4.4 验证是否安装成功</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre><p>会下载docker镜像，然后执行，打印信息。</p>\n<p>4.5 更新docker<br>根据上面安装过程，重新安装即可。</p>\n<h3 id=\"2-2-安装包方式（更喜欢方式）\"><a href=\"#2-2-安装包方式（更喜欢方式）\" class=\"headerlink\" title=\"2.2 安装包方式（更喜欢方式）\"></a>2.2 安装包方式（更喜欢方式）</h3><p>如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。</p>\n<ol>\n<li>下载安装包：</li>\n</ol>\n<p>打开网址 <em><a href=\"https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\" target=\"_blank\" rel=\"external\">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></em>，下载<code>.rpm</code>合适版本下载。</p>\n<blockquote>\n<p>Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.</p>\n</blockquote>\n<ol>\n<li>安装docker<br>指向包所在路径，如果是更新，把<code>install</code>改成<code>update</code></li>\n</ol>\n<pre><code>$ sudo yum install /path/to/package.rpm\n</code></pre><ol>\n<li><p>启动docker</p>\n<p> $ sudo systemctl start docker</p>\n</li>\n<li><p>验证是否安装成功</p>\n<p> $ sudo docker run hello-world</p>\n</li>\n</ol>\n<img src=\"/2017/11/15/docker-install-centos7/a.png\">\n<p>看到红色标注部分说明安装成功。    </p>\n<ol>\n<li>更新docker-ce<br>下载新的安装包，用<code>yum -y upgrade</code>替换<code>yum -y install</code>,指向新的安装包。    </li>\n</ol>\n<h2 id=\"3-卸载docker-ce\"><a href=\"#3-卸载docker-ce\" class=\"headerlink\" title=\"3. 卸载docker-ce\"></a>3. 卸载docker-ce</h2><ol>\n<li>卸载docker安装包：</li>\n</ol>\n<pre><code>$ sudo yum remove docker-ce\n</code></pre><ol>\n<li>卸载docker安装包不会自动删除相关资源，要手动删除：</li>\n</ol>\n<pre><code>$ sudo rm -rf /var/lib/docker\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>本文介绍docker在centos7系统上的安装。<br>参考：<a href=\"https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions\" target=\"_blank\" rel=\"external\">https://docs.docker.com/engine/installation/linux/docker-ce/centos/#uninstall-old-versions</a></p>\n<h2 id=\"1-卸载旧版本docker\"><a href=\"#1-卸载旧版本docker\" class=\"headerlink\" title=\"1. 卸载旧版本docker\"></a>1. 卸载旧版本docker</h2><pre><code>$ sudo yum remove docker \\\n                  docker-common \\\n                  docker-selinux \\\n                  docker-engine\n</code></pre><hr>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# sudo yum remove docker \\\n&gt;                   docker-common \\\n&gt;                   docker-selinux \\\n&gt;                   docker-engine\nLoaded plugins: fastestmirror\nNo Match for argument: docker\nNo Match for argument: docker-common\nNo Match for argument: docker-selinux\nNo Match for argument: docker-engine\nNo Packages marked for removal\n\n---\n表明没有旧版本\n</code></pre><p>旧版本的会安装在<code>/var/lib/docker/</code>，包括images，images, containers, volumes, 和 networks。docker ce现在命名为docker-ce。</p>\n<h2 id=\"2-安装docker-ce\"><a href=\"#2-安装docker-ce\" class=\"headerlink\" title=\"2. 安装docker-ce\"></a>2. 安装docker-ce</h2><p>共有三种方式安装,根据自己喜欢方式选择一种安装：</p>\n<ul>\n<li>配置安装源，从安装源拉取安装。推荐，但是网络要好</li>\n<li>下载安装包，执行安装。网络不好，采用。</li>\n<li>下载脚本执行安装。开发环境这种方式方便。</li>\n</ul>\n<h3 id=\"2-1-repository方式安装，推荐\"><a href=\"#2-1-repository方式安装，推荐\" class=\"headerlink\" title=\"2.1 repository方式安装，推荐\"></a>2.1 repository方式安装，推荐</h3><p>第一次安装，需要先安装Docker repository,然后就可以从repository安装docker或者更新docker。</p>\n<ol>\n<li>安装依赖包</li>\n</ol>\n<pre><code>$ sudo yum install -y yum-utils \\\n  device-mapper-persistent-data \\\n  lvm2\n</code></pre><ol>\n<li>安装源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager \\\n    --add-repo \\\n    https://download.docker.com/linux/centos/docker-ce.repo                   \n</code></pre><ol>\n<li>可选: 开启edge和test源</li>\n</ol>\n<pre><code>$ sudo yum-config-manager --enable docker-ce-edge\n$ sudo yum-config-manager --enable docker-ce-test                     \n-----\n关闭：\n$ sudo yum-config-manager --disable docker-ce-edge    \n</code></pre><ol>\n<li>安装docker</li>\n</ol>\n<p>4.1 安装最新版本</p>\n<pre><code>$ sudo yum install docker-ce\n</code></pre><blockquote>\n<p>Warning: If you have multiple Docker repositories enabled, installing or updating without specifying a version in the yum install or yum update command will always install the highest possible version, which may not be appropriate for your stability needs.</p>\n</blockquote>\n<p>4.2 安装指定版本<br>在生成环境，有时候要安装指定版本。</p>\n<ul>\n<li><p>查看所有可用版本</p>\n<pre><code>$ yum list docker-ce --showduplicates | sort -r\n\ndocker-ce.x86_64            17.09.ce-1.el7.centos             docker-ce-stable                     \n</code></pre></li>\n</ul>\n<p>The contents of the list depend upon which repositories are enabled, and will be specific to your version of CentOS (indicated by the .el7 suffix on the version, in this example). Choose a specific version to install. The second column is the version string. You can use the entire version string, but you need to include at least to the first hyphen. The third column is the repository name, which indicates which repository the package is from and by extension its stability level. To install a specific version, append the version string to the package name and separate them by a hyphen (-).</p>\n<blockquote>\n<p>Note: The version string is the package name plus the version up to the first hyphen. In the example above, the fully qualified package name is docker-ce-17.06.1.ce.</p>\n</blockquote>\n<pre><code>$ sudo yum install &lt;FULLY-QUALIFIED-PACKAGE-NAME&gt;\n</code></pre><p>4.3 启动docker                 </p>\n<pre><code>$ sudo systemctl start docker                      \n</code></pre><p>4.4 验证是否安装成功</p>\n<pre><code>$ sudo docker run hello-world\n</code></pre><p>会下载docker镜像，然后执行，打印信息。</p>\n<p>4.5 更新docker<br>根据上面安装过程，重新安装即可。</p>\n<h3 id=\"2-2-安装包方式（更喜欢方式）\"><a href=\"#2-2-安装包方式（更喜欢方式）\" class=\"headerlink\" title=\"2.2 安装包方式（更喜欢方式）\"></a>2.2 安装包方式（更喜欢方式）</h3><p>如果无法使用安装源方式（网络不通），那就可以采用安装包方式。但是每次更新都要下载最新包。</p>\n<ol>\n<li>下载安装包：</li>\n</ol>\n<p>打开网址 <em><a href=\"https://download.docker.com/linux/centos/7/x86_64/stable/Packages/\" target=\"_blank\" rel=\"external\">https://download.docker.com/linux/centos/7/x86_64/stable/Packages/</a></em>，下载<code>.rpm</code>合适版本下载。</p>\n<blockquote>\n<p>Note: To install an edge package, change the word stable in the above URL to edge. Learn about stable and edge channels.</p>\n</blockquote>\n<ol>\n<li>安装docker<br>指向包所在路径，如果是更新，把<code>install</code>改成<code>update</code></li>\n</ol>\n<pre><code>$ sudo yum install /path/to/package.rpm\n</code></pre><ol>\n<li><p>启动docker</p>\n<p> $ sudo systemctl start docker</p>\n</li>\n<li><p>验证是否安装成功</p>\n<p> $ sudo docker run hello-world</p>\n</li>\n</ol>\n<img src=\"/2017/11/15/docker-install-centos7/a.png\">\n<p>看到红色标注部分说明安装成功。    </p>\n<ol>\n<li>更新docker-ce<br>下载新的安装包，用<code>yum -y upgrade</code>替换<code>yum -y install</code>,指向新的安装包。    </li>\n</ol>\n<h2 id=\"3-卸载docker-ce\"><a href=\"#3-卸载docker-ce\" class=\"headerlink\" title=\"3. 卸载docker-ce\"></a>3. 卸载docker-ce</h2><ol>\n<li>卸载docker安装包：</li>\n</ol>\n<pre><code>$ sudo yum remove docker-ce\n</code></pre><ol>\n<li>卸载docker安装包不会自动删除相关资源，要手动删除：</li>\n</ol>\n<pre><code>$ sudo rm -rf /var/lib/docker\n</code></pre>"},{"title":"git在centos7下源码编译安装","date":"2017-10-14T02:04:31.000Z","_content":"\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>   n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","source":"_posts/git-install-in-centos7.md","raw":"---\ntitle: git在centos7下源码编译安装\ndate: 2017-10-14 10:04:31\ncategories: git\ntags: git-install-in-centos\n---\n\n## 一、安装依赖包\nyum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker\n\n## 二、下载最新稳定版本安装包\n源码网址：https://github.com/git/git\n\n## 三、查看是否已经安装了旧版本\n> git --version\n如果有显示版本信息，则先卸载旧版本\n> yum -y remove git\n> yum autoremove\n\n## 四、解压安装包,并安装\n> cd /server/tools\n> unzip git-2.14.1.zip\n> cd git-2.14.1\n> make prefix=/server/git all   #安装在目录/server/git下\n>  make prefix=/server/git install\n\n## 五、添加link\n> ln -s /server/git/bin/git /usr/bin/\n注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。\n\n## 六、将git设置为默认路径，不然后面克隆时会报错\n>  ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack\n>   n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack\n\n## 七、查看版本\n> git --version\n\n-----------------------------------------------------\n\n_更新git版本_\n下载最新源码重新编译覆盖即可\n\n----------------------------------------- 官网 -------------------------------------\n从源代码安装\n有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。\n如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：\n\n    $ sudo yum install curl-devel expat-devel gettext-devel \\\n    openssl-devel zlib-devel\n    $ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\n    libz-dev libssl-dev\n\n为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：\n\n    $ sudo yum install asciidoc xmlto docbook2x\n    $ sudo apt-get install asciidoc xmlto docbook2x\n\n当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 https://www.kernel.org/pub/software/scm/git，或从 GitHub 网站上的镜像来获得，网址为 https://github.com/git/git/releases。 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。\n接着，编译并安装：\n\n    $ tar -zxf git-2.0.0.tar.gz\n    $ cd git-2.0.0\n    $ make configure\n    $ ./configure --prefix=/usr\n    $ make all doc info\n    $ sudo make install install-doc install-html install-info\n\n完成后，你可以使用 Git 来获取 Git 的升级：\n\n    $ git clone git://git.kernel.org/pub/scm/git/git.git","slug":"git-install-in-centos7","published":1,"updated":"2017-11-14T08:30:11.185Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknk000o8oragdbn4p8x","content":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"external\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br>  n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"external\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"external\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"一、安装依赖包\"><a href=\"#一、安装依赖包\" class=\"headerlink\" title=\"一、安装依赖包\"></a>一、安装依赖包</h2><p>yum -y install zlib-devel curl-devel openssl-devel perl cpio expat-devel gettext-devel openssl zlib autoconf tk perl-ExtUtils-MakeMaker</p>\n<h2 id=\"二、下载最新稳定版本安装包\"><a href=\"#二、下载最新稳定版本安装包\" class=\"headerlink\" title=\"二、下载最新稳定版本安装包\"></a>二、下载最新稳定版本安装包</h2><p>源码网址：<a href=\"https://github.com/git/git\" target=\"_blank\" rel=\"external\">https://github.com/git/git</a></p>\n<h2 id=\"三、查看是否已经安装了旧版本\"><a href=\"#三、查看是否已经安装了旧版本\" class=\"headerlink\" title=\"三、查看是否已经安装了旧版本\"></a>三、查看是否已经安装了旧版本</h2><blockquote>\n<p>git –version<br>如果有显示版本信息，则先卸载旧版本<br>yum -y remove git<br>yum autoremove</p>\n</blockquote>\n<h2 id=\"四、解压安装包-并安装\"><a href=\"#四、解压安装包-并安装\" class=\"headerlink\" title=\"四、解压安装包,并安装\"></a>四、解压安装包,并安装</h2><blockquote>\n<p>cd /server/tools<br>unzip git-2.14.1.zip<br>cd git-2.14.1<br>make prefix=/server/git all   #安装在目录/server/git下<br> make prefix=/server/git install</p>\n</blockquote>\n<h2 id=\"五、添加link\"><a href=\"#五、添加link\" class=\"headerlink\" title=\"五、添加link\"></a>五、添加link</h2><blockquote>\n<p>ln -s /server/git/bin/git /usr/bin/<br>注：这一步对于原本系统中有旧版git的系统很重要，会报告Link已存在，此时要删除原来的Link即/usr/bin/git，再执行第六步。</p>\n</blockquote>\n<h2 id=\"六、将git设置为默认路径，不然后面克隆时会报错\"><a href=\"#六、将git设置为默认路径，不然后面克隆时会报错\" class=\"headerlink\" title=\"六、将git设置为默认路径，不然后面克隆时会报错\"></a>六、将git设置为默认路径，不然后面克隆时会报错</h2><blockquote>\n<p> ln -s /server/git/bin/ git-upload-pack /usr/bin/git-upload-pack<br>  n -s /server/git/bin/git-receive-pack /usr/bin/git-receive-pack</p>\n</blockquote>\n<h2 id=\"七、查看版本\"><a href=\"#七、查看版本\" class=\"headerlink\" title=\"七、查看版本\"></a>七、查看版本</h2><blockquote>\n<p>git –version</p>\n</blockquote>\n<hr>\n<p><em>更新git版本</em><br>下载最新源码重新编译覆盖即可</p>\n<p>—————————————– 官网 ————————————-<br>从源代码安装<br>有人觉得从源码安装 Git 更实用，因为你能得到最新的版本。 二进制安装程序倾向于有一些滞后，当然近几年 Git 已经成熟，这个差异不再显著。<br>如果你想从源码安装 Git，需要安装 Git 依赖的库：curl、zlib、openssl、expat，还有libiconv。 如果你的系统上有 yum （如 Fedora）或者 apt-get（如基于 Debian 的系统），可以使用以下命令之一来安装最小化的依赖包来编译和安装 Git 的二进制版：</p>\n<pre><code>$ sudo yum install curl-devel expat-devel gettext-devel \\\nopenssl-devel zlib-devel\n$ sudo apt-get install libcurl4-gnutls-dev libexpat1-dev gettext \\\nlibz-dev libssl-dev\n</code></pre><p>为了能够添加更多格式的文档（如 doc, html, info），你需要安装以下的依赖包：</p>\n<pre><code>$ sudo yum install asciidoc xmlto docbook2x\n$ sudo apt-get install asciidoc xmlto docbook2x\n</code></pre><p>当你安装好所有的必要依赖，你可以继续从几个地方来取得最新发布版本的 tar 包。 你可以从 Kernel.org 网站获取，网址为 <a href=\"https://www.kernel.org/pub/software/scm/git，或从\" target=\"_blank\" rel=\"external\">https://www.kernel.org/pub/software/scm/git，或从</a> GitHub 网站上的镜像来获得，网址为 <a href=\"https://github.com/git/git/releases。\" target=\"_blank\" rel=\"external\">https://github.com/git/git/releases。</a> 通常在 GitHub 上的是最新版本，但 kernel.org 上包含有文件下载签名，如果你想验证下载正确性的话会用到。<br>接着，编译并安装：</p>\n<pre><code>$ tar -zxf git-2.0.0.tar.gz\n$ cd git-2.0.0\n$ make configure\n$ ./configure --prefix=/usr\n$ make all doc info\n$ sudo make install install-doc install-html install-info\n</code></pre><p>完成后，你可以使用 Git 来获取 Git 的升级：</p>\n<pre><code>$ git clone git://git.kernel.org/pub/scm/git/git.git\n</code></pre>"},{"title":"如何直接在github网站上更新你fork的repo","date":"2017-10-13T01:39:58.000Z","_content":"玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","source":"_posts/github-fork-repo-update.md","raw":"---\ntitle: 如何直接在github网站上更新你fork的repo\ndate: 2017-10-13 09:39:58\ncategories: github\ntags: github-fork-repo-update\n---\n玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？\n\n解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：\n\n> 1.打开你的github fork repo;\n 2.点击Pull request;\n3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；\n4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;\n5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;\n6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！\nenjoy it!\n\n附上比较费劲的另外一种更新办法：\n\n    git remote add upstream <pathtooriginalrepo>\n    \n    git fetch upstream\n    \n    git merge upstream/master master\n    \n    git push origin master","slug":"github-fork-repo-update","published":1,"updated":"2017-11-14T08:30:11.187Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckno000s8oradjyzqkr7","content":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>玩过github的人一定会在你自己的账号上fork了一些github开源项目。这些开源项目往往更新比较活跃，你今天fork用到你自己的项目中去了，过几个星期这个fork的origin可能有一些bugfix了，你怎么办呢？当然直接到Origin repo中去clone是一个方法，但是github的public repo有可能过一段时间就被作者删除了，你是否希望在origin即使已经被删除的情况下，你的账号下依然有你钟情的repo？</p>\n<p>解决上面的问题，最好的方法就是不定时地将origin的commit sync到你自己的fork repo中，一方面能够保持鲜活，另一方面有备无患。那么如何sync呢？又有几种方案，一种是你直接在本地clone的repo中，pull upstrame,做好merge，随后push到你自己的fork repo中。另外还有一种更加简便聪明的方法：只需在github网站上点几个鼠标，不用本地开发环境轻松搞定：</p>\n<blockquote>\n<p>1.打开你的github fork repo;<br> 2.点击Pull request;<br>3.点击new pull request.默认情况下，github会比较original/your fork，这时应该不会有任何输出，因为你并没有做过任何变更；<br>4.点击switching the base.这时github将反过来比较yourfork/original，这时你将看到original相对你fork时的所有commit;<br>5.点击create a pull request for this comparison，这时将会反过来向你的repo提交一个pull request;<br>6.这时你作为你自己fork的repo的owner，你就可以点击confirm the merge，大笔一挥，所有的改动都被你一网打尽了@！<br>enjoy it!</p>\n</blockquote>\n<p>附上比较费劲的另外一种更新办法：</p>\n<pre><code>git remote add upstream &lt;pathtooriginalrepo&gt;\n\ngit fetch upstream\n\ngit merge upstream/master master\n\ngit push origin master\n</code></pre>"},{"title":"git服务器使用","date":"2017-10-14T01:58:47.000Z","_content":"搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","source":"_posts/git-server-build.md","raw":"---\ntitle: git服务器使用\ndate: 2017-10-14 09:58:47\ncategories: git\ntags: git-server-build\n---\n搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。\n本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。\n\n首先安装最新版本git\n\n## 创建git仓库\n\n一、创建git用户，用来管理git服务，为git设置密码\n> id git\n查看是否已经有该用户，如果没有则创建用户\n> useradd zmt\n> passwd **** #设置zmt用户密码，注意记得密码\n\n二、创建git仓库\n> mkdir -p /server/data/git/test.git\n> git init --bare /server/data/git/test.git/ #初始化空的版本库于test.git\n> cd /server/data/git/\n> chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户\n\n三、客户端克隆仓库\n>  git clone git@119.23.78.160:/server/data/git/test.git\nCloning into 'test'...\nThe authenticity of host '119.23.78.160 (119.23.78.160)' can't be established.\nECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.\nAre you sure you want to continue connecting (yes/no)? yes\nWarning: Permanently added '119.23.78.160' (ECDSA) to the list of known hosts.\ngit@119.23.78.160's password:\n\n#输入git系统用户密码：a1234567\nwarning: You appear to have cloned an empty repository.","slug":"git-server-build","published":1,"updated":"2017-11-14T08:30:11.186Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknp000u8ora31f0l04k","content":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone git@119.23.78.160:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br>git@119.23.78.160’s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>搭建git服务器之前，要在服务器上安装git环境。这里假定已经安装git环境。<br>本篇主要有两部分内容，一、git服务器搭建、二、用户的分配以及用户对文件权限的控制。</p>\n<p>首先安装最新版本git</p>\n<h2 id=\"创建git仓库\"><a href=\"#创建git仓库\" class=\"headerlink\" title=\"创建git仓库\"></a>创建git仓库</h2><p>一、创建git用户，用来管理git服务，为git设置密码</p>\n<blockquote>\n<p>id git<br>查看是否已经有该用户，如果没有则创建用户<br>useradd zmt<br>passwd <em>**</em> #设置zmt用户密码，注意记得密码</p>\n</blockquote>\n<p>二、创建git仓库</p>\n<blockquote>\n<p>mkdir -p /server/data/git/test.git<br>git init –bare /server/data/git/test.git/ #初始化空的版本库于test.git<br>cd /server/data/git/<br>chown -R zmt:gits test.git/ #把仓库的owner设置为gits用户组下zmt系统用户</p>\n</blockquote>\n<p>三、客户端克隆仓库</p>\n<blockquote>\n<p> git clone git@119.23.78.160:/server/data/git/test.git<br>Cloning into ‘test’…<br>The authenticity of host ‘119.23.78.160 (119.23.78.160)’ can’t be established.<br>ECDSA key fingerprint is SHA256:u7IEulSBpZOfmqBXkr8tW4JJ423qbuM7kMERgAw6MMk.<br>Are you sure you want to continue connecting (yes/no)? yes<br>Warning: Permanently added ‘119.23.78.160’ (ECDSA) to the list of known hosts.<br>git@119.23.78.160’s password:</p>\n</blockquote>\n<p>#输入git系统用户密码：a1234567<br>warning: You appear to have cloned an empty repository.</p>\n"},{"title":"HashiCorp Vault使用　","date":"2017-09-30T15:40:58.000Z","_content":"## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","source":"_posts/hashicorp-vault.md","raw":"---\ntitle: HashiCorp Vault使用　\ndate: 2017-09-30 23:40:58\ncategories: security\ntags: hashicorp-vault\n---\n## １. 简介\nHashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。\n官网：https://www.vaultproject.io/\n\n### 1.1 什么是私密信息\n私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。\n\n这里举几个私密信息的例子：\n> 1. 数据库登录信息\n2. SSL证书\n3. 云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）\n4. 其他加密用的密钥\n5. API的认证信息\n\n### 1.2 Vault的目标和特性\nVault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。\n\nVault为了实现这些目标提供了以下特性：\n> 1. 安全的私密信息存储\n2. 动态的私密信息支持\n3. 提供对于私密信息的更新，延长有效时间的功能\n4. 高度灵活的权限控制\n5. 多种客户端验证方式\n\n## 2. Vault的使用\n\n### 2.1 源码编译安装\n\n1. 安装go环境，配置GOPATH。\n查看以前配置记录，这里不做介绍。[golang](https://golang.org/)\n2. 安装git环境\n查看以前配置记录，这里不做介绍。[git](https://git-scm.com/)\n3. 下载源码\n> $ mkdir -p $GOPATH/src/github.com/hashicorp && cd $!\n$ git clone https://github.com/hashicorp/vault.git\n$ cd vault\n4. 下载相关依赖包\n> $ make bootstrap\n5. 编译安装到./bin/下\n> $ make dev\n6. 验证安装是否成功\n注意查看输出信息，确认vault在环境变量下。\n> $ vault -v\n\n《未完，待续……》\n\n\n\n\n\n \n","slug":"hashicorp-vault","published":1,"updated":"2017-11-14T08:30:11.190Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknr000x8ora39wwmew2","content":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"external\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"external\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"external\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"１-简介\"><a href=\"#１-简介\" class=\"headerlink\" title=\"１. 简介\"></a>１. 简介</h2><p>HashiCorp Vault是一个私密信息管理的工具。在应用开发中，特别是微服务开发中，用来更好的保护诸如数据库密码，api权限密码，第三方一些账号密码等，以避免在配置文件或者代码中明文硬编码，造成泄露。其在spring-cloud中也有很好的应用。<br>官网：<a href=\"https://www.vaultproject.io/\" target=\"_blank\" rel=\"external\">https://www.vaultproject.io/</a></p>\n<h3 id=\"1-1-什么是私密信息\"><a href=\"#1-1-什么是私密信息\" class=\"headerlink\" title=\"1.1 什么是私密信息\"></a>1.1 什么是私密信息</h3><p>私密信息主要是一些需要保密的值或者键值对，很多时候会和敏感信息混淆。</p>\n<p>这里举几个私密信息的例子：</p>\n<blockquote>\n<ol>\n<li>数据库登录信息</li>\n<li>SSL证书</li>\n<li>云服务商的ACCESS KEY（比如AWS Cloud的IAM信息）</li>\n<li>其他加密用的密钥</li>\n<li>API的认证信息</li>\n</ol>\n</blockquote>\n<h3 id=\"1-2-Vault的目标和特性\"><a href=\"#1-2-Vault的目标和特性\" class=\"headerlink\" title=\"1.2 Vault的目标和特性\"></a>1.2 Vault的目标和特性</h3><p>Vault的目标是成为私密信息的唯一来源，即一个集中化的管理工具。而私密信息的需求方可以程序化的获得所需的信息。对于私密信息，还应该有完善的审计和可视化方法，并且作为一个集中化的依赖，Vault自身必须是高可用的，对于云数据中心友好的安全架构。</p>\n<p>Vault为了实现这些目标提供了以下特性：</p>\n<blockquote>\n<ol>\n<li>安全的私密信息存储</li>\n<li>动态的私密信息支持</li>\n<li>提供对于私密信息的更新，延长有效时间的功能</li>\n<li>高度灵活的权限控制</li>\n<li>多种客户端验证方式</li>\n</ol>\n</blockquote>\n<h2 id=\"2-Vault的使用\"><a href=\"#2-Vault的使用\" class=\"headerlink\" title=\"2. Vault的使用\"></a>2. Vault的使用</h2><h3 id=\"2-1-源码编译安装\"><a href=\"#2-1-源码编译安装\" class=\"headerlink\" title=\"2.1 源码编译安装\"></a>2.1 源码编译安装</h3><ol>\n<li>安装go环境，配置GOPATH。<br>查看以前配置记录，这里不做介绍。<a href=\"https://golang.org/\" target=\"_blank\" rel=\"external\">golang</a></li>\n<li>安装git环境<br>查看以前配置记录，这里不做介绍。<a href=\"https://git-scm.com/\" target=\"_blank\" rel=\"external\">git</a></li>\n<li>下载源码<blockquote>\n<p>$ mkdir -p $GOPATH/src/github.com/hashicorp &amp;&amp; cd $!<br>$ git clone <a href=\"https://github.com/hashicorp/vault.git\" target=\"_blank\" rel=\"external\">https://github.com/hashicorp/vault.git</a><br>$ cd vault</p>\n</blockquote>\n</li>\n<li>下载相关依赖包<blockquote>\n<p>$ make bootstrap</p>\n</blockquote>\n</li>\n<li>编译安装到./bin/下<blockquote>\n<p>$ make dev</p>\n</blockquote>\n</li>\n<li>验证安装是否成功<br>注意查看输出信息，确认vault在环境变量下。<blockquote>\n<p>$ vault -v</p>\n</blockquote>\n</li>\n</ol>\n<p>《未完，待续……》</p>\n"},{"title":"hibernate表关系映射示例","date":"2017-11-01T09:18:44.000Z","_content":"\n## 1. OneToOne\n一对一关系，存在n+1问题。\n\n#### 1.1 单向 @OneToOne\n- 实体：\n\n\n        @Entity(name = \"Phone\")\n        public static class Phone {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            @Column(name = \"`number`\")\n            private String number;\n        \n            @OneToOne\n            @JoinColumn(name = \"details_id\")\n            private PhoneDetails details;\n        \n            public Phone() {\n            }\n        \n            public Phone(String number) {\n                this.number = number;\n            }\n        \n            public Long getId() {\n                return id;\n            }\n        \n            public String getNumber() {\n                return number;\n            }\n        \n            public PhoneDetails getDetails() {\n                return details;\n            }\n        \n            public void setDetails(PhoneDetails details) {\n                this.details = details;\n            }\n        }\n\t\n---\t\n        @Entity(name = \"PhoneDetails\")\n        public static class PhoneDetails {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            private String provider;\n        \n            private String technology;\n        \n            public PhoneDetails() {\n            }\n        \n            public PhoneDetails(String provider, String technology) {\n                this.provider = provider;\n                this.technology = technology;\n            }\n        \n            public String getProvider() {\n                return provider;\n            }\n        \n            public String getTechnology() {\n                return technology;\n            }\n        \n            public void setTechnology(String technology) {\n                this.technology = technology;\n            }\n        }\n\t\n- *生成sql*：\n\n        CREATE TABLE Phone (\n            id BIGINT NOT NULL ,\n            number VARCHAR(255) ,\n            details_id BIGINT ,\n            PRIMARY KEY ( id )\n        )\n        \n        CREATE TABLE PhoneDetails (\n            id BIGINT NOT NULL ,\n            provider VARCHAR(255) ,\n            technology VARCHAR(255) ,\n            PRIMARY KEY ( id )\n        )\n        \n        ALTER TABLE Phone\n        ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\n        FOREIGN KEY (details_id) REFERENCES PhoneDetails\n\t\n\t\n- *操作*：\n\t作为外键，相当于ManyToOne作为外键操作\n\n---\n\t\n#### 1.2 双向 @OneToOne\n\n- 实体：\n\n\n    @Entity(name = \"Phone\")\n    public static class Phone {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n    \n        @Column(name = \"`number`\")\n        private String number;\n    \n        @OneToOne(mappedBy = \"phone\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n        private PhoneDetails details;\n    \n        public Phone() {\n        }\n    \n        public Phone(String number) {\n            this.number = number;\n        }\n    \n        public Long getId() {\n            return id;\n        }\n    \n        public String getNumber() {\n            return number;\n        }\n    \n        public PhoneDetails getDetails() {\n            return details;\n        }\n    \n        public void addDetails(PhoneDetails details) {\n            details.setPhone( this );\n            this.details = details;\n        }\n    \n        public void removeDetails() {\n            if ( details != null ) {\n                details.setPhone( null );\n                this.details = null;\n            }\n        }\n    }\n\t\n---\n\t\n\t@Entity(name = \"PhoneDetails\")\n\tpublic static class PhoneDetails {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String provider;\n\t\n\t    private String technology;\n\t\n\t    @OneToOne(fetch = FetchType.LAZY)\n\t    @JoinColumn(name = \"phone_id\")\n\t    private Phone phone;\n\t\n\t    public PhoneDetails() {\n\t    }\n\t\n\t    public PhoneDetails(String provider, String technology) {\n\t        this.provider = provider;\n\t        this.technology = technology;\n\t    }\n\t\n\t    public String getProvider() {\n\t        return provider;\n\t    }\n\t\n\t    public String getTechnology() {\n\t        return technology;\n\t    }\n\t\n\t    public void setTechnology(String technology) {\n\t        this.technology = technology;\n\t    }\n\t\n\t    public Phone getPhone() {\n\t        return phone;\n\t    }\n\t\n\t    public void setPhone(Phone phone) {\n\t        this.phone = phone;\n\t    }\n\t}\n\n- *生成sql*：\n\n\n    CREATE TABLE Phone (\n        id BIGINT NOT NULL ,\n        number VARCHAR(255) ,\n        PRIMARY KEY ( id )\n    )\n    \n    CREATE TABLE PhoneDetails (\n        id BIGINT NOT NULL ,\n        provider VARCHAR(255) ,\n        technology VARCHAR(255) ,\n        phone_id BIGINT ,\n        PRIMARY KEY ( id )\n    )\n    \n    ALTER TABLE PhoneDetails\n    ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\n    FOREIGN KEY (phone_id) REFERENCES Phone\n\n- *操作*：\n\n\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tPhoneDetails details = new PhoneDetails( \"T-Mobile\", \"GSM\" );\n\t\n\tphone.addDetails( details );\n\tentityManager.persist( phone );\n\t\n\t-------------------------------------\n\tINSERT INTO Phone ( number, id )\n\tVALUES ( '123 - 456 - 7890', 1 )\n\t\n\tINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\n\tVALUES ( 1, 'T - Mobile, GSM', 2 )\n\t\n\n---\n## 2. OneToMany\n一对多关系，一般在多的一段维护，也可双边维护关系。\n\n#### 2.1 单向 @OneToMany association\n\n- 实体:\n\n\n    @Entity(name = \"Person\")\n    public static class Person {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n        @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n        private List<Phone> phones = new ArrayList<>();\n    \n        public Person() {\n        }\n    \n        public List<Phone> getPhones() {\n            return phones;\n        }\n    }\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\n\tCREATE TABLE Person_Phone (\n\t    Person_id BIGINT NOT NULL ,\n\t    phones_id BIGINT NOT NULL\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\n\tUNIQUE (phones_id)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\n\tFOREIGN KEY (phones_id) REFERENCES Phone\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\n- *操作代码*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.getPhones().add( phone1 );\n\tperson.getPhones().add( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.getPhones().remove( phone1 );\n\t\n\t-----------------------------------------------\n\tINSERT INTO Person\n       ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '123 - 456 - 7890', 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '321 - 654 - 0987', 3 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Person_Phone\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n#### 2.2 双向@OneToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<Phone> phones = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(Long id) {\n\t        this.id = id;\n\t    }\n\t\n\t    public List<Phone> getPhones() {\n\t        return phones;\n\t    }\n\t\n\t    public void addPhone(Phone phone) {\n\t        phones.add( phone );\n\t        phone.setPerson( this );\n\t    }\n\t\n\t    public void removePhone(Phone phone) {\n\t        phones.remove( phone );\n\t        phone.setPerson( null );\n\t    }\n\t}\t\t\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    @Column(name = \"`number`\", unique = true)\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Phone phone = (Phone) o;\n\t        return Objects.equals( number, phone.number );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( number );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\n\tUNIQUE (number)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\n\tFOREIGN KEY (person_id) REFERENCES Person\n\n- *操作*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.addPhone( phone1 );\n\tperson.addPhone( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.removePhone( phone1 );\t\n\t\n\t-----------------------------------------\n\t\n\tINSERT INTO Phone\n       ( number, person_id, id )\n\tVALUES ( '123-456-7890', NULL, 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, person_id, id )\n\tVALUES ( '321-654-0987', NULL, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n---\n## 3. ManyToOne\n多对一关系\n\n#### 3.1 @ManyToOne association\n相当于外键\n\n- 实体\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t\t@Id\n\t\t@GeneratedValue\n\t\tprivate Long id;\n\t\t\n\t\tpublic Person() {\n\t\t\n\t\t}\n\t}\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    @JoinColumn(name = \"person_id\",\n\t            foreignKey = @ForeignKey(name = \"PERSON_ID_FK\")\n\t    )\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT PERSON_ID_FK\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n- *生命周期*:\n\n\n\tPerson person = new Person();\n\tentityManager.persist( person );\n\t\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tphone.setPerson( person );\n\tentityManager.persist( phone );\n\t\n\tentityManager.flush();\n\tphone.setPerson( null );\n\t\n\t实际sql：\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone ( number, person_id, id )\n\tVALUES ( '123-456-7890', 1, 2 )\n\t\n\tUPDATE Phone\n\tSET    number = '123-456-7890',\n\t       person_id = NULL\n\tWHERE  id = 2\n\n---\t\n## 4. ManyToMany\n多对多关系，两边都要维护。\n\n#### 4.1 单向 @ManyToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number) {\n\t        this.street = street;\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    Person_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person();\n\tPerson person2 = new Person();\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\" );\n\t\n\tperson1.getAddresses().add( address1 );\n\tperson1.getAddresses().add( address2 );\n\t\n\tperson2.getAddresses().add( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.getAddresses().remove( address1 );\n\t\n\t-------------------------------------------\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '12A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '18B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( id )\n\tVALUES ( 4 )\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 2 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.2 双向 @ManyToMany\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        addresses.add( address );\n\t        address.getOwners().add( this );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        addresses.remove( address );\n\t        address.getOwners().remove( this );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @ManyToMany(mappedBy = \"addresses\")\n\t    private List<Person> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<Person> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    owners_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\n\tFOREIGN KEY (owners_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.removeAddress( address1 );\n\t\n\t------------------------------------------\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'ABC-123', 1 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '12A', '4005A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '18B', '4007B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'DEF-456', 4 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  owners_id = 1\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.3 双向 many-to-many with a link entity\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public List<PersonAddress> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        addresses.add( personAddress );\n\t        address.getOwners().add( personAddress );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        address.getOwners().remove( personAddress );\n\t        addresses.remove( personAddress );\n\t        personAddress.setPerson( null );\n\t        personAddress.setAddress( null );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"PersonAddress\")\n\tpublic static class PersonAddress implements Serializable {\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Address address;\n\t\n\t    public PersonAddress() {\n\t    }\n\t\n\t    public PersonAddress(Person person, Address address) {\n\t        this.person = person;\n\t        this.address = address;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    public Address getAddress() {\n\t        return address;\n\t    }\n\t\n\t    public void setAddress(Address address) {\n\t        this.address = address;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        PersonAddress that = (PersonAddress) o;\n\t        return Objects.equals( person, that.person ) &&\n\t                Objects.equals( address, that.address );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( person, address );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @OneToMany(mappedBy = \"address\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<PersonAddress> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE PersonAddress (\n\t    person_id BIGINT NOT NULL ,\n\t    address_id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( person_id, address_id )\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\n\tFOREIGN KEY (address_id) REFERENCES Address\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.persist( address1 );\n\tentityManager.persist( address2 );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.flush();\n\t\n\tlog.info( \"Removing address\" );\n\tperson1.removeAddress( address1 );\n\t---------------------------------------------------\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'ABC-123', 1 )\n\t\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'DEF-456', 2 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '12A', '4005A', '12th Avenue', 3 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '18B', '4007B', '18th Avenue', 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 3 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 2, 3 )\n\t\n\tDELETE  FROM PersonAddress\n\tWHERE   person_id = 1 AND address_id = 3\n\t\n\n\t","source":"_posts/hibernate-relation-mapping.md","raw":"---\ntitle: hibernate表关系映射示例\ndate: 2017-11-01 17:18:44\ncategories: jpa/hibernate\ntags: hibernate-relation\n---\n\n## 1. OneToOne\n一对一关系，存在n+1问题。\n\n#### 1.1 单向 @OneToOne\n- 实体：\n\n\n        @Entity(name = \"Phone\")\n        public static class Phone {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            @Column(name = \"`number`\")\n            private String number;\n        \n            @OneToOne\n            @JoinColumn(name = \"details_id\")\n            private PhoneDetails details;\n        \n            public Phone() {\n            }\n        \n            public Phone(String number) {\n                this.number = number;\n            }\n        \n            public Long getId() {\n                return id;\n            }\n        \n            public String getNumber() {\n                return number;\n            }\n        \n            public PhoneDetails getDetails() {\n                return details;\n            }\n        \n            public void setDetails(PhoneDetails details) {\n                this.details = details;\n            }\n        }\n\t\n---\t\n        @Entity(name = \"PhoneDetails\")\n        public static class PhoneDetails {\n        \n            @Id\n            @GeneratedValue\n            private Long id;\n        \n            private String provider;\n        \n            private String technology;\n        \n            public PhoneDetails() {\n            }\n        \n            public PhoneDetails(String provider, String technology) {\n                this.provider = provider;\n                this.technology = technology;\n            }\n        \n            public String getProvider() {\n                return provider;\n            }\n        \n            public String getTechnology() {\n                return technology;\n            }\n        \n            public void setTechnology(String technology) {\n                this.technology = technology;\n            }\n        }\n\t\n- *生成sql*：\n\n        CREATE TABLE Phone (\n            id BIGINT NOT NULL ,\n            number VARCHAR(255) ,\n            details_id BIGINT ,\n            PRIMARY KEY ( id )\n        )\n        \n        CREATE TABLE PhoneDetails (\n            id BIGINT NOT NULL ,\n            provider VARCHAR(255) ,\n            technology VARCHAR(255) ,\n            PRIMARY KEY ( id )\n        )\n        \n        ALTER TABLE Phone\n        ADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\n        FOREIGN KEY (details_id) REFERENCES PhoneDetails\n\t\n\t\n- *操作*：\n\t作为外键，相当于ManyToOne作为外键操作\n\n---\n\t\n#### 1.2 双向 @OneToOne\n\n- 实体：\n\n\n    @Entity(name = \"Phone\")\n    public static class Phone {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n    \n        @Column(name = \"`number`\")\n        private String number;\n    \n        @OneToOne(mappedBy = \"phone\", cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n        private PhoneDetails details;\n    \n        public Phone() {\n        }\n    \n        public Phone(String number) {\n            this.number = number;\n        }\n    \n        public Long getId() {\n            return id;\n        }\n    \n        public String getNumber() {\n            return number;\n        }\n    \n        public PhoneDetails getDetails() {\n            return details;\n        }\n    \n        public void addDetails(PhoneDetails details) {\n            details.setPhone( this );\n            this.details = details;\n        }\n    \n        public void removeDetails() {\n            if ( details != null ) {\n                details.setPhone( null );\n                this.details = null;\n            }\n        }\n    }\n\t\n---\n\t\n\t@Entity(name = \"PhoneDetails\")\n\tpublic static class PhoneDetails {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String provider;\n\t\n\t    private String technology;\n\t\n\t    @OneToOne(fetch = FetchType.LAZY)\n\t    @JoinColumn(name = \"phone_id\")\n\t    private Phone phone;\n\t\n\t    public PhoneDetails() {\n\t    }\n\t\n\t    public PhoneDetails(String provider, String technology) {\n\t        this.provider = provider;\n\t        this.technology = technology;\n\t    }\n\t\n\t    public String getProvider() {\n\t        return provider;\n\t    }\n\t\n\t    public String getTechnology() {\n\t        return technology;\n\t    }\n\t\n\t    public void setTechnology(String technology) {\n\t        this.technology = technology;\n\t    }\n\t\n\t    public Phone getPhone() {\n\t        return phone;\n\t    }\n\t\n\t    public void setPhone(Phone phone) {\n\t        this.phone = phone;\n\t    }\n\t}\n\n- *生成sql*：\n\n\n    CREATE TABLE Phone (\n        id BIGINT NOT NULL ,\n        number VARCHAR(255) ,\n        PRIMARY KEY ( id )\n    )\n    \n    CREATE TABLE PhoneDetails (\n        id BIGINT NOT NULL ,\n        provider VARCHAR(255) ,\n        technology VARCHAR(255) ,\n        phone_id BIGINT ,\n        PRIMARY KEY ( id )\n    )\n    \n    ALTER TABLE PhoneDetails\n    ADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\n    FOREIGN KEY (phone_id) REFERENCES Phone\n\n- *操作*：\n\n\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tPhoneDetails details = new PhoneDetails( \"T-Mobile\", \"GSM\" );\n\t\n\tphone.addDetails( details );\n\tentityManager.persist( phone );\n\t\n\t-------------------------------------\n\tINSERT INTO Phone ( number, id )\n\tVALUES ( '123 - 456 - 7890', 1 )\n\t\n\tINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\n\tVALUES ( 1, 'T - Mobile, GSM', 2 )\n\t\n\n---\n## 2. OneToMany\n一对多关系，一般在多的一段维护，也可双边维护关系。\n\n#### 2.1 单向 @OneToMany association\n\n- 实体:\n\n\n    @Entity(name = \"Person\")\n    public static class Person {\n    \n        @Id\n        @GeneratedValue\n        private Long id;\n        @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n        private List<Phone> phones = new ArrayList<>();\n    \n        public Person() {\n        }\n    \n        public List<Phone> getPhones() {\n            return phones;\n        }\n    }\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\n\tCREATE TABLE Person_Phone (\n\t    Person_id BIGINT NOT NULL ,\n\t    phones_id BIGINT NOT NULL\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\n\tUNIQUE (phones_id)\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\n\tFOREIGN KEY (phones_id) REFERENCES Phone\n\t\n\tALTER TABLE Person_Phone\n\tADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\n- *操作代码*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.getPhones().add( phone1 );\n\tperson.getPhones().add( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.getPhones().remove( phone1 );\n\t\n\t-----------------------------------------------\n\tINSERT INTO Person\n       ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '123 - 456 - 7890', 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, id )\n\tVALUES ( '321 - 654 - 0987', 3 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Person_Phone\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Phone\n\t       ( Person_id, phones_id )\n\tVALUES ( 1, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n#### 2.2 双向@OneToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<Phone> phones = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(Long id) {\n\t        this.id = id;\n\t    }\n\t\n\t    public List<Phone> getPhones() {\n\t        return phones;\n\t    }\n\t\n\t    public void addPhone(Phone phone) {\n\t        phones.add( phone );\n\t        phone.setPerson( this );\n\t    }\n\t\n\t    public void removePhone(Phone phone) {\n\t        phones.remove( phone );\n\t        phone.setPerson( null );\n\t    }\n\t}\t\t\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    @Column(name = \"`number`\", unique = true)\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Phone phone = (Phone) o;\n\t        return Objects.equals( number, phone.number );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( number );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\n\tUNIQUE (number)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\n\tFOREIGN KEY (person_id) REFERENCES Person\n\n- *操作*：\n\n\n\tPerson person = new Person();\n\tPhone phone1 = new Phone( \"123-456-7890\" );\n\tPhone phone2 = new Phone( \"321-654-0987\" );\n\t\n\tperson.addPhone( phone1 );\n\tperson.addPhone( phone2 );\n\tentityManager.persist( person );\n\tentityManager.flush();\n\t\n\tperson.removePhone( phone1 );\t\n\t\n\t-----------------------------------------\n\t\n\tINSERT INTO Phone\n       ( number, person_id, id )\n\tVALUES ( '123-456-7890', NULL, 2 )\n\t\n\tINSERT INTO Phone\n\t       ( number, person_id, id )\n\tVALUES ( '321-654-0987', NULL, 3 )\n\t\n\tDELETE FROM Phone\n\tWHERE  id = 2\n\t\n---\n## 3. ManyToOne\n多对一关系\n\n#### 3.1 @ManyToOne association\n相当于外键\n\n- 实体\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t\t@Id\n\t\t@GeneratedValue\n\t\tprivate Long id;\n\t\t\n\t\tpublic Person() {\n\t\t\n\t\t}\n\t}\n\t\n---\t\n\t\n\t@Entity(name = \"Phone\")\n\tpublic static class Phone {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    @ManyToOne\n\t    @JoinColumn(name = \"person_id\",\n\t            foreignKey = @ForeignKey(name = \"PERSON_ID_FK\")\n\t    )\n\t    private Person person;\n\t\n\t    public Phone() {\n\t    }\n\t\n\t    public Phone(String number) {\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t}\n\t\n- *sql生成*：\n\n\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Phone (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    person_id BIGINT ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tALTER TABLE Phone\n\tADD CONSTRAINT PERSON_ID_FK\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n- *生命周期*:\n\n\n\tPerson person = new Person();\n\tentityManager.persist( person );\n\t\n\tPhone phone = new Phone( \"123-456-7890\" );\n\tphone.setPerson( person );\n\tentityManager.persist( phone );\n\t\n\tentityManager.flush();\n\tphone.setPerson( null );\n\t\n\t实际sql：\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Phone ( number, person_id, id )\n\tVALUES ( '123-456-7890', 1, 2 )\n\t\n\tUPDATE Phone\n\tSET    number = '123-456-7890',\n\t       person_id = NULL\n\tWHERE  id = 2\n\n---\t\n## 4. ManyToMany\n多对多关系，两边都要维护。\n\n#### 4.1 单向 @ManyToMany\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number) {\n\t        this.street = street;\n\t        this.number = number;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    Person_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\n\tFOREIGN KEY (Person_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person();\n\tPerson person2 = new Person();\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\" );\n\t\n\tperson1.getAddresses().add( address1 );\n\tperson1.getAddresses().add( address2 );\n\t\n\tperson2.getAddresses().add( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.getAddresses().remove( address1 );\n\t\n\t-------------------------------------------\n\tINSERT INTO Person ( id )\n\tVALUES ( 1 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '12A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, street, id )\n\tVALUES ( '18B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( id )\n\tVALUES ( 4 )\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 2 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  Person_id = 1\n\t\n\tINSERT INTO Person_Address ( Person_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.2 双向 @ManyToMany\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n\t    private List<Address> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public List<Address> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        addresses.add( address );\n\t        address.getOwners().add( this );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        addresses.remove( address );\n\t        address.getOwners().remove( this );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @ManyToMany(mappedBy = \"addresses\")\n\t    private List<Person> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<Person> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person_Address (\n\t    owners_id BIGINT NOT NULL ,\n\t    addresses_id BIGINT NOT NULL\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\n\tFOREIGN KEY (addresses_id) REFERENCES Address\n\t\n\tALTER TABLE Person_Address\n\tADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\n\tFOREIGN KEY (owners_id) REFERENCES Person\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.flush();\n\t\n\tperson1.removeAddress( address1 );\n\t\n\t------------------------------------------\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'ABC-123', 1 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '12A', '4005A', '12th Avenue', 2 )\n\t\n\tINSERT INTO Address ( number, postalCode, street, id )\n\tVALUES ( '18B', '4007B', '18th Avenue', 3 )\n\t\n\tINSERT INTO Person ( registrationNumber, id )\n\tVALUES ( 'DEF-456', 4 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 2 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 4, 2 )\n\t\n\tDELETE FROM Person_Address\n\tWHERE  owners_id = 1\n\t\n\tINSERT INTO Person_Address ( owners_id, addresses_id )\n\tVALUES ( 1, 3 )\n\t\n\t\n#### 4.3 双向 many-to-many with a link entity\n\n- 实体：\n\n\n\t@Entity(name = \"Person\")\n\tpublic static class Person implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    @NaturalId\n\t    private String registrationNumber;\n\t\n\t    @OneToMany(mappedBy = \"person\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> addresses = new ArrayList<>();\n\t\n\t    public Person() {\n\t    }\n\t\n\t    public Person(String registrationNumber) {\n\t        this.registrationNumber = registrationNumber;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public List<PersonAddress> getAddresses() {\n\t        return addresses;\n\t    }\n\t\n\t    public void addAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        addresses.add( personAddress );\n\t        address.getOwners().add( personAddress );\n\t    }\n\t\n\t    public void removeAddress(Address address) {\n\t        PersonAddress personAddress = new PersonAddress( this, address );\n\t        address.getOwners().remove( personAddress );\n\t        addresses.remove( personAddress );\n\t        personAddress.setPerson( null );\n\t        personAddress.setAddress( null );\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Person person = (Person) o;\n\t        return Objects.equals( registrationNumber, person.registrationNumber );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( registrationNumber );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"PersonAddress\")\n\tpublic static class PersonAddress implements Serializable {\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Person person;\n\t\n\t    @Id\n\t    @ManyToOne\n\t    private Address address;\n\t\n\t    public PersonAddress() {\n\t    }\n\t\n\t    public PersonAddress(Person person, Address address) {\n\t        this.person = person;\n\t        this.address = address;\n\t    }\n\t\n\t    public Person getPerson() {\n\t        return person;\n\t    }\n\t\n\t    public void setPerson(Person person) {\n\t        this.person = person;\n\t    }\n\t\n\t    public Address getAddress() {\n\t        return address;\n\t    }\n\t\n\t    public void setAddress(Address address) {\n\t        this.address = address;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        PersonAddress that = (PersonAddress) o;\n\t        return Objects.equals( person, that.person ) &&\n\t                Objects.equals( address, that.address );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( person, address );\n\t    }\n\t}\n\t\n---\t\n\t@Entity(name = \"Address\")\n\tpublic static class Address implements Serializable {\n\t\n\t    @Id\n\t    @GeneratedValue\n\t    private Long id;\n\t\n\t    private String street;\n\t\n\t    @Column(name = \"`number`\")\n\t    private String number;\n\t\n\t    private String postalCode;\n\t\n\t    @OneToMany(mappedBy = \"address\", cascade = CascadeType.ALL, orphanRemoval = true)\n\t    private List<PersonAddress> owners = new ArrayList<>();\n\t\n\t    public Address() {\n\t    }\n\t\n\t    public Address(String street, String number, String postalCode) {\n\t        this.street = street;\n\t        this.number = number;\n\t        this.postalCode = postalCode;\n\t    }\n\t\n\t    public Long getId() {\n\t        return id;\n\t    }\n\t\n\t    public String getStreet() {\n\t        return street;\n\t    }\n\t\n\t    public String getNumber() {\n\t        return number;\n\t    }\n\t\n\t    public String getPostalCode() {\n\t        return postalCode;\n\t    }\n\t\n\t    public List<PersonAddress> getOwners() {\n\t        return owners;\n\t    }\n\t\n\t    @Override\n\t    public boolean equals(Object o) {\n\t        if ( this == o ) {\n\t            return true;\n\t        }\n\t        if ( o == null || getClass() != o.getClass() ) {\n\t            return false;\n\t        }\n\t        Address address = (Address) o;\n\t        return Objects.equals( street, address.street ) &&\n\t                Objects.equals( number, address.number ) &&\n\t                Objects.equals( postalCode, address.postalCode );\n\t    }\n\t\n\t    @Override\n\t    public int hashCode() {\n\t        return Objects.hash( street, number, postalCode );\n\t    }\n\t}\n\t\n- *生成sql*：\n\n\n\tCREATE TABLE Address (\n\t    id BIGINT NOT NULL ,\n\t    number VARCHAR(255) ,\n\t    postalCode VARCHAR(255) ,\n\t    street VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE Person (\n\t    id BIGINT NOT NULL ,\n\t    registrationNumber VARCHAR(255) ,\n\t    PRIMARY KEY ( id )\n\t)\n\t\n\tCREATE TABLE PersonAddress (\n\t    person_id BIGINT NOT NULL ,\n\t    address_id BIGINT NOT NULL ,\n\t    PRIMARY KEY ( person_id, address_id )\n\t)\n\t\n\tALTER TABLE Person\n\tADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\n\tUNIQUE (registrationNumber)\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\n\tFOREIGN KEY (person_id) REFERENCES Person\n\t\n\tALTER TABLE PersonAddress\n\tADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\n\tFOREIGN KEY (address_id) REFERENCES Address\n\t\n- *操作*：\n\n\n\tPerson person1 = new Person( \"ABC-123\" );\n\tPerson person2 = new Person( \"DEF-456\" );\n\t\n\tAddress address1 = new Address( \"12th Avenue\", \"12A\", \"4005A\" );\n\tAddress address2 = new Address( \"18th Avenue\", \"18B\", \"4007B\" );\n\t\n\tentityManager.persist( person1 );\n\tentityManager.persist( person2 );\n\t\n\tentityManager.persist( address1 );\n\tentityManager.persist( address2 );\n\t\n\tperson1.addAddress( address1 );\n\tperson1.addAddress( address2 );\n\t\n\tperson2.addAddress( address1 );\n\t\n\tentityManager.flush();\n\t\n\tlog.info( \"Removing address\" );\n\tperson1.removeAddress( address1 );\n\t---------------------------------------------------\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'ABC-123', 1 )\n\t\n\tINSERT  INTO Person ( registrationNumber, id )\n\tVALUES  ( 'DEF-456', 2 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '12A', '4005A', '12th Avenue', 3 )\n\t\n\tINSERT  INTO Address ( number, postalCode, street, id )\n\tVALUES  ( '18B', '4007B', '18th Avenue', 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 3 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 1, 4 )\n\t\n\tINSERT  INTO PersonAddress ( person_id, address_id )\n\tVALUES  ( 2, 3 )\n\t\n\tDELETE  FROM PersonAddress\n\tWHERE   person_id = 1 AND address_id = 3\n\t\n\n\t","slug":"hibernate-relation-mapping","published":1,"updated":"2017-11-14T08:30:11.194Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknt00108ora5fzsf5i9","content":"<h2 id=\"1-OneToOne\"><a href=\"#1-OneToOne\" class=\"headerlink\" title=\"1. OneToOne\"></a>1. OneToOne</h2><p>一对一关系，存在n+1问题。</p>\n<h4 id=\"1-1-单向-OneToOne\"><a href=\"#1-1-单向-OneToOne\" class=\"headerlink\" title=\"1.1 单向 @OneToOne\"></a>1.1 单向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne\n    @JoinColumn(name = &quot;details_id&quot;)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void setDetails(PhoneDetails details) {\n        this.details = details;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n}\n</code></pre><ul>\n<li><p><em>生成sql</em>：</p>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    details_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\nFOREIGN KEY (details_id) REFERENCES PhoneDetails\n</code></pre></li>\n</ul>\n<ul>\n<li><em>操作</em>：<br>  作为外键，相当于ManyToOne作为外键操作</li>\n</ul>\n<hr>\n<h4 id=\"1-2-双向-OneToOne\"><a href=\"#1-2-双向-OneToOne\" class=\"headerlink\" title=\"1.2 双向 @OneToOne\"></a>1.2 双向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne(mappedBy = &quot;phone&quot;, cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void addDetails(PhoneDetails details) {\n        details.setPhone( this );\n        this.details = details;\n    }\n\n    public void removeDetails() {\n        if ( details != null ) {\n            details.setPhone( null );\n            this.details = null;\n        }\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    @OneToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;phone_id&quot;)\n    private Phone phone;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    phone_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE PhoneDetails\nADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\nFOREIGN KEY (phone_id) REFERENCES Phone\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Phone phone = new Phone( &quot;123-456-7890&quot; );\nPhoneDetails details = new PhoneDetails( &quot;T-Mobile&quot;, &quot;GSM&quot; );\n\nphone.addDetails( details );\nentityManager.persist( phone );\n\n-------------------------------------\nINSERT INTO Phone ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 1 )\n\nINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\nVALUES ( 1, &apos;T - Mobile, GSM&apos;, 2 )\n</code></pre><hr>\n<h2 id=\"2-OneToMany\"><a href=\"#2-OneToMany\" class=\"headerlink\" title=\"2. OneToMany\"></a>2. OneToMany</h2><p>一对多关系，一般在多的一段维护，也可双边维护关系。</p>\n<h4 id=\"2-1-单向-OneToMany-association\"><a href=\"#2-1-单向-OneToMany-association\" class=\"headerlink\" title=\"2.1 单向 @OneToMany association\"></a>2.1 单向 @OneToMany association</h4><ul>\n<li>实体:</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Phone (\n    Person_id BIGINT NOT NULL ,\n    phones_id BIGINT NOT NULL\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\nUNIQUE (phones_id)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\nFOREIGN KEY (phones_id) REFERENCES Phone\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作代码</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.getPhones().add( phone1 );\nperson.getPhones().add( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.getPhones().remove( phone1 );\n\n-----------------------------------------------\nINSERT INTO Person\n   ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 2 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;321 - 654 - 0987&apos;, 3 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Person_Phone\nWHERE  Person_id = 1\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><h4 id=\"2-2-双向-OneToMany\"><a href=\"#2-2-双向-OneToMany\" class=\"headerlink\" title=\"2.2 双向@OneToMany\"></a>2.2 双向@OneToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(Long id) {\n        this.id = id;\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n\n    public void addPhone(Phone phone) {\n        phones.add( phone );\n        phone.setPerson( this );\n    }\n\n    public void removePhone(Phone phone) {\n        phones.remove( phone );\n        phone.setPerson( null );\n    }\n}        \n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    @Column(name = &quot;`number`&quot;, unique = true)\n    private String number;\n\n    @ManyToOne\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Phone phone = (Phone) o;\n        return Objects.equals( number, phone.number );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( number );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\nUNIQUE (number)\n\nALTER TABLE Phone\nADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.addPhone( phone1 );\nperson.addPhone( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.removePhone( phone1 );    \n\n-----------------------------------------\n\nINSERT INTO Phone\n   ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, NULL, 2 )\n\nINSERT INTO Phone\n       ( number, person_id, id )\nVALUES ( &apos;321-654-0987&apos;, NULL, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"3-ManyToOne\"><a href=\"#3-ManyToOne\" class=\"headerlink\" title=\"3. ManyToOne\"></a>3. ManyToOne</h2><p>多对一关系</p>\n<h4 id=\"3-1-ManyToOne-association\"><a href=\"#3-1-ManyToOne-association\" class=\"headerlink\" title=\"3.1 @ManyToOne association\"></a>3.1 @ManyToOne association</h4><p>相当于外键</p>\n<ul>\n<li>实体</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    public Person() {\n\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;person_id&quot;,\n            foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;)\n    )\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT PERSON_ID_FK\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>生命周期</em>:</li>\n</ul>\n<pre><code>Person person = new Person();\nentityManager.persist( person );\n\nPhone phone = new Phone( &quot;123-456-7890&quot; );\nphone.setPerson( person );\nentityManager.persist( phone );\n\nentityManager.flush();\nphone.setPerson( null );\n\n实际sql：\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, 1, 2 )\n\nUPDATE Phone\nSET    number = &apos;123-456-7890&apos;,\n       person_id = NULL\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"4-ManyToMany\"><a href=\"#4-ManyToMany\" class=\"headerlink\" title=\"4. ManyToMany\"></a>4. ManyToMany</h2><p>多对多关系，两边都要维护。</p>\n<h4 id=\"4-1-单向-ManyToMany\"><a href=\"#4-1-单向-ManyToMany\" class=\"headerlink\" title=\"4.1 单向 @ManyToMany\"></a>4.1 单向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Address() {\n    }\n\n    public Address(String street, String number) {\n        this.street = street;\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    Person_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person();\nPerson person2 = new Person();\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot; );\n\nperson1.getAddresses().add( address1 );\nperson1.getAddresses().add( address2 );\n\nperson2.getAddresses().add( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.getAddresses().remove( address1 );\n\n-------------------------------------------\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;12A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;18B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( id )\nVALUES ( 4 )\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 2 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  Person_id = 1\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-2-双向-ManyToMany\"><a href=\"#4-2-双向-ManyToMany\" class=\"headerlink\" title=\"4.2 双向 @ManyToMany\"></a>4.2 双向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        addresses.add( address );\n        address.getOwners().add( this );\n    }\n\n    public void removeAddress(Address address) {\n        addresses.remove( address );\n        address.getOwners().remove( this );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @ManyToMany(mappedBy = &quot;addresses&quot;)\n    private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;Person&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    owners_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\nFOREIGN KEY (owners_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.removeAddress( address1 );\n\n------------------------------------------\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;ABC-123&apos;, 1 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;DEF-456&apos;, 4 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  owners_id = 1\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-3-双向-many-to-many-with-a-link-entity\"><a href=\"#4-3-双向-many-to-many-with-a-link-entity\" class=\"headerlink\" title=\"4.3 双向 many-to-many with a link entity\"></a>4.3 双向 many-to-many with a link entity</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public List&lt;PersonAddress&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        addresses.add( personAddress );\n        address.getOwners().add( personAddress );\n    }\n\n    public void removeAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        address.getOwners().remove( personAddress );\n        addresses.remove( personAddress );\n        personAddress.setPerson( null );\n        personAddress.setAddress( null );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PersonAddress&quot;)\npublic static class PersonAddress implements Serializable {\n\n    @Id\n    @ManyToOne\n    private Person person;\n\n    @Id\n    @ManyToOne\n    private Address address;\n\n    public PersonAddress() {\n    }\n\n    public PersonAddress(Person person, Address address) {\n        this.person = person;\n        this.address = address;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        PersonAddress that = (PersonAddress) o;\n        return Objects.equals( person, that.person ) &amp;&amp;\n                Objects.equals( address, that.address );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( person, address );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;PersonAddress&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PersonAddress (\n    person_id BIGINT NOT NULL ,\n    address_id BIGINT NOT NULL ,\n    PRIMARY KEY ( person_id, address_id )\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\nFOREIGN KEY (person_id) REFERENCES Person\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\nFOREIGN KEY (address_id) REFERENCES Address\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.persist( address1 );\nentityManager.persist( address2 );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.flush();\n\nlog.info( &quot;Removing address&quot; );\nperson1.removeAddress( address1 );\n---------------------------------------------------\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;ABC-123&apos;, 1 )\n\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;DEF-456&apos;, 2 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 3 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 3 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 2, 3 )\n\nDELETE  FROM PersonAddress\nWHERE   person_id = 1 AND address_id = 3\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-OneToOne\"><a href=\"#1-OneToOne\" class=\"headerlink\" title=\"1. OneToOne\"></a>1. OneToOne</h2><p>一对一关系，存在n+1问题。</p>\n<h4 id=\"1-1-单向-OneToOne\"><a href=\"#1-1-单向-OneToOne\" class=\"headerlink\" title=\"1.1 单向 @OneToOne\"></a>1.1 单向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne\n    @JoinColumn(name = &quot;details_id&quot;)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void setDetails(PhoneDetails details) {\n        this.details = details;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n}\n</code></pre><ul>\n<li><p><em>生成sql</em>：</p>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    details_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT FKnoj7cj83ppfqbnvqqa5kolub7\nFOREIGN KEY (details_id) REFERENCES PhoneDetails\n</code></pre></li>\n</ul>\n<ul>\n<li><em>操作</em>：<br>  作为外键，相当于ManyToOne作为外键操作</li>\n</ul>\n<hr>\n<h4 id=\"1-2-双向-OneToOne\"><a href=\"#1-2-双向-OneToOne\" class=\"headerlink\" title=\"1.2 双向 @OneToOne\"></a>1.2 双向 @OneToOne</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @OneToOne(mappedBy = &quot;phone&quot;, cascade = CascadeType.ALL, orphanRemoval = true, fetch = FetchType.LAZY)\n    private PhoneDetails details;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public PhoneDetails getDetails() {\n        return details;\n    }\n\n    public void addDetails(PhoneDetails details) {\n        details.setPhone( this );\n        this.details = details;\n    }\n\n    public void removeDetails() {\n        if ( details != null ) {\n            details.setPhone( null );\n            this.details = null;\n        }\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PhoneDetails&quot;)\npublic static class PhoneDetails {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String provider;\n\n    private String technology;\n\n    @OneToOne(fetch = FetchType.LAZY)\n    @JoinColumn(name = &quot;phone_id&quot;)\n    private Phone phone;\n\n    public PhoneDetails() {\n    }\n\n    public PhoneDetails(String provider, String technology) {\n        this.provider = provider;\n        this.technology = technology;\n    }\n\n    public String getProvider() {\n        return provider;\n    }\n\n    public String getTechnology() {\n        return technology;\n    }\n\n    public void setTechnology(String technology) {\n        this.technology = technology;\n    }\n\n    public Phone getPhone() {\n        return phone;\n    }\n\n    public void setPhone(Phone phone) {\n        this.phone = phone;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PhoneDetails (\n    id BIGINT NOT NULL ,\n    provider VARCHAR(255) ,\n    technology VARCHAR(255) ,\n    phone_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE PhoneDetails\nADD CONSTRAINT FKeotuev8ja8v0sdh29dynqj05p\nFOREIGN KEY (phone_id) REFERENCES Phone\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Phone phone = new Phone( &quot;123-456-7890&quot; );\nPhoneDetails details = new PhoneDetails( &quot;T-Mobile&quot;, &quot;GSM&quot; );\n\nphone.addDetails( details );\nentityManager.persist( phone );\n\n-------------------------------------\nINSERT INTO Phone ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 1 )\n\nINSERT INTO PhoneDetails ( phone_id, provider, technology, id )\nVALUES ( 1, &apos;T - Mobile, GSM&apos;, 2 )\n</code></pre><hr>\n<h2 id=\"2-OneToMany\"><a href=\"#2-OneToMany\" class=\"headerlink\" title=\"2. OneToMany\"></a>2. OneToMany</h2><p>一对多关系，一般在多的一段维护，也可双边维护关系。</p>\n<h4 id=\"2-1-单向-OneToMany-association\"><a href=\"#2-1-单向-OneToMany-association\" class=\"headerlink\" title=\"2.1 单向 @OneToMany association\"></a>2.1 单向 @OneToMany association</h4><ul>\n<li>实体:</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Phone (\n    Person_id BIGINT NOT NULL ,\n    phones_id BIGINT NOT NULL\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT UK_9uhc5itwc9h5gcng944pcaslf\nUNIQUE (phones_id)\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FKr38us2n8g5p9rj0b494sd3391\nFOREIGN KEY (phones_id) REFERENCES Phone\n\nALTER TABLE Person_Phone\nADD CONSTRAINT FK2ex4e4p7w1cj310kg2woisjl2\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作代码</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.getPhones().add( phone1 );\nperson.getPhones().add( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.getPhones().remove( phone1 );\n\n-----------------------------------------------\nINSERT INTO Person\n   ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;123 - 456 - 7890&apos;, 2 )\n\nINSERT INTO Phone\n       ( number, id )\nVALUES ( &apos;321 - 654 - 0987&apos;, 3 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Person_Phone\nWHERE  Person_id = 1\n\nINSERT INTO Person_Phone\n       ( Person_id, phones_id )\nVALUES ( 1, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><h4 id=\"2-2-双向-OneToMany\"><a href=\"#2-2-双向-OneToMany\" class=\"headerlink\" title=\"2.2 双向@OneToMany\"></a>2.2 双向@OneToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;Phone&gt; phones = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(Long id) {\n        this.id = id;\n    }\n\n    public List&lt;Phone&gt; getPhones() {\n        return phones;\n    }\n\n    public void addPhone(Phone phone) {\n        phones.add( phone );\n        phone.setPerson( this );\n    }\n\n    public void removePhone(Phone phone) {\n        phones.remove( phone );\n        phone.setPerson( null );\n    }\n}        \n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    @Column(name = &quot;`number`&quot;, unique = true)\n    private String number;\n\n    @ManyToOne\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Phone phone = (Phone) o;\n        return Objects.equals( number, phone.number );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( number );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT UK_l329ab0g4c1t78onljnxmbnp6\nUNIQUE (number)\n\nALTER TABLE Phone\nADD CONSTRAINT FKmw13yfsjypiiq0i1osdkaeqpg\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person = new Person();\nPhone phone1 = new Phone( &quot;123-456-7890&quot; );\nPhone phone2 = new Phone( &quot;321-654-0987&quot; );\n\nperson.addPhone( phone1 );\nperson.addPhone( phone2 );\nentityManager.persist( person );\nentityManager.flush();\n\nperson.removePhone( phone1 );    \n\n-----------------------------------------\n\nINSERT INTO Phone\n   ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, NULL, 2 )\n\nINSERT INTO Phone\n       ( number, person_id, id )\nVALUES ( &apos;321-654-0987&apos;, NULL, 3 )\n\nDELETE FROM Phone\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"3-ManyToOne\"><a href=\"#3-ManyToOne\" class=\"headerlink\" title=\"3. ManyToOne\"></a>3. ManyToOne</h2><p>多对一关系</p>\n<h4 id=\"3-1-ManyToOne-association\"><a href=\"#3-1-ManyToOne-association\" class=\"headerlink\" title=\"3.1 @ManyToOne association\"></a>3.1 @ManyToOne association</h4><p>相当于外键</p>\n<ul>\n<li>实体</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    public Person() {\n\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Phone&quot;)\npublic static class Phone {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    @ManyToOne\n    @JoinColumn(name = &quot;person_id&quot;,\n            foreignKey = @ForeignKey(name = &quot;PERSON_ID_FK&quot;)\n    )\n    private Person person;\n\n    public Phone() {\n    }\n\n    public Phone(String number) {\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n}\n</code></pre><ul>\n<li><em>sql生成</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Phone (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    person_id BIGINT ,\n    PRIMARY KEY ( id )\n)\n\nALTER TABLE Phone\nADD CONSTRAINT PERSON_ID_FK\nFOREIGN KEY (person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>生命周期</em>:</li>\n</ul>\n<pre><code>Person person = new Person();\nentityManager.persist( person );\n\nPhone phone = new Phone( &quot;123-456-7890&quot; );\nphone.setPerson( person );\nentityManager.persist( phone );\n\nentityManager.flush();\nphone.setPerson( null );\n\n实际sql：\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Phone ( number, person_id, id )\nVALUES ( &apos;123-456-7890&apos;, 1, 2 )\n\nUPDATE Phone\nSET    number = &apos;123-456-7890&apos;,\n       person_id = NULL\nWHERE  id = 2\n</code></pre><hr>\n<h2 id=\"4-ManyToMany\"><a href=\"#4-ManyToMany\" class=\"headerlink\" title=\"4. ManyToMany\"></a>4. ManyToMany</h2><p>多对多关系，两边都要维护。</p>\n<h4 id=\"4-1-单向-ManyToMany\"><a href=\"#4-1-单向-ManyToMany\" class=\"headerlink\" title=\"4.1 单向 @ManyToMany\"></a>4.1 单向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    public Address() {\n    }\n\n    public Address(String street, String number) {\n        this.street = street;\n        this.number = number;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    Person_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKba7rc9qe2vh44u93u0p2auwti\nFOREIGN KEY (Person_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person();\nPerson person2 = new Person();\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot; );\n\nperson1.getAddresses().add( address1 );\nperson1.getAddresses().add( address2 );\n\nperson2.getAddresses().add( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.getAddresses().remove( address1 );\n\n-------------------------------------------\nINSERT INTO Person ( id )\nVALUES ( 1 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;12A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, street, id )\nVALUES ( &apos;18B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( id )\nVALUES ( 4 )\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 2 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  Person_id = 1\n\nINSERT INTO Person_Address ( Person_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-2-双向-ManyToMany\"><a href=\"#4-2-双向-ManyToMany\" class=\"headerlink\" title=\"4.2 双向 @ManyToMany\"></a>4.2 双向 @ManyToMany</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n    @ManyToMany(cascade = {CascadeType.PERSIST, CascadeType.MERGE})\n    private List&lt;Address&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public List&lt;Address&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        addresses.add( address );\n        address.getOwners().add( this );\n    }\n\n    public void removeAddress(Address address) {\n        addresses.remove( address );\n        address.getOwners().remove( this );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @ManyToMany(mappedBy = &quot;addresses&quot;)\n    private List&lt;Person&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;Person&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person_Address (\n    owners_id BIGINT NOT NULL ,\n    addresses_id BIGINT NOT NULL\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKm7j0bnabh2yr0pe99il1d066u\nFOREIGN KEY (addresses_id) REFERENCES Address\n\nALTER TABLE Person_Address\nADD CONSTRAINT FKbn86l24gmxdv2vmekayqcsgup\nFOREIGN KEY (owners_id) REFERENCES Person\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.flush();\n\nperson1.removeAddress( address1 );\n\n------------------------------------------\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;ABC-123&apos;, 1 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 2 )\n\nINSERT INTO Address ( number, postalCode, street, id )\nVALUES ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 3 )\n\nINSERT INTO Person ( registrationNumber, id )\nVALUES ( &apos;DEF-456&apos;, 4 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 2 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 4, 2 )\n\nDELETE FROM Person_Address\nWHERE  owners_id = 1\n\nINSERT INTO Person_Address ( owners_id, addresses_id )\nVALUES ( 1, 3 )\n</code></pre><h4 id=\"4-3-双向-many-to-many-with-a-link-entity\"><a href=\"#4-3-双向-many-to-many-with-a-link-entity\" class=\"headerlink\" title=\"4.3 双向 many-to-many with a link entity\"></a>4.3 双向 many-to-many with a link entity</h4><ul>\n<li>实体：</li>\n</ul>\n<pre><code>@Entity(name = &quot;Person&quot;)\npublic static class Person implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    @NaturalId\n    private String registrationNumber;\n\n    @OneToMany(mappedBy = &quot;person&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; addresses = new ArrayList&lt;&gt;();\n\n    public Person() {\n    }\n\n    public Person(String registrationNumber) {\n        this.registrationNumber = registrationNumber;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public List&lt;PersonAddress&gt; getAddresses() {\n        return addresses;\n    }\n\n    public void addAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        addresses.add( personAddress );\n        address.getOwners().add( personAddress );\n    }\n\n    public void removeAddress(Address address) {\n        PersonAddress personAddress = new PersonAddress( this, address );\n        address.getOwners().remove( personAddress );\n        addresses.remove( personAddress );\n        personAddress.setPerson( null );\n        personAddress.setAddress( null );\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Person person = (Person) o;\n        return Objects.equals( registrationNumber, person.registrationNumber );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( registrationNumber );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;PersonAddress&quot;)\npublic static class PersonAddress implements Serializable {\n\n    @Id\n    @ManyToOne\n    private Person person;\n\n    @Id\n    @ManyToOne\n    private Address address;\n\n    public PersonAddress() {\n    }\n\n    public PersonAddress(Person person, Address address) {\n        this.person = person;\n        this.address = address;\n    }\n\n    public Person getPerson() {\n        return person;\n    }\n\n    public void setPerson(Person person) {\n        this.person = person;\n    }\n\n    public Address getAddress() {\n        return address;\n    }\n\n    public void setAddress(Address address) {\n        this.address = address;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        PersonAddress that = (PersonAddress) o;\n        return Objects.equals( person, that.person ) &amp;&amp;\n                Objects.equals( address, that.address );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( person, address );\n    }\n}\n</code></pre><hr>\n<pre><code>@Entity(name = &quot;Address&quot;)\npublic static class Address implements Serializable {\n\n    @Id\n    @GeneratedValue\n    private Long id;\n\n    private String street;\n\n    @Column(name = &quot;`number`&quot;)\n    private String number;\n\n    private String postalCode;\n\n    @OneToMany(mappedBy = &quot;address&quot;, cascade = CascadeType.ALL, orphanRemoval = true)\n    private List&lt;PersonAddress&gt; owners = new ArrayList&lt;&gt;();\n\n    public Address() {\n    }\n\n    public Address(String street, String number, String postalCode) {\n        this.street = street;\n        this.number = number;\n        this.postalCode = postalCode;\n    }\n\n    public Long getId() {\n        return id;\n    }\n\n    public String getStreet() {\n        return street;\n    }\n\n    public String getNumber() {\n        return number;\n    }\n\n    public String getPostalCode() {\n        return postalCode;\n    }\n\n    public List&lt;PersonAddress&gt; getOwners() {\n        return owners;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if ( this == o ) {\n            return true;\n        }\n        if ( o == null || getClass() != o.getClass() ) {\n            return false;\n        }\n        Address address = (Address) o;\n        return Objects.equals( street, address.street ) &amp;&amp;\n                Objects.equals( number, address.number ) &amp;&amp;\n                Objects.equals( postalCode, address.postalCode );\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash( street, number, postalCode );\n    }\n}\n</code></pre><ul>\n<li><em>生成sql</em>：</li>\n</ul>\n<pre><code>CREATE TABLE Address (\n    id BIGINT NOT NULL ,\n    number VARCHAR(255) ,\n    postalCode VARCHAR(255) ,\n    street VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE Person (\n    id BIGINT NOT NULL ,\n    registrationNumber VARCHAR(255) ,\n    PRIMARY KEY ( id )\n)\n\nCREATE TABLE PersonAddress (\n    person_id BIGINT NOT NULL ,\n    address_id BIGINT NOT NULL ,\n    PRIMARY KEY ( person_id, address_id )\n)\n\nALTER TABLE Person\nADD CONSTRAINT UK_23enodonj49jm8uwec4i7y37f\nUNIQUE (registrationNumber)\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK8b3lru5fyej1aarjflamwghqq\nFOREIGN KEY (person_id) REFERENCES Person\n\nALTER TABLE PersonAddress\nADD CONSTRAINT FK7p69mgialumhegyl4byrh65jk\nFOREIGN KEY (address_id) REFERENCES Address\n</code></pre><ul>\n<li><em>操作</em>：</li>\n</ul>\n<pre><code>Person person1 = new Person( &quot;ABC-123&quot; );\nPerson person2 = new Person( &quot;DEF-456&quot; );\n\nAddress address1 = new Address( &quot;12th Avenue&quot;, &quot;12A&quot;, &quot;4005A&quot; );\nAddress address2 = new Address( &quot;18th Avenue&quot;, &quot;18B&quot;, &quot;4007B&quot; );\n\nentityManager.persist( person1 );\nentityManager.persist( person2 );\n\nentityManager.persist( address1 );\nentityManager.persist( address2 );\n\nperson1.addAddress( address1 );\nperson1.addAddress( address2 );\n\nperson2.addAddress( address1 );\n\nentityManager.flush();\n\nlog.info( &quot;Removing address&quot; );\nperson1.removeAddress( address1 );\n---------------------------------------------------\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;ABC-123&apos;, 1 )\n\nINSERT  INTO Person ( registrationNumber, id )\nVALUES  ( &apos;DEF-456&apos;, 2 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;12A&apos;, &apos;4005A&apos;, &apos;12th Avenue&apos;, 3 )\n\nINSERT  INTO Address ( number, postalCode, street, id )\nVALUES  ( &apos;18B&apos;, &apos;4007B&apos;, &apos;18th Avenue&apos;, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 3 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 1, 4 )\n\nINSERT  INTO PersonAddress ( person_id, address_id )\nVALUES  ( 2, 3 )\n\nDELETE  FROM PersonAddress\nWHERE   person_id = 1 AND address_id = 3\n</code></pre>"},{"title":"idea集成XRebel分析web应用性能","date":"2017-12-04T07:50:14.000Z","_content":"","source":"_posts/idea-XRebel.md","raw":"---\ntitle: idea集成XRebel分析web应用性能\ndate: 2017-12-04 15:50:14\ncategories:\ntags:\n---\n","slug":"idea-XRebel","published":1,"updated":"2017-12-04T07:50:48.068Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknv00138orajighogop","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"http协议概述(学习笔记)","date":"2017-10-17T13:45:50.000Z","_content":"\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","source":"_posts/http-protocol-overview.md","raw":"---\ntitle: http协议概述(学习笔记)\ndate: 2017-10-17 21:45:50\ncategories: http协议\ntags: http-overview\n---\n\nHTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\n{% asset_img a.png %}\n\n## 1. 基于HTTP的组件系统\n\n## 2. HTTP 的基本性质\n\n## 3. HTTP 能控制什么\n\n## 4. HTTP 流\n\n## 5. HTTP 报文\n\n## 6. 总结\n\n","slug":"http-protocol-overview","published":1,"updated":"2017-11-14T08:30:11.195Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknx00158orah2jj8uh9","content":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>","site":{"data":{}},"excerpt":"","more":"<p>HTTP被设计于上20世纪90年代初期，是一种可扩展性的协议。它是应用层的协议，虽然理论上它可以通过任何可靠的传输协议来发送，但是它还是通过TCP，或者是TLS－加密的TCP连接来发送。因为它很好的扩展性，时至今日它不仅被用来传输超文本文档，还用来传输图片、视频或者向服务器发送如HTML表单这样的信息。HTTP还可以根据网页需求，来获取部分web文档的内容来更新网页。<a href=\"https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview\" target=\"_blank\" rel=\"external\">https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Overview</a><br><img src=\"/2017/10/17/http-protocol-overview/a.png\"></p>\n<h2 id=\"1-基于HTTP的组件系统\"><a href=\"#1-基于HTTP的组件系统\" class=\"headerlink\" title=\"1. 基于HTTP的组件系统\"></a>1. 基于HTTP的组件系统</h2><h2 id=\"2-HTTP-的基本性质\"><a href=\"#2-HTTP-的基本性质\" class=\"headerlink\" title=\"2. HTTP 的基本性质\"></a>2. HTTP 的基本性质</h2><h2 id=\"3-HTTP-能控制什么\"><a href=\"#3-HTTP-能控制什么\" class=\"headerlink\" title=\"3. HTTP 能控制什么\"></a>3. HTTP 能控制什么</h2><h2 id=\"4-HTTP-流\"><a href=\"#4-HTTP-流\" class=\"headerlink\" title=\"4. HTTP 流\"></a>4. HTTP 流</h2><h2 id=\"5-HTTP-报文\"><a href=\"#5-HTTP-报文\" class=\"headerlink\" title=\"5. HTTP 报文\"></a>5. HTTP 报文</h2><h2 id=\"6-总结\"><a href=\"#6-总结\" class=\"headerlink\" title=\"6. 总结\"></a>6. 总结</h2>"},{"title":"idea插件利器","date":"2017-11-10T01:55:50.000Z","_content":"\n## 1. GsonFormat\n1. 作用：json字符串自动生成javabean工具。\n2. 使用：\n\n","source":"_posts/idea-good-plug.md","raw":"---\ntitle: idea插件利器\ndate: 2017-11-10 09:55:50\ncategories: idea\ntags: idea插件利器\n---\n\n## 1. GsonFormat\n1. 作用：json字符串自动生成javabean工具。\n2. 使用：\n\n","slug":"idea-good-plug","published":1,"updated":"2017-11-14T08:30:11.200Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcknz00188ora3rbkk3y5","content":"<h2 id=\"1-GsonFormat\"><a href=\"#1-GsonFormat\" class=\"headerlink\" title=\"1. GsonFormat\"></a>1. GsonFormat</h2><ol>\n<li>作用：json字符串自动生成javabean工具。</li>\n<li>使用：</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-GsonFormat\"><a href=\"#1-GsonFormat\" class=\"headerlink\" title=\"1. GsonFormat\"></a>1. GsonFormat</h2><ol>\n<li>作用：json字符串自动生成javabean工具。</li>\n<li>使用：</li>\n</ol>\n"},{"title":"jackson使用录","date":"2017-10-01T01:07:36.000Z","_content":"## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","source":"_posts/jackson-show-time.md","raw":"---\ntitle: jackson使用录\ndate: 2017-10-01 09:07:36\ncategories: json\ntags: jackson\n---\n## 简介\nJackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。\n1. 流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。\n\n2. 树模型：提供一个可变内存树表示JSON文档。\n\n3. 数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。\n\n一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：\nhttp://repo1.maven.org/maven2/com/fasterxml/jackson/core/\n\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-core</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-databind</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n    <dependency>\n        <groupId>com.fasterxml.jackson.core</groupId>\n        <artifactId>jackson-annotations</artifactId>\n        <version>2.9.1</version>\n    </dependency>\n\n\n## 1. Jackson Annotations介绍\n\n","slug":"jackson-show-time","published":1,"updated":"2017-11-14T08:30:11.201Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcko1001b8orauf8pv6wj","content":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"external\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h2><p>Jackson库是一个“旨在为开发者提供更快，更正确，更轻量级，更符合人性思维” 的类库。Jackson为处理JSON格式提供了三种模型的处理方法。</p>\n<ol>\n<li><p>流式API或者增量解析/产生（ incremental parsing/generation）：读写JSON内容被作为离散的事件。</p>\n</li>\n<li><p>树模型：提供一个可变内存树表示JSON文档。</p>\n</li>\n<li><p>数据绑定（Data binding）：实现JSON与POJO（简单的Java对象（Plain Old Java Object））的转换。</p>\n</li>\n</ol>\n<p>一般的，我们更加关心json和javad对象的互相转换，这也是程序开发中最常用的。要使用jackson,要下载下面依赖包：<br><a href=\"http://repo1.maven.org/maven2/com/fasterxml/jackson/core/\" target=\"_blank\" rel=\"external\">http://repo1.maven.org/maven2/com/fasterxml/jackson/core/</a></p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-core&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-databind&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n&lt;dependency&gt;\n    &lt;groupId&gt;com.fasterxml.jackson.core&lt;/groupId&gt;\n    &lt;artifactId&gt;jackson-annotations&lt;/artifactId&gt;\n    &lt;version&gt;2.9.1&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre><h2 id=\"1-Jackson-Annotations介绍\"><a href=\"#1-Jackson-Annotations介绍\" class=\"headerlink\" title=\"1. Jackson Annotations介绍\"></a>1. Jackson Annotations介绍</h2>"},{"title":"CGLIB介绍与原理","date":"2017-10-26T07:57:08.000Z","_content":"http://blog.csdn.net/zghwaicsdn/article/details/50957474","source":"_posts/javase-cglib.md","raw":"---\ntitle: CGLIB介绍与原理\ndate: 2017-10-26 15:57:08\ncategories: java\ntags: cglib\n---\nhttp://blog.csdn.net/zghwaicsdn/article/details/50957474","slug":"javase-cglib","published":1,"updated":"2017-11-14T08:30:11.202Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcko3001d8orank9c9qmg","content":"<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zghwaicsdn/article/details/50957474</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"http://blog.csdn.net/zghwaicsdn/article/details/50957474\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/zghwaicsdn/article/details/50957474</a></p>\n"},{"title":"Java Nio 缓冲区","date":"2017-10-25T06:57:22.000Z","_content":"","source":"_posts/javase-nio-buffer.md","raw":"---\ntitle: Java Nio 缓冲区\ndate: 2017-10-25 14:57:22\ncategories: java\ntags: java-nio-buffer\n---\n","slug":"javase-nio-buffer","published":1,"updated":"2017-11-14T08:30:11.203Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcko5001h8oraq27kzi5p","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"jenkins-java-maven持续集成（CentOs7）","date":"2017-11-28T01:15:26.000Z","_content":"\n传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。\n\n参考：  \nhttp://www.jianshu.com/p/a7d7df97fe4b\n\n## 1. 安装并运行jenkins-war\n- [下载](https://jenkins.io/download/)\n- 运行 `java -jar jenkins.war --httpPort=8080.`\n- 在浏览器访问 http://localhost:8080. 记得开防火墙。\n\n图一：\n{% asset_img a.png %}\n\n## 2. 初次访问配置\n- 按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。\n- 按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。\n- 创建管理员账号，按照页面设置即可。\n\n这样，下面就可以开始使用jenkins了。\n\n\n## 3. maven，svn,springboot下持续构建java应用\n- 安装maven环境。[下载maven](http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz)\n\n### 3.1 配置jenkins\n\n{% asset_img b.png %}\n\n点击`系统管理`。\n\n{% asset_img c.png %}\n\n配置各种环境：\n\n- maven setting.xml\n\n{% asset_img e.png %}\n\n- jdk,取消自动安装\n\n{% asset_img f.png %}\n\n- maven,取消自动安装\n\n{% asset_img g.png %}\n\n### 3.2 安装maven插件\n\n{% asset_img h.png %}\n\n-------\n\n{% asset_img i.png %}\n\n点击直接安装即可。\n\n### 3.3 创建新项目\n\n{% asset_img 1.png %}\n\n选定。\n\n{% asset_img 2.png %}\n\n点击ok。\n\n### 3.4 配置项目各种信息\n{% asset_img 3.png %}\n\n------------\n{% asset_img 4.png %}\n\n### 3.5 开始构建项目\n\n{% asset_img 5.png %}\n\n查看构建结果\n\n{% asset_img 6.png %}\n\n然后再服务器相关目录下就能看到构建后的jar包:\n{% asset_img 7.png %}\n\n### 3.6 构建后配置\n构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。\n\n#### 3.6.1 直接执行jar\n修改项目配置：\n{% asset_img 8.png %}\n\n添加成功构建后要执行的脚本：\n{% asset_img 8_1.png %}\n\n> 注意脚本写法，如果是后台执行：\n    `BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`\n\n#### 3.6.2 发布jar到远程服务器，并执行\n - 下载相关插件：\n {% asset_img 10.png %}\n \n- 在系统设置中添加远程服务器：\n {% asset_img 11.png %}\n\n- 在项目中设置，选定远程服务器：\n{% asset_img 12.png %}\n\n*注意：*\n{% asset_img 13.png %}\n\n- 备份，执行远程服务器上的jar包\n\n1. 在远程服务器上设置脚本，放在目录：`server/bin`：\n\n>停止应用脚本`stop.sh`：\n    # 将应用停止\n    #stop.sh\n    #!/bin/bash\n    echo \"Stopping SpringBoot Application\"\n    pid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk '{print $2}'`\n    if [ -n \"$pid\" ]\n    then\n       kill -9 $pid\n    fi\n---    \n> 备份应用脚本`replace.sh`:\n    #replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n    #!/bin/bash\n    # 先判断文件是否存在，如果存在，则备份\n    file=\"/server/java/apps/jenkins-demo.jar\"\n    if [ -f \"$file\" ]\n    then\n       mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\n    fi\n    mv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n---\n> 启动应用包脚本`start.sh`:\n    # startup.sh 启动项目\n    #!/bin/bash\n    echo \"授予当前用户权限\"\n    chmod 777 /server/java/apps/jenkins-demo.jar\n    echo \"执行.....\"\n    java -jar /server/java/apps/jenkins-demo.jar\n   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行`nohub java -jar /server/java/apps/jenkins-demo.jar &`不起作用，所在要在jenkins上这样配置`BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`  \n   如果是远程服务器，就可以改成：\n       # startup.sh 启动项目\n       #!/bin/bash\n       echo \"授予当前用户权限\"\n       chmod 777 /server/java/apps/jenkins-demo.jar\n       echo \"执行.....\"\n       nohup java -jar /server/java/apps/jenkins-demo.jar > jenkins-demo.out 2>& 1 &\n    \n---\n2. 设置远程服务器执行脚本： \n\n{% asset_img 14.png %}   \n\n如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。\n\n{% asset_img 15.png %}   ","source":"_posts/jenkins-java-maven.md","raw":"---\ntitle: jenkins-java-maven持续集成（CentOs7）\ndate: 2017-11-28 09:15:26\ncategories: 持续集成\ntags: jenkins-java-maven\n---\n\n传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。\n\n参考：  \nhttp://www.jianshu.com/p/a7d7df97fe4b\n\n## 1. 安装并运行jenkins-war\n- [下载](https://jenkins.io/download/)\n- 运行 `java -jar jenkins.war --httpPort=8080.`\n- 在浏览器访问 http://localhost:8080. 记得开防火墙。\n\n图一：\n{% asset_img a.png %}\n\n## 2. 初次访问配置\n- 按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。\n- 按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。\n- 创建管理员账号，按照页面设置即可。\n\n这样，下面就可以开始使用jenkins了。\n\n\n## 3. maven，svn,springboot下持续构建java应用\n- 安装maven环境。[下载maven](http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz)\n\n### 3.1 配置jenkins\n\n{% asset_img b.png %}\n\n点击`系统管理`。\n\n{% asset_img c.png %}\n\n配置各种环境：\n\n- maven setting.xml\n\n{% asset_img e.png %}\n\n- jdk,取消自动安装\n\n{% asset_img f.png %}\n\n- maven,取消自动安装\n\n{% asset_img g.png %}\n\n### 3.2 安装maven插件\n\n{% asset_img h.png %}\n\n-------\n\n{% asset_img i.png %}\n\n点击直接安装即可。\n\n### 3.3 创建新项目\n\n{% asset_img 1.png %}\n\n选定。\n\n{% asset_img 2.png %}\n\n点击ok。\n\n### 3.4 配置项目各种信息\n{% asset_img 3.png %}\n\n------------\n{% asset_img 4.png %}\n\n### 3.5 开始构建项目\n\n{% asset_img 5.png %}\n\n查看构建结果\n\n{% asset_img 6.png %}\n\n然后再服务器相关目录下就能看到构建后的jar包:\n{% asset_img 7.png %}\n\n### 3.6 构建后配置\n构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。\n\n#### 3.6.1 直接执行jar\n修改项目配置：\n{% asset_img 8.png %}\n\n添加成功构建后要执行的脚本：\n{% asset_img 8_1.png %}\n\n> 注意脚本写法，如果是后台执行：\n    `BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`\n\n#### 3.6.2 发布jar到远程服务器，并执行\n - 下载相关插件：\n {% asset_img 10.png %}\n \n- 在系统设置中添加远程服务器：\n {% asset_img 11.png %}\n\n- 在项目中设置，选定远程服务器：\n{% asset_img 12.png %}\n\n*注意：*\n{% asset_img 13.png %}\n\n- 备份，执行远程服务器上的jar包\n\n1. 在远程服务器上设置脚本，放在目录：`server/bin`：\n\n>停止应用脚本`stop.sh`：\n    # 将应用停止\n    #stop.sh\n    #!/bin/bash\n    echo \"Stopping SpringBoot Application\"\n    pid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk '{print $2}'`\n    if [ -n \"$pid\" ]\n    then\n       kill -9 $pid\n    fi\n---    \n> 备份应用脚本`replace.sh`:\n    #replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n    #!/bin/bash\n    # 先判断文件是否存在，如果存在，则备份\n    file=\"/server/java/apps/jenkins-demo.jar\"\n    if [ -f \"$file\" ]\n    then\n       mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\n    fi\n    mv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n---\n> 启动应用包脚本`start.sh`:\n    # startup.sh 启动项目\n    #!/bin/bash\n    echo \"授予当前用户权限\"\n    chmod 777 /server/java/apps/jenkins-demo.jar\n    echo \"执行.....\"\n    java -jar /server/java/apps/jenkins-demo.jar\n   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行`nohub java -jar /server/java/apps/jenkins-demo.jar &`不起作用，所在要在jenkins上这样配置`BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &`  \n   如果是远程服务器，就可以改成：\n       # startup.sh 启动项目\n       #!/bin/bash\n       echo \"授予当前用户权限\"\n       chmod 777 /server/java/apps/jenkins-demo.jar\n       echo \"执行.....\"\n       nohup java -jar /server/java/apps/jenkins-demo.jar > jenkins-demo.out 2>& 1 &\n    \n---\n2. 设置远程服务器执行脚本： \n\n{% asset_img 14.png %}   \n\n如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。\n\n{% asset_img 15.png %}   ","slug":"jenkins-java-maven","published":1,"updated":"2017-12-04T07:01:22.911Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcko7001j8oran80tacch","content":"<p>传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。</p>\n<p>参考：<br><a href=\"http://www.jianshu.com/p/a7d7df97fe4b\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/a7d7df97fe4b</a></p>\n<h2 id=\"1-安装并运行jenkins-war\"><a href=\"#1-安装并运行jenkins-war\" class=\"headerlink\" title=\"1. 安装并运行jenkins-war\"></a>1. 安装并运行jenkins-war</h2><ul>\n<li><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"external\">下载</a></li>\n<li>运行 <code>java -jar jenkins.war --httpPort=8080.</code></li>\n<li>在浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"external\">http://localhost:8080</a>. 记得开防火墙。</li>\n</ul>\n<p>图一：<br><img src=\"/2017/11/28/jenkins-java-maven/a.png\"></p>\n<h2 id=\"2-初次访问配置\"><a href=\"#2-初次访问配置\" class=\"headerlink\" title=\"2. 初次访问配置\"></a>2. 初次访问配置</h2><ul>\n<li>按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。</li>\n<li>按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。</li>\n<li>创建管理员账号，按照页面设置即可。</li>\n</ul>\n<p>这样，下面就可以开始使用jenkins了。</p>\n<h2 id=\"3-maven，svn-springboot下持续构建java应用\"><a href=\"#3-maven，svn-springboot下持续构建java应用\" class=\"headerlink\" title=\"3. maven，svn,springboot下持续构建java应用\"></a>3. maven，svn,springboot下持续构建java应用</h2><ul>\n<li>安装maven环境。<a href=\"http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz\" target=\"_blank\" rel=\"external\">下载maven</a></li>\n</ul>\n<h3 id=\"3-1-配置jenkins\"><a href=\"#3-1-配置jenkins\" class=\"headerlink\" title=\"3.1 配置jenkins\"></a>3.1 配置jenkins</h3><img src=\"/2017/11/28/jenkins-java-maven/b.png\">\n<p>点击<code>系统管理</code>。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/c.png\">\n<p>配置各种环境：</p>\n<ul>\n<li>maven setting.xml</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/e.png\">\n<ul>\n<li>jdk,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/f.png\">\n<ul>\n<li>maven,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/g.png\">\n<h3 id=\"3-2-安装maven插件\"><a href=\"#3-2-安装maven插件\" class=\"headerlink\" title=\"3.2 安装maven插件\"></a>3.2 安装maven插件</h3><img src=\"/2017/11/28/jenkins-java-maven/h.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/i.png\">\n<p>点击直接安装即可。</p>\n<h3 id=\"3-3-创建新项目\"><a href=\"#3-3-创建新项目\" class=\"headerlink\" title=\"3.3 创建新项目\"></a>3.3 创建新项目</h3><img src=\"/2017/11/28/jenkins-java-maven/1.png\">\n<p>选定。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/2.png\">\n<p>点击ok。</p>\n<h3 id=\"3-4-配置项目各种信息\"><a href=\"#3-4-配置项目各种信息\" class=\"headerlink\" title=\"3.4 配置项目各种信息\"></a>3.4 配置项目各种信息</h3><img src=\"/2017/11/28/jenkins-java-maven/3.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/4.png\">\n<h3 id=\"3-5-开始构建项目\"><a href=\"#3-5-开始构建项目\" class=\"headerlink\" title=\"3.5 开始构建项目\"></a>3.5 开始构建项目</h3><img src=\"/2017/11/28/jenkins-java-maven/5.png\">\n<p>查看构建结果</p>\n<img src=\"/2017/11/28/jenkins-java-maven/6.png\">\n<p>然后再服务器相关目录下就能看到构建后的jar包:<br><img src=\"/2017/11/28/jenkins-java-maven/7.png\"></p>\n<h3 id=\"3-6-构建后配置\"><a href=\"#3-6-构建后配置\" class=\"headerlink\" title=\"3.6 构建后配置\"></a>3.6 构建后配置</h3><p>构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。</p>\n<h4 id=\"3-6-1-直接执行jar\"><a href=\"#3-6-1-直接执行jar\" class=\"headerlink\" title=\"3.6.1 直接执行jar\"></a>3.6.1 直接执行jar</h4><p>修改项目配置：<br><img src=\"/2017/11/28/jenkins-java-maven/8.png\"></p>\n<p>添加成功构建后要执行的脚本：<br><img src=\"/2017/11/28/jenkins-java-maven/8_1.png\"></p>\n<blockquote>\n<p>注意脚本写法，如果是后台执行：<br>    <code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code></p>\n</blockquote>\n<h4 id=\"3-6-2-发布jar到远程服务器，并执行\"><a href=\"#3-6-2-发布jar到远程服务器，并执行\" class=\"headerlink\" title=\"3.6.2 发布jar到远程服务器，并执行\"></a>3.6.2 发布jar到远程服务器，并执行</h4><ul>\n<li>下载相关插件：<img src=\"/2017/11/28/jenkins-java-maven/10.png\">\n</li>\n</ul>\n<ul>\n<li><p>在系统设置中添加远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/11.png\">\n</li>\n<li><p>在项目中设置，选定远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/12.png\">\n</li>\n</ul>\n<p><em>注意：</em><br><img src=\"/2017/11/28/jenkins-java-maven/13.png\"></p>\n<ul>\n<li>备份，执行远程服务器上的jar包</li>\n</ul>\n<ol>\n<li>在远程服务器上设置脚本，放在目录：<code>server/bin</code>：</li>\n</ol>\n<blockquote>\n<p>停止应用脚本<code>stop.sh</code>：</p>\n<pre><code># 将应用停止\n#stop.sh\n#!/bin/bash\necho &quot;Stopping SpringBoot Application&quot;\npid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk &apos;{print $2}&apos;`\nif [ -n &quot;$pid&quot; ]\nthen\n   kill -9 $pid\nfi\n</code></pre><hr>\n<p>备份应用脚本<code>replace.sh</code>:</p>\n<pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n#!/bin/bash\n# 先判断文件是否存在，如果存在，则备份\nfile=&quot;/server/java/apps/jenkins-demo.jar&quot;\nif [ -f &quot;$file&quot; ]\nthen\n   mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\nfi\nmv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n</code></pre><hr>\n<p>启动应用包脚本<code>start.sh</code>:</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\njava -jar /server/java/apps/jenkins-demo.jar\n</code></pre><p>   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行<code>nohub java -jar /server/java/apps/jenkins-demo.jar &amp;</code>不起作用，所在要在jenkins上这样配置<code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code><br>   如果是远程服务器，就可以改成：</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\nnohup java -jar /server/java/apps/jenkins-demo.jar &gt; jenkins-demo.out 2&gt;&amp; 1 &amp;\n</code></pre></blockquote>\n<hr>\n<ol>\n<li>设置远程服务器执行脚本： </li>\n</ol>\n<img src=\"/2017/11/28/jenkins-java-maven/14.png\">   \n<p>如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/15.png\">   ","site":{"data":{}},"excerpt":"","more":"<p>传统的开发是开发，打包测试，开发，打包测试，且每次都是全量打包。这给运维，测试带来大量没必要的工作量，同时每次全量打包导致系统每次测试不全面，bug不断，测试，开发，运维叫苦连天。因此持续集成开发势在必行。</p>\n<p>参考：<br><a href=\"http://www.jianshu.com/p/a7d7df97fe4b\" target=\"_blank\" rel=\"external\">http://www.jianshu.com/p/a7d7df97fe4b</a></p>\n<h2 id=\"1-安装并运行jenkins-war\"><a href=\"#1-安装并运行jenkins-war\" class=\"headerlink\" title=\"1. 安装并运行jenkins-war\"></a>1. 安装并运行jenkins-war</h2><ul>\n<li><a href=\"https://jenkins.io/download/\" target=\"_blank\" rel=\"external\">下载</a></li>\n<li>运行 <code>java -jar jenkins.war --httpPort=8080.</code></li>\n<li>在浏览器访问 <a href=\"http://localhost:8080\" target=\"_blank\" rel=\"external\">http://localhost:8080</a>. 记得开防火墙。</li>\n</ul>\n<p>图一：<br><img src=\"/2017/11/28/jenkins-java-maven/a.png\"></p>\n<h2 id=\"2-初次访问配置\"><a href=\"#2-初次访问配置\" class=\"headerlink\" title=\"2. 初次访问配置\"></a>2. 初次访问配置</h2><ul>\n<li>按图一红色提示，在服务器对应目录下找到安全密码，拷贝进去登录。</li>\n<li>按照页面想到，安装插件，如果不确定要安装什么插件，那就选择推荐的插件按钮即可。</li>\n<li>创建管理员账号，按照页面设置即可。</li>\n</ul>\n<p>这样，下面就可以开始使用jenkins了。</p>\n<h2 id=\"3-maven，svn-springboot下持续构建java应用\"><a href=\"#3-maven，svn-springboot下持续构建java应用\" class=\"headerlink\" title=\"3. maven，svn,springboot下持续构建java应用\"></a>3. maven，svn,springboot下持续构建java应用</h2><ul>\n<li>安装maven环境。<a href=\"http://mirror.bit.edu.cn/apache/maven/maven-3/3.5.2/binaries/apache-maven-3.5.2-bin.tar.gz\" target=\"_blank\" rel=\"external\">下载maven</a></li>\n</ul>\n<h3 id=\"3-1-配置jenkins\"><a href=\"#3-1-配置jenkins\" class=\"headerlink\" title=\"3.1 配置jenkins\"></a>3.1 配置jenkins</h3><img src=\"/2017/11/28/jenkins-java-maven/b.png\">\n<p>点击<code>系统管理</code>。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/c.png\">\n<p>配置各种环境：</p>\n<ul>\n<li>maven setting.xml</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/e.png\">\n<ul>\n<li>jdk,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/f.png\">\n<ul>\n<li>maven,取消自动安装</li>\n</ul>\n<img src=\"/2017/11/28/jenkins-java-maven/g.png\">\n<h3 id=\"3-2-安装maven插件\"><a href=\"#3-2-安装maven插件\" class=\"headerlink\" title=\"3.2 安装maven插件\"></a>3.2 安装maven插件</h3><img src=\"/2017/11/28/jenkins-java-maven/h.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/i.png\">\n<p>点击直接安装即可。</p>\n<h3 id=\"3-3-创建新项目\"><a href=\"#3-3-创建新项目\" class=\"headerlink\" title=\"3.3 创建新项目\"></a>3.3 创建新项目</h3><img src=\"/2017/11/28/jenkins-java-maven/1.png\">\n<p>选定。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/2.png\">\n<p>点击ok。</p>\n<h3 id=\"3-4-配置项目各种信息\"><a href=\"#3-4-配置项目各种信息\" class=\"headerlink\" title=\"3.4 配置项目各种信息\"></a>3.4 配置项目各种信息</h3><img src=\"/2017/11/28/jenkins-java-maven/3.png\">\n<hr>\n<img src=\"/2017/11/28/jenkins-java-maven/4.png\">\n<h3 id=\"3-5-开始构建项目\"><a href=\"#3-5-开始构建项目\" class=\"headerlink\" title=\"3.5 开始构建项目\"></a>3.5 开始构建项目</h3><img src=\"/2017/11/28/jenkins-java-maven/5.png\">\n<p>查看构建结果</p>\n<img src=\"/2017/11/28/jenkins-java-maven/6.png\">\n<p>然后再服务器相关目录下就能看到构建后的jar包:<br><img src=\"/2017/11/28/jenkins-java-maven/7.png\"></p>\n<h3 id=\"3-6-构建后配置\"><a href=\"#3-6-构建后配置\" class=\"headerlink\" title=\"3.6 构建后配置\"></a>3.6 构建后配置</h3><p>构建成功后，我们需要发布项目到远程服务器，或者执行等一系列动作。</p>\n<h4 id=\"3-6-1-直接执行jar\"><a href=\"#3-6-1-直接执行jar\" class=\"headerlink\" title=\"3.6.1 直接执行jar\"></a>3.6.1 直接执行jar</h4><p>修改项目配置：<br><img src=\"/2017/11/28/jenkins-java-maven/8.png\"></p>\n<p>添加成功构建后要执行的脚本：<br><img src=\"/2017/11/28/jenkins-java-maven/8_1.png\"></p>\n<blockquote>\n<p>注意脚本写法，如果是后台执行：<br>    <code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code></p>\n</blockquote>\n<h4 id=\"3-6-2-发布jar到远程服务器，并执行\"><a href=\"#3-6-2-发布jar到远程服务器，并执行\" class=\"headerlink\" title=\"3.6.2 发布jar到远程服务器，并执行\"></a>3.6.2 发布jar到远程服务器，并执行</h4><ul>\n<li>下载相关插件：<img src=\"/2017/11/28/jenkins-java-maven/10.png\">\n</li>\n</ul>\n<ul>\n<li><p>在系统设置中添加远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/11.png\">\n</li>\n<li><p>在项目中设置，选定远程服务器：</p>\n<img src=\"/2017/11/28/jenkins-java-maven/12.png\">\n</li>\n</ul>\n<p><em>注意：</em><br><img src=\"/2017/11/28/jenkins-java-maven/13.png\"></p>\n<ul>\n<li>备份，执行远程服务器上的jar包</li>\n</ul>\n<ol>\n<li>在远程服务器上设置脚本，放在目录：<code>server/bin</code>：</li>\n</ol>\n<blockquote>\n<p>停止应用脚本<code>stop.sh</code>：</p>\n<pre><code># 将应用停止\n#stop.sh\n#!/bin/bash\necho &quot;Stopping SpringBoot Application&quot;\npid=`ps -ef | grep jenkins-demo*.jar | grep -v grep | awk &apos;{print $2}&apos;`\nif [ -n &quot;$pid&quot; ]\nthen\n   kill -9 $pid\nfi\n</code></pre><hr>\n<p>备份应用脚本<code>replace.sh</code>:</p>\n<pre><code>#replace.sh 用于将上次构建的结果备份，然后将新的构建结果移动到合适的位置\n#!/bin/bash\n# 先判断文件是否存在，如果存在，则备份\nfile=&quot;/server/java/apps/jenkins-demo.jar&quot;\nif [ -f &quot;$file&quot; ]\nthen\n   mv /server/java/apps/jenkins-demo.jar /server/java/apps/backup/jenkins-demo.jar.`date +%Y%m%d%H%M%S`\nfi\nmv /server/java/apps/jenkins-demo*.jar /server/java/apps/jenkins-demo.jar\n</code></pre><hr>\n<p>启动应用包脚本<code>start.sh</code>:</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\njava -jar /server/java/apps/jenkins-demo.jar\n</code></pre><p>   注意：启动脚本如果是放在和jenkins同一个服务器上，后台执行<code>nohub java -jar /server/java/apps/jenkins-demo.jar &amp;</code>不起作用，所在要在jenkins上这样配置<code>BUILD_ID=dontKillMe nohup /usr/local/SBA/startup.sh &amp;</code><br>   如果是远程服务器，就可以改成：</p>\n<pre><code># startup.sh 启动项目\n#!/bin/bash\necho &quot;授予当前用户权限&quot;\nchmod 777 /server/java/apps/jenkins-demo.jar\necho &quot;执行.....&quot;\nnohup java -jar /server/java/apps/jenkins-demo.jar &gt; jenkins-demo.out 2&gt;&amp; 1 &amp;\n</code></pre></blockquote>\n<hr>\n<ol>\n<li>设置远程服务器执行脚本： </li>\n</ol>\n<img src=\"/2017/11/28/jenkins-java-maven/14.png\">   \n<p>如果是jenkins所在服务器执行后台jar，要注意，远程服务器其实可以去掉，在脚本改成后台执行就可以。</p>\n<img src=\"/2017/11/28/jenkins-java-maven/15.png\">   "},{"title":"jvm优化-垃圾回收机制","date":"2017-10-20T04:51:08.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1548866","source":"_posts/jvm-gc.md","raw":"---\ntitle: jvm优化-垃圾回收机制\ndate: 2017-10-20 12:51:08\ncategories: jvm\ntags: gc垃圾回收\n---\n\nhttps://my.oschina.net/u/1859679/blog/1548866","slug":"jvm-gc","published":1,"updated":"2017-11-14T08:30:11.205Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwcko9001m8orad335ksl4","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1548866\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/1859679/blog/1548866</a></p>\n"},{"title":"jvm优化-监控工具","date":"2017-10-20T04:52:40.000Z","_content":"\nhttps://my.oschina.net/u/1859679/blog/1552290","source":"_posts/jvm-look-tools.md","raw":"---\ntitle: jvm优化-监控工具\ndate: 2017-10-20 12:52:40\ncategories: jvm\ntags: jvm监控工具\n---\n\nhttps://my.oschina.net/u/1859679/blog/1552290","slug":"jvm-look-tools","published":1,"updated":"2017-11-14T08:30:11.206Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckoe001q8orafcuqslik","content":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p><a href=\"https://my.oschina.net/u/1859679/blog/1552290\" target=\"_blank\" rel=\"external\">https://my.oschina.net/u/1859679/blog/1552290</a></p>\n"},{"title":"linux常用命令使用收藏","date":"2017-10-14T03:26:18.000Z","_content":"收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n## 4. 开机启动命令-chkconfig\n\n## 5. 文档操作\n### 5.1 复制文件-cp命令使用\n1. 文件到文件复制\n> 将文档a复制成b（相当于备份并改名）。\ncp -i a b\n或，\ncp a b\n\n2. 文件到目录复制\n>将文档 file1复制到dir1目录下，复制后名称仍未file1\ncp -i file1 dir1\n或，\ncp file1 dir1\n\n3. 目录到目录复制\n>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2\ncp -r dir1 dir2\n将目录dir1下所有文件包括文件夹，都复制到dir2目录下\ncp -r dir1/*.* dir2\n常见错误：\n1、提示cp: omitting directory错误\n复制目录时，使用-r选项即可递归拷贝，如下：\ncp -r dir1 dir2\n\n## 6. 解压/压缩\n### 6.1 压缩\n> 压缩\n  tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n  \n### 6.2 解压\n> 解压\n  tar –xvf file.tar //解压 tar包\n  tar -xzvf file.tar.gz //解压tar.gz\n  tar -xjvf file.tar.bz2   //解压 tar.bz2\n  tar –xZvf file.tar.Z   //解压tar.Z\n  unrar e file.rar //解压rar\n  unzip file.zip //解压zip\n  \n### 6.3 ubuntu 下rar解压工具安装方法：\n \n> 1、压缩功能\n 安装 sudo apt-get install rar\n 卸载 sudo apt-get remove rar\n 2、解压功能\n 安装 sudo apt-get install unrar\n 卸载 sudo apt-get remove unrar\n 压缩解压缩.rar\n 解压：rar x FileName.rar\n 压缩：rar a FileName.rar DirName  \n  \n### 6.4 总结\n> 1、`*.tar` 用 tar –xvf 解压\n  2、`*.gz` 用 gzip -d或者gunzip 解压\n  3、`*.tar.gz`和`*.tgz` 用 tar –xzf 解压\n  4、`*.bz2` 用 bzip2 -d或者用bunzip2 解压\n  5、`*.tar.bz2`用tar –xjf 解压\n  6、`*.Z` 用 uncompress 解压\n  7、`*.tar.Z` 用tar –xZf 解压\n  8、`*.rar` 用 unrar e解压\n  9、`*.zip` 用 unzip 解压    \n\n","source":"_posts/linux-command-use.md","raw":"---\ntitle: linux常用命令使用收藏\ndate: 2017-10-14 11:26:18\ncategories: linux\ntags: linux-command\n---\n收集linux系统实践过程常用的命令。方便查看！\n\n## 1. 系统用户管理\n### 1.1. 查看所有系统用户\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd`\n\n### 1.2. 查看系统用户对应的UID\n`[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group`\n\n### 1.3. 添加系统用户\n`> useradd zmt`  添加用户zmt\n`> passwd zmt`   为用户zmt添加密码，输入密码即可\n\n### 1.4. 删除系统用户\n`> userdel -r xz`  加上-r参数，userdel会删除用户的HOME目录以及邮件目录\n\n_警告_ 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目\n录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之\n前一定要检查清楚！\n\n### 1.5 修改用户\n表7-3 用户账户修改工具\n\n| 命 令 | 描 述 |\n| :---: | :----: |\n| usermod  |  修改用户账户的字段，还可以指定主要组以及附加组的所属关系   |\n| passwd   |  修改已有用户的密码                      |\n| chpasswd |  从文件中读取登录名密码对，并更新密码             |\n| chage    |  修改密码的过期日期                      |\n| chfn     |  修改用户账户的备注信息                    |\n| chsh     |  修改用户账户的默认登录shell               |\n\n_1. usermod_\nusermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。\n\n> - -l修改用户账户的登录名。\n- -L锁定账户，使用户无法登录。\n- -p修改账户的密码。\n- -U解除锁定，使用户能够登录。\n\n-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。\n要让账户恢复正常，只要用-U选项就行了。\n\n_2. passwd和chpasswd_\n改变用户密码的一个简便方法就是用passwd命令。\n\n    # passwd test\n    Changing password for user test.\n    New UNIX password:\n    Retype new UNIX password:\n    passwd: all authentication tokens updated successfully.\n    #\n    \n如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只\n有root用户才有权限改别人的密码。\n_-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制\n在下次登录时改成他们能记住的更复杂的密码。_\n如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从\n标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你\n也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。\n\n    # chpasswd < users.txt\n    #    \n    \n## 2. 系统用户组管理    \n\n### 2.1 查看所有用户组\n> `> cat /etc/group`\nroot:x:0:root\nbin:x:1:root,bin,daemon\ndaemon:x:2:root,bin,daemon\nsys:x:3:root,bin,adm\nadm:x:4:root,adm,daemon\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\n\n和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID\n值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：\n\n- 组名\n- 组密码\n- GID\n- 属于该组的用户列表\n\n### 2.2 创建新组\n    \n    [root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n    [root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\n    mysql:x:1000:\n    cgred:x:994:\n    docker:x:993:\n    nexus:x:1001:\n    git:x:1002:\n    elsearch:x:1003:\n    epmd:x:992:\n    rabbitmq:x:991:\n    zmt:x:1004:\n    spcs:x:1005:\n\n_为spcs组添加成员_\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt`\n`[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git`\n两个系统用户zmt、git将添加到用户组spcs。\n\n_说明_ 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更\n改才能生效。\n\n### 2.3 修改组\n在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的\nGID（加-g选项）或组名（加-n选项）。\n\n1. 修改组名\n\n        # /usr/sbin/groupmod -n spcs spcselling\n        # tail /etc/group\n        haldaemon:x:68:\n        xfs:x:43:\n        gdm:x:42:\n        rich:x:500:\n        mama:x:501:\n        katie:x:502:\n        jessica:x:503:\n        mysql:x:27:\n        test:x:504:\n        sharing:x:505:test,rich\n        #\n    \n修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，\n你可以随意改变组名而不会影响文件的安全性。\n\n## 3. 文件权限管理    \n\n## 4. 开机启动命令-chkconfig\n\n## 5. 文档操作\n### 5.1 复制文件-cp命令使用\n1. 文件到文件复制\n> 将文档a复制成b（相当于备份并改名）。\ncp -i a b\n或，\ncp a b\n\n2. 文件到目录复制\n>将文档 file1复制到dir1目录下，复制后名称仍未file1\ncp -i file1 dir1\n或，\ncp file1 dir1\n\n3. 目录到目录复制\n>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2\ncp -r dir1 dir2\n将目录dir1下所有文件包括文件夹，都复制到dir2目录下\ncp -r dir1/*.* dir2\n常见错误：\n1、提示cp: omitting directory错误\n复制目录时，使用-r选项即可递归拷贝，如下：\ncp -r dir1 dir2\n\n## 6. 解压/压缩\n### 6.1 压缩\n> 压缩\n  tar –cvf jpg.tar *.jpg //将目录里所有jpg文件打包成tar.jpg\n  tar –czf jpg.tar.gz *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz\n  tar –cjf jpg.tar.bz2 *.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2\n  tar –cZf jpg.tar.Z *.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z\n  rar a jpg.rar *.jpg //rar格式的压缩，需要先下载rar for linux\n  zip jpg.zip *.jpg //zip格式的压缩，需要先下载zip for linux\n  \n### 6.2 解压\n> 解压\n  tar –xvf file.tar //解压 tar包\n  tar -xzvf file.tar.gz //解压tar.gz\n  tar -xjvf file.tar.bz2   //解压 tar.bz2\n  tar –xZvf file.tar.Z   //解压tar.Z\n  unrar e file.rar //解压rar\n  unzip file.zip //解压zip\n  \n### 6.3 ubuntu 下rar解压工具安装方法：\n \n> 1、压缩功能\n 安装 sudo apt-get install rar\n 卸载 sudo apt-get remove rar\n 2、解压功能\n 安装 sudo apt-get install unrar\n 卸载 sudo apt-get remove unrar\n 压缩解压缩.rar\n 解压：rar x FileName.rar\n 压缩：rar a FileName.rar DirName  \n  \n### 6.4 总结\n> 1、`*.tar` 用 tar –xvf 解压\n  2、`*.gz` 用 gzip -d或者gunzip 解压\n  3、`*.tar.gz`和`*.tgz` 用 tar –xzf 解压\n  4、`*.bz2` 用 bzip2 -d或者用bunzip2 解压\n  5、`*.tar.bz2`用tar –xjf 解压\n  6、`*.Z` 用 uncompress 解压\n  7、`*.tar.Z` 用tar –xZf 解压\n  8、`*.rar` 用 unrar e解压\n  9、`*.zip` 用 unzip 解压    \n\n","slug":"linux-command-use","published":1,"updated":"2017-11-14T08:30:11.207Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckoh001t8orajl7kqk09","content":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p><em>警告</em> 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p><em>说明</em> 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2><h2 id=\"4-开机启动命令-chkconfig\"><a href=\"#4-开机启动命令-chkconfig\" class=\"headerlink\" title=\"4. 开机启动命令-chkconfig\"></a>4. 开机启动命令-chkconfig</h2><h2 id=\"5-文档操作\"><a href=\"#5-文档操作\" class=\"headerlink\" title=\"5. 文档操作\"></a>5. 文档操作</h2><h3 id=\"5-1-复制文件-cp命令使用\"><a href=\"#5-1-复制文件-cp命令使用\" class=\"headerlink\" title=\"5.1 复制文件-cp命令使用\"></a>5.1 复制文件-cp命令使用</h3><ol>\n<li><p>文件到文件复制</p>\n<blockquote>\n<p>将文档a复制成b（相当于备份并改名）。<br>cp -i a b<br>或，<br>cp a b</p>\n</blockquote>\n</li>\n<li><p>文件到目录复制</p>\n<blockquote>\n<p>将文档 file1复制到dir1目录下，复制后名称仍未file1<br>cp -i file1 dir1<br>或，<br>cp file1 dir1</p>\n</blockquote>\n</li>\n<li><p>目录到目录复制</p>\n<blockquote>\n<p>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2<br>cp -r dir1 dir2<br>将目录dir1下所有文件包括文件夹，都复制到dir2目录下<br>cp -r dir1/<em>.</em> dir2<br>常见错误：<br>1、提示cp: omitting directory错误<br>复制目录时，使用-r选项即可递归拷贝，如下：<br>cp -r dir1 dir2</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"6-解压-压缩\"><a href=\"#6-解压-压缩\" class=\"headerlink\" title=\"6. 解压/压缩\"></a>6. 解压/压缩</h2><h3 id=\"6-1-压缩\"><a href=\"#6-1-压缩\" class=\"headerlink\" title=\"6.1 压缩\"></a>6.1 压缩</h3><blockquote>\n<p>压缩<br>  tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>  tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>  tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>  tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>  rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for linux<br>  zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>\n</blockquote>\n<h3 id=\"6-2-解压\"><a href=\"#6-2-解压\" class=\"headerlink\" title=\"6.2 解压\"></a>6.2 解压</h3><blockquote>\n<p>解压<br>  tar –xvf file.tar //解压 tar包<br>  tar -xzvf file.tar.gz //解压tar.gz<br>  tar -xjvf file.tar.bz2   //解压 tar.bz2<br>  tar –xZvf file.tar.Z   //解压tar.Z<br>  unrar e file.rar //解压rar<br>  unzip file.zip //解压zip</p>\n</blockquote>\n<h3 id=\"6-3-ubuntu-下rar解压工具安装方法：\"><a href=\"#6-3-ubuntu-下rar解压工具安装方法：\" class=\"headerlink\" title=\"6.3 ubuntu 下rar解压工具安装方法：\"></a>6.3 ubuntu 下rar解压工具安装方法：</h3><blockquote>\n<p>1、压缩功能<br> 安装 sudo apt-get install rar<br> 卸载 sudo apt-get remove rar<br> 2、解压功能<br> 安装 sudo apt-get install unrar<br> 卸载 sudo apt-get remove unrar<br> 压缩解压缩.rar<br> 解压：rar x FileName.rar<br> 压缩：rar a FileName.rar DirName  </p>\n</blockquote>\n<h3 id=\"6-4-总结\"><a href=\"#6-4-总结\" class=\"headerlink\" title=\"6.4 总结\"></a>6.4 总结</h3><blockquote>\n<p>1、<code>*.tar</code> 用 tar –xvf 解压<br>  2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>  3、<code>*.tar.gz</code>和<code>*.tgz</code> 用 tar –xzf 解压<br>  4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>  5、<code>*.tar.bz2</code>用tar –xjf 解压<br>  6、<code>*.Z</code> 用 uncompress 解压<br>  7、<code>*.tar.Z</code> 用tar –xZf 解压<br>  8、<code>*.rar</code> 用 unrar e解压<br>  9、<code>*.zip</code> 用 unzip 解压    </p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>收集linux系统实践过程常用的命令。方便查看！</p>\n<h2 id=\"1-系统用户管理\"><a href=\"#1-系统用户管理\" class=\"headerlink\" title=\"1. 系统用户管理\"></a>1. 系统用户管理</h2><h3 id=\"1-1-查看所有系统用户\"><a href=\"#1-1-查看所有系统用户\" class=\"headerlink\" title=\"1.1. 查看所有系统用户\"></a>1.1. 查看所有系统用户</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/passwd</code></p>\n<h3 id=\"1-2-查看系统用户对应的UID\"><a href=\"#1-2-查看系统用户对应的UID\" class=\"headerlink\" title=\"1.2. 查看系统用户对应的UID\"></a>1.2. 查看系统用户对应的UID</h3><p><code>[root@izwz924c5ufaoooso1wswiz ~]# cat /etc/group</code></p>\n<h3 id=\"1-3-添加系统用户\"><a href=\"#1-3-添加系统用户\" class=\"headerlink\" title=\"1.3. 添加系统用户\"></a>1.3. 添加系统用户</h3><p><code>&gt; useradd zmt</code>  添加用户zmt<br><code>&gt; passwd zmt</code>   为用户zmt添加密码，输入密码即可</p>\n<h3 id=\"1-4-删除系统用户\"><a href=\"#1-4-删除系统用户\" class=\"headerlink\" title=\"1.4. 删除系统用户\"></a>1.4. 删除系统用户</h3><p><code>&gt; userdel -r xz</code>  加上-r参数，userdel会删除用户的HOME目录以及邮件目录</p>\n<p><em>警告</em> 在有大量用户的环境中使用-r参数时要特别小心。你永远不知道用户是否在其HOME目<br>录下存放了其他用户或其他程序要使用的重要文件。记住，在删除用户的HOME目录之<br>前一定要检查清楚！</p>\n<h3 id=\"1-5-修改用户\"><a href=\"#1-5-修改用户\" class=\"headerlink\" title=\"1.5 修改用户\"></a>1.5 修改用户</h3><p>表7-3 用户账户修改工具</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">命 令</th>\n<th style=\"text-align:center\">描 述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">usermod</td>\n<td style=\"text-align:center\">修改用户账户的字段，还可以指定主要组以及附加组的所属关系</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">passwd</td>\n<td style=\"text-align:center\">修改已有用户的密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chpasswd</td>\n<td style=\"text-align:center\">从文件中读取登录名密码对，并更新密码</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chage</td>\n<td style=\"text-align:center\">修改密码的过期日期</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chfn</td>\n<td style=\"text-align:center\">修改用户账户的备注信息</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">chsh</td>\n<td style=\"text-align:center\">修改用户账户的默认登录shell</td>\n</tr>\n</tbody>\n</table>\n<p><em>1. usermod</em><br>usermod命令是用户账户修改工具中最强大的一个。它能用来修改/etc/passwd文件中的大部分字段，只需用与想修改的字段对应的命令行参数就可以了。参数大部分跟useradd命令的参数一样（比如，-c修改备注字段，-e修改过期日期，-g修改默认的登录组）。除此之外，还有另外一些可能派上用场的选项。</p>\n<blockquote>\n<ul>\n<li>-l修改用户账户的登录名。</li>\n<li>-L锁定账户，使用户无法登录。</li>\n<li>-p修改账户的密码。</li>\n<li>-U解除锁定，使用户能够登录。</li>\n</ul>\n</blockquote>\n<p>-L选项尤其实用。它可以将账户锁定，使用户无法登录，同时无需删除账户和用户的数据。<br>要让账户恢复正常，只要用-U选项就行了。</p>\n<p><em>2. passwd和chpasswd</em><br>改变用户密码的一个简便方法就是用passwd命令。</p>\n<pre><code># passwd test\nChanging password for user test.\nNew UNIX password:\nRetype new UNIX password:\npasswd: all authentication tokens updated successfully.\n#\n</code></pre><p>如果只用passwd命令，它会改你自己的密码。系统上的任何用户都能改自己的密码，但只<br>有root用户才有权限改别人的密码。<br><em>-e选项能强制用户下次登录时修改密码。你可以先给用户设置一个简单的密码，之后再强制<br>在下次登录时改成他们能记住的更复杂的密码。</em><br>如果需要为系统中的大量用户修改密码，chpasswd命令可以事半功倍。chpasswd命令能从<br>标准输入自动读取登录名和密码对（由冒号分割）列表，给密码加密，然后为用户账户设置。你<br>也可以用重定向命令来将含有userid:passwd对的文件重定向给该命令。</p>\n<pre><code># chpasswd &lt; users.txt\n#    \n</code></pre><h2 id=\"2-系统用户组管理\"><a href=\"#2-系统用户组管理\" class=\"headerlink\" title=\"2. 系统用户组管理\"></a>2. 系统用户组管理</h2><h3 id=\"2-1-查看所有用户组\"><a href=\"#2-1-查看所有用户组\" class=\"headerlink\" title=\"2.1 查看所有用户组\"></a>2.1 查看所有用户组</h3><blockquote>\n<p><code>&gt; cat /etc/group</code><br>root:x:0:root<br>bin:x:1:root,bin,daemon<br>daemon:x:2:root,bin,daemon<br>sys:x:3:root,bin,adm<br>adm:x:4:root,adm,daemon<br>rich:x:500:<br>mama:x:501:<br>katie:x:502:<br>jessica:x:503:<br>mysql:x:27:<br>test:x:504:</p>\n</blockquote>\n<p>和UID一样，GID在分配时也采用了特定的格式。系统账户用的组通常会分配低于500的GID<br>值，而用户组的GID则会从500开始分配。/etc/group文件有4个字段：</p>\n<ul>\n<li>组名</li>\n<li>组密码</li>\n<li>GID</li>\n<li>属于该组的用户列表</li>\n</ul>\n<h3 id=\"2-2-创建新组\"><a href=\"#2-2-创建新组\" class=\"headerlink\" title=\"2.2 创建新组\"></a>2.2 创建新组</h3><pre><code>[root@izwz924c5ufaoooso1wswiz ~]# groupadd spcs\n[root@izwz924c5ufaoooso1wswiz ~]# tail /etc/group\nmysql:x:1000:\ncgred:x:994:\ndocker:x:993:\nnexus:x:1001:\ngit:x:1002:\nelsearch:x:1003:\nepmd:x:992:\nrabbitmq:x:991:\nzmt:x:1004:\nspcs:x:1005:\n</code></pre><p><em>为spcs组添加成员</em><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs zmt</code><br><code>[root@izwz924c5ufaoooso1wswiz ~]# usermod -G spcs git</code><br>两个系统用户zmt、git将添加到用户组spcs。</p>\n<p><em>说明</em> 如果更改了已登录系统账户所属的用户组，该用户必须登出系统后再登录，组关系的更<br>改才能生效。</p>\n<h3 id=\"2-3-修改组\"><a href=\"#2-3-修改组\" class=\"headerlink\" title=\"2.3 修改组\"></a>2.3 修改组</h3><p>在/etc/group文件中可以看到，需要修改的组信息并不多。groupmod命令可以修改已有组的<br>GID（加-g选项）或组名（加-n选项）。</p>\n<ol>\n<li><p>修改组名</p>\n<pre><code># /usr/sbin/groupmod -n spcs spcselling\n# tail /etc/group\nhaldaemon:x:68:\nxfs:x:43:\ngdm:x:42:\nrich:x:500:\nmama:x:501:\nkatie:x:502:\njessica:x:503:\nmysql:x:27:\ntest:x:504:\nsharing:x:505:test,rich\n#\n</code></pre></li>\n</ol>\n<p>修改组名时，GID和组成员不会变，只有组名改变。由于所有的安全权限都是基于GID的，<br>你可以随意改变组名而不会影响文件的安全性。</p>\n<h2 id=\"3-文件权限管理\"><a href=\"#3-文件权限管理\" class=\"headerlink\" title=\"3. 文件权限管理\"></a>3. 文件权限管理</h2><h2 id=\"4-开机启动命令-chkconfig\"><a href=\"#4-开机启动命令-chkconfig\" class=\"headerlink\" title=\"4. 开机启动命令-chkconfig\"></a>4. 开机启动命令-chkconfig</h2><h2 id=\"5-文档操作\"><a href=\"#5-文档操作\" class=\"headerlink\" title=\"5. 文档操作\"></a>5. 文档操作</h2><h3 id=\"5-1-复制文件-cp命令使用\"><a href=\"#5-1-复制文件-cp命令使用\" class=\"headerlink\" title=\"5.1 复制文件-cp命令使用\"></a>5.1 复制文件-cp命令使用</h3><ol>\n<li><p>文件到文件复制</p>\n<blockquote>\n<p>将文档a复制成b（相当于备份并改名）。<br>cp -i a b<br>或，<br>cp a b</p>\n</blockquote>\n</li>\n<li><p>文件到目录复制</p>\n<blockquote>\n<p>将文档 file1复制到dir1目录下，复制后名称仍未file1<br>cp -i file1 dir1<br>或，<br>cp file1 dir1</p>\n</blockquote>\n</li>\n<li><p>目录到目录复制</p>\n<blockquote>\n<p>将目录dir1复制到dir2目录下，复制结果目录被改名为dir2<br>cp -r dir1 dir2<br>将目录dir1下所有文件包括文件夹，都复制到dir2目录下<br>cp -r dir1/<em>.</em> dir2<br>常见错误：<br>1、提示cp: omitting directory错误<br>复制目录时，使用-r选项即可递归拷贝，如下：<br>cp -r dir1 dir2</p>\n</blockquote>\n</li>\n</ol>\n<h2 id=\"6-解压-压缩\"><a href=\"#6-解压-压缩\" class=\"headerlink\" title=\"6. 解压/压缩\"></a>6. 解压/压缩</h2><h3 id=\"6-1-压缩\"><a href=\"#6-1-压缩\" class=\"headerlink\" title=\"6.1 压缩\"></a>6.1 压缩</h3><blockquote>\n<p>压缩<br>  tar –cvf jpg.tar <em>.jpg //将目录里所有jpg文件打包成tar.jpg<br>  tar –czf jpg.tar.gz </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用gzip压缩，生成一个gzip压缩过的包，命名为jpg.tar.gz<br>  tar –cjf jpg.tar.bz2 <em>.jpg //将目录里所有jpg文件打包成jpg.tar后，并且将其用bzip2压缩，生成一个bzip2压缩过的包，命名为jpg.tar.bz2<br>  tar –cZf jpg.tar.Z </em>.jpg   //将目录里所有jpg文件打包成jpg.tar后，并且将其用compress压缩，生成一个umcompress压缩过的包，命名为jpg.tar.Z<br>  rar a jpg.rar <em>.jpg //rar格式的压缩，需要先下载rar for linux<br>  zip jpg.zip </em>.jpg //zip格式的压缩，需要先下载zip for linux</p>\n</blockquote>\n<h3 id=\"6-2-解压\"><a href=\"#6-2-解压\" class=\"headerlink\" title=\"6.2 解压\"></a>6.2 解压</h3><blockquote>\n<p>解压<br>  tar –xvf file.tar //解压 tar包<br>  tar -xzvf file.tar.gz //解压tar.gz<br>  tar -xjvf file.tar.bz2   //解压 tar.bz2<br>  tar –xZvf file.tar.Z   //解压tar.Z<br>  unrar e file.rar //解压rar<br>  unzip file.zip //解压zip</p>\n</blockquote>\n<h3 id=\"6-3-ubuntu-下rar解压工具安装方法：\"><a href=\"#6-3-ubuntu-下rar解压工具安装方法：\" class=\"headerlink\" title=\"6.3 ubuntu 下rar解压工具安装方法：\"></a>6.3 ubuntu 下rar解压工具安装方法：</h3><blockquote>\n<p>1、压缩功能<br> 安装 sudo apt-get install rar<br> 卸载 sudo apt-get remove rar<br> 2、解压功能<br> 安装 sudo apt-get install unrar<br> 卸载 sudo apt-get remove unrar<br> 压缩解压缩.rar<br> 解压：rar x FileName.rar<br> 压缩：rar a FileName.rar DirName  </p>\n</blockquote>\n<h3 id=\"6-4-总结\"><a href=\"#6-4-总结\" class=\"headerlink\" title=\"6.4 总结\"></a>6.4 总结</h3><blockquote>\n<p>1、<code>*.tar</code> 用 tar –xvf 解压<br>  2、<code>*.gz</code> 用 gzip -d或者gunzip 解压<br>  3、<code>*.tar.gz</code>和<code>*.tgz</code> 用 tar –xzf 解压<br>  4、<code>*.bz2</code> 用 bzip2 -d或者用bunzip2 解压<br>  5、<code>*.tar.bz2</code>用tar –xjf 解压<br>  6、<code>*.Z</code> 用 uncompress 解压<br>  7、<code>*.tar.Z</code> 用tar –xZf 解压<br>  8、<code>*.rar</code> 用 unrar e解压<br>  9、<code>*.zip</code> 用 unzip 解压    </p>\n</blockquote>\n"},{"title":"maven使用常见错误收集","date":"2017-10-25T06:41:24.000Z","_content":"\n本文收集使用maven过程中的常见错误。\n\n> - 问题：\nmaven继承，使用 *`<relativePath></relativePath>`*，出现找不到指向pom，但是实际上已经正确指向了。 \n- 解决：\n    The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, `the group ID, artifact ID and version are still required,` and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.\n  Default value is: ../pom.xml.\n  *所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。*\n    \n    \n","source":"_posts/maven-use-error-collect.md","raw":"---\ntitle: maven使用常见错误收集\ndate: 2017-10-25 14:41:24\ncategories: maven\ntags: maven-error\n---\n\n本文收集使用maven过程中的常见错误。\n\n> - 问题：\nmaven继承，使用 *`<relativePath></relativePath>`*，出现找不到指向pom，但是实际上已经正确指向了。 \n- 解决：\n    The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, `the group ID, artifact ID and version are still required,` and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.\n  Default value is: ../pom.xml.\n  *所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。*\n    \n    \n","slug":"maven-use-error-collect","published":1,"updated":"2017-11-14T08:30:11.212Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckok001w8oradd5wbz9w","content":"<p>本文收集使用maven过程中的常见错误。</p>\n<blockquote>\n<ul>\n<li>问题：<br>maven继承，使用 <em><code>&lt;relativePath&gt;&lt;/relativePath&gt;</code></em>，出现找不到指向pom，但是实际上已经正确指向了。 </li>\n<li>解决：<br>  The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, <code>the group ID, artifact ID and version are still required,</code> and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.<br>Default value is: ../pom.xml.<br><em>所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。</em></li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<p>本文收集使用maven过程中的常见错误。</p>\n<blockquote>\n<ul>\n<li>问题：<br>maven继承，使用 <em><code>&lt;relativePath&gt;&lt;/relativePath&gt;</code></em>，出现找不到指向pom，但是实际上已经正确指向了。 </li>\n<li>解决：<br>  The relative path of the parent pom.xml file within the check out. If not specified, it defaults to ../pom.xml. Maven looks for the parent POM first in this location on the filesystem, then the local repository, and lastly in the remote repo. relativePath allows you to select a different location, for example when your structure is flat, or deeper without an intermediate parent POM. However, <code>the group ID, artifact ID and version are still required,</code> and must match the file in the location given or it will revert to the repository for the POM. This feature is only for enhancing the development in a local checkout of that project. Set the value to an empty string in case you want to disable the feature and always resolve the parent POM from the repositories.<br>Default value is: ../pom.xml.<br><em>所以，要在每个父pom上都要加上groupId,artifactId,version。搞定。</em></li>\n</ul>\n</blockquote>\n"},{"title":"mysql建表规范","date":"2017-11-20T05:51:19.000Z","_content":"\n在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：\n\n## 1. 选择优化的数据类型\n\n原则：\n1. 更小的通常更好\n更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。\n\n2. 简单就好\n简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。\n\n3. 尽量避免NULL\n通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。   \n通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。\n\n### 1.1 整数类型\n整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。  \n整数计算通常使用64位的BIGINT。\n\n### 1.2 实数类型\n实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。  \nDOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。  \n在做高精度计算时，使用DECIMAL，比如财务计算。  \n\n### 1.3 字符串类型\nVARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。\nCHAR 不可变长。少用。\nBINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。\nBLOB 存储很大的数据量的字符串类型，二进制存储。\nTEXT 大文本。字符存储。\n- 使用枚举代替字符串\n可以存储枚举对应整型或者字符串……\n\n## 1.4 日期和时间类型\n\n\n","source":"_posts/mysql-create.md","raw":"---\ntitle: mysql建表规范\ndate: 2017-11-20 13:51:19\ncategories: mysql\ntags: mysql建表规范\n---\n\n在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：\n\n## 1. 选择优化的数据类型\n\n原则：\n1. 更小的通常更好\n更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。\n\n2. 简单就好\n简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。\n\n3. 尽量避免NULL\n通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。   \n通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。\n\n### 1.1 整数类型\n整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。  \n整数计算通常使用64位的BIGINT。\n\n### 1.2 实数类型\n实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。  \nDOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。  \n在做高精度计算时，使用DECIMAL，比如财务计算。  \n\n### 1.3 字符串类型\nVARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。\nCHAR 不可变长。少用。\nBINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。\nBLOB 存储很大的数据量的字符串类型，二进制存储。\nTEXT 大文本。字符存储。\n- 使用枚举代替字符串\n可以存储枚举对应整型或者字符串……\n\n## 1.4 日期和时间类型\n\n\n","slug":"mysql-create","published":1,"updated":"2017-11-20T07:50:55.119Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckoo00208oraaraxg091","content":"<p>在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：</p>\n<h2 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1. 选择优化的数据类型\"></a>1. 选择优化的数据类型</h2><p>原则：</p>\n<ol>\n<li><p>更小的通常更好<br>更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。</p>\n</li>\n<li><p>简单就好<br>简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。</p>\n</li>\n<li><p>尽量避免NULL<br>通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。<br>通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。</p>\n</li>\n</ol>\n<h3 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h3><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。<br>整数计算通常使用64位的BIGINT。</p>\n<h3 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h3><p>实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。<br>DOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。<br>在做高精度计算时，使用DECIMAL，比如财务计算。  </p>\n<h3 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h3><p>VARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。<br>CHAR 不可变长。少用。<br>BINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。<br>BLOB 存储很大的数据量的字符串类型，二进制存储。<br>TEXT 大文本。字符存储。</p>\n<ul>\n<li>使用枚举代替字符串<br>可以存储枚举对应整型或者字符串……</li>\n</ul>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2>","site":{"data":{}},"excerpt":"","more":"<p>在关系数据库中，良好的表结构设计有助于性能的提高，对后续的优化作用也极大。同时对后续的优化也意义重大。因此，在表设计阶段，必须要遵循一些规范。下面介绍在mysql中设计表的一些注意问题：</p>\n<h2 id=\"1-选择优化的数据类型\"><a href=\"#1-选择优化的数据类型\" class=\"headerlink\" title=\"1. 选择优化的数据类型\"></a>1. 选择优化的数据类型</h2><p>原则：</p>\n<ol>\n<li><p>更小的通常更好<br>更小的数据类型代表着占用更小的磁盘空间、内存和cpu，处理时需要的cpu时间也更小。但是一定要确定其可能的长度，不要低估这一点。否则到了后面需要添加长度，将会变得很麻烦。</p>\n</li>\n<li><p>简单就好<br>简单的数据类型需要更小的cpu操作周期。比如整型比字符串操作代价更小，因为字符集和校对规则（排序）使得字符串比整型更加复杂。</p>\n</li>\n<li><p>尽量避免NULL<br>通常情况下，应该设置成NOT NULL，给出默认值，除非真的需要存储NULL。可为NULL的列需要更多的存储空间，在NULL的列上添加索引也非常麻烦，因为，有可能建立索引的列最好设置成NOT NULL。<br>通常，把NULL的列改成NOT NULL 对性能提升很小，所以调优时没必要这么做，除非真的是因为NULL引起。但记住，在计划添加索引的列上，尽量避免设计成可NULL。</p>\n</li>\n</ol>\n<h3 id=\"1-1-整数类型\"><a href=\"#1-1-整数类型\" class=\"headerlink\" title=\"1.1 整数类型\"></a>1.1 整数类型</h3><p>整数类型：TINYINT、SMALLINT、MEDIUMINT、INT、BIGINT,分别对应8,16,14,32,64位存储空间。值的范围-2的N-1次方到2的N-1次方。整数有可选的UNSIGNED属性，表示非负值，选择该属性，可以使整数的上限提高一倍。有符号和无符号使用相同的存储空间，具有相同的性能，根据需要选择。<br>整数计算通常使用64位的BIGINT。</p>\n<h3 id=\"1-2-实数类型\"><a href=\"#1-2-实数类型\" class=\"headerlink\" title=\"1.2 实数类型\"></a>1.2 实数类型</h3><p>实数是带有小数部分的数字。通常有：DECIMAL,DOUBLE,FLOAT。<br>DOUBLE占用8位，FLOAT占用4位。两者用来做浮点近似计算。<br>在做高精度计算时，使用DECIMAL，比如财务计算。  </p>\n<h3 id=\"1-3-字符串类型\"><a href=\"#1-3-字符串类型\" class=\"headerlink\" title=\"1.3 字符串类型\"></a>1.3 字符串类型</h3><p>VARCHAR 可变长，指定合适的分配长度更好。越短代表性能越好。<br>CHAR 不可变长。少用。<br>BINARY,VARBINARY类似上面两种，但是存储的是二进制。单确定不需要字符串比较时，存储为二进制更好，性能更高。<br>BLOB 存储很大的数据量的字符串类型，二进制存储。<br>TEXT 大文本。字符存储。</p>\n<ul>\n<li>使用枚举代替字符串<br>可以存储枚举对应整型或者字符串……</li>\n</ul>\n<h2 id=\"1-4-日期和时间类型\"><a href=\"#1-4-日期和时间类型\" class=\"headerlink\" title=\"1.4 日期和时间类型\"></a>1.4 日期和时间类型</h2>"},{"title":"在Pivotal Web Service上发布Spring Boot应用","date":"2017-10-12T07:08:33.000Z","_content":"\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","source":"_posts/pivotal-web-service-start.md","raw":"---\ntitle: 在Pivotal Web Service上发布Spring Boot应用\ndate: 2017-10-12 15:08:33\ncategories: Pivotal Web Service\ntags: pws-push\n---\n\nPWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。\n\n## 1. 注册账号\n在 https://run.pivotal.io/ 注册一个账号，完成手机绑定。\n\n{% asset_img a.png %}\n\n## 2. 安装 cf CLI\n\n    $ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n    $ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n    \n其他系统安装方式：[Cloud Foundry Command Line Interface (cf CLI)](http://docs.run.pivotal.io/cf-cli/install-go-cli.html)    \n\n\n## 3. 打包应用\n### 3.1 下载srping-boot应用\n在 Github 上克隆一个 Spring Boot 的 hello world 的项目。\n`git clone https://github.com/spring-guides/gs-spring-boot.git`\n\n### 3.2 maven打包\n在 gs-spring-boot/complete 路径下执行：\n`$ mvn clean package`\n\n### 3.3 创建文件manifest.yml\ngs-spring-boot/complete路径下，编写 manifest.yml 文件:\n`$ vim manifest.yml`\n\n内容如下:\n\n    applications:\n    - name: myTestApp\n      path: target/gs-spring-boot-0.1.0.jar\n      \n说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      \n\n## 4. 发布应用\n### 4.1 登录 CLI\n`$ cf login -a api.run.pivotal.io`\n账号和密码填上面注册的。\n\n### 4.2 提交应用\n`$ cf push -m 1G`\n\n{% asset_img b.png %}\n\n## 5.查看发布结果\n1. 在 Pivotal 控制台查看发布的应用程序\n{% asset_img c.png %}\n\n2. 访问 https://mytestapp.cfapps.io/ 查看 Web 内容\n{% asset_img d.png %}","slug":"pivotal-web-service-start","published":1,"updated":"2017-11-14T08:30:11.216Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckoq00228oraoy45ozq4","content":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"external\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"external\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"external\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\"></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>PWS（Pivotal Web Service），由 Pivotal 公司提供的 ，可以运行Java, Grails, Play, Spring, Node.js, Ruby on Rails, Sinatra or Go 等Web应用的服务。本文将介绍一个 Hello World 级别的 Spring Boot 应用发布到 PWS 的过程。</p>\n<h2 id=\"1-注册账号\"><a href=\"#1-注册账号\" class=\"headerlink\" title=\"1. 注册账号\"></a>1. 注册账号</h2><p>在 <a href=\"https://run.pivotal.io/\" target=\"_blank\" rel=\"external\">https://run.pivotal.io/</a> 注册一个账号，完成手机绑定。</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/a.png\">\n<h2 id=\"2-安装-cf-CLI\"><a href=\"#2-安装-cf-CLI\" class=\"headerlink\" title=\"2. 安装 cf CLI\"></a>2. 安装 cf CLI</h2><pre><code>$ wget https://s3-us-west-1.amazonaws.com/cf-cli-releases/releases/v6.29.1/cf-cli-installer_6.29.1_x86-64.rpm\n$ rpm -ivh cf-cli-installer_6.29.1_x86-64.rpm\n</code></pre><p>其他系统安装方式：<a href=\"http://docs.run.pivotal.io/cf-cli/install-go-cli.html\" target=\"_blank\" rel=\"external\">Cloud Foundry Command Line Interface (cf CLI)</a>    </p>\n<h2 id=\"3-打包应用\"><a href=\"#3-打包应用\" class=\"headerlink\" title=\"3. 打包应用\"></a>3. 打包应用</h2><h3 id=\"3-1-下载srping-boot应用\"><a href=\"#3-1-下载srping-boot应用\" class=\"headerlink\" title=\"3.1 下载srping-boot应用\"></a>3.1 下载srping-boot应用</h3><p>在 Github 上克隆一个 Spring Boot 的 hello world 的项目。<br><code>git clone https://github.com/spring-guides/gs-spring-boot.git</code></p>\n<h3 id=\"3-2-maven打包\"><a href=\"#3-2-maven打包\" class=\"headerlink\" title=\"3.2 maven打包\"></a>3.2 maven打包</h3><p>在 gs-spring-boot/complete 路径下执行：<br><code>$ mvn clean package</code></p>\n<h3 id=\"3-3-创建文件manifest-yml\"><a href=\"#3-3-创建文件manifest-yml\" class=\"headerlink\" title=\"3.3 创建文件manifest.yml\"></a>3.3 创建文件manifest.yml</h3><p>gs-spring-boot/complete路径下，编写 manifest.yml 文件:<br><code>$ vim manifest.yml</code></p>\n<p>内容如下:</p>\n<pre><code>applications:\n- name: myTestApp\n  path: target/gs-spring-boot-0.1.0.jar\n</code></pre><p>说明：name 为应用程序的名字，需自定义；path 为可执行的 jar 文件路径。      </p>\n<h2 id=\"4-发布应用\"><a href=\"#4-发布应用\" class=\"headerlink\" title=\"4. 发布应用\"></a>4. 发布应用</h2><h3 id=\"4-1-登录-CLI\"><a href=\"#4-1-登录-CLI\" class=\"headerlink\" title=\"4.1 登录 CLI\"></a>4.1 登录 CLI</h3><p><code>$ cf login -a api.run.pivotal.io</code><br>账号和密码填上面注册的。</p>\n<h3 id=\"4-2-提交应用\"><a href=\"#4-2-提交应用\" class=\"headerlink\" title=\"4.2 提交应用\"></a>4.2 提交应用</h3><p><code>$ cf push -m 1G</code></p>\n<img src=\"/2017/10/12/pivotal-web-service-start/b.png\">\n<h2 id=\"5-查看发布结果\"><a href=\"#5-查看发布结果\" class=\"headerlink\" title=\"5.查看发布结果\"></a>5.查看发布结果</h2><ol>\n<li><p>在 Pivotal 控制台查看发布的应用程序</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/c.png\">\n</li>\n<li><p>访问 <a href=\"https://mytestapp.cfapps.io/\" target=\"_blank\" rel=\"external\">https://mytestapp.cfapps.io/</a> 查看 Web 内容</p>\n<img src=\"/2017/10/12/pivotal-web-service-start/d.png\"></li>\n</ol>\n"},{"title":"mysql性能优化神器explain","date":"2017-11-21T05:36:04.000Z","_content":"\nMySQL 性能优化神器 Explain 使用分析\n\nmysql mysql优化  永顺 1月16日发布\n赞  |   6收藏  |  50\n3.2k 次浏览\n简介\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n\nEXPLAIN SELECT * from user_info WHERE id < 300;\n准备\n为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:\n\n    CREATE TABLE `user_info` (\n      `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `name` VARCHAR(50) NOT NULL DEFAULT '',\n      `age`  INT(11)              DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `name_index` (`name`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO user_info (name, age) VALUES ('xys', 20);\n    INSERT INTO user_info (name, age) VALUES ('a', 21);\n    INSERT INTO user_info (name, age) VALUES ('b', 23);\n    INSERT INTO user_info (name, age) VALUES ('c', 50);\n    INSERT INTO user_info (name, age) VALUES ('d', 15);\n    INSERT INTO user_info (name, age) VALUES ('e', 20);\n    INSERT INTO user_info (name, age) VALUES ('f', 21);\n    INSERT INTO user_info (name, age) VALUES ('g', 23);\n    INSERT INTO user_info (name, age) VALUES ('h', 50);\n    INSERT INTO user_info (name, age) VALUES ('i', 15);\n    CREATE TABLE `order_info` (\n      `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `user_id`      BIGINT(20)           DEFAULT NULL,\n      `product_name` VARCHAR(50) NOT NULL DEFAULT '',\n      `productor`    VARCHAR(30)          DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE');\nEXPLAIN 输出格式\nEXPLAIN 命令的输出内容大致如下:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n各列的含义如下:\n\n- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n- select_type: SELECT 查询的类型.\n- table: 查询的是哪个表\n- partitions: 匹配的分区\n- type: join 类型\n- possible_keys: 此次查询中可能选用的索引\n- key: 此次查询中确切使用到的索引.\n- ref: 哪个字段或常数与 key 一起被使用\n- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n- filtered: 表示此查询条件所过滤的数据的百分比\n- extra: 额外的信息\n接下来我们来重点看一下比较重要的几个字段.\n\nselect_type  \nselect_type 表示了查询的类型, 它的常用取值有:\n\nSIMPLE, 表示此查询不包含 UNION 查询或子查询  \nPRIMARY, 表示此查询是最外层的查询  \nUNION, 表示此查询是 UNION 的第二或随后的查询  \nDEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询  \nUNION RESULT, UNION 的结果  \nSUBQUERY, 子查询中的第一个 SELECT  \nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.   \n最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:\n\n    mysql> EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n        -> UNION\n        -> (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    |  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.00 sec)\n    table\n表示查询涉及的表或衍生表\n\n- type  \ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.   \ntype 常用类型   \ntype 常用的取值有:   \nsystem: 表中只有一条数据. 这个类型是特殊的 const 类型.   \nconst: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.   \n例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   \n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n    \n- eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 314\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using where; Using index\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: eq_ref\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: test.order_info.user_id\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        2 rows in set, 1 warning (0.00 sec)\n        \n- ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. \n例如下面这个例子中, 就使用到了 ref 类型的查询:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: const\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: Using index\n        2 rows in set, 1 warning (0.01 sec)\n\n- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.  \n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\n例如下面的例子就是一个范围查询:  \n\n        mysql> EXPLAIN SELECT *\n            ->         FROM user_info\n            ->         WHERE id BETWEEN 2 AND 8 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: range\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: NULL\n                 rows: 7\n             filtered: 100.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n    \n- index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.  \nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.  \n例如:  \n\n        mysql> EXPLAIN SELECT name FROM  user_info \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: name_index\n              key_len: 152\n                  ref: NULL\n                 rows: 10\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n    \n上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  \n\n- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.   \n下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   \n\n        mysql> EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: ALL\n        possible_keys: NULL\n                  key: NULL\n              key_len: NULL\n                  ref: NULL\n                 rows: 10\n             filtered: 10.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n        \n- type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\nALL < index < range ~ index_merge < ref < eq_ref < const < system\nALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\npossible_keys\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\nkey\n此字段是 MySQL 在当前查询时所真正使用到的索引.\nkey_len\n表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\nkey_len 的计算规则如下:\n字符串\nchar(n): n 字节长度\nvarchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.\n数值类型:\nTINYINT: 1字节\nSMALLINT: 2字节\nMEDIUMINT: 3字节\nINT: 4字节\nBIGINT: 8字节\n时间类型\nDATE: 3字节\nTIMESTAMP: 4字节\nDATETIME: 8字节\n字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n我们来举两个简单的栗子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: range\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: NULL\n                 rows: 5\n             filtered: 11.11\n                Extra: Using where; Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:\n\n- `KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n不过此查询语句 WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT '0', 则 key_length 应该是8.\n\n上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.\n\n接下来我们来看一下下一个例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \\G;\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 161\n                  ref: const,const\n                 rows: 2\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = 'p1' 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161\n\n- rows\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n\n- Extra\nEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:\n\n- Using filesort\n当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n例如下面的例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index; Using filesort\n        1 row in set, 1 warning (0.00 sec)\n        \n我们的索引是\n\n`KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.\n如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n- Using index\n\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n-   Using temporary\n查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","source":"_posts/mysql-explain.md","raw":"---\ntitle: mysql性能优化神器explain\ndate: 2017-11-21 13:36:04\ncategories: mysql\ntags: mysql-expain\n---\n\nMySQL 性能优化神器 Explain 使用分析\n\nmysql mysql优化  永顺 1月16日发布\n赞  |   6收藏  |  50\n3.2k 次浏览\n简介\nMySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.\nEXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:\n\nEXPLAIN SELECT * from user_info WHERE id < 300;\n准备\n为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:\n\n    CREATE TABLE `user_info` (\n      `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `name` VARCHAR(50) NOT NULL DEFAULT '',\n      `age`  INT(11)              DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `name_index` (`name`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO user_info (name, age) VALUES ('xys', 20);\n    INSERT INTO user_info (name, age) VALUES ('a', 21);\n    INSERT INTO user_info (name, age) VALUES ('b', 23);\n    INSERT INTO user_info (name, age) VALUES ('c', 50);\n    INSERT INTO user_info (name, age) VALUES ('d', 15);\n    INSERT INTO user_info (name, age) VALUES ('e', 20);\n    INSERT INTO user_info (name, age) VALUES ('f', 21);\n    INSERT INTO user_info (name, age) VALUES ('g', 23);\n    INSERT INTO user_info (name, age) VALUES ('h', 50);\n    INSERT INTO user_info (name, age) VALUES ('i', 15);\n    CREATE TABLE `order_info` (\n      `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n      `user_id`      BIGINT(20)           DEFAULT NULL,\n      `product_name` VARCHAR(50) NOT NULL DEFAULT '',\n      `productor`    VARCHAR(30)          DEFAULT NULL,\n      PRIMARY KEY (`id`),\n      KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n    )\n      ENGINE = InnoDB\n      DEFAULT CHARSET = utf8\n    \n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p2', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (1, 'p1', 'DX');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (2, 'p5', 'WL');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (3, 'p3', 'MA');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (4, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (6, 'p1', 'WHH');\n    INSERT INTO order_info (user_id, product_name, productor) VALUES (9, 'p8', 'TE');\nEXPLAIN 输出格式\nEXPLAIN 命令的输出内容大致如下:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n各列的含义如下:\n\n- id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.\n- select_type: SELECT 查询的类型.\n- table: 查询的是哪个表\n- partitions: 匹配的分区\n- type: join 类型\n- possible_keys: 此次查询中可能选用的索引\n- key: 此次查询中确切使用到的索引.\n- ref: 哪个字段或常数与 key 一起被使用\n- rows: 显示此查询一共扫描了多少行. 这个是一个估计值.\n- filtered: 表示此查询条件所过滤的数据的百分比\n- extra: 额外的信息\n接下来我们来重点看一下比较重要的几个字段.\n\nselect_type  \nselect_type 表示了查询的类型, 它的常用取值有:\n\nSIMPLE, 表示此查询不包含 UNION 查询或子查询  \nPRIMARY, 表示此查询是最外层的查询  \nUNION, 表示此查询是 UNION 的第二或随后的查询  \nDEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询  \nUNION RESULT, UNION 的结果  \nSUBQUERY, 子查询中的第一个 SELECT  \nDEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.   \n最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:\n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:\n\n    mysql> EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n        -> UNION\n        -> (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    | id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    |  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    |  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n    | NULL | UNION RESULT | <union1,2> | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n    +----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n    3 rows in set, 1 warning (0.00 sec)\n    table\n表示查询涉及的表或衍生表\n\n- type  \ntype 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.   \ntype 常用类型   \ntype 常用的取值有:   \nsystem: 表中只有一条数据. 这个类型是特殊的 const 类型.   \nconst: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.   \n例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   \n\n    mysql> explain select * from user_info where id = 2\\G\n    *************************** 1. row ***************************\n               id: 1\n      select_type: SIMPLE\n            table: user_info\n       partitions: NULL\n             type: const\n    possible_keys: PRIMARY\n              key: PRIMARY\n          key_len: 8\n              ref: const\n             rows: 1\n         filtered: 100.00\n            Extra: NULL\n    1 row in set, 1 warning (0.00 sec)\n    \n- eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 314\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using where; Using index\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: eq_ref\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: test.order_info.user_id\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        2 rows in set, 1 warning (0.00 sec)\n        \n- ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询. \n例如下面这个例子中, 就使用到了 ref 类型的查询:\n\n        mysql> EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: const\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: NULL\n        *************************** 2. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: const\n                 rows: 1\n             filtered: 100.00\n                Extra: Using index\n        2 rows in set, 1 warning (0.01 sec)\n\n- range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, <>, >, >=, <, <=, IS NULL, <=>, BETWEEN, IN() 操作中.  \n当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.\n例如下面的例子就是一个范围查询:  \n\n        mysql> EXPLAIN SELECT *\n            ->         FROM user_info\n            ->         WHERE id BETWEEN 2 AND 8 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: range\n        possible_keys: PRIMARY\n                  key: PRIMARY\n              key_len: 8\n                  ref: NULL\n                 rows: 7\n             filtered: 100.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n    \n- index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.  \nindex 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.  \n例如:  \n\n        mysql> EXPLAIN SELECT name FROM  user_info \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: name_index\n              key_len: 152\n                  ref: NULL\n                 rows: 10\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n    \n上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  \n\n- ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.   \n下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   \n\n        mysql> EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: user_info\n           partitions: NULL\n                 type: ALL\n        possible_keys: NULL\n                  key: NULL\n              key_len: NULL\n                  ref: NULL\n                 rows: 10\n             filtered: 10.00\n                Extra: Using where\n        1 row in set, 1 warning (0.00 sec)\n        \n- type 类型的性能比较\n通常来说, 不同的 type 类型的性能关系如下:\nALL < index < range ~ index_merge < ref < eq_ref < const < system\nALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.\n而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.\n后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.\npossible_keys\npossible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.\nkey\n此字段是 MySQL 在当前查询时所真正使用到的索引.\nkey_len\n表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.\nkey_len 的计算规则如下:\n字符串\nchar(n): n 字节长度\nvarchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.\n数值类型:\nTINYINT: 1字节\nSMALLINT: 2字节\nMEDIUMINT: 3字节\nINT: 4字节\nBIGINT: 8字节\n时间类型\nDATE: 3字节\nTIMESTAMP: 4字节\nDATETIME: 8字节\n字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.\n我们来举两个简单的栗子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: range\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 9\n                  ref: NULL\n                 rows: 5\n             filtered: 11.11\n                Extra: Using where; Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:\n\n- `KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n不过此查询语句 WHERE user_id < 3 AND product_name = 'p1' AND productor = 'WHH' 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT '0', 则 key_length 应该是8.\n\n上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.\n\n接下来我们来看一下下一个例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = 'p1' \\G;\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: ref\n        possible_keys: user_product_detail_index\n                  key: user_product_detail_index\n              key_len: 161\n                  ref: const,const\n                 rows: 2\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = 'p1' 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161\n\n- rows\nrows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.\n这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.\n\n- Extra\nEXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:\n\n- Using filesort\n当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.\n例如下面的例子:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index; Using filesort\n        1 row in set, 1 warning (0.00 sec)\n        \n我们的索引是\n\n`KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)`\n但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.\n如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:\n\n        mysql> EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n        *************************** 1. row ***************************\n                   id: 1\n          select_type: SIMPLE\n                table: order_info\n           partitions: NULL\n                 type: index\n        possible_keys: NULL\n                  key: user_product_detail_index\n              key_len: 253\n                  ref: NULL\n                 rows: 9\n             filtered: 100.00\n                Extra: Using index\n        1 row in set, 1 warning (0.00 sec)\n        \n- Using index\n\"覆盖索引扫描\", 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错\n-   Using temporary\n查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.","slug":"mysql-explain","published":1,"updated":"2017-11-21T05:50:49.432Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckot00268ora07i4wp1v","content":"<p>MySQL 性能优化神器 Explain 使用分析</p>\n<p>mysql mysql优化  永顺 1月16日发布<br>赞  |   6收藏  |  50<br>3.2k 次浏览<br>简介<br>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>\n<p>EXPLAIN SELECT * from user_info WHERE id &lt; 300;<br>准备<br>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>\n<pre><code>CREATE TABLE `user_info` (\n  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `age`  INT(11)              DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name_index` (`name`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);\nINSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);\nCREATE TABLE `order_info` (\n  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `user_id`      BIGINT(20)           DEFAULT NULL,\n  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `productor`    VARCHAR(30)          DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);\n</code></pre><p>EXPLAIN 输出格式<br>EXPLAIN 命令的输出内容大致如下:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>各列的含义如下:</p>\n<ul>\n<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li>select_type: SELECT 查询的类型.</li>\n<li>table: 查询的是哪个表</li>\n<li>partitions: 匹配的分区</li>\n<li>type: join 类型</li>\n<li>possible_keys: 此次查询中可能选用的索引</li>\n<li>key: 此次查询中确切使用到的索引.</li>\n<li>ref: 哪个字段或常数与 key 一起被使用</li>\n<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>\n<li>filtered: 表示此查询条件所过滤的数据的百分比</li>\n<li>extra: 额外的信息<br>接下来我们来重点看一下比较重要的几个字段.</li>\n</ul>\n<p>select_type<br>select_type 表示了查询的类型, 它的常用取值有:</p>\n<p>SIMPLE, 表示此查询不包含 UNION 查询或子查询<br>PRIMARY, 表示此查询是最外层的查询<br>UNION, 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>SUBQUERY, 子查询中的第一个 SELECT<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.<br>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>\n<pre><code>mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n    -&gt; UNION\n    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n3 rows in set, 1 warning (0.00 sec)\ntable\n</code></pre><p>表示查询涉及的表或衍生表</p>\n<ul>\n<li><p>type<br>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>type 常用类型<br>type 常用的取值有:<br>system: 表中只有一条数据. 这个类型是特殊的 const 类型.<br>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   </p>\n<p>  mysql&gt; explain select <em> from user_info where id = 2\\G<br>  <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></p>\n<pre><code>         id: 1\nselect_type: SIMPLE\n      table: user_info\n partitions: NULL\n       type: const\n</code></pre><p>  possible_keys: PRIMARY</p>\n<pre><code>     key: PRIMARY\n key_len: 8\n     ref: const\n    rows: 1\nfiltered: 100.00\n   Extra: NULL\n</code></pre><p>  1 row in set, 1 warning (0.00 sec)</p>\n</li>\n<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 314\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using where; Using index\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: eq_ref\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: test.order_info.user_id\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n2 rows in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index\n2 rows in set, 1 warning (0.01 sec)\n</code></pre></li>\n<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.<br>例如下面的例子就是一个范围查询:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT *\n    -&gt;         FROM user_info\n    -&gt;         WHERE id BETWEEN 2 AND 8 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 7\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.<br>例如:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT name FROM  user_info \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: name_index\n      key_len: 152\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  </p>\n<ul>\n<li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   </p>\n<pre><code>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 10.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.<br>possible_keys<br>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.<br>key<br>此字段是 MySQL 在当前查询时所真正使用到的索引.<br>key_len<br>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:<br>字符串<br>char(n): n 字节长度<br>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.<br>数值类型:<br>TINYINT: 1字节<br>SMALLINT: 2字节<br>MEDIUMINT: 3字节<br>INT: 4字节<br>BIGINT: 8字节<br>时间类型<br>DATE: 3字节<br>TIMESTAMP: 4字节<br>DATETIME: 8字节<br>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.<br>我们来举两个简单的栗子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: range\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: NULL\n         rows: 5\n     filtered: 11.11\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>\n<ul>\n<li><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</li>\n</ul>\n<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>\n<p>接下来我们来看一下下一个例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 161\n          ref: const,const\n         rows: 2\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>\n<ul>\n<li><p>rows<br>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n</li>\n<li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.<br>例如下面的例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index; Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>我们的索引是</p>\n<p><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><ul>\n<li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<p>MySQL 性能优化神器 Explain 使用分析</p>\n<p>mysql mysql优化  永顺 1月16日发布<br>赞  |   6收藏  |  50<br>3.2k 次浏览<br>简介<br>MySQL 提供了一个 EXPLAIN 命令, 它可以对 SELECT 语句进行分析, 并输出 SELECT 执行的详细信息, 以供开发人员针对性优化.<br>EXPLAIN 命令用法十分简单, 在 SELECT 语句前加上 Explain 就可以了, 例如:</p>\n<p>EXPLAIN SELECT * from user_info WHERE id &lt; 300;<br>准备<br>为了接下来方便演示 EXPLAIN 的使用, 首先我们需要建立两个测试用的表, 并添加相应的数据:</p>\n<pre><code>CREATE TABLE `user_info` (\n  `id`   BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `age`  INT(11)              DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `name_index` (`name`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO user_info (name, age) VALUES (&apos;xys&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;a&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;b&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;c&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;d&apos;, 15);\nINSERT INTO user_info (name, age) VALUES (&apos;e&apos;, 20);\nINSERT INTO user_info (name, age) VALUES (&apos;f&apos;, 21);\nINSERT INTO user_info (name, age) VALUES (&apos;g&apos;, 23);\nINSERT INTO user_info (name, age) VALUES (&apos;h&apos;, 50);\nINSERT INTO user_info (name, age) VALUES (&apos;i&apos;, 15);\nCREATE TABLE `order_info` (\n  `id`           BIGINT(20)  NOT NULL AUTO_INCREMENT,\n  `user_id`      BIGINT(20)           DEFAULT NULL,\n  `product_name` VARCHAR(50) NOT NULL DEFAULT &apos;&apos;,\n  `productor`    VARCHAR(30)          DEFAULT NULL,\n  PRIMARY KEY (`id`),\n  KEY `user_product_detail_index` (`user_id`, `product_name`, `productor`)\n)\n  ENGINE = InnoDB\n  DEFAULT CHARSET = utf8\n\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p2&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (1, &apos;p1&apos;, &apos;DX&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (2, &apos;p5&apos;, &apos;WL&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (3, &apos;p3&apos;, &apos;MA&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (4, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (6, &apos;p1&apos;, &apos;WHH&apos;);\nINSERT INTO order_info (user_id, product_name, productor) VALUES (9, &apos;p8&apos;, &apos;TE&apos;);\n</code></pre><p>EXPLAIN 输出格式<br>EXPLAIN 命令的输出内容大致如下:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>各列的含义如下:</p>\n<ul>\n<li>id: SELECT 查询的标识符. 每个 SELECT 都会自动分配一个唯一的标识符.</li>\n<li>select_type: SELECT 查询的类型.</li>\n<li>table: 查询的是哪个表</li>\n<li>partitions: 匹配的分区</li>\n<li>type: join 类型</li>\n<li>possible_keys: 此次查询中可能选用的索引</li>\n<li>key: 此次查询中确切使用到的索引.</li>\n<li>ref: 哪个字段或常数与 key 一起被使用</li>\n<li>rows: 显示此查询一共扫描了多少行. 这个是一个估计值.</li>\n<li>filtered: 表示此查询条件所过滤的数据的百分比</li>\n<li>extra: 额外的信息<br>接下来我们来重点看一下比较重要的几个字段.</li>\n</ul>\n<p>select_type<br>select_type 表示了查询的类型, 它的常用取值有:</p>\n<p>SIMPLE, 表示此查询不包含 UNION 查询或子查询<br>PRIMARY, 表示此查询是最外层的查询<br>UNION, 表示此查询是 UNION 的第二或随后的查询<br>DEPENDENT UNION, UNION 中的第二个或后面的查询语句, 取决于外面的查询<br>UNION RESULT, UNION 的结果<br>SUBQUERY, 子查询中的第一个 SELECT<br>DEPENDENT SUBQUERY: 子查询中的第一个 SELECT, 取决于外面的查询. 即子查询依赖于外层查询的结果.<br>最常见的查询类别应该是 SIMPLE 了, 比如当我们的查询没有子查询, 也没有 UNION 查询时, 那么通常就是 SIMPLE 类型,   例如:</p>\n<pre><code>mysql&gt; explain select * from user_info where id = 2\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>如果我们使用了 UNION 查询, 那么 EXPLAIN 输出 的结果类似如下:</p>\n<pre><code>mysql&gt; EXPLAIN (SELECT * FROM user_info  WHERE id IN (1, 2, 3))\n    -&gt; UNION\n    -&gt; (SELECT * FROM user_info WHERE id IN (3, 4, 5));\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n| id | select_type  | table      | partitions | type  | possible_keys | key     | key_len | ref  | rows | filtered | Extra           |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n|  1 | PRIMARY      | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n|  2 | UNION        | user_info  | NULL       | range | PRIMARY       | PRIMARY | 8       | NULL |    3 |   100.00 | Using where     |\n| NULL | UNION RESULT | &lt;union1,2&gt; | NULL       | ALL   | NULL          | NULL    | NULL    | NULL | NULL |     NULL | Using temporary |\n+----+--------------+------------+------------+-------+---------------+---------+---------+------+------+----------+-----------------+\n3 rows in set, 1 warning (0.00 sec)\ntable\n</code></pre><p>表示查询涉及的表或衍生表</p>\n<ul>\n<li><p>type<br>type 字段比较重要, 它提供了判断查询是否高效的重要依据依据. 通过 type 字段, 我们判断此次查询是 全表扫描 还是 索引扫描 等.<br>type 常用类型<br>type 常用的取值有:<br>system: 表中只有一条数据. 这个类型是特殊的 const 类型.<br>const: 针对主键或唯一索引的等值查询扫描, 最多只返回一行数据. const 查询速度非常快, 因为它仅仅读取一次即可.<br>例如下面的这个查询, 它使用了主键索引, 因此 type 就是 const 类型的.   </p>\n<p>  mysql&gt; explain select <em> from user_info where id = 2\\G<br>  <strong><strong><strong><strong><strong><strong>**</strong></strong></strong></strong></strong></strong></em> 1. row <strong><strong><strong><strong><strong><strong><em>*</em></strong></strong></strong></strong></strong></strong></p>\n<pre><code>         id: 1\nselect_type: SIMPLE\n      table: user_info\n partitions: NULL\n       type: const\n</code></pre><p>  possible_keys: PRIMARY</p>\n<pre><code>     key: PRIMARY\n key_len: 8\n     ref: const\n    rows: 1\nfiltered: 100.00\n   Extra: NULL\n</code></pre><p>  1 row in set, 1 warning (0.00 sec)</p>\n</li>\n<li><p>eq_ref: 此类型通常出现在多表的 join 查询, 表示对于前表的每一个结果, 都只能匹配到后表的一行结果. 并且查询的比较操作通常是 =, 查询效率较高. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 314\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using where; Using index\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: eq_ref\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: test.order_info.user_id\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n2 rows in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>ref: 此类型通常出现在多表的 join 查询, 针对于非唯一或非主键索引, 或者是使用了 最左前缀 规则索引的查询.<br>例如下面这个例子中, 就使用到了 ref 类型的查询:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM user_info, order_info WHERE user_info.id = order_info.user_id AND order_info.user_id = 5\\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: const\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: NULL\n*************************** 2. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: const\n         rows: 1\n     filtered: 100.00\n        Extra: Using index\n2 rows in set, 1 warning (0.01 sec)\n</code></pre></li>\n<li><p>range: 表示使用索引范围查询, 通过索引字段范围获取表中部分数据记录. 这个类型通常出现在 =, &lt;&gt;, &gt;, &gt;=, &lt;, &lt;=, IS NULL, &lt;=&gt;, BETWEEN, IN() 操作中.<br>当 type 是 range 时, 那么 EXPLAIN 输出的 ref 字段为 NULL, 并且 key_len 字段是此次查询中使用到的索引的最长的那个.<br>例如下面的例子就是一个范围查询:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT *\n    -&gt;         FROM user_info\n    -&gt;         WHERE id BETWEEN 2 AND 8 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: range\npossible_keys: PRIMARY\n          key: PRIMARY\n      key_len: 8\n          ref: NULL\n         rows: 7\n     filtered: 100.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>index: 表示全索引扫描(full index scan), 和 ALL 类型类似, 只不过 ALL 类型是全表扫描, 而 index 类型则仅仅扫描所有的索引, 而不扫描数据.<br>index 类型通常出现在: 所要查询的数据直接在索引树中就可以获取到, 而不需要扫描数据. 当是这种情况时, Extra 字段 会显示 Using index.<br>例如:  </p>\n<pre><code>mysql&gt; EXPLAIN SELECT name FROM  user_info \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: name_index\n      key_len: 152\n          ref: NULL\n         rows: 10\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子中, 我们查询的 name 字段恰好是一个索引, 因此我们直接从索引中获取数据就可以满足查询的需求了, 而不需要查询表中的数据. 因此这样的情况下, type 的值是 index, 并且 Extra 的值是 Using index.  </p>\n<ul>\n<li><p>ALL: 表示全表扫描, 这个类型的查询是性能最差的查询之一. 通常来说, 我们的查询不应该出现 ALL 类型的查询, 因为这样的查询在数据量大的情况下, 对数据库的性能是巨大的灾难. 如一个查询是 ALL 类型查询, 那么一般来说可以对相应的字段添加索引来避免.<br>下面是一个全表扫描的例子, 可以看到, 在全表扫描时, possible_keys 和 key 字段都是 NULL, 表示没有使用到索引, 并且 rows 十分巨大, 因此整个查询效率是十分低下的.   </p>\n<pre><code>mysql&gt; EXPLAIN SELECT age FROM  user_info WHERE age = 20 \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: user_info\n   partitions: NULL\n         type: ALL\npossible_keys: NULL\n          key: NULL\n      key_len: NULL\n          ref: NULL\n         rows: 10\n     filtered: 10.00\n        Extra: Using where\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n<li><p>type 类型的性能比较<br>通常来说, 不同的 type 类型的性能关系如下:<br>ALL &lt; index &lt; range ~ index_merge &lt; ref &lt; eq_ref &lt; const &lt; system<br>ALL 类型因为是全表扫描, 因此在相同的查询条件下, 它是速度最慢的.<br>而 index 类型的查询虽然不是全表扫描, 但是它扫描了所有的索引, 因此比 ALL 类型的稍快.<br>后面的几种类型都是利用了索引来查询数据, 因此可以过滤部分或大部分数据, 因此查询效率就比较高了.<br>possible_keys<br>possible_keys 表示 MySQL 在查询时, 能够使用到的索引. 注意, 即使有些索引在 possible_keys 中出现, 但是并不表示此索引会真正地被 MySQL 使用到. MySQL 在查询时具体使用了哪些索引, 由 key 字段决定.<br>key<br>此字段是 MySQL 在当前查询时所真正使用到的索引.<br>key_len<br>表示查询优化器使用了索引的字节数. 这个字段可以评估组合索引是否完全被使用, 或只有最左部分字段被使用到.<br>key_len 的计算规则如下:<br>字符串<br>char(n): n 字节长度<br>varchar(n): 如果是 utf8 编码, 则是 3 n + 2字节; 如果是 utf8mb4 编码, 则是 4 n + 2 字节.<br>数值类型:<br>TINYINT: 1字节<br>SMALLINT: 2字节<br>MEDIUMINT: 3字节<br>INT: 4字节<br>BIGINT: 8字节<br>时间类型<br>DATE: 3字节<br>TIMESTAMP: 4字节<br>DATETIME: 8字节<br>字段属性: NULL 属性 占用一个字节. 如果一个字段是 NOT NULL 的, 则没有此属性.<br>我们来举两个简单的栗子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id &lt; 3 AND product_name = &apos;p1&apos; AND productor = &apos;WHH&apos; \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: range\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 9\n          ref: NULL\n         rows: 5\n     filtered: 11.11\n        Extra: Using where; Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>上面的例子是从表 order_info 中查询指定的内容, 而我们从此表的建表语句中可以知道, 表 order_info 有一个联合索引:</p>\n<ul>\n<li><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>不过此查询语句 WHERE user_id &lt; 3 AND product_name = ‘p1’ AND productor = ‘WHH’ 中, 因为先进行 user_id 的范围查询, 而根据 最左前缀匹配 原则, 当遇到范围查询时, 就停止索引的匹配, 因此实际上我们使用到的索引的字段只有 user_id, 因此在 EXPLAIN 中, 显示的 key_len 为 9. 因为 user_id 字段是 BIGINT, 占用 8 字节, 而 NULL 属性占用一个字节, 因此总共是 9 个字节. 若我们将user_id 字段改为 BIGINT(20) NOT NULL DEFAULT ‘0’, 则 key_length 应该是8.</li>\n</ul>\n<p>上面因为 最左前缀匹配 原则, 我们的查询仅仅使用到了联合索引的 user_id 字段, 因此效率不算高.</p>\n<p>接下来我们来看一下下一个例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info WHERE user_id = 1 AND product_name = &apos;p1&apos; \\G;\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: ref\npossible_keys: user_product_detail_index\n          key: user_product_detail_index\n      key_len: 161\n          ref: const,const\n         rows: 2\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><p>这次的查询中, 我们没有使用到范围查询, key_len 的值为 161. 为什么呢? 因为我们的查询条件 WHERE user_id = 1 AND product_name = ‘p1’ 中, 仅仅使用到了联合索引中的前两个字段, 因此 keyLen(user_id) + keyLen(product_name) = 9 + 50 * 3 + 2 = 161</p>\n<ul>\n<li><p>rows<br>rows 也是一个重要的字段. MySQL 查询优化器根据统计信息, 估算 SQL 要查找到结果集需要扫描读取的数据行数.<br>这个值非常直观显示 SQL 的效率好坏, 原则上 rows 越少越好.</p>\n</li>\n<li><p>Extra<br>EXplain 中的很多额外的信息会在 Extra 字段显示, 常见的有以下几种内容:</p>\n</li>\n<li><p>Using filesort<br>当 Extra 中有 Using filesort 时, 表示 MySQL 需额外的排序操作, 不能通过索引顺序达到排序效果. 一般有 Using filesort, 都建议优化去掉, 因为这样的查询 CPU 资源消耗大.<br>例如下面的例子:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index; Using filesort\n1 row in set, 1 warning (0.00 sec)\n</code></pre></li>\n</ul>\n<p>我们的索引是</p>\n<p><code>KEY</code>user_product_detail_index<code>(</code>user_id<code>,</code>product_name<code>,</code>productor<code>)</code><br>但是上面的查询中根据 product_name 来排序, 因此不能使用索引进行优化, 进而会产生 Using filesort.<br>如果我们将排序依据改为 ORDER BY user_id, product_name, 那么就不会出现 Using filesort 了. 例如:</p>\n<pre><code>mysql&gt; EXPLAIN SELECT * FROM order_info ORDER BY user_id, product_name \\G\n*************************** 1. row ***************************\n           id: 1\n  select_type: SIMPLE\n        table: order_info\n   partitions: NULL\n         type: index\npossible_keys: NULL\n          key: user_product_detail_index\n      key_len: 253\n          ref: NULL\n         rows: 9\n     filtered: 100.00\n        Extra: Using index\n1 row in set, 1 warning (0.00 sec)\n</code></pre><ul>\n<li>Using index<br>“覆盖索引扫描”, 表示查询在索引树中就可查找所需数据, 不用扫描表数据文件, 往往说明性能不错</li>\n<li>Using temporary<br>查询有使用临时表, 一般出现于排序, 分组和多表 join 的情况, 查询效率不高, 建议优化.</li>\n</ul>\n"},{"title":"redis一主多从集群配置","date":"2017-09-21T05:46:08.000Z","_content":"","source":"_posts/redis-cluster-centos.md","raw":"---\ntitle: redis一主多从集群配置\ndate: 2017-09-21 13:46:08\ncategories: 数据库\ntags:   redis\n---\n","slug":"redis-cluster-centos","published":1,"updated":"2017-11-14T08:30:11.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckov00288orafw18nvbh","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"restful-api设计摘要","date":"2017-09-29T14:07:54.000Z","_content":"本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","source":"_posts/restful-api-dev.md","raw":"---\ntitle: restful-api设计摘要\ndate: 2017-09-29 22:07:54\ncategories: api-manage\ntags: restful-api\n---\n本文来源网络第三方。\nrestfull api代码风格思想，参考：\n- [RESTful API](https://en.wikipedia.org/wiki/Representational_state_transfer)\n\n- [《理解RESTful架构》](http://www.ruanyifeng.com/blog/2011/09/restful.html)\n\n- [https://restfulapi.net/resource-naming/](https://restfulapi.net/resource-naming/)\n\n## 一. 协议\nAPI与用户的通信协议，总是使用HTTPs协议。\n\n## 二. 域名\n应该尽量将API部署在专用域名之下。\n\n`https://api.example.com`\n\n如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。\n\n`https://example.org/api/`\n\n## 三. 版本（Versioning）\n应该将API的版本号放入URL。\n\n`https://api.example.com/v1/`\n\n另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。\n\n## 四. 路径（Endpoint）\n路径又称\"终点\"（endpoint），表示API的具体网址。\n\n在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的\"集合\"（collection），所以API中的名词也应该使用复数。\n\n举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。\n\n> - `https://api.example.com/v1/zoos`\n> - `https://api.example.com/v1/animals`\n> - `https://api.example.com/v1/employees`\n\n## 五. HTTP动词\n对于资源的具体操作类型，由HTTP动词表示。\n常用的HTTP动词有下面五个（括号里是对应的SQL命令）。\n\n> - GET（SELECT）：从服务器取出资源（一项或多项）。\n- POST（CREATE）：在服务器新建一个资源。\n- PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。\n- PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。\n- DELETE（DELETE）：从服务器删除资源。\n\n还有两个不常用的HTTP动词。\n> - HEAD：获取资源的元数据。\n- OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。\n\n下面是一些例子。\n> - GET /zoos：列出所有动物园\n- POST /zoos：新建一个动物园\n- GET /zoos/ID：获取某个指定动物园的信息\n- PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）\n- PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）\n- DELETE /zoos/ID：删除某个动物园\n- GET /zoos/ID/animals：列出某个指定动物园的所有动物\n- DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物\n\n## 六. 过滤信息（Filtering）\n如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。\n\n下面是一些常见的参数。\n> - ?limit=10：指定返回记录的数量\n- ?offset=10：指定返回记录的开始位置。\n- ?page=2&per_page=100：指定第几页，以及每页的记录数。\n- ?sortby=name&order=asc：指定返回结果按照哪个属性排序，以及排序顺序。\n- ?animal_type_id=1：指定筛选条件\n\n参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。\n\n## 七. 状态码（Status Codes）\n服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。\n\n> - 200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。\n- 201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。\n- 202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）\n- 204 NO CONTENT - [DELETE]：用户删除数据成功。\n- 400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。\n- 401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。\n- 403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。\n- 404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。\n- 406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。\n- 410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。\n- 422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。\n- 500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。\n\n状态码的完全列表参见[这里](https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html)。\n\n## 八. 错误处理（Error handling）\n如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。\n\n    {\n        error: \"Invalid API key\"\n    }\n    \n## 九. 返回结果\n针对不同操作，服务器向用户返回的结果应该符合以下规范。\n\n> - GET /collection：返回资源对象的列表（数组）\n- GET /collection/resource：返回单个资源对象\n- POST /collection：返回新生成的资源对象\n- PUT /collection/resource：返回完整的资源对象\n- PATCH /collection/resource：返回完整的资源对象\n- DELETE /collection/resource：返回一个空文档  \n\n## 十. 超媒体api(Hypermedia API)\nRESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。\n\n比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。\n\n    {\"link\": {\n      \"rel\":   \"collection https://www.example.com/zoos\",\n      \"href\":  \"https://api.example.com/zoos\",\n      \"title\": \"List of zoos\",\n      \"type\":  \"application/vnd.yourformat+json\"\n    }}\n    \n上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。\n\nHypermedia API的设计被称为[HATEOAS](https://en.wikipedia.org/wiki/HATEOAS)。Github的API就是这种设计，访问[api.github.com](api.github.com)会得到一个所有可用API的网址列表。 \n\n    {\n      \"current_user_url\": \"https://api.github.com/user\",\n      \"authorizations_url\": \"https://api.github.com/authorizations\",\n      // ...\n    }\n    \n从上面可以看到，如果想获取当前用户的信息，应该去访问[api.github.com/user](api.github.com/user)，然后就得到了下面结果。\n\n    {\n      \"message\": \"Requires authentication\",\n      \"documentation_url\": \"https://developer.github.com/v3\"\n    }  \n    \n面代码表示，服务器给出了提示信息，以及文档的网址。         ","slug":"restful-api-dev","published":1,"updated":"2017-11-14T08:30:11.233Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckox002c8orax47qi90a","content":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"external\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"external\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"external\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n","site":{"data":{}},"excerpt":"","more":"<p>本文来源网络第三方。<br>restfull api代码风格思想，参考：</p>\n<ul>\n<li><p><a href=\"https://en.wikipedia.org/wiki/Representational_state_transfer\" target=\"_blank\" rel=\"external\">RESTful API</a></p>\n</li>\n<li><p><a href=\"http://www.ruanyifeng.com/blog/2011/09/restful.html\" target=\"_blank\" rel=\"external\">《理解RESTful架构》</a></p>\n</li>\n<li><p><a href=\"https://restfulapi.net/resource-naming/\" target=\"_blank\" rel=\"external\">https://restfulapi.net/resource-naming/</a></p>\n</li>\n</ul>\n<h2 id=\"一-协议\"><a href=\"#一-协议\" class=\"headerlink\" title=\"一. 协议\"></a>一. 协议</h2><p>API与用户的通信协议，总是使用HTTPs协议。</p>\n<h2 id=\"二-域名\"><a href=\"#二-域名\" class=\"headerlink\" title=\"二. 域名\"></a>二. 域名</h2><p>应该尽量将API部署在专用域名之下。</p>\n<p><code>https://api.example.com</code></p>\n<p>如果确定API很简单，不会有进一步扩展，可以考虑放在主域名下。</p>\n<p><code>https://example.org/api/</code></p>\n<h2 id=\"三-版本（Versioning）\"><a href=\"#三-版本（Versioning）\" class=\"headerlink\" title=\"三. 版本（Versioning）\"></a>三. 版本（Versioning）</h2><p>应该将API的版本号放入URL。</p>\n<p><code>https://api.example.com/v1/</code></p>\n<p>另一种做法是，将版本号放在HTTP头信息中，但不如放入URL方便和直观。Github采用这种做法。</p>\n<h2 id=\"四-路径（Endpoint）\"><a href=\"#四-路径（Endpoint）\" class=\"headerlink\" title=\"四. 路径（Endpoint）\"></a>四. 路径（Endpoint）</h2><p>路径又称”终点”（endpoint），表示API的具体网址。</p>\n<p>在RESTful架构中，每个网址代表一种资源（resource），所以网址中不能有动词，只能有名词，而且所用的名词往往与数据库的表格名对应。一般来说，数据库中的表都是同种记录的”集合”（collection），所以API中的名词也应该使用复数。</p>\n<p>举例来说，有一个API提供动物园（zoo）的信息，还包括各种动物和雇员的信息，则它的路径应该设计成下面这样。</p>\n<blockquote>\n<ul>\n<li><code>https://api.example.com/v1/zoos</code></li>\n<li><code>https://api.example.com/v1/animals</code></li>\n<li><code>https://api.example.com/v1/employees</code></li>\n</ul>\n</blockquote>\n<h2 id=\"五-HTTP动词\"><a href=\"#五-HTTP动词\" class=\"headerlink\" title=\"五. HTTP动词\"></a>五. HTTP动词</h2><p>对于资源的具体操作类型，由HTTP动词表示。<br>常用的HTTP动词有下面五个（括号里是对应的SQL命令）。</p>\n<blockquote>\n<ul>\n<li>GET（SELECT）：从服务器取出资源（一项或多项）。</li>\n<li>POST（CREATE）：在服务器新建一个资源。</li>\n<li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li>\n<li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li>\n<li>DELETE（DELETE）：从服务器删除资源。</li>\n</ul>\n</blockquote>\n<p>还有两个不常用的HTTP动词。</p>\n<blockquote>\n<ul>\n<li>HEAD：获取资源的元数据。</li>\n<li>OPTIONS：获取信息，关于资源的哪些属性是客户端可以改变的。</li>\n</ul>\n</blockquote>\n<p>下面是一些例子。</p>\n<blockquote>\n<ul>\n<li>GET /zoos：列出所有动物园</li>\n<li>POST /zoos：新建一个动物园</li>\n<li>GET /zoos/ID：获取某个指定动物园的信息</li>\n<li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li>\n<li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li>\n<li>DELETE /zoos/ID：删除某个动物园</li>\n<li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li>\n<li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li>\n</ul>\n</blockquote>\n<h2 id=\"六-过滤信息（Filtering）\"><a href=\"#六-过滤信息（Filtering）\" class=\"headerlink\" title=\"六. 过滤信息（Filtering）\"></a>六. 过滤信息（Filtering）</h2><p>如果记录数量很多，服务器不可能都将它们返回给用户。API应该提供参数，过滤返回结果。</p>\n<p>下面是一些常见的参数。</p>\n<blockquote>\n<ul>\n<li>?limit=10：指定返回记录的数量</li>\n<li>?offset=10：指定返回记录的开始位置。</li>\n<li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li>\n<li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li>\n<li>?animal_type_id=1：指定筛选条件</li>\n</ul>\n</blockquote>\n<p>参数的设计允许存在冗余，即允许API路径和URL参数偶尔有重复。比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p>\n<h2 id=\"七-状态码（Status-Codes）\"><a href=\"#七-状态码（Status-Codes）\" class=\"headerlink\" title=\"七. 状态码（Status Codes）\"></a>七. 状态码（Status Codes）</h2><p>服务器向用户返回的状态码和提示信息，常见的有以下一些（方括号中是该状态码对应的HTTP动词）。</p>\n<blockquote>\n<ul>\n<li>200 OK - [GET]：服务器成功返回用户请求的数据，该操作是幂等的（Idempotent）。</li>\n<li>201 CREATED - [POST/PUT/PATCH]：用户新建或修改数据成功。</li>\n<li>202 Accepted - [*]：表示一个请求已经进入后台排队（异步任务）</li>\n<li>204 NO CONTENT - [DELETE]：用户删除数据成功。</li>\n<li>400 INVALID REQUEST - [POST/PUT/PATCH]：用户发出的请求有错误，服务器没有进行新建或修改数据的操作，该操作是幂等的。</li>\n<li>401 Unauthorized - [*]：表示用户没有权限（令牌、用户名、密码错误）。</li>\n<li>403 Forbidden - [*] 表示用户得到授权（与401错误相对），但是访问是被禁止的。</li>\n<li>404 NOT FOUND - [*]：用户发出的请求针对的是不存在的记录，服务器没有进行操作，该操作是幂等的。</li>\n<li>406 Not Acceptable - [GET]：用户请求的格式不可得（比如用户请求JSON格式，但是只有XML格式）。</li>\n<li>410 Gone -[GET]：用户请求的资源被永久删除，且不会再得到的。</li>\n<li>422 Unprocesable entity - [POST/PUT/PATCH] 当创建一个对象时，发生一个验证错误。</li>\n<li>500 INTERNAL SERVER ERROR - [*]：服务器发生错误，用户将无法判断发出的请求是否成功。</li>\n</ul>\n</blockquote>\n<p>状态码的完全列表参见<a href=\"https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html\" target=\"_blank\" rel=\"external\">这里</a>。</p>\n<h2 id=\"八-错误处理（Error-handling）\"><a href=\"#八-错误处理（Error-handling）\" class=\"headerlink\" title=\"八. 错误处理（Error handling）\"></a>八. 错误处理（Error handling）</h2><p>如果状态码是4xx，就应该向用户返回出错信息。一般来说，返回的信息中将error作为键名，出错信息作为键值即可。</p>\n<pre><code>{\n    error: &quot;Invalid API key&quot;\n}\n</code></pre><h2 id=\"九-返回结果\"><a href=\"#九-返回结果\" class=\"headerlink\" title=\"九. 返回结果\"></a>九. 返回结果</h2><p>针对不同操作，服务器向用户返回的结果应该符合以下规范。</p>\n<blockquote>\n<ul>\n<li>GET /collection：返回资源对象的列表（数组）</li>\n<li>GET /collection/resource：返回单个资源对象</li>\n<li>POST /collection：返回新生成的资源对象</li>\n<li>PUT /collection/resource：返回完整的资源对象</li>\n<li>PATCH /collection/resource：返回完整的资源对象</li>\n<li>DELETE /collection/resource：返回一个空文档  </li>\n</ul>\n</blockquote>\n<h2 id=\"十-超媒体api-Hypermedia-API\"><a href=\"#十-超媒体api-Hypermedia-API\" class=\"headerlink\" title=\"十. 超媒体api(Hypermedia API)\"></a>十. 超媒体api(Hypermedia API)</h2><p>RESTful API最好做到Hypermedia，即返回结果中提供链接，连向其他API方法，使得用户不查文档，也知道下一步应该做什么。</p>\n<p>比如，当用户向api.example.com的根目录发出请求，会得到这样一个文档。</p>\n<pre><code>{&quot;link&quot;: {\n  &quot;rel&quot;:   &quot;collection https://www.example.com/zoos&quot;,\n  &quot;href&quot;:  &quot;https://api.example.com/zoos&quot;,\n  &quot;title&quot;: &quot;List of zoos&quot;,\n  &quot;type&quot;:  &quot;application/vnd.yourformat+json&quot;\n}}\n</code></pre><p>上面代码表示，文档中有一个link属性，用户读取这个属性就知道下一步该调用什么API了。rel表示这个API与当前网址的关系（collection关系，并给出该collection的网址），href表示API的路径，title表示API的标题，type表示返回类型。</p>\n<p>Hypermedia API的设计被称为<a href=\"https://en.wikipedia.org/wiki/HATEOAS\" target=\"_blank\" rel=\"external\">HATEOAS</a>。Github的API就是这种设计，访问<a href=\"api.github.com\">api.github.com</a>会得到一个所有可用API的网址列表。 </p>\n<pre><code>{\n  &quot;current_user_url&quot;: &quot;https://api.github.com/user&quot;,\n  &quot;authorizations_url&quot;: &quot;https://api.github.com/authorizations&quot;,\n  // ...\n}\n</code></pre><p>从上面可以看到，如果想获取当前用户的信息，应该去访问<a href=\"api.github.com/user\">api.github.com/user</a>，然后就得到了下面结果。</p>\n<pre><code>{\n  &quot;message&quot;: &quot;Requires authentication&quot;,\n  &quot;documentation_url&quot;: &quot;https://developer.github.com/v3&quot;\n}  \n</code></pre><p>面代码表示，服务器给出了提示信息，以及文档的网址。         </p>\n"},{"title":"spring-boot更改ContextPath方法","date":"2017-09-28T06:03:23.000Z","_content":"在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","source":"_posts/sboot-change-contextpath.md","raw":"---\ntitle: spring-boot更改ContextPath方法\ndate: 2017-09-28 14:03:23\ncategories: spring-boot\ntags: change-contextpath-way\n---\n在spring-boot项目中，启动后容器的默认context-path为/,如：`http://localhost:8080/`，那么如何改成`http://localhost:8080/api`的形式呢？有以下几种方式：\n\n## 1. 在配置文件Properties & Yaml添加配置\n\n### 1.1 更改properties \n    /src/main/resources/application.properties\n    server.port=8080\n    server.contextPath=/mkyong\n\n### 1.2 更改yaml\n    /src/main/resources/application.properties\n    server:\n      port: 8080\n      contextPath: /mkyong\n      \n## 2、 自定义容器设置EmbeddedServletContainerCustomizer\n\n`CustomContainer.java`\n  \n    package com.mkyong;\n    \n    import org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\n    import org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\n    import org.springframework.stereotype.Component;\n    \n    @Component\n    public class CustomContainer implements EmbeddedServletContainerCustomizer {\n    \n    \t@Override\n    \tpublic void customize(ConfigurableEmbeddedServletContainer container) {\n    \n    \t\tcontainer.setPort(8080);\n    \t\tcontainer.setContextPath(\"/mkyong\");\n    \n    \t}\n    \n    }   \n    \n## 3. 命令行方式\n`java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar`\n    ","slug":"sboot-change-contextpath","published":1,"updated":"2017-11-14T08:30:11.237Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckoz002d8oraqk53zzw8","content":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n","site":{"data":{}},"excerpt":"","more":"<p>在spring-boot项目中，启动后容器的默认context-path为/,如：<code>http://localhost:8080/</code>，那么如何改成<code>http://localhost:8080/api</code>的形式呢？有以下几种方式：</p>\n<h2 id=\"1-在配置文件Properties-amp-Yaml添加配置\"><a href=\"#1-在配置文件Properties-amp-Yaml添加配置\" class=\"headerlink\" title=\"1. 在配置文件Properties &amp; Yaml添加配置\"></a>1. 在配置文件Properties &amp; Yaml添加配置</h2><h3 id=\"1-1-更改properties\"><a href=\"#1-1-更改properties\" class=\"headerlink\" title=\"1.1 更改properties\"></a>1.1 更改properties</h3><pre><code>/src/main/resources/application.properties\nserver.port=8080\nserver.contextPath=/mkyong\n</code></pre><h3 id=\"1-2-更改yaml\"><a href=\"#1-2-更改yaml\" class=\"headerlink\" title=\"1.2 更改yaml\"></a>1.2 更改yaml</h3><pre><code>/src/main/resources/application.properties\nserver:\n  port: 8080\n  contextPath: /mkyong\n</code></pre><h2 id=\"2、-自定义容器设置EmbeddedServletContainerCustomizer\"><a href=\"#2、-自定义容器设置EmbeddedServletContainerCustomizer\" class=\"headerlink\" title=\"2、 自定义容器设置EmbeddedServletContainerCustomizer\"></a>2、 自定义容器设置EmbeddedServletContainerCustomizer</h2><p><code>CustomContainer.java</code></p>\n<pre><code>package com.mkyong;\n\nimport org.springframework.boot.context.embedded.ConfigurableEmbeddedServletContainer;\nimport org.springframework.boot.context.embedded.EmbeddedServletContainerCustomizer;\nimport org.springframework.stereotype.Component;\n\n@Component\npublic class CustomContainer implements EmbeddedServletContainerCustomizer {\n\n    @Override\n    public void customize(ConfigurableEmbeddedServletContainer container) {\n\n        container.setPort(8080);\n        container.setContextPath(&quot;/mkyong&quot;);\n\n    }\n\n}   \n</code></pre><h2 id=\"3-命令行方式\"><a href=\"#3-命令行方式\" class=\"headerlink\" title=\"3. 命令行方式\"></a>3. 命令行方式</h2><p><code>java -jar -Dserver.contextPath=/mkyong spring-boot-example-1.0.jar</code></p>\n"},{"title":"spring-boot开发常见异常收录","date":"2017-09-28T16:31:25.000Z","_content":"\n## 1. 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n### 1.2　不传递依赖\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n### 1.3 在@SpringBootApplication中排除其注入\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n\n","source":"_posts/sboot-dev-error-show.md","raw":"---\ntitle: spring-boot开发常见异常收录\ndate: 2017-09-29 00:31:25\ncategories: spring-boot\ntags: sboot-often-error\n---\n\n## 1. 异常一：缺少jpa数据源配置\n异常描述：Cannot determine embedded database driver class for database type NONE\n\n原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。\n\n### 1.1 处理方法一\n在pom中剔除jpa注入\n\n     <dependency>\n         <groupId>com.ymu.spcselling</groupId>\n         <artifactId>spcselling-infrastructure</artifactId>\n         <exclusions>\n             <exclusion>\n                 <groupId>org.springframework.boot</groupId>\n                 <artifactId>spring-boot-starter-data-jpa</artifactId>\n             </exclusion>\n         </exclusions>\n     </dependency>\n     \n### 1.2　不传递依赖\n    <dependency>\n        <groupId>org.springframework.boot</groupId>\n        <artifactId>spring-boot-starter-data-jpa</artifactId>\n        <optional>true</optional><!--不在子应用中传递-->\n    </dependency>    \n\n    \n### 1.3 在@SpringBootApplication中排除其注入\n    @SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n\n\n","slug":"sboot-dev-error-show","published":1,"updated":"2017-11-14T08:30:11.241Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckp1002h8ora20cmhe3x","content":"<h2 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1. 异常一：缺少jpa数据源配置\"></a>1. 异常一：缺少jpa数据源配置</h2><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h3 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h3><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h3 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2　不传递依赖\"></a>1.2　不传递依赖</h3><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h3 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h3><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-异常一：缺少jpa数据源配置\"><a href=\"#1-异常一：缺少jpa数据源配置\" class=\"headerlink\" title=\"1. 异常一：缺少jpa数据源配置\"></a>1. 异常一：缺少jpa数据源配置</h2><p>异常描述：Cannot determine embedded database driver class for database type NONE</p>\n<p>原因：该异常在spring-boot应用启动时候报异常。是因为maven依赖中依赖如了jpa，所以系统会自动配置试图注入jpa数据源。但是如果没又配置数据源，则会报该异常。</p>\n<h3 id=\"1-1-处理方法一\"><a href=\"#1-1-处理方法一\" class=\"headerlink\" title=\"1.1 处理方法一\"></a>1.1 处理方法一</h3><p>在pom中剔除jpa注入</p>\n<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;com.ymu.spcselling&lt;/groupId&gt;\n    &lt;artifactId&gt;spcselling-infrastructure&lt;/artifactId&gt;\n    &lt;exclusions&gt;\n        &lt;exclusion&gt;\n            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n        &lt;/exclusion&gt;\n    &lt;/exclusions&gt;\n&lt;/dependency&gt;\n</code></pre><h3 id=\"1-2-不传递依赖\"><a href=\"#1-2-不传递依赖\" class=\"headerlink\" title=\"1.2　不传递依赖\"></a>1.2　不传递依赖</h3><pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;\n    &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;\n    &lt;optional&gt;true&lt;/optional&gt;&lt;!--不在子应用中传递--&gt;\n&lt;/dependency&gt;    \n</code></pre><h3 id=\"1-3-在-SpringBootApplication中排除其注入\"><a href=\"#1-3-在-SpringBootApplication中排除其注入\" class=\"headerlink\" title=\"1.3 在@SpringBootApplication中排除其注入\"></a>1.3 在@SpringBootApplication中排除其注入</h3><pre><code>@SpringBootApplication(exclude={DataSourceAutoConfiguration.class,HibernateJpaAutoConfiguration.class})\n</code></pre>"},{"title":"spring-cloud-feign在使用中遇到的一些问题","date":"2017-09-24T13:53:46.000Z","_content":"\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","source":"_posts/scloud-feign-anyquestion.md","raw":"---\ntitle: spring-cloud-feign在使用中遇到的一些问题\ndate: 2017-09-24 21:53:46\ncategories: spring-cloud\ntags: feign使用常见问题\n---\n\n## 1. feign的接口继承特性\n\n### 1.1 暴露的接口\n    package service.sys.common.api;\n    \n    import com.ymu.spcselling.infrastructure.constants.SpcsConstants;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.springframework.validation.annotation.Validated;\n    import org.springframework.web.bind.annotation.*;\n    import service.sys.common.vo.req.VIdGenReq;\n    \n    /**\n     * 分布式id生成服务。\n     */\n    @RequestMapping(SpcsConstants.API_VERSION + \"/id\")\n    public interface IdGenerateApi {\n    \n        /**\n         * 生成分布式id\n         * @param vIdGenReq 请求对象。body体\n         * @return 生成的系统全局唯一id\n         *\n         * @api {post} /v1/id/gen 生成分布式id\n         * @apiVersion 1.0.0\n         * @apiName genId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 通过数据中心id，机器id生成long型唯一id\n         *\n         * @apiParam {long} dataCenterId 数据中心id,0-31。\n         * @apiParam {long} workerId 机器id，0-31。\n         *\n         * @apiParamExample {json} Request-Example:\n         *     Request Headers\n         *         Content-Type:application/json\n         *     body:\n         *     {\n         *       \"dataCenterId\": 0,\n         *       \"workerId:\" 0\n         *     }\n         *\n         * @apiExample 请求例子:\n         * curl -i http://localhost/user/4711\n         *\n         * @apiSuccess {long}   id      生成的id\n         *\n         * @apiError NoAccessRight 认证不通过\n         * @apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest url\n         *\n         */\n        @PostMapping(\"/gen\")\n        long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n    \n        /**\n         *\n         * 解析分布式id\n         * @param id\n         * @return\n         *\n         * @api {post} /v1/id/expId  解析分布式id\n         * @apiVersion 1.0.0\n         * @apiName expId\n         * @apiGroup ID\n         * @apiPermission admin\n         *\n         * @apiDescription 把id解析成ID对象\n         *\n         * @apiParam {long} id 接口生成的id，必传。\n         *\n         * @apiExample 请求例子:\n         *  http://localhost/v1/id/expId?id=352608540609069079\n         *\n         * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n         * @apiSuccess {long}   dataCenterId     数据中心id\n         * @apiSuccess {long}   workerId     节点机器id\n         * @apiSuccess {long}   sequence     序列号\n         *\n         * @apiError NoAccessRight 认证不通过\n         *  //@apiError UserNotFound   The <code>id</code> of the User was not found.\n         *\n         * @apiErrorExample 响应例子:\n         *     HTTP/1.1 401 Not Authenticated\n         *     {\n         *       \"error\": \"NoAccessRight\"\n         *     }\n         *\n         * @apiSampleRequest http://localhost/v1/id/expId\n         *\n         */\n        @GetMapping(\"/expId\")\n        ID expId(@RequestParam(value = \"id\") long id);\n    }\n\n### 1.2 接口的实现\n    package service.sys.common.controller;\n    \n    import com.ymu.spcselling.infrastructure.base.AbstractBaseController;\n    import com.ymu.spcselling.infrastructure.idgenerator.ID;\n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.cloud.context.config.annotation.RefreshScope;\n    import org.springframework.web.bind.WebDataBinder;\n    import org.springframework.web.bind.annotation.RequestBody;\n    import org.springframework.web.bind.annotation.RestController;\n    import service.sys.common.api.IdGenerateApi;\n    import service.sys.common.service.local.IdService;\n    import service.sys.common.vo.req.VIdGenReq;\n    import service.sys.common.vo.req.VIdGenReqValidator;\n    \n    @RefreshScope\n    @RestController\n    public class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n    \n        private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n    \n        @Override\n        protected void initBinder(WebDataBinder binder) {\n            binder.addValidators(new VIdGenReqValidator());\n        }\n    \n    \n        @Autowired\n        private IdService idService;\n    \n        @Override\n        public long genId(@RequestBody VIdGenReq vIdGenReq) {\n            long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n            LOGGER.debug(\"genId:\" + id);\n            return id;\n        }\n    \n        @Override\n        public ID expId(long id) {\n            ID ID = idService.expId(id);\n            LOGGER.debug(\"ID=\", ID.toString());\n            return ID;\n        }\n    \n    \n    }\n    \n注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。\n类似的，还有一些其他的注解也要加上。\n> 常见的在实现中要加上的注解有：\n> - @RequestBody\n> - @Validated\n> - @RequestHeader \n> - @RequestParam    \n","slug":"scloud-feign-anyquestion","published":1,"updated":"2017-11-14T08:30:11.245Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckp3002j8ora508j4qdo","content":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-feign的接口继承特性\"><a href=\"#1-feign的接口继承特性\" class=\"headerlink\" title=\"1. feign的接口继承特性\"></a>1. feign的接口继承特性</h2><h3 id=\"1-1-暴露的接口\"><a href=\"#1-1-暴露的接口\" class=\"headerlink\" title=\"1.1 暴露的接口\"></a>1.1 暴露的接口</h3><pre><code>package service.sys.common.api;\n\nimport com.ymu.spcselling.infrastructure.constants.SpcsConstants;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.springframework.validation.annotation.Validated;\nimport org.springframework.web.bind.annotation.*;\nimport service.sys.common.vo.req.VIdGenReq;\n\n/**\n * 分布式id生成服务。\n */\n@RequestMapping(SpcsConstants.API_VERSION + &quot;/id&quot;)\npublic interface IdGenerateApi {\n\n    /**\n     * 生成分布式id\n     * @param vIdGenReq 请求对象。body体\n     * @return 生成的系统全局唯一id\n     *\n     * @api {post} /v1/id/gen 生成分布式id\n     * @apiVersion 1.0.0\n     * @apiName genId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 通过数据中心id，机器id生成long型唯一id\n     *\n     * @apiParam {long} dataCenterId 数据中心id,0-31。\n     * @apiParam {long} workerId 机器id，0-31。\n     *\n     * @apiParamExample {json} Request-Example:\n     *     Request Headers\n     *         Content-Type:application/json\n     *     body:\n     *     {\n     *       &quot;dataCenterId&quot;: 0,\n     *       &quot;workerId:&quot; 0\n     *     }\n     *\n     * @apiExample 请求例子:\n     * curl -i http://localhost/user/4711\n     *\n     * @apiSuccess {long}   id      生成的id\n     *\n     * @apiError NoAccessRight 认证不通过\n     * @apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest url\n     *\n     */\n    @PostMapping(&quot;/gen&quot;)\n    long genId(@RequestBody @Validated VIdGenReq vIdGenReq);\n\n    /**\n     *\n     * 解析分布式id\n     * @param id\n     * @return\n     *\n     * @api {post} /v1/id/expId  解析分布式id\n     * @apiVersion 1.0.0\n     * @apiName expId\n     * @apiGroup ID\n     * @apiPermission admin\n     *\n     * @apiDescription 把id解析成ID对象\n     *\n     * @apiParam {long} id 接口生成的id，必传。\n     *\n     * @apiExample 请求例子:\n     *  http://localhost/v1/id/expId?id=352608540609069079\n     *\n     * @apiSuccess {long}   timeStamp     时间戳。41位的时间序列\n     * @apiSuccess {long}   dataCenterId     数据中心id\n     * @apiSuccess {long}   workerId     节点机器id\n     * @apiSuccess {long}   sequence     序列号\n     *\n     * @apiError NoAccessRight 认证不通过\n     *  //@apiError UserNotFound   The &lt;code&gt;id&lt;/code&gt; of the User was not found.\n     *\n     * @apiErrorExample 响应例子:\n     *     HTTP/1.1 401 Not Authenticated\n     *     {\n     *       &quot;error&quot;: &quot;NoAccessRight&quot;\n     *     }\n     *\n     * @apiSampleRequest http://localhost/v1/id/expId\n     *\n     */\n    @GetMapping(&quot;/expId&quot;)\n    ID expId(@RequestParam(value = &quot;id&quot;) long id);\n}\n</code></pre><h3 id=\"1-2-接口的实现\"><a href=\"#1-2-接口的实现\" class=\"headerlink\" title=\"1.2 接口的实现\"></a>1.2 接口的实现</h3><pre><code>package service.sys.common.controller;\n\nimport com.ymu.spcselling.infrastructure.base.AbstractBaseController;\nimport com.ymu.spcselling.infrastructure.idgenerator.ID;\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.cloud.context.config.annotation.RefreshScope;\nimport org.springframework.web.bind.WebDataBinder;\nimport org.springframework.web.bind.annotation.RequestBody;\nimport org.springframework.web.bind.annotation.RestController;\nimport service.sys.common.api.IdGenerateApi;\nimport service.sys.common.service.local.IdService;\nimport service.sys.common.vo.req.VIdGenReq;\nimport service.sys.common.vo.req.VIdGenReqValidator;\n\n@RefreshScope\n@RestController\npublic class IdGenerateController extends AbstractBaseController implements IdGenerateApi {\n\n    private static final Logger LOGGER = LogManager.getLogger(SendEmailController.class);\n\n    @Override\n    protected void initBinder(WebDataBinder binder) {\n        binder.addValidators(new VIdGenReqValidator());\n    }\n\n\n    @Autowired\n    private IdService idService;\n\n    @Override\n    public long genId(@RequestBody VIdGenReq vIdGenReq) {\n        long id = idService.genId(vIdGenReq.getDataCenterId(), vIdGenReq.getWorkerId());\n        LOGGER.debug(&quot;genId:&quot; + id);\n        return id;\n    }\n\n    @Override\n    public ID expId(long id) {\n        ID ID = idService.expId(id);\n        LOGGER.debug(&quot;ID=&quot;, ID.toString());\n        return ID;\n    }\n\n\n}\n</code></pre><p>注意：在gen()接口方法中，虽然加了mvn的参数注解@RequestBody @Validated，但是在其实现中也要加上，否则这些注解功能将失效。<br>类似的，还有一些其他的注解也要加上。</p>\n<blockquote>\n<p>常见的在实现中要加上的注解有：</p>\n<ul>\n<li>@RequestBody</li>\n<li>@Validated</li>\n<li>@RequestHeader </li>\n<li>@RequestParam    </li>\n</ul>\n</blockquote>\n"},{"title":"spring-cloud-zuul网关统一异常处理","date":"2017-09-23T09:48:05.000Z","_content":"","source":"_posts/scloud-zuul-exception.md","raw":"---\ntitle: spring-cloud-zuul网关统一异常处理\ndate: 2017-09-23 17:48:05\ncategories: spring-cloud\ntags: zuul-exception\n---\n","slug":"scloud-zuul-exception","published":1,"updated":"2017-11-14T08:30:11.249Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckp5002m8ora3zi9w285","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"scloud-zuul-filters网关过滤","date":"2017-10-11T08:56:22.000Z","_content":"在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","source":"_posts/scloud-zuul-filters.md","raw":"---\ntitle: scloud-zuul-filters网关过滤\ndate: 2017-10-11 16:56:22\ncategories: spring-cloud\ntags: zuul-filters\n---\n在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。\n为了达到这个目的，因此需要在网关层做拦截，过滤。\n\n","slug":"scloud-zuul-filters","published":1,"updated":"2017-11-14T08:30:11.253Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckp6002q8oralzqrcj32","content":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一个微服务系统中，多个服务可能都需要做一些同样的非业务层面的鉴权，校验等，如果分散在各个服务中做，将加大维护难度。因此，放到统一网关中做同样的鉴权处理，简化维护。<br>为了达到这个目的，因此需要在网关层做拦截，过滤。</p>\n"},{"title":"shadowsocks-go代理服务器搭建","date":"2017-11-11T09:05:31.000Z","_content":"\n这是用来干嘛的，你懂的。\n\n网址：\n\n[shadowsocks](https://github.com/shadowsocks)\n\n[sadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)\n\n## 服务端\n\n1. 首先，买个国外的服务器再说吧……\n   \n2. 在服务器安装golang环境。\n    安装包：{% asset_link go1.9.2.linux-amd64.tar.gz go1.9.2 %}\n    \n    这里不做介绍……\n    \n3. 在服务器安装git环境。\n\n    这里不做介绍……\n    \n4. 下载服务端代码shadowsocks-go.\n\n        # on server\n        go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n    \n    golang环境会自动编译可执行代码到${GOPATH}/bin  \n      \n5.  执行启动\n\n- *创建配置文件*：\n`touch /server/shadowsocks/shadowsocks.json`\n- *编辑shadowsocks.json*：\n    \n        {\t \n            \"server\":\"30.12.6.2\",\n            \"server_port\":8388,\n            \"local_port\":1080,\n            \"password\":\"123456\",\n            \"method\": \"aes-256-cfb\",\n            \"timeout\":600\n        }\n\n> 说明：       \n`server`:服务器ip地址；\n`server_port`:服务器端口；\n`local_port:`客户端代理端口；\n`method`:加密方式； \n\n- *启动*:\n\n\n    shadowsocks-server -c /server/shadowsocks/shadowsocks.json > /server/shadowsocks/log &.   \n    \n> 说明：\n`-c` 指定配置文件。 \n`log`记录日志。\n`&.` 后台执行    \n\n- *查看是否启动*：\n\n        [root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\n        tcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n\n\n---\n\n## 客户端\n\n### windows系统\n直接下载客户端。[网址](https://github.com/shadowsocks/shadowsocks-windows)\n安装包：{% asset_link Shadowsocks-4.0.6.zip Shadowsocks-win %}\n双击打开：\n{% asset_img a.png %}\n\n把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。\n\n### ubuntu系统    \n\n- go客户端：\n`go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local`\n由于被墙，客户端下载不了。\n所以要在服务端执行，然后再把可执行二进制文件下拉到本地。\n\n*配置客户端文件*\n创建文件：shadowsocks-local.json\n编辑：\n    \n    {\n    \t\"local_port\": 1081,\n    \t\"server_password\": [\n    \t\t[\"127.0.0.1:8387\", \"foobar\"],\n    \t\t[\"127.0.0.1:8388\", \"barfoo\", \"aes-128-cfb\"]\n    \t]\n    }\n\n可以配置多个服务器，单个服务器，则去掉一个。\n\n启动：类似服务端，用`-c`指定配置文件。    \n\n- qt5客户端：\n[安装网址](https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)  \n\n\n### 修改浏览器代理\n> SOCKS5 127.0.0.1:local_port\n\n如果可以，在chrome中可以安装代理设置插件       \n{% asset_img b.png %}\n\n然后启动，试下访问：[google](https://www.google.com)\n\n\n","source":"_posts/shadowsocks-go.md","raw":"---\ntitle: shadowsocks-go代理服务器搭建\ndate: 2017-11-11 17:05:31\ncategories: shadowsocks\ntags: shadowsocks-go\n---\n\n这是用来干嘛的，你懂的。\n\n网址：\n\n[shadowsocks](https://github.com/shadowsocks)\n\n[sadowsocks-go](https://github.com/shadowsocks/shadowsocks-go)\n\n## 服务端\n\n1. 首先，买个国外的服务器再说吧……\n   \n2. 在服务器安装golang环境。\n    安装包：{% asset_link go1.9.2.linux-amd64.tar.gz go1.9.2 %}\n    \n    这里不做介绍……\n    \n3. 在服务器安装git环境。\n\n    这里不做介绍……\n    \n4. 下载服务端代码shadowsocks-go.\n\n        # on server\n        go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n    \n    golang环境会自动编译可执行代码到${GOPATH}/bin  \n      \n5.  执行启动\n\n- *创建配置文件*：\n`touch /server/shadowsocks/shadowsocks.json`\n- *编辑shadowsocks.json*：\n    \n        {\t \n            \"server\":\"30.12.6.2\",\n            \"server_port\":8388,\n            \"local_port\":1080,\n            \"password\":\"123456\",\n            \"method\": \"aes-256-cfb\",\n            \"timeout\":600\n        }\n\n> 说明：       \n`server`:服务器ip地址；\n`server_port`:服务器端口；\n`local_port:`客户端代理端口；\n`method`:加密方式； \n\n- *启动*:\n\n\n    shadowsocks-server -c /server/shadowsocks/shadowsocks.json > /server/shadowsocks/log &.   \n    \n> 说明：\n`-c` 指定配置文件。 \n`log`记录日志。\n`&.` 后台执行    \n\n- *查看是否启动*：\n\n        [root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\n        tcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n\n\n---\n\n## 客户端\n\n### windows系统\n直接下载客户端。[网址](https://github.com/shadowsocks/shadowsocks-windows)\n安装包：{% asset_link Shadowsocks-4.0.6.zip Shadowsocks-win %}\n双击打开：\n{% asset_img a.png %}\n\n把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。\n\n### ubuntu系统    \n\n- go客户端：\n`go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local`\n由于被墙，客户端下载不了。\n所以要在服务端执行，然后再把可执行二进制文件下拉到本地。\n\n*配置客户端文件*\n创建文件：shadowsocks-local.json\n编辑：\n    \n    {\n    \t\"local_port\": 1081,\n    \t\"server_password\": [\n    \t\t[\"127.0.0.1:8387\", \"foobar\"],\n    \t\t[\"127.0.0.1:8388\", \"barfoo\", \"aes-128-cfb\"]\n    \t]\n    }\n\n可以配置多个服务器，单个服务器，则去掉一个。\n\n启动：类似服务端，用`-c`指定配置文件。    \n\n- qt5客户端：\n[安装网址](https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97)  \n\n\n### 修改浏览器代理\n> SOCKS5 127.0.0.1:local_port\n\n如果可以，在chrome中可以安装代理设置插件       \n{% asset_img b.png %}\n\n然后启动，试下访问：[google](https://www.google.com)\n\n\n","slug":"shadowsocks-go","published":1,"updated":"2017-11-14T08:30:11.261Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckp8002s8orautizmcpv","content":"<p>这是用来干嘛的，你懂的。</p>\n<p>网址：</p>\n<p><a href=\"https://github.com/shadowsocks\" target=\"_blank\" rel=\"external\">shadowsocks</a></p>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"external\">sadowsocks-go</a></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><ol>\n<li><p>首先，买个国外的服务器再说吧……</p>\n</li>\n<li><p>在服务器安装golang环境。<br> 安装包：<a href=\"/2017/11/11/shadowsocks-go/go1.9.2.linux-amd64.tar.gz\" title=\"go1.9.2\">go1.9.2</a></p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>在服务器安装git环境。</p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>下载服务端代码shadowsocks-go.</p>\n<pre><code># on server\ngo get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n</code></pre><p> golang环境会自动编译可执行代码到${GOPATH}/bin  </p>\n</li>\n<li><p>执行启动</p>\n</li>\n</ol>\n<ul>\n<li><em>创建配置文件</em>：<br><code>touch /server/shadowsocks/shadowsocks.json</code></li>\n<li><p><em>编辑shadowsocks.json</em>：</p>\n<pre><code>{     \n    &quot;server&quot;:&quot;30.12.6.2&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;method&quot;: &quot;aes-256-cfb&quot;,\n    &quot;timeout&quot;:600\n}\n</code></pre></li>\n</ul>\n<blockquote>\n<p>说明：<br><code>server</code>:服务器ip地址；<br><code>server_port</code>:服务器端口；<br><code>local_port:</code>客户端代理端口；<br><code>method</code>:加密方式； </p>\n</blockquote>\n<ul>\n<li><em>启动</em>:</li>\n</ul>\n<pre><code>shadowsocks-server -c /server/shadowsocks/shadowsocks.json &gt; /server/shadowsocks/log &amp;.   \n</code></pre><blockquote>\n<p>说明：<br><code>-c</code> 指定配置文件。<br><code>log</code>记录日志。<br><code>&amp;.</code> 后台执行    </p>\n</blockquote>\n<ul>\n<li><p><em>查看是否启动</em>：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\ntcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"windows系统\"><a href=\"#windows系统\" class=\"headerlink\" title=\"windows系统\"></a>windows系统</h3><p>直接下载客户端。<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"external\">网址</a><br>安装包：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks-4.0.6.zip\" title=\"Shadowsocks-win\">Shadowsocks-win</a><br>双击打开：<br><img src=\"/2017/11/11/shadowsocks-go/a.png\"></p>\n<p>把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。</p>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><ul>\n<li>go客户端：<br><code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</code><br>由于被墙，客户端下载不了。<br>所以要在服务端执行，然后再把可执行二进制文件下拉到本地。</li>\n</ul>\n<p><em>配置客户端文件</em><br>创建文件：shadowsocks-local.json<br>编辑：</p>\n<pre><code>{\n    &quot;local_port&quot;: 1081,\n    &quot;server_password&quot;: [\n        [&quot;127.0.0.1:8387&quot;, &quot;foobar&quot;],\n        [&quot;127.0.0.1:8388&quot;, &quot;barfoo&quot;, &quot;aes-128-cfb&quot;]\n    ]\n}\n</code></pre><p>可以配置多个服务器，单个服务器，则去掉一个。</p>\n<p>启动：类似服务端，用<code>-c</code>指定配置文件。    </p>\n<ul>\n<li>qt5客户端：<br><a href=\"https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"external\">安装网址</a>  </li>\n</ul>\n<h3 id=\"修改浏览器代理\"><a href=\"#修改浏览器代理\" class=\"headerlink\" title=\"修改浏览器代理\"></a>修改浏览器代理</h3><blockquote>\n<p>SOCKS5 127.0.0.1:local_port</p>\n</blockquote>\n<p>如果可以，在chrome中可以安装代理设置插件<br><img src=\"/2017/11/11/shadowsocks-go/b.png\"></p>\n<p>然后启动，试下访问：<a href=\"https://www.google.com\" target=\"_blank\" rel=\"external\">google</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>这是用来干嘛的，你懂的。</p>\n<p>网址：</p>\n<p><a href=\"https://github.com/shadowsocks\" target=\"_blank\" rel=\"external\">shadowsocks</a></p>\n<p><a href=\"https://github.com/shadowsocks/shadowsocks-go\" target=\"_blank\" rel=\"external\">sadowsocks-go</a></p>\n<h2 id=\"服务端\"><a href=\"#服务端\" class=\"headerlink\" title=\"服务端\"></a>服务端</h2><ol>\n<li><p>首先，买个国外的服务器再说吧……</p>\n</li>\n<li><p>在服务器安装golang环境。<br> 安装包：<a href=\"/2017/11/11/shadowsocks-go/go1.9.2.linux-amd64.tar.gz\" title=\"go1.9.2\">go1.9.2</a></p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>在服务器安装git环境。</p>\n<p> 这里不做介绍……</p>\n</li>\n<li><p>下载服务端代码shadowsocks-go.</p>\n<pre><code># on server\ngo get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-server  \n</code></pre><p> golang环境会自动编译可执行代码到${GOPATH}/bin  </p>\n</li>\n<li><p>执行启动</p>\n</li>\n</ol>\n<ul>\n<li><em>创建配置文件</em>：<br><code>touch /server/shadowsocks/shadowsocks.json</code></li>\n<li><p><em>编辑shadowsocks.json</em>：</p>\n<pre><code>{     \n    &quot;server&quot;:&quot;30.12.6.2&quot;,\n    &quot;server_port&quot;:8388,\n    &quot;local_port&quot;:1080,\n    &quot;password&quot;:&quot;123456&quot;,\n    &quot;method&quot;: &quot;aes-256-cfb&quot;,\n    &quot;timeout&quot;:600\n}\n</code></pre></li>\n</ul>\n<blockquote>\n<p>说明：<br><code>server</code>:服务器ip地址；<br><code>server_port</code>:服务器端口；<br><code>local_port:</code>客户端代理端口；<br><code>method</code>:加密方式； </p>\n</blockquote>\n<ul>\n<li><em>启动</em>:</li>\n</ul>\n<pre><code>shadowsocks-server -c /server/shadowsocks/shadowsocks.json &gt; /server/shadowsocks/log &amp;.   \n</code></pre><blockquote>\n<p>说明：<br><code>-c</code> 指定配置文件。<br><code>log</code>记录日志。<br><code>&amp;.</code> 后台执行    </p>\n</blockquote>\n<ul>\n<li><p><em>查看是否启动</em>：</p>\n<pre><code>[root@iZj6ca50pk1lwxqo14jss8Z ~]# netstat -lnp|grep 8388\ntcp6       0      0 :::8388                 :::*                    LISTEN      25719/shadowsocks-s \n</code></pre></li>\n</ul>\n<hr>\n<h2 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h2><h3 id=\"windows系统\"><a href=\"#windows系统\" class=\"headerlink\" title=\"windows系统\"></a>windows系统</h3><p>直接下载客户端。<a href=\"https://github.com/shadowsocks/shadowsocks-windows\" target=\"_blank\" rel=\"external\">网址</a><br>安装包：<a href=\"/2017/11/11/shadowsocks-go/Shadowsocks-4.0.6.zip\" title=\"Shadowsocks-win\">Shadowsocks-win</a><br>双击打开：<br><img src=\"/2017/11/11/shadowsocks-go/a.png\"></p>\n<p>把服务器ip地址，还有设定的密码天上，确定即可。注意加密方法要和服务端设定的一致。</p>\n<h3 id=\"ubuntu系统\"><a href=\"#ubuntu系统\" class=\"headerlink\" title=\"ubuntu系统\"></a>ubuntu系统</h3><ul>\n<li>go客户端：<br><code>go get github.com/shadowsocks/shadowsocks-go/cmd/shadowsocks-local</code><br>由于被墙，客户端下载不了。<br>所以要在服务端执行，然后再把可执行二进制文件下拉到本地。</li>\n</ul>\n<p><em>配置客户端文件</em><br>创建文件：shadowsocks-local.json<br>编辑：</p>\n<pre><code>{\n    &quot;local_port&quot;: 1081,\n    &quot;server_password&quot;: [\n        [&quot;127.0.0.1:8387&quot;, &quot;foobar&quot;],\n        [&quot;127.0.0.1:8388&quot;, &quot;barfoo&quot;, &quot;aes-128-cfb&quot;]\n    ]\n}\n</code></pre><p>可以配置多个服务器，单个服务器，则去掉一个。</p>\n<p>启动：类似服务端，用<code>-c</code>指定配置文件。    </p>\n<ul>\n<li>qt5客户端：<br><a href=\"https://github.com/shadowsocks/shadowsocks-qt5/wiki/%E5%AE%89%E8%A3%85%E6%8C%87%E5%8D%97\" target=\"_blank\" rel=\"external\">安装网址</a>  </li>\n</ul>\n<h3 id=\"修改浏览器代理\"><a href=\"#修改浏览器代理\" class=\"headerlink\" title=\"修改浏览器代理\"></a>修改浏览器代理</h3><blockquote>\n<p>SOCKS5 127.0.0.1:local_port</p>\n</blockquote>\n<p>如果可以，在chrome中可以安装代理设置插件<br><img src=\"/2017/11/11/shadowsocks-go/b.png\"></p>\n<p>然后启动，试下访问：<a href=\"https://www.google.com\" target=\"_blank\" rel=\"external\">google</a></p>\n"},{"title":"微服务实践思考","date":"2017-09-26T02:14:45.000Z","_content":"","source":"_posts/microservice-think.md","raw":"---\ntitle: 微服务实践思考\ndate: 2017-09-26 10:14:45\ncategories: micro-service\ntags: 微服务实践总结\n---\n","slug":"microservice-think","published":1,"updated":"2017-11-14T08:30:11.213Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckpa002w8orary0im9k5","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"spring-cloud-zuul网关入门","date":"2017-10-11T07:42:53.000Z","_content":"## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","source":"_posts/scloud-zuul-start.md","raw":"---\ntitle: spring-cloud-zuul网关入门\ndate: 2017-10-11 15:42:53\ncategories: spring-cloud\ntags: zuul-start\n---\n## 1. Zuul简介\n路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。\n\n能做什么：\n> - Authentication\n- Insights\n- Stress Testing\n- Canary Testing\n- Dynamic Routing\n- Service Migration\n- Load Shedding\n- Security\n- Static Response handling\n- Active/Active traffic management\n\n引入网关后，整个微服务架构演变为:\n\n{% asset_img a.png %} \n\n## 2. 使用Zuul\n\n### 2.1 引入Zuul组件\n\n    <dependencies>\n        <!--引入网关组件-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-zuul</artifactId>\n        </dependency>\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-eureka</artifactId>\n        </dependency>\n    \n        <!--读取配置中心-->\n        <dependency>\n            <groupId>org.springframework.cloud</groupId>\n            <artifactId>spring-cloud-starter-config</artifactId>\n        </dependency>\n    </dependencies>\n\n### 2.2 开启Zuul\n    \n    /**\n     * 使用@EnableZuulProxy注解激活zuul。\n     * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n     */\n    @EnableZuulProxy\n    @SpringBootApplication\n    public class SpcsellingApiGatewayApp {\n    \n    \tpublic static void main(String[] args) {\n    \t\tnew SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    \t}\n    }\t\n    \n### 2.3 添加基本配置(.yml )   \n\n    spring:\n      application:\n        name: api-gateway\n    \n    ---\n    eureka:\n      instance:\n        hostname: api.spcs.com #域名\n      client:\n        service-url:\n           defaultZone: http://localhost:1111/eureka/ #注册发现服务\n    \n    ---\n    #从配置中心读取配置\n    spring:\n      cloud:\n        config:\n          name: api-gateway\n          profile: dev\n          label: master\n          fail-fast: true\n          discovery:\n            enabled: true\n            service-id: config-server\n          username: admin\n          password: 123456\n          \n    #配置路由\n    zuul:\n      routes:\n        api-a:\n          path: /a/**\n          stripPrefix: true\n          service-id: service-a #服务id  \n        api-b:\n          path: /b/**\n          stripPrefix: true\n          service-id: service-b #服务id\n          \n首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。\n\n## 3. 具体配置使用\n\n### 3.1 负载均衡访问服务\n\n*application.yml.*\n \n    zuul:\n      routes:\n        users:\n          path: /myusers/**\n          serviceId: users\n    \n    # 关闭ribbon负载均衡器\n    ribbon:\n      eureka:\n        enabled: false\n    \n    #user服务\n    users: \n      ribbon:\n        listOfServers: example.com,google.com   #多个实例      ","slug":"scloud-zuul-start","published":1,"updated":"2017-11-14T08:30:11.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckpc002y8ora49vh7lgh","content":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"1-Zuul简介\"><a href=\"#1-Zuul简介\" class=\"headerlink\" title=\"1. Zuul简介\"></a>1. Zuul简介</h2><p>路由是微服务架构的不可或缺的一部分。例如：”/” 可能映射到你应用主页，/api/users映射到用户服务，/api/shop映射到购物服务。Zuul。Zuul是Netflix出品的一个基于JVM路由和服务端的负载均衡器。</p>\n<p>能做什么：</p>\n<blockquote>\n<ul>\n<li>Authentication</li>\n<li>Insights</li>\n<li>Stress Testing</li>\n<li>Canary Testing</li>\n<li>Dynamic Routing</li>\n<li>Service Migration</li>\n<li>Load Shedding</li>\n<li>Security</li>\n<li>Static Response handling</li>\n<li>Active/Active traffic management</li>\n</ul>\n</blockquote>\n<p>引入网关后，整个微服务架构演变为:</p>\n<img src=\"/2017/10/11/scloud-zuul-start/a.png\"> \n<h2 id=\"2-使用Zuul\"><a href=\"#2-使用Zuul\" class=\"headerlink\" title=\"2. 使用Zuul\"></a>2. 使用Zuul</h2><h3 id=\"2-1-引入Zuul组件\"><a href=\"#2-1-引入Zuul组件\" class=\"headerlink\" title=\"2.1 引入Zuul组件\"></a>2.1 引入Zuul组件</h3><pre><code>&lt;dependencies&gt;\n    &lt;!--引入网关组件--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-zuul&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-eureka&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n\n    &lt;!--读取配置中心--&gt;\n    &lt;dependency&gt;\n        &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;\n        &lt;artifactId&gt;spring-cloud-starter-config&lt;/artifactId&gt;\n    &lt;/dependency&gt;\n&lt;/dependencies&gt;\n</code></pre><h3 id=\"2-2-开启Zuul\"><a href=\"#2-2-开启Zuul\" class=\"headerlink\" title=\"2.2 开启Zuul\"></a>2.2 开启Zuul</h3><pre><code>/**\n * 使用@EnableZuulProxy注解激活zuul。\n * 跟进该注解可以看到该注解整合了@EnableCircuitBreaker、@EnableDiscoveryClient，是个组合注解，目的是简化配置。\n */\n@EnableZuulProxy\n@SpringBootApplication\npublic class SpcsellingApiGatewayApp {\n\n    public static void main(String[] args) {\n        new SpringApplicationBuilder(SpcsellingApiGatewayApp.class).run(args);\n    }\n}    \n</code></pre><h3 id=\"2-3-添加基本配置-yml\"><a href=\"#2-3-添加基本配置-yml\" class=\"headerlink\" title=\"2.3 添加基本配置(.yml )\"></a>2.3 添加基本配置(.yml )</h3><pre><code>spring:\n  application:\n    name: api-gateway\n\n---\neureka:\n  instance:\n    hostname: api.spcs.com #域名\n  client:\n    service-url:\n       defaultZone: http://localhost:1111/eureka/ #注册发现服务\n\n---\n#从配置中心读取配置\nspring:\n  cloud:\n    config:\n      name: api-gateway\n      profile: dev\n      label: master\n      fail-fast: true\n      discovery:\n        enabled: true\n        service-id: config-server\n      username: admin\n      password: 123456\n\n#配置路由\nzuul:\n  routes:\n    api-a:\n      path: /a/**\n      stripPrefix: true\n      service-id: service-a #服务id  \n    api-b:\n      path: /b/**\n      stripPrefix: true\n      service-id: service-b #服务id\n</code></pre><p>首先向eureka注册自己，服务名称为api-gateway；请求路由示例：api.spcs.com/a/users/1 将路由到服务service-a,为：localhost:8001/users/1。b服务的路由也类似。</p>\n<h2 id=\"3-具体配置使用\"><a href=\"#3-具体配置使用\" class=\"headerlink\" title=\"3. 具体配置使用\"></a>3. 具体配置使用</h2><h3 id=\"3-1-负载均衡访问服务\"><a href=\"#3-1-负载均衡访问服务\" class=\"headerlink\" title=\"3.1 负载均衡访问服务\"></a>3.1 负载均衡访问服务</h3><p><em>application.yml.</em></p>\n<pre><code>zuul:\n  routes:\n    users:\n      path: /myusers/**\n      serviceId: users\n\n# 关闭ribbon负载均衡器\nribbon:\n  eureka:\n    enabled: false\n\n#user服务\nusers: \n  ribbon:\n    listOfServers: example.com,google.com   #多个实例      \n</code></pre>"},{"title":"spring-boot异步调用","date":"2017-11-10T08:22:18.000Z","_content":"\n在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。\n在spring-boot中，通过简单的注解 `@Async` 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：\n\n参考：\n- http://blog.csdn.net/blueheart20/article/details/44648667\n- http://blog.csdn.net/liuchuanhong1/article/details/64132520\n\n## 1. 启用异步操作功能\n很简单，只需要在主类中添加注解`@EnableAsync` 即可。\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.scheduling.annotation.EnableAsync;\n    \n    @EnableAsync\n    @SpringBootApplication\n    public class SpringBootAsyncApplication {\n    \n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(SpringBootAsyncApplication.class, args);\n    \t}\n    }\n\n## 2. 定义处理类，并添加方法\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.scheduling.annotation.Async;\n    import org.springframework.scheduling.annotation.AsyncResult;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Random;\n    import java.util.concurrent.Future;\n    \n    @Component\n    public class Task {\n    \n        public static Random random =new Random();\n    \n        @Async\n        public void webTest() throws Exception {\n            System.out.println(\"开始测试异步\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成测试异步，耗时：\" + (end - start) + \"毫秒\");\n        }\n    \n        @Async\n        public Future<String> doTaskOne() throws Exception {\n            System.out.println(\"开始做任务一\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务一，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务一完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskTwo() throws Exception {\n            System.out.println(\"开始做任务二\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务二，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务二完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskThree() throws Exception {\n            System.out.println(\"开始做任务三\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务三，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务三完成\");\n        }\n    }\n\n只需要在方法上添加注解`@Async`。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。\n\n## 3. 测试\n\n    package com.ymu.demo.async;\n    \n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import java.util.concurrent.Future;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class SpringBootAsyncApplicationTests {\n    \n        @Autowired\n        private Task task;\n    \n        @Test\n        public void contextLoads() {\n    \n            System.out.println(\"===============load context\");\n        }\n    \n        @Test\n        public void test() throws Exception {\n    \n            long start = System.currentTimeMillis();\n    \n            Future<String> task1 = task.doTaskOne();\n            Future<String> task2 = task.doTaskTwo();\n            Future<String> task3 = task.doTaskThree();\n    \n            while(true) {\n                if(task1.isDone() && task2.isDone() && task3.isDone()) {\n                    // 三个任务都调用完成，退出循环等待\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n    \n            long end = System.currentTimeMillis();\n    \n            System.out.println(\"任务全部完成，总耗时：\" + (end - start) + \"毫秒\");\n    \n        }\n    \n    }\n\n---\n    package com.ymu.demo.async;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    public class IndexController {\n    \n        @Autowired\n        Task task;\n    \n        @GetMapping(\"/index\")\n        public String index() throws Exception {\n            task.webTest();\n            return \"index\";\n        }\n    }\n    \n## 4. 基于@Async调用中的异常处理机制\n   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：\n   \n1. 自定义实现AsyncTaskExecutor的任务执行器。\n2. 配置由自定义的TaskExecutor替代内置的任务执行器。      \n\n自定义的TaskExecutor\n\n    \n","source":"_posts/spring-boot-async.md","raw":"---\ntitle: spring-boot异步调用\ndate: 2017-11-10 16:22:18\ncategories: spring-boot\ntags: spring-boot-async\n---\n\n在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。\n在spring-boot中，通过简单的注解 `@Async` 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：\n\n参考：\n- http://blog.csdn.net/blueheart20/article/details/44648667\n- http://blog.csdn.net/liuchuanhong1/article/details/64132520\n\n## 1. 启用异步操作功能\n很简单，只需要在主类中添加注解`@EnableAsync` 即可。\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.boot.SpringApplication;\n    import org.springframework.boot.autoconfigure.SpringBootApplication;\n    import org.springframework.scheduling.annotation.EnableAsync;\n    \n    @EnableAsync\n    @SpringBootApplication\n    public class SpringBootAsyncApplication {\n    \n    \tpublic static void main(String[] args) {\n    \t\tSpringApplication.run(SpringBootAsyncApplication.class, args);\n    \t}\n    }\n\n## 2. 定义处理类，并添加方法\n\n    package com.ymu.demo.async;\n    \n    import org.springframework.scheduling.annotation.Async;\n    import org.springframework.scheduling.annotation.AsyncResult;\n    import org.springframework.stereotype.Component;\n    \n    import java.util.Random;\n    import java.util.concurrent.Future;\n    \n    @Component\n    public class Task {\n    \n        public static Random random =new Random();\n    \n        @Async\n        public void webTest() throws Exception {\n            System.out.println(\"开始测试异步\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成测试异步，耗时：\" + (end - start) + \"毫秒\");\n        }\n    \n        @Async\n        public Future<String> doTaskOne() throws Exception {\n            System.out.println(\"开始做任务一\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务一，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务一完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskTwo() throws Exception {\n            System.out.println(\"开始做任务二\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务二，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务二完成\");\n        }\n    \n        @Async\n        public Future<String> doTaskThree() throws Exception {\n            System.out.println(\"开始做任务三\");\n            long start = System.currentTimeMillis();\n            Thread.sleep(random.nextInt(10000));\n            long end = System.currentTimeMillis();\n            System.out.println(\"完成任务三，耗时：\" + (end - start) + \"毫秒\");\n            return new AsyncResult<>(\"任务三完成\");\n        }\n    }\n\n只需要在方法上添加注解`@Async`。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。\n\n## 3. 测试\n\n    package com.ymu.demo.async;\n    \n    import org.junit.Test;\n    import org.junit.runner.RunWith;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.boot.test.context.SpringBootTest;\n    import org.springframework.test.context.junit4.SpringRunner;\n    \n    import java.util.concurrent.Future;\n    \n    @RunWith(SpringRunner.class)\n    @SpringBootTest\n    public class SpringBootAsyncApplicationTests {\n    \n        @Autowired\n        private Task task;\n    \n        @Test\n        public void contextLoads() {\n    \n            System.out.println(\"===============load context\");\n        }\n    \n        @Test\n        public void test() throws Exception {\n    \n            long start = System.currentTimeMillis();\n    \n            Future<String> task1 = task.doTaskOne();\n            Future<String> task2 = task.doTaskTwo();\n            Future<String> task3 = task.doTaskThree();\n    \n            while(true) {\n                if(task1.isDone() && task2.isDone() && task3.isDone()) {\n                    // 三个任务都调用完成，退出循环等待\n                    break;\n                }\n                Thread.sleep(1000);\n            }\n    \n            long end = System.currentTimeMillis();\n    \n            System.out.println(\"任务全部完成，总耗时：\" + (end - start) + \"毫秒\");\n    \n        }\n    \n    }\n\n---\n    package com.ymu.demo.async;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.web.bind.annotation.GetMapping;\n    import org.springframework.web.bind.annotation.RestController;\n    \n    @RestController\n    public class IndexController {\n    \n        @Autowired\n        Task task;\n    \n        @GetMapping(\"/index\")\n        public String index() throws Exception {\n            task.webTest();\n            return \"index\";\n        }\n    }\n    \n## 4. 基于@Async调用中的异常处理机制\n   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：\n   \n1. 自定义实现AsyncTaskExecutor的任务执行器。\n2. 配置由自定义的TaskExecutor替代内置的任务执行器。      \n\n自定义的TaskExecutor\n\n    \n","slug":"spring-boot-async","published":1,"updated":"2017-11-15T01:42:06.528Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckpe00328oraf2h79g76","content":"<p>在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。<br>在spring-boot中，通过简单的注解 <code>@Async</code> 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/blueheart20/article/details/44648667\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/blueheart20/article/details/44648667</a></li>\n<li><a href=\"http://blog.csdn.net/liuchuanhong1/article/details/64132520\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/liuchuanhong1/article/details/64132520</a></li>\n</ul>\n<h2 id=\"1-启用异步操作功能\"><a href=\"#1-启用异步操作功能\" class=\"headerlink\" title=\"1. 启用异步操作功能\"></a>1. 启用异步操作功能</h2><p>很简单，只需要在主类中添加注解<code>@EnableAsync</code> 即可。</p>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootAsyncApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAsyncApplication.class, args);\n    }\n}\n</code></pre><h2 id=\"2-定义处理类，并添加方法\"><a href=\"#2-定义处理类，并添加方法\" class=\"headerlink\" title=\"2. 定义处理类，并添加方法\"></a>2. 定义处理类，并添加方法</h2><pre><code>package com.ymu.demo.async;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.AsyncResult;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Random;\nimport java.util.concurrent.Future;\n\n@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    @Async\n    public void webTest() throws Exception {\n        System.out.println(&quot;开始测试异步&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成测试异步，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskOne() throws Exception {\n        System.out.println(&quot;开始做任务一&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskTwo() throws Exception {\n        System.out.println(&quot;开始做任务二&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务二完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskThree() throws Exception {\n        System.out.println(&quot;开始做任务三&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务三完成&quot;);\n    }\n}\n</code></pre><p>只需要在方法上添加注解<code>@Async</code>。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。</p>\n<h2 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h2><pre><code>package com.ymu.demo.async;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.concurrent.Future;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootAsyncApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void contextLoads() {\n\n        System.out.println(&quot;===============load context&quot;);\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        Future&lt;String&gt; task1 = task.doTaskOne();\n        Future&lt;String&gt; task2 = task.doTaskTwo();\n        Future&lt;String&gt; task3 = task.doTaskThree();\n\n        while(true) {\n            if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {\n                // 三个任务都调用完成，退出循环等待\n                break;\n            }\n            Thread.sleep(1000);\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n\n    }\n\n}\n</code></pre><hr>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class IndexController {\n\n    @Autowired\n    Task task;\n\n    @GetMapping(&quot;/index&quot;)\n    public String index() throws Exception {\n        task.webTest();\n        return &quot;index&quot;;\n    }\n}\n</code></pre><h2 id=\"4-基于-Async调用中的异常处理机制\"><a href=\"#4-基于-Async调用中的异常处理机制\" class=\"headerlink\" title=\"4. 基于@Async调用中的异常处理机制\"></a>4. 基于@Async调用中的异常处理机制</h2><p>   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：</p>\n<ol>\n<li>自定义实现AsyncTaskExecutor的任务执行器。</li>\n<li>配置由自定义的TaskExecutor替代内置的任务执行器。      </li>\n</ol>\n<p>自定义的TaskExecutor</p>\n","site":{"data":{}},"excerpt":"","more":"<p>在一些场景中，为了快速响应页面，把一些对数据一致性要求没那么严格的业务逻辑放到异步执行，可以有效的提交系统性能。<br>在spring-boot中，通过简单的注解 <code>@Async</code> 就可以实现，非常优雅，不用再像以前自己直接new线程。下面是其使用方式：</p>\n<p>参考：</p>\n<ul>\n<li><a href=\"http://blog.csdn.net/blueheart20/article/details/44648667\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/blueheart20/article/details/44648667</a></li>\n<li><a href=\"http://blog.csdn.net/liuchuanhong1/article/details/64132520\" target=\"_blank\" rel=\"external\">http://blog.csdn.net/liuchuanhong1/article/details/64132520</a></li>\n</ul>\n<h2 id=\"1-启用异步操作功能\"><a href=\"#1-启用异步操作功能\" class=\"headerlink\" title=\"1. 启用异步操作功能\"></a>1. 启用异步操作功能</h2><p>很简单，只需要在主类中添加注解<code>@EnableAsync</code> 即可。</p>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.boot.SpringApplication;\nimport org.springframework.boot.autoconfigure.SpringBootApplication;\nimport org.springframework.scheduling.annotation.EnableAsync;\n\n@EnableAsync\n@SpringBootApplication\npublic class SpringBootAsyncApplication {\n\n    public static void main(String[] args) {\n        SpringApplication.run(SpringBootAsyncApplication.class, args);\n    }\n}\n</code></pre><h2 id=\"2-定义处理类，并添加方法\"><a href=\"#2-定义处理类，并添加方法\" class=\"headerlink\" title=\"2. 定义处理类，并添加方法\"></a>2. 定义处理类，并添加方法</h2><pre><code>package com.ymu.demo.async;\n\nimport org.springframework.scheduling.annotation.Async;\nimport org.springframework.scheduling.annotation.AsyncResult;\nimport org.springframework.stereotype.Component;\n\nimport java.util.Random;\nimport java.util.concurrent.Future;\n\n@Component\npublic class Task {\n\n    public static Random random =new Random();\n\n    @Async\n    public void webTest() throws Exception {\n        System.out.println(&quot;开始测试异步&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成测试异步，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskOne() throws Exception {\n        System.out.println(&quot;开始做任务一&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务一，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务一完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskTwo() throws Exception {\n        System.out.println(&quot;开始做任务二&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务二，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务二完成&quot;);\n    }\n\n    @Async\n    public Future&lt;String&gt; doTaskThree() throws Exception {\n        System.out.println(&quot;开始做任务三&quot;);\n        long start = System.currentTimeMillis();\n        Thread.sleep(random.nextInt(10000));\n        long end = System.currentTimeMillis();\n        System.out.println(&quot;完成任务三，耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n        return new AsyncResult&lt;&gt;(&quot;任务三完成&quot;);\n    }\n}\n</code></pre><p>只需要在方法上添加注解<code>@Async</code>。方法webTest是无返回值的，其他的是有返回值，返回的数据类型为Future类型，其为一个接口。具体的结果类型为AsyncResult,这个是需要注意的地方。通过其返回类型，可以检测异步线程执行的情况。</p>\n<h2 id=\"3-测试\"><a href=\"#3-测试\" class=\"headerlink\" title=\"3. 测试\"></a>3. 测试</h2><pre><code>package com.ymu.demo.async;\n\nimport org.junit.Test;\nimport org.junit.runner.RunWith;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.test.context.junit4.SpringRunner;\n\nimport java.util.concurrent.Future;\n\n@RunWith(SpringRunner.class)\n@SpringBootTest\npublic class SpringBootAsyncApplicationTests {\n\n    @Autowired\n    private Task task;\n\n    @Test\n    public void contextLoads() {\n\n        System.out.println(&quot;===============load context&quot;);\n    }\n\n    @Test\n    public void test() throws Exception {\n\n        long start = System.currentTimeMillis();\n\n        Future&lt;String&gt; task1 = task.doTaskOne();\n        Future&lt;String&gt; task2 = task.doTaskTwo();\n        Future&lt;String&gt; task3 = task.doTaskThree();\n\n        while(true) {\n            if(task1.isDone() &amp;&amp; task2.isDone() &amp;&amp; task3.isDone()) {\n                // 三个任务都调用完成，退出循环等待\n                break;\n            }\n            Thread.sleep(1000);\n        }\n\n        long end = System.currentTimeMillis();\n\n        System.out.println(&quot;任务全部完成，总耗时：&quot; + (end - start) + &quot;毫秒&quot;);\n\n    }\n\n}\n</code></pre><hr>\n<pre><code>package com.ymu.demo.async;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.GetMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\n@RestController\npublic class IndexController {\n\n    @Autowired\n    Task task;\n\n    @GetMapping(&quot;/index&quot;)\n    public String index() throws Exception {\n        task.webTest();\n        return &quot;index&quot;;\n    }\n}\n</code></pre><h2 id=\"4-基于-Async调用中的异常处理机制\"><a href=\"#4-基于-Async调用中的异常处理机制\" class=\"headerlink\" title=\"4. 基于@Async调用中的异常处理机制\"></a>4. 基于@Async调用中的异常处理机制</h2><p>   在上面的异步调用中，调用者是无法感知异步线程的执行成功与否的。所以当要对异步线程执行异常做处理的时候，可以按下面方法来：</p>\n<ol>\n<li>自定义实现AsyncTaskExecutor的任务执行器。</li>\n<li>配置由自定义的TaskExecutor替代内置的任务执行器。      </li>\n</ol>\n<p>自定义的TaskExecutor</p>\n"},{"title":"springboot跨域请求解决","date":"2017-11-15T01:43:12.000Z","_content":"先推荐三篇文章\n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[同源策略和跨域访问](http://blog.csdn.net/shimiso/article/details/21830313)\n[详解js跨域问题](https://segmentfault.com/a/1190000000718840)\n[springboot前后端分离跨域](https://my.oschina.net/u/3677020/blog/1573162)\n\n## 什么是跨域\n\n要想了解跨域，就先要知道什么是同源策略。\n\n同源策略，它是由Netscape提出的一个著名的安全策略。\n\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\n\n域：协议+地址(域名或IP)+端口\n\n## 为什么要有同源策略\n\n可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。\n\n## 为什么要有跨域\n\n最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。\n\n## 如何解决跨域\n\n*JSONP*\n\n只能实现GET请求，但是被一些老浏览器支持。\n\n*代理*\n\n在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。\n\n*CORS*\n\n2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。\n\n出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 http://example.com 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 http://hello-world.example，就需要使用该标准。http://hello-world.example 在HTTP的响应头部中定义 Access-Control-Allow-Origin: http://example.org，通知浏览器允许 http://example.org 跨源从 http://hello-world.example上获取资源。\n\n## springboot跨域\n\n### 设置全局跨域\n- 方法一：\n    \n        @Configuration\n        public class WebConfig extends WebMvcConfigurationSupport {\n            /**\n             * 全局跨域设置\n             *\n             * @param registry\n             */\n            @Override\n            protected void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\");\n        //                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n        //                .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        \n        }\n\n### 局部跨域\n","source":"_posts/spring-boot-cors.md","raw":"---\ntitle: springboot跨域请求解决\ndate: 2017-11-15 09:43:12\ncategories: spring-boot\ntags: spring-cors\n---\n先推荐三篇文章\n[跨域资源共享 CORS 详解](http://www.ruanyifeng.com/blog/2016/04/cors.html)\n[同源策略和跨域访问](http://blog.csdn.net/shimiso/article/details/21830313)\n[详解js跨域问题](https://segmentfault.com/a/1190000000718840)\n[springboot前后端分离跨域](https://my.oschina.net/u/3677020/blog/1573162)\n\n## 什么是跨域\n\n要想了解跨域，就先要知道什么是同源策略。\n\n同源策略，它是由Netscape提出的一个著名的安全策略。\n\n同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。\n\n域：协议+地址(域名或IP)+端口\n\n## 为什么要有同源策略\n\n可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。\n\n## 为什么要有跨域\n\n最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。\n\n## 如何解决跨域\n\n*JSONP*\n\n只能实现GET请求，但是被一些老浏览器支持。\n\n*代理*\n\n在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。\n\n*CORS*\n\n2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。\n\n出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 http://example.com 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 http://hello-world.example，就需要使用该标准。http://hello-world.example 在HTTP的响应头部中定义 Access-Control-Allow-Origin: http://example.org，通知浏览器允许 http://example.org 跨源从 http://hello-world.example上获取资源。\n\n## springboot跨域\n\n### 设置全局跨域\n- 方法一：\n    \n        @Configuration\n        public class WebConfig extends WebMvcConfigurationSupport {\n            /**\n             * 全局跨域设置\n             *\n             * @param registry\n             */\n            @Override\n            protected void addCorsMappings(CorsRegistry registry) {\n                registry.addMapping(\"/**\")\n                        //放行哪些原始域\n                        .allowedOrigins(\"*\")\n                        //是否发送Cookie信息\n                        .allowCredentials(true)\n                        //放行哪些原始域(请求方式)\n                        .allowedMethods(\"GET\", \"POST\", \"PUT\", \"DELETE\")\n                        //放行哪些原始域(头部信息)\n                        .allowedHeaders(\"*\");\n        //                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n        //                .exposedHeaders(\"Header1\", \"Header2\");\n            }\n        \n        }\n\n### 局部跨域\n","slug":"spring-boot-cors","published":1,"updated":"2017-11-15T08:33:46.400Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckpf00338ora7ys2a0kg","content":"<p>先推荐三篇文章<br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"external\">跨域资源共享 CORS 详解</a><br><a href=\"http://blog.csdn.net/shimiso/article/details/21830313\" target=\"_blank\" rel=\"external\">同源策略和跨域访问</a><br><a href=\"https://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"external\">详解js跨域问题</a><br><a href=\"https://my.oschina.net/u/3677020/blog/1573162\" target=\"_blank\" rel=\"external\">springboot前后端分离跨域</a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>要想了解跨域，就先要知道什么是同源策略。</p>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略。</p>\n<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>\n<p>域：协议+地址(域名或IP)+端口</p>\n<h2 id=\"为什么要有同源策略\"><a href=\"#为什么要有同源策略\" class=\"headerlink\" title=\"为什么要有同源策略\"></a>为什么要有同源策略</h2><p>可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。</p>\n<h2 id=\"为什么要有跨域\"><a href=\"#为什么要有跨域\" class=\"headerlink\" title=\"为什么要有跨域\"></a>为什么要有跨域</h2><p>最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。</p>\n<h2 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h2><p><em>JSONP</em></p>\n<p>只能实现GET请求，但是被一些老浏览器支持。</p>\n<p><em>代理</em></p>\n<p>在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。</p>\n<p><em>CORS</em></p>\n<p>2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。</p>\n<p>出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"external\">http://example.com</a> 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 <a href=\"http://hello-world.example，就需要使用该标准。http://hello-world.example\" target=\"_blank\" rel=\"external\">http://hello-world.example，就需要使用该标准。http://hello-world.example</a> 在HTTP的响应头部中定义 Access-Control-Allow-Origin: <a href=\"http://example.org，通知浏览器允许\" target=\"_blank\" rel=\"external\">http://example.org，通知浏览器允许</a> <a href=\"http://example.org\" target=\"_blank\" rel=\"external\">http://example.org</a> 跨源从 <a href=\"http://hello-world.example上获取资源。\" target=\"_blank\" rel=\"external\">http://hello-world.example上获取资源。</a></p>\n<h2 id=\"springboot跨域\"><a href=\"#springboot跨域\" class=\"headerlink\" title=\"springboot跨域\"></a>springboot跨域</h2><h3 id=\"设置全局跨域\"><a href=\"#设置全局跨域\" class=\"headerlink\" title=\"设置全局跨域\"></a>设置全局跨域</h3><ul>\n<li><p>方法一：</p>\n<pre><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n    /**\n     * 全局跨域设置\n     *\n     * @param registry\n     */\n    @Override\n    protected void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;)\n                //放行哪些原始域\n                .allowedOrigins(&quot;*&quot;)\n                //是否发送Cookie信息\n                .allowCredentials(true)\n                //放行哪些原始域(请求方式)\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)\n                //放行哪些原始域(头部信息)\n                .allowedHeaders(&quot;*&quot;);\n//                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n//                .exposedHeaders(&quot;Header1&quot;, &quot;Header2&quot;);\n    }\n\n}\n</code></pre></li>\n</ul>\n<h3 id=\"局部跨域\"><a href=\"#局部跨域\" class=\"headerlink\" title=\"局部跨域\"></a>局部跨域</h3>","site":{"data":{}},"excerpt":"","more":"<p>先推荐三篇文章<br><a href=\"http://www.ruanyifeng.com/blog/2016/04/cors.html\" target=\"_blank\" rel=\"external\">跨域资源共享 CORS 详解</a><br><a href=\"http://blog.csdn.net/shimiso/article/details/21830313\" target=\"_blank\" rel=\"external\">同源策略和跨域访问</a><br><a href=\"https://segmentfault.com/a/1190000000718840\" target=\"_blank\" rel=\"external\">详解js跨域问题</a><br><a href=\"https://my.oschina.net/u/3677020/blog/1573162\" target=\"_blank\" rel=\"external\">springboot前后端分离跨域</a></p>\n<h2 id=\"什么是跨域\"><a href=\"#什么是跨域\" class=\"headerlink\" title=\"什么是跨域\"></a>什么是跨域</h2><p>要想了解跨域，就先要知道什么是同源策略。</p>\n<p>同源策略，它是由Netscape提出的一个著名的安全策略。</p>\n<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。可以说Web是构建在同源策略基础之上的，浏览器只是针对同源策略的一种实现。</p>\n<p>域：协议+地址(域名或IP)+端口</p>\n<h2 id=\"为什么要有同源策略\"><a href=\"#为什么要有同源策略\" class=\"headerlink\" title=\"为什么要有同源策略\"></a>为什么要有同源策略</h2><p>可以简单的理解为：同源策略是一个安全策略，浏览器只是对同源策略的一种实现。它限制着只有同源的脚本(Javascript)才能调用该源的接口，以保护服务器资源或数据。</p>\n<h2 id=\"为什么要有跨域\"><a href=\"#为什么要有跨域\" class=\"headerlink\" title=\"为什么要有跨域\"></a>为什么要有跨域</h2><p>最常见的：多个系统前端需要调用另外系统的接口；前后端分开部署。</p>\n<h2 id=\"如何解决跨域\"><a href=\"#如何解决跨域\" class=\"headerlink\" title=\"如何解决跨域\"></a>如何解决跨域</h2><p><em>JSONP</em></p>\n<p>只能实现GET请求，但是被一些老浏览器支持。</p>\n<p><em>代理</em></p>\n<p>在服务器端处理其他源资源请求访问，使得浏览器端无跨域问题。</p>\n<p><em>CORS</em></p>\n<p>2014年1月16日，W3C的Web应用工作组（Web Applications Working Group）和Web应用安全工作组（Web AppSec）联合发布了跨源资源共享（Cross-Origin Resource Sharing）的W3C正式推荐标准（W3C Recommendation）。该标准定义了在必须访问跨域资源时，浏览器与服务端应该如何沟通，它提供一种机制，允许客户端（如浏览器）对非源站点的资源发出访问请求。所有提供跨源资源请求的API都可以使用本规范中定义的算法。</p>\n<p>出于安全性的考虑，用户代理（如浏览器）通常拒绝跨站的访问请求，但这会限制运行在用户代理的Web应用通过Ajax或者其他机制从另一个站点访问资源、获取数据。跨源资源共享（CORS）扩充了这个模型，通过使用自定义的HTTP响应头部（HTTP Response Header），通知浏览器资源可能被哪些跨源站点以何种HTTP方法获得。例如，浏览器在访问 <a href=\"http://example.com\" target=\"_blank\" rel=\"external\">http://example.com</a> 站点的Web应用时，Web应用如果需要跨站访问另一站点的资源 <a href=\"http://hello-world.example，就需要使用该标准。http://hello-world.example\" target=\"_blank\" rel=\"external\">http://hello-world.example，就需要使用该标准。http://hello-world.example</a> 在HTTP的响应头部中定义 Access-Control-Allow-Origin: <a href=\"http://example.org，通知浏览器允许\" target=\"_blank\" rel=\"external\">http://example.org，通知浏览器允许</a> <a href=\"http://example.org\" target=\"_blank\" rel=\"external\">http://example.org</a> 跨源从 <a href=\"http://hello-world.example上获取资源。\" target=\"_blank\" rel=\"external\">http://hello-world.example上获取资源。</a></p>\n<h2 id=\"springboot跨域\"><a href=\"#springboot跨域\" class=\"headerlink\" title=\"springboot跨域\"></a>springboot跨域</h2><h3 id=\"设置全局跨域\"><a href=\"#设置全局跨域\" class=\"headerlink\" title=\"设置全局跨域\"></a>设置全局跨域</h3><ul>\n<li><p>方法一：</p>\n<pre><code>@Configuration\npublic class WebConfig extends WebMvcConfigurationSupport {\n    /**\n     * 全局跨域设置\n     *\n     * @param registry\n     */\n    @Override\n    protected void addCorsMappings(CorsRegistry registry) {\n        registry.addMapping(&quot;/**&quot;)\n                //放行哪些原始域\n                .allowedOrigins(&quot;*&quot;)\n                //是否发送Cookie信息\n                .allowCredentials(true)\n                //放行哪些原始域(请求方式)\n                .allowedMethods(&quot;GET&quot;, &quot;POST&quot;, &quot;PUT&quot;, &quot;DELETE&quot;)\n                //放行哪些原始域(头部信息)\n                .allowedHeaders(&quot;*&quot;);\n//                //暴露哪些头部信息（因为跨域访问默认不能获取全部头部信息）\n//                .exposedHeaders(&quot;Header1&quot;, &quot;Header2&quot;);\n    }\n\n}\n</code></pre></li>\n</ul>\n<h3 id=\"局部跨域\"><a href=\"#局部跨域\" class=\"headerlink\" title=\"局部跨域\"></a>局部跨域</h3>"},{"title":"spring-data-jpa动态数据源读写分离","date":"2017-11-08T15:02:49.000Z","_content":"\n在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。\n\n## 1. 配置数据源\n\n采用阿里druid数据源配置连接池。\n\n具体配置如下：\n\n    package service.basic.user.config.ds;\n    \n    import com.alibaba.druid.filter.Filter;\n    import com.alibaba.druid.filter.logging.Log4j2Filter;\n    import com.alibaba.druid.filter.stat.StatFilter;\n    import com.alibaba.druid.pool.DruidDataSource;\n    import com.alibaba.druid.wall.WallConfig;\n    import com.alibaba.druid.wall.WallFilter;\n    import com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.context.annotation.*;\n    import org.springframework.core.env.Environment;\n    \n    import javax.sql.DataSource;\n    import java.sql.SQLException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    \n    \n    /**\n     * 配置数据源\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        /**\n         * druid监控filter配置。\n         * @return\n         */\n        @Bean\n        public StatFilter statFilter() {\n            StatFilter statFilter = new StatFilter();\n            statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n            statFilter.setLogSlowSql(true); //日志记录慢sql\n            statFilter.setMergeSql(true); //相同sql合并\n            return statFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 start ---------//\n    \n        @Bean\n        public WallConfig wallConfig() {\n            WallConfig wallConfig = new WallConfig();\n            wallConfig.setDir(\"classpath:druid/wall/mysql\"); //sql过滤规则装载位置。\n            return wallConfig;\n        }\n    \n        @Bean\n        public WallFilter wallFilter() {\n            WallFilter wallFilter = new WallFilter();\n            wallFilter.setDbType(\"mysql\"); //指定数据库类型。\n            wallFilter.setConfig(wallConfig());\n            return wallFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 end ---------//\n    \n    \n        /**\n         * 打印sql语句。\n         * @return\n         */\n        @Bean(name = \"log4j2Filter\")\n        public Log4j2Filter log4j2Filter() {\n            Log4j2Filter log4j2Filter = new Log4j2Filter();\n            log4j2Filter.setConnectionLogEnabled(false);\n            log4j2Filter.setResultSetLogEnabled(true); //显示sql\n            log4j2Filter.setDataSourceLogEnabled(false);\n            log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n            log4j2Filter.setStatementLogEnabled(false);\n            return log4j2Filter;\n        }\n    \n    \n    \n        //-------------- 数据源配置 start ---------------//\n    \n        /**\n         * 会员主库（spcs_user）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceWrite\")\n        @Qualifier(\"spcsUserDataSourceWrite\")\n        public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n        /**\n         * 会员从库（spcs_user_slave）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceRead_0\")\n        @Qualifier(\"spcsUserDataSourceRead_0\")\n        public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"spcsUserDataSourceWrite\",\"spcsUserDataSourceRead_0\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"spcsUserDataSourceWrite\") DataSource spcsUserDataSource,\n                                              @Qualifier(\"spcsUserDataSourceRead_0\") DataSource spcsUserSlaveDataSource) {\n            // 配置多数据源\n            Map<Object, Object> dsMap = new HashMap<>(5);\n            dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n            dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n    \n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            // 默认数据源\n            dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n            dynamicDataSource.setTargetDataSources(dsMap);\n            return dynamicDataSource;\n        }\n    \n    }\n\n> *注意*：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。\n\n## 2. 实现自己的数据源路由（关键）\n\n相当于多数据源的路由功能。\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n    \n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            log.debug(\"数据源为{}\", DataSourceContextHolder.getDS());\n            //可以做一个简单的负载均衡策略\n            return DataSourceContextHolder.getDS();\n        }\n    \n    }\n    \n## 3. 持有数据源\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    public class DataSourceContextHolder {\n    \n        private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n    \n        private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n    \n        /**\n         * 设置数据源名。\n         * @param dbType\n         */\n        public static void setDS(String dbType) {\n            if (dbType == null) {\n                throw new NullPointerException(\"数据源不能null\");\n            }\n            LOGGER.debug(\"切换到{}数据源\", dbType);\n            contextHolder.set(dbType);\n        }\n    \n        /**\n         * 获取数据源名。\n         * @return\n         */\n        public static String getDS() {\n            return (contextHolder.get());\n        }\n    \n        /**\n         * 清除数据源名。\n         */\n        public static void clearDS() {\n            contextHolder.remove();\n        }\n    }\n    \n## 4. 通过aop，注解方式持有数据源\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.ds.DSInject;\n    import com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.annotation.After;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.aspectj.lang.annotation.Before;\n    import org.aspectj.lang.reflect.MethodSignature;\n    import org.springframework.stereotype.Component;\n    \n    import java.lang.reflect.Method;\n    \n    /**\n     *  解析注入的数据源。\n     */\n    @Aspect\n    @Component\n    public class DynamicDataSourceAspect {\n    \n    \t@Before(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void beforeSwitchDS(JoinPoint point) {\n    \n    \t\t// 获得当前访问的class\n    \t\tClass<?> className = point.getTarget().getClass();\n    \n    \t\t// 获得访问的方法名\n    \t\tString methodName = point.getSignature().getName();\n    \t\t// 得到方法的参数的类型\n    \t\tClass[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n    \t\tString dataSource = DSType.SPCS_USER.name(); //默认主库\n    \t\ttry {\n    \t\t\t// 得到访问的方法对象\n    \t\t\tMethod method = className.getMethod(methodName, argClass);\n    \n    \t\t\t// 判断是否存在@DBInject注解\n    \t\t\tif (method.isAnnotationPresent(DSInject.class)) {\n    \t\t\t\tDSInject annotation = method.getAnnotation(DSInject.class);\n    \t\t\t\t// 取出注解中的数据源名\n    \t\t\t\tdataSource = annotation.value();\n    \t\t\t}\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t}\n    \n    \t\t// 切换数据源\n    \t\tDataSourceContextHolder.setDS(dataSource);\n    \n    \t}\n    \n    \t@After(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void afterSwitchDS(JoinPoint point) {\n    \t\tDataSourceContextHolder.clearDS();\n    \t}\n    }\n\n---\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Target({ ElementType.PARAMETER, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface DSInject {\n    \tString value() default \"\";\n    }\n\n## 5. 配置jpa\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\n    import net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\n    import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.core.env.Environment;\n    import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n    import org.springframework.orm.jpa.JpaTransactionManager;\n    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n    import org.springframework.transaction.PlatformTransactionManager;\n    import org.springframework.transaction.annotation.EnableTransactionManagement;\n    import service.basic.user.common.Constants;\n    \n    import javax.persistence.EntityManager;\n    import javax.sql.DataSource;\n    import java.util.Map;\n    \n    @Configuration\n    @EnableTransactionManagement\n    @EnableJpaRepositories(entityManagerFactoryRef = \"entityManagerFactorySpcsUserDB\", transactionManagerRef = \"transactionManagerSpcsUserDB\", basePackages = {\n            Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\n    public class SpcsUserDBConfig {\n    \n        @Autowired\n        Environment ev;\n    \n        @Autowired\n        @Qualifier(\"dataSource\")\n        private DataSource dataSource; // 数据源\n    \n        @Primary\n        @Bean(name = \"entityManagerSpcsUser\")\n        public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n            return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n        }\n    \n        @Primary\n        @Bean(name = \"entityManagerFactorySpcsUserDB\")\n        public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n            if (ev.acceptsProfiles(\"dev\") || ev.acceptsProfiles(\"test\")\n                    || ev.acceptsProfiles(\"update\")) {\n                dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n            }\n            return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                    .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                    .persistenceUnit(\"spcsUserUnit\").build(); //实体管理器别名,多数据元要设置。\n        }\n    \n        private Map<String, String> getVendorProperties(DataSource dataSource) {\n            JpaProperties jpaProperties = new JpaProperties();\n            return jpaProperties.getHibernateProperties(dataSource);\n        }\n    \n        /**\n         * 开启事务。\n         *\n         * @param builder\n         * @return\n         */\n        @Primary\n        @Bean(name = \"transactionManagerSpcsUserDB\")\n        public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n            return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n        }\n    \n    }\n    \n> *注意*: 注入的数据源为上面配置的动态数据源。\n@Autowired\n@Qualifier(\"dataSource\")\nprivate DataSource dataSource; // 数据源    \n\n\n## 6. 配置spring jdbcTemplate\n\n    package service.basic.user.config.ds;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import javax.sql.DataSource;\n    \n    @Configuration\n    @AutoConfigureAfter(DataSourceConfig.class)\n    public class JdbcTemplateConfig {\n    \n        @Autowired\n        @Qualifier(value = \"dataSource\")\n        private DataSource dataSource;\n    \n        /**\n         * spring jdbc。\n         *\n         * @return\n         */\n        @Bean(name = \"jdbcTemplate\")\n        @Qualifier(\"jdbcTemplate\")\n        public JdbcTemplate jdbcTemplate() {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n\n## 7. 使用\n\n- 方式一：\n可在service层，也可在dao层做。\n在开始操作数据库前调用：\n\n\n    DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n    \n    //查询数据\n    \n    DataSourceContextHolder.clearDS();\n    \n- 方式二：\n通过注解，可在service层，也可在dao层做。\n\n\n    @DSInject(value = Constants.SPCS_USER_SLAVE)\n    @Override\n    public User getUserByMobile(String mobile) {\n        return userDao.findUserByMobile(mobile);\n    }    ","source":"_posts/spring-jpa-multiple-datasource.md","raw":"---\ntitle: spring-data-jpa动态数据源读写分离\ndate: 2017-11-08 23:02:49\ncategories: spring-boot\ntags: jpa读写分离配置\n---\n\n在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。\n\n## 1. 配置数据源\n\n采用阿里druid数据源配置连接池。\n\n具体配置如下：\n\n    package service.basic.user.config.ds;\n    \n    import com.alibaba.druid.filter.Filter;\n    import com.alibaba.druid.filter.logging.Log4j2Filter;\n    import com.alibaba.druid.filter.stat.StatFilter;\n    import com.alibaba.druid.pool.DruidDataSource;\n    import com.alibaba.druid.wall.WallConfig;\n    import com.alibaba.druid.wall.WallFilter;\n    import com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.context.annotation.*;\n    import org.springframework.core.env.Environment;\n    \n    import javax.sql.DataSource;\n    import java.sql.SQLException;\n    import java.util.ArrayList;\n    import java.util.HashMap;\n    import java.util.List;\n    import java.util.Map;\n    \n    \n    /**\n     * 配置数据源\n     */\n    @Configuration\n    public class DataSourceConfig {\n    \n        /**\n         * druid监控filter配置。\n         * @return\n         */\n        @Bean\n        public StatFilter statFilter() {\n            StatFilter statFilter = new StatFilter();\n            statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n            statFilter.setLogSlowSql(true); //日志记录慢sql\n            statFilter.setMergeSql(true); //相同sql合并\n            return statFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 start ---------//\n    \n        @Bean\n        public WallConfig wallConfig() {\n            WallConfig wallConfig = new WallConfig();\n            wallConfig.setDir(\"classpath:druid/wall/mysql\"); //sql过滤规则装载位置。\n            return wallConfig;\n        }\n    \n        @Bean\n        public WallFilter wallFilter() {\n            WallFilter wallFilter = new WallFilter();\n            wallFilter.setDbType(\"mysql\"); //指定数据库类型。\n            wallFilter.setConfig(wallConfig());\n            return wallFilter;\n        }\n    \n        //----------- sql注入攻击防御配置 end ---------//\n    \n    \n        /**\n         * 打印sql语句。\n         * @return\n         */\n        @Bean(name = \"log4j2Filter\")\n        public Log4j2Filter log4j2Filter() {\n            Log4j2Filter log4j2Filter = new Log4j2Filter();\n            log4j2Filter.setConnectionLogEnabled(false);\n            log4j2Filter.setResultSetLogEnabled(true); //显示sql\n            log4j2Filter.setDataSourceLogEnabled(false);\n            log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n            log4j2Filter.setStatementLogEnabled(false);\n            return log4j2Filter;\n        }\n    \n    \n    \n        //-------------- 数据源配置 start ---------------//\n    \n        /**\n         * 会员主库（spcs_user）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceWrite\")\n        @Qualifier(\"spcsUserDataSourceWrite\")\n        public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n        /**\n         * 会员从库（spcs_user_slave）数据源。\n         *\n         * @return\n         * @throws SQLException\n         */\n        @Bean(name = \"spcsUserDataSourceRead_0\")\n        @Qualifier(\"spcsUserDataSourceRead_0\")\n        public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n            DruidDataSource dataSource = new DruidDataSource();\n            dataSource.setUrl(args.getUrl());\n            dataSource.setUsername(args.getUsername());\n            dataSource.setPassword(args.getPassword());\n            dataSource.setDriverClassName(args.getDriverClassName());\n            dataSource.setMinIdle(args.getMinIdle());\n            dataSource.setInitialSize(args.getInitialSize());\n            dataSource.setMaxActive(args.getMaxActive());\n            dataSource.setMaxWait(args.getMaxWait());\n            dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n            dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n    \n            List<Filter> proxyFilters = new ArrayList<>();\n            proxyFilters.add(statFilter());\n            proxyFilters.add(log4j2Filter());\n            proxyFilters.add(wallFilter());\n            dataSource.setProxyFilters(proxyFilters);\n    \n            return dataSource;\n        }\n    \n    \n        /**\n         * 动态数据源: 通过AOP在不同数据源之间动态切换\n         *\n         * @return\n         */\n        @Primary\n        @Bean(name = \"dataSource\")\n        @Scope(\"singleton\")\n        @DependsOn({\"spcsUserDataSourceWrite\",\"spcsUserDataSourceRead_0\"}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n        public DataSource dynamicDataSource(@Qualifier(\"spcsUserDataSourceWrite\") DataSource spcsUserDataSource,\n                                              @Qualifier(\"spcsUserDataSourceRead_0\") DataSource spcsUserSlaveDataSource) {\n            // 配置多数据源\n            Map<Object, Object> dsMap = new HashMap<>(5);\n            dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n            dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n    \n            DynamicDataSource dynamicDataSource = new DynamicDataSource();\n            // 默认数据源\n            dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n            dynamicDataSource.setTargetDataSources(dsMap);\n            return dynamicDataSource;\n        }\n    \n    }\n\n> *注意*：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。\n\n## 2. 实现自己的数据源路由（关键）\n\n相当于多数据源的路由功能。\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import org.slf4j.Logger;\n    import org.slf4j.LoggerFactory;\n    import org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n    \n    public class DynamicDataSource extends AbstractRoutingDataSource {\n    \n        private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n    \n        @Override\n        protected Object determineCurrentLookupKey() {\n            log.debug(\"数据源为{}\", DataSourceContextHolder.getDS());\n            //可以做一个简单的负载均衡策略\n            return DataSourceContextHolder.getDS();\n        }\n    \n    }\n    \n## 3. 持有数据源\n\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    \n    import org.apache.logging.log4j.LogManager;\n    import org.apache.logging.log4j.Logger;\n    \n    public class DataSourceContextHolder {\n    \n        private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n    \n        private static final ThreadLocal<String> contextHolder = new ThreadLocal<>();\n    \n        /**\n         * 设置数据源名。\n         * @param dbType\n         */\n        public static void setDS(String dbType) {\n            if (dbType == null) {\n                throw new NullPointerException(\"数据源不能null\");\n            }\n            LOGGER.debug(\"切换到{}数据源\", dbType);\n            contextHolder.set(dbType);\n        }\n    \n        /**\n         * 获取数据源名。\n         * @return\n         */\n        public static String getDS() {\n            return (contextHolder.get());\n        }\n    \n        /**\n         * 清除数据源名。\n         */\n        public static void clearDS() {\n            contextHolder.remove();\n        }\n    }\n    \n## 4. 通过aop，注解方式持有数据源\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.ds.DSInject;\n    import com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\n    import org.aspectj.lang.JoinPoint;\n    import org.aspectj.lang.annotation.After;\n    import org.aspectj.lang.annotation.Aspect;\n    import org.aspectj.lang.annotation.Before;\n    import org.aspectj.lang.reflect.MethodSignature;\n    import org.springframework.stereotype.Component;\n    \n    import java.lang.reflect.Method;\n    \n    /**\n     *  解析注入的数据源。\n     */\n    @Aspect\n    @Component\n    public class DynamicDataSourceAspect {\n    \n    \t@Before(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void beforeSwitchDS(JoinPoint point) {\n    \n    \t\t// 获得当前访问的class\n    \t\tClass<?> className = point.getTarget().getClass();\n    \n    \t\t// 获得访问的方法名\n    \t\tString methodName = point.getSignature().getName();\n    \t\t// 得到方法的参数的类型\n    \t\tClass[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n    \t\tString dataSource = DSType.SPCS_USER.name(); //默认主库\n    \t\ttry {\n    \t\t\t// 得到访问的方法对象\n    \t\t\tMethod method = className.getMethod(methodName, argClass);\n    \n    \t\t\t// 判断是否存在@DBInject注解\n    \t\t\tif (method.isAnnotationPresent(DSInject.class)) {\n    \t\t\t\tDSInject annotation = method.getAnnotation(DSInject.class);\n    \t\t\t\t// 取出注解中的数据源名\n    \t\t\t\tdataSource = annotation.value();\n    \t\t\t}\n    \t\t} catch (Exception e) {\n    \t\t\te.printStackTrace();\n    \t\t}\n    \n    \t\t// 切换数据源\n    \t\tDataSourceContextHolder.setDS(dataSource);\n    \n    \t}\n    \n    \t@After(\"@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)\")\n    \tpublic void afterSwitchDS(JoinPoint point) {\n    \t\tDataSourceContextHolder.clearDS();\n    \t}\n    }\n\n---\n    package com.ymu.spcselling.infrastructure.dao.ds;\n    \n    import java.lang.annotation.Documented;\n    import java.lang.annotation.ElementType;\n    import java.lang.annotation.Retention;\n    import java.lang.annotation.RetentionPolicy;\n    import java.lang.annotation.Target;\n    \n    @Target({ ElementType.PARAMETER, ElementType.METHOD })\n    @Retention(RetentionPolicy.RUNTIME)\n    @Documented\n    public @interface DSInject {\n    \tString value() default \"\";\n    }\n\n## 5. 配置jpa\n\n    package service.basic.user.config.ds;\n    \n    import com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\n    import net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\n    import org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.context.annotation.Primary;\n    import org.springframework.core.env.Environment;\n    import org.springframework.data.jpa.repository.config.EnableJpaRepositories;\n    import org.springframework.orm.jpa.JpaTransactionManager;\n    import org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\n    import org.springframework.transaction.PlatformTransactionManager;\n    import org.springframework.transaction.annotation.EnableTransactionManagement;\n    import service.basic.user.common.Constants;\n    \n    import javax.persistence.EntityManager;\n    import javax.sql.DataSource;\n    import java.util.Map;\n    \n    @Configuration\n    @EnableTransactionManagement\n    @EnableJpaRepositories(entityManagerFactoryRef = \"entityManagerFactorySpcsUserDB\", transactionManagerRef = \"transactionManagerSpcsUserDB\", basePackages = {\n            Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\n    public class SpcsUserDBConfig {\n    \n        @Autowired\n        Environment ev;\n    \n        @Autowired\n        @Qualifier(\"dataSource\")\n        private DataSource dataSource; // 数据源\n    \n        @Primary\n        @Bean(name = \"entityManagerSpcsUser\")\n        public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n            return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n        }\n    \n        @Primary\n        @Bean(name = \"entityManagerFactorySpcsUserDB\")\n        public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n            if (ev.acceptsProfiles(\"dev\") || ev.acceptsProfiles(\"test\")\n                    || ev.acceptsProfiles(\"update\")) {\n                dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n            }\n            return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                    .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                    .persistenceUnit(\"spcsUserUnit\").build(); //实体管理器别名,多数据元要设置。\n        }\n    \n        private Map<String, String> getVendorProperties(DataSource dataSource) {\n            JpaProperties jpaProperties = new JpaProperties();\n            return jpaProperties.getHibernateProperties(dataSource);\n        }\n    \n        /**\n         * 开启事务。\n         *\n         * @param builder\n         * @return\n         */\n        @Primary\n        @Bean(name = \"transactionManagerSpcsUserDB\")\n        public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n            return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n        }\n    \n    }\n    \n> *注意*: 注入的数据源为上面配置的动态数据源。\n@Autowired\n@Qualifier(\"dataSource\")\nprivate DataSource dataSource; // 数据源    \n\n\n## 6. 配置spring jdbcTemplate\n\n    package service.basic.user.config.ds;\n    \n    import org.springframework.beans.factory.annotation.Autowired;\n    import org.springframework.beans.factory.annotation.Qualifier;\n    import org.springframework.boot.autoconfigure.AutoConfigureAfter;\n    import org.springframework.context.annotation.Bean;\n    import org.springframework.context.annotation.Configuration;\n    import org.springframework.jdbc.core.JdbcTemplate;\n    \n    import javax.sql.DataSource;\n    \n    @Configuration\n    @AutoConfigureAfter(DataSourceConfig.class)\n    public class JdbcTemplateConfig {\n    \n        @Autowired\n        @Qualifier(value = \"dataSource\")\n        private DataSource dataSource;\n    \n        /**\n         * spring jdbc。\n         *\n         * @return\n         */\n        @Bean(name = \"jdbcTemplate\")\n        @Qualifier(\"jdbcTemplate\")\n        public JdbcTemplate jdbcTemplate() {\n            return new JdbcTemplate(dataSource);\n        }\n    }\n\n\n## 7. 使用\n\n- 方式一：\n可在service层，也可在dao层做。\n在开始操作数据库前调用：\n\n\n    DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n    \n    //查询数据\n    \n    DataSourceContextHolder.clearDS();\n    \n- 方式二：\n通过注解，可在service层，也可在dao层做。\n\n\n    @DSInject(value = Constants.SPCS_USER_SLAVE)\n    @Override\n    public User getUserByMobile(String mobile) {\n        return userDao.findUserByMobile(mobile);\n    }    ","slug":"spring-jpa-multiple-datasource","published":1,"updated":"2017-11-14T08:30:11.851Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckph00378orazloys5k5","content":"<p>在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。</p>\n<h2 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h2><p>采用阿里druid数据源配置连接池。</p>\n<p>具体配置如下：</p>\n<pre><code>package service.basic.user.config.ds;\n\nimport com.alibaba.druid.filter.Filter;\nimport com.alibaba.druid.filter.logging.Log4j2Filter;\nimport com.alibaba.druid.filter.stat.StatFilter;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.wall.WallConfig;\nimport com.alibaba.druid.wall.WallFilter;\nimport com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.*;\nimport org.springframework.core.env.Environment;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * 配置数据源\n */\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * druid监控filter配置。\n     * @return\n     */\n    @Bean\n    public StatFilter statFilter() {\n        StatFilter statFilter = new StatFilter();\n        statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n        statFilter.setLogSlowSql(true); //日志记录慢sql\n        statFilter.setMergeSql(true); //相同sql合并\n        return statFilter;\n    }\n\n    //----------- sql注入攻击防御配置 start ---------//\n\n    @Bean\n    public WallConfig wallConfig() {\n        WallConfig wallConfig = new WallConfig();\n        wallConfig.setDir(&quot;classpath:druid/wall/mysql&quot;); //sql过滤规则装载位置。\n        return wallConfig;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n        WallFilter wallFilter = new WallFilter();\n        wallFilter.setDbType(&quot;mysql&quot;); //指定数据库类型。\n        wallFilter.setConfig(wallConfig());\n        return wallFilter;\n    }\n\n    //----------- sql注入攻击防御配置 end ---------//\n\n\n    /**\n     * 打印sql语句。\n     * @return\n     */\n    @Bean(name = &quot;log4j2Filter&quot;)\n    public Log4j2Filter log4j2Filter() {\n        Log4j2Filter log4j2Filter = new Log4j2Filter();\n        log4j2Filter.setConnectionLogEnabled(false);\n        log4j2Filter.setResultSetLogEnabled(true); //显示sql\n        log4j2Filter.setDataSourceLogEnabled(false);\n        log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n        log4j2Filter.setStatementLogEnabled(false);\n        return log4j2Filter;\n    }\n\n\n\n    //-------------- 数据源配置 start ---------------//\n\n    /**\n     * 会员主库（spcs_user）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceWrite&quot;)\n    @Qualifier(&quot;spcsUserDataSourceWrite&quot;)\n    public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n    /**\n     * 会员从库（spcs_user_slave）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceRead_0&quot;)\n    @Qualifier(&quot;spcsUserDataSourceRead_0&quot;)\n    public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;spcsUserDataSourceWrite&quot;,&quot;spcsUserDataSourceRead_0&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;spcsUserDataSourceWrite&quot;) DataSource spcsUserDataSource,\n                                          @Qualifier(&quot;spcsUserDataSourceRead_0&quot;) DataSource spcsUserSlaveDataSource) {\n        // 配置多数据源\n        Map&lt;Object, Object&gt; dsMap = new HashMap&lt;&gt;(5);\n        dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n        dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        // 默认数据源\n        dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n        dynamicDataSource.setTargetDataSources(dsMap);\n        return dynamicDataSource;\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。</p>\n</blockquote>\n<h2 id=\"2-实现自己的数据源路由（关键）\"><a href=\"#2-实现自己的数据源路由（关键）\" class=\"headerlink\" title=\"2. 实现自己的数据源路由（关键）\"></a>2. 实现自己的数据源路由（关键）</h2><p>相当于多数据源的路由功能。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.debug(&quot;数据源为{}&quot;, DataSourceContextHolder.getDS());\n        //可以做一个简单的负载均衡策略\n        return DataSourceContextHolder.getDS();\n    }\n\n}\n</code></pre><h2 id=\"3-持有数据源\"><a href=\"#3-持有数据源\" class=\"headerlink\" title=\"3. 持有数据源\"></a>3. 持有数据源</h2><pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class DataSourceContextHolder {\n\n    private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n\n    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();\n\n    /**\n     * 设置数据源名。\n     * @param dbType\n     */\n    public static void setDS(String dbType) {\n        if (dbType == null) {\n            throw new NullPointerException(&quot;数据源不能null&quot;);\n        }\n        LOGGER.debug(&quot;切换到{}数据源&quot;, dbType);\n        contextHolder.set(dbType);\n    }\n\n    /**\n     * 获取数据源名。\n     * @return\n     */\n    public static String getDS() {\n        return (contextHolder.get());\n    }\n\n    /**\n     * 清除数据源名。\n     */\n    public static void clearDS() {\n        contextHolder.remove();\n    }\n}\n</code></pre><h2 id=\"4-通过aop，注解方式持有数据源\"><a href=\"#4-通过aop，注解方式持有数据源\" class=\"headerlink\" title=\"4. 通过aop，注解方式持有数据源\"></a>4. 通过aop，注解方式持有数据源</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.ds.DSInject;\nimport com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n *  解析注入的数据源。\n */\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    @Before(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void beforeSwitchDS(JoinPoint point) {\n\n        // 获得当前访问的class\n        Class&lt;?&gt; className = point.getTarget().getClass();\n\n        // 获得访问的方法名\n        String methodName = point.getSignature().getName();\n        // 得到方法的参数的类型\n        Class[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n        String dataSource = DSType.SPCS_USER.name(); //默认主库\n        try {\n            // 得到访问的方法对象\n            Method method = className.getMethod(methodName, argClass);\n\n            // 判断是否存在@DBInject注解\n            if (method.isAnnotationPresent(DSInject.class)) {\n                DSInject annotation = method.getAnnotation(DSInject.class);\n                // 取出注解中的数据源名\n                dataSource = annotation.value();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 切换数据源\n        DataSourceContextHolder.setDS(dataSource);\n\n    }\n\n    @After(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void afterSwitchDS(JoinPoint point) {\n        DataSourceContextHolder.clearDS();\n    }\n}\n</code></pre><hr>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface DSInject {\n    String value() default &quot;&quot;;\n}\n</code></pre><h2 id=\"5-配置jpa\"><a href=\"#5-配置jpa\" class=\"headerlink\" title=\"5. 配置jpa\"></a>5. 配置jpa</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\nimport net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport service.basic.user.common.Constants;\n\nimport javax.persistence.EntityManager;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactorySpcsUserDB&quot;, transactionManagerRef = &quot;transactionManagerSpcsUserDB&quot;, basePackages = {\n        Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\npublic class SpcsUserDBConfig {\n\n    @Autowired\n    Environment ev;\n\n    @Autowired\n    @Qualifier(&quot;dataSource&quot;)\n    private DataSource dataSource; // 数据源\n\n    @Primary\n    @Bean(name = &quot;entityManagerSpcsUser&quot;)\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = &quot;entityManagerFactorySpcsUserDB&quot;)\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n        if (ev.acceptsProfiles(&quot;dev&quot;) || ev.acceptsProfiles(&quot;test&quot;)\n                || ev.acceptsProfiles(&quot;update&quot;)) {\n            dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n        }\n        return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                .persistenceUnit(&quot;spcsUserUnit&quot;).build(); //实体管理器别名,多数据元要设置。\n    }\n\n    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {\n        JpaProperties jpaProperties = new JpaProperties();\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    /**\n     * 开启事务。\n     *\n     * @param builder\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;transactionManagerSpcsUserDB&quot;)\n    public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>: 注入的数据源为上面配置的动态数据源。<br>@Autowired<br>@Qualifier(“dataSource”)<br>private DataSource dataSource; // 数据源    </p>\n</blockquote>\n<h2 id=\"6-配置spring-jdbcTemplate\"><a href=\"#6-配置spring-jdbcTemplate\" class=\"headerlink\" title=\"6. 配置spring jdbcTemplate\"></a>6. 配置spring jdbcTemplate</h2><pre><code>package service.basic.user.config.ds;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@AutoConfigureAfter(DataSourceConfig.class)\npublic class JdbcTemplateConfig {\n\n    @Autowired\n    @Qualifier(value = &quot;dataSource&quot;)\n    private DataSource dataSource;\n\n    /**\n     * spring jdbc。\n     *\n     * @return\n     */\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    @Qualifier(&quot;jdbcTemplate&quot;)\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource);\n    }\n}\n</code></pre><h2 id=\"7-使用\"><a href=\"#7-使用\" class=\"headerlink\" title=\"7. 使用\"></a>7. 使用</h2><ul>\n<li>方式一：<br>可在service层，也可在dao层做。<br>在开始操作数据库前调用：</li>\n</ul>\n<pre><code>DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n\n//查询数据\n\nDataSourceContextHolder.clearDS();\n</code></pre><ul>\n<li>方式二：<br>通过注解，可在service层，也可在dao层做。</li>\n</ul>\n<pre><code>@DSInject(value = Constants.SPCS_USER_SLAVE)\n@Override\npublic User getUserByMobile(String mobile) {\n    return userDao.findUserByMobile(mobile);\n}    \n</code></pre>","site":{"data":{}},"excerpt":"","more":"<p>在代码层面配置多数据源，手动或者注解方式自动切换数据源，达到读写分离的目的。可以jpa，jdbc，mybatis共存。</p>\n<h2 id=\"1-配置数据源\"><a href=\"#1-配置数据源\" class=\"headerlink\" title=\"1. 配置数据源\"></a>1. 配置数据源</h2><p>采用阿里druid数据源配置连接池。</p>\n<p>具体配置如下：</p>\n<pre><code>package service.basic.user.config.ds;\n\nimport com.alibaba.druid.filter.Filter;\nimport com.alibaba.druid.filter.logging.Log4j2Filter;\nimport com.alibaba.druid.filter.stat.StatFilter;\nimport com.alibaba.druid.pool.DruidDataSource;\nimport com.alibaba.druid.wall.WallConfig;\nimport com.alibaba.druid.wall.WallFilter;\nimport com.ymu.spcselling.infrastructure.dao.ds.DynamicDataSource;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.context.annotation.*;\nimport org.springframework.core.env.Environment;\n\nimport javax.sql.DataSource;\nimport java.sql.SQLException;\nimport java.util.ArrayList;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\n\n/**\n * 配置数据源\n */\n@Configuration\npublic class DataSourceConfig {\n\n    /**\n     * druid监控filter配置。\n     * @return\n     */\n    @Bean\n    public StatFilter statFilter() {\n        StatFilter statFilter = new StatFilter();\n        statFilter.setSlowSqlMillis(5 * 1000); //超过5秒执行的为慢sql\n        statFilter.setLogSlowSql(true); //日志记录慢sql\n        statFilter.setMergeSql(true); //相同sql合并\n        return statFilter;\n    }\n\n    //----------- sql注入攻击防御配置 start ---------//\n\n    @Bean\n    public WallConfig wallConfig() {\n        WallConfig wallConfig = new WallConfig();\n        wallConfig.setDir(&quot;classpath:druid/wall/mysql&quot;); //sql过滤规则装载位置。\n        return wallConfig;\n    }\n\n    @Bean\n    public WallFilter wallFilter() {\n        WallFilter wallFilter = new WallFilter();\n        wallFilter.setDbType(&quot;mysql&quot;); //指定数据库类型。\n        wallFilter.setConfig(wallConfig());\n        return wallFilter;\n    }\n\n    //----------- sql注入攻击防御配置 end ---------//\n\n\n    /**\n     * 打印sql语句。\n     * @return\n     */\n    @Bean(name = &quot;log4j2Filter&quot;)\n    public Log4j2Filter log4j2Filter() {\n        Log4j2Filter log4j2Filter = new Log4j2Filter();\n        log4j2Filter.setConnectionLogEnabled(false);\n        log4j2Filter.setResultSetLogEnabled(true); //显示sql\n        log4j2Filter.setDataSourceLogEnabled(false);\n        log4j2Filter.setStatementExecutableSqlLogEnable(true); //输出可执行的SQL\n        log4j2Filter.setStatementLogEnabled(false);\n        return log4j2Filter;\n    }\n\n\n\n    //-------------- 数据源配置 start ---------------//\n\n    /**\n     * 会员主库（spcs_user）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceWrite&quot;)\n    @Qualifier(&quot;spcsUserDataSourceWrite&quot;)\n    public DataSource spcsUserDataSource(@Autowired SpcsUserDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        dataSource.setUseGlobalDataSourceStat(true); //合并多个DruidDataSource的监控数据\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n    /**\n     * 会员从库（spcs_user_slave）数据源。\n     *\n     * @return\n     * @throws SQLException\n     */\n    @Bean(name = &quot;spcsUserDataSourceRead_0&quot;)\n    @Qualifier(&quot;spcsUserDataSourceRead_0&quot;)\n    public DataSource spcsUserSlaveDataSource(@Autowired SpcsUserSlaveDSArgs args) throws SQLException {\n        DruidDataSource dataSource = new DruidDataSource();\n        dataSource.setUrl(args.getUrl());\n        dataSource.setUsername(args.getUsername());\n        dataSource.setPassword(args.getPassword());\n        dataSource.setDriverClassName(args.getDriverClassName());\n        dataSource.setMinIdle(args.getMinIdle());\n        dataSource.setInitialSize(args.getInitialSize());\n        dataSource.setMaxActive(args.getMaxActive());\n        dataSource.setMaxWait(args.getMaxWait());\n        dataSource.setTimeBetweenEvictionRunsMillis(args.getTimeBetweenEvictionRunsMillis());\n        dataSource.setMinEvictableIdleTimeMillis(args.getMinEvictableIdleTimeMillis());\n\n        List&lt;Filter&gt; proxyFilters = new ArrayList&lt;&gt;();\n        proxyFilters.add(statFilter());\n        proxyFilters.add(log4j2Filter());\n        proxyFilters.add(wallFilter());\n        dataSource.setProxyFilters(proxyFilters);\n\n        return dataSource;\n    }\n\n\n    /**\n     * 动态数据源: 通过AOP在不同数据源之间动态切换\n     *\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;dataSource&quot;)\n    @Scope(&quot;singleton&quot;)\n    @DependsOn({&quot;spcsUserDataSourceWrite&quot;,&quot;spcsUserDataSourceRead_0&quot;}) //要加入这个注解，在数据源初始化之后，再初始化本bean，否则会出现循环依赖注入无法启动。\n    public DataSource dynamicDataSource(@Qualifier(&quot;spcsUserDataSourceWrite&quot;) DataSource spcsUserDataSource,\n                                          @Qualifier(&quot;spcsUserDataSourceRead_0&quot;) DataSource spcsUserSlaveDataSource) {\n        // 配置多数据源\n        Map&lt;Object, Object&gt; dsMap = new HashMap&lt;&gt;(5);\n        dsMap.put(DSType.SPCS_USER.name(), spcsUserDataSource);\n        dsMap.put(DSType.SPCS_USER_SLAVE.name(), spcsUserSlaveDataSource);\n\n        DynamicDataSource dynamicDataSource = new DynamicDataSource();\n        // 默认数据源\n        dynamicDataSource.setDefaultTargetDataSource(spcsUserDataSource);\n        dynamicDataSource.setTargetDataSources(dsMap);\n        return dynamicDataSource;\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>：dynamicDataSource中一定要加入注解 @Primary，单多个数据元时候，默认取该个，避免无法区分。另外特别注意注解：@DependsOn。一定要加该注解，在实际实际数据源注入后，再注入动态数据源，否则会出现循环依赖导致系统无法启动的局面。</p>\n</blockquote>\n<h2 id=\"2-实现自己的数据源路由（关键）\"><a href=\"#2-实现自己的数据源路由（关键）\" class=\"headerlink\" title=\"2. 实现自己的数据源路由（关键）\"></a>2. 实现自己的数据源路由（关键）</h2><p>相当于多数据源的路由功能。</p>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport org.slf4j.Logger;\nimport org.slf4j.LoggerFactory;\nimport org.springframework.jdbc.datasource.lookup.AbstractRoutingDataSource;\n\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n    private static final Logger log = LoggerFactory.getLogger(DynamicDataSource.class);\n\n    @Override\n    protected Object determineCurrentLookupKey() {\n        log.debug(&quot;数据源为{}&quot;, DataSourceContextHolder.getDS());\n        //可以做一个简单的负载均衡策略\n        return DataSourceContextHolder.getDS();\n    }\n\n}\n</code></pre><h2 id=\"3-持有数据源\"><a href=\"#3-持有数据源\" class=\"headerlink\" title=\"3. 持有数据源\"></a>3. 持有数据源</h2><pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\n\nimport org.apache.logging.log4j.LogManager;\nimport org.apache.logging.log4j.Logger;\n\npublic class DataSourceContextHolder {\n\n    private static final Logger LOGGER = LogManager.getLogger(DataSourceContextHolder.class);\n\n    private static final ThreadLocal&lt;String&gt; contextHolder = new ThreadLocal&lt;&gt;();\n\n    /**\n     * 设置数据源名。\n     * @param dbType\n     */\n    public static void setDS(String dbType) {\n        if (dbType == null) {\n            throw new NullPointerException(&quot;数据源不能null&quot;);\n        }\n        LOGGER.debug(&quot;切换到{}数据源&quot;, dbType);\n        contextHolder.set(dbType);\n    }\n\n    /**\n     * 获取数据源名。\n     * @return\n     */\n    public static String getDS() {\n        return (contextHolder.get());\n    }\n\n    /**\n     * 清除数据源名。\n     */\n    public static void clearDS() {\n        contextHolder.remove();\n    }\n}\n</code></pre><h2 id=\"4-通过aop，注解方式持有数据源\"><a href=\"#4-通过aop，注解方式持有数据源\" class=\"headerlink\" title=\"4. 通过aop，注解方式持有数据源\"></a>4. 通过aop，注解方式持有数据源</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.ds.DSInject;\nimport com.ymu.spcselling.infrastructure.dao.ds.DataSourceContextHolder;\nimport org.aspectj.lang.JoinPoint;\nimport org.aspectj.lang.annotation.After;\nimport org.aspectj.lang.annotation.Aspect;\nimport org.aspectj.lang.annotation.Before;\nimport org.aspectj.lang.reflect.MethodSignature;\nimport org.springframework.stereotype.Component;\n\nimport java.lang.reflect.Method;\n\n/**\n *  解析注入的数据源。\n */\n@Aspect\n@Component\npublic class DynamicDataSourceAspect {\n\n    @Before(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void beforeSwitchDS(JoinPoint point) {\n\n        // 获得当前访问的class\n        Class&lt;?&gt; className = point.getTarget().getClass();\n\n        // 获得访问的方法名\n        String methodName = point.getSignature().getName();\n        // 得到方法的参数的类型\n        Class[] argClass = ((MethodSignature) point.getSignature()).getParameterTypes();\n        String dataSource = DSType.SPCS_USER.name(); //默认主库\n        try {\n            // 得到访问的方法对象\n            Method method = className.getMethod(methodName, argClass);\n\n            // 判断是否存在@DBInject注解\n            if (method.isAnnotationPresent(DSInject.class)) {\n                DSInject annotation = method.getAnnotation(DSInject.class);\n                // 取出注解中的数据源名\n                dataSource = annotation.value();\n            }\n        } catch (Exception e) {\n            e.printStackTrace();\n        }\n\n        // 切换数据源\n        DataSourceContextHolder.setDS(dataSource);\n\n    }\n\n    @After(&quot;@annotation(com.ymu.spcselling.infrastructure.dao.ds.DSInject)&quot;)\n    public void afterSwitchDS(JoinPoint point) {\n        DataSourceContextHolder.clearDS();\n    }\n}\n</code></pre><hr>\n<pre><code>package com.ymu.spcselling.infrastructure.dao.ds;\n\nimport java.lang.annotation.Documented;\nimport java.lang.annotation.ElementType;\nimport java.lang.annotation.Retention;\nimport java.lang.annotation.RetentionPolicy;\nimport java.lang.annotation.Target;\n\n@Target({ ElementType.PARAMETER, ElementType.METHOD })\n@Retention(RetentionPolicy.RUNTIME)\n@Documented\npublic @interface DSInject {\n    String value() default &quot;&quot;;\n}\n</code></pre><h2 id=\"5-配置jpa\"><a href=\"#5-配置jpa\" class=\"headerlink\" title=\"5. 配置jpa\"></a>5. 配置jpa</h2><pre><code>package service.basic.user.config.ds;\n\nimport com.ymu.spcselling.infrastructure.dao.BaseRepositoryFactoryBean;\nimport net.sf.log4jdbc.sql.jdbcapi.DataSourceSpy;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.orm.jpa.JpaProperties;\nimport org.springframework.boot.orm.jpa.EntityManagerFactoryBuilder;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.context.annotation.Primary;\nimport org.springframework.core.env.Environment;\nimport org.springframework.data.jpa.repository.config.EnableJpaRepositories;\nimport org.springframework.orm.jpa.JpaTransactionManager;\nimport org.springframework.orm.jpa.LocalContainerEntityManagerFactoryBean;\nimport org.springframework.transaction.PlatformTransactionManager;\nimport org.springframework.transaction.annotation.EnableTransactionManagement;\nimport service.basic.user.common.Constants;\n\nimport javax.persistence.EntityManager;\nimport javax.sql.DataSource;\nimport java.util.Map;\n\n@Configuration\n@EnableTransactionManagement\n@EnableJpaRepositories(entityManagerFactoryRef = &quot;entityManagerFactorySpcsUserDB&quot;, transactionManagerRef = &quot;transactionManagerSpcsUserDB&quot;, basePackages = {\n        Constants.SPCS_USER_REPOSITORY_PACKAGE_PATH}, repositoryFactoryBeanClass = BaseRepositoryFactoryBean.class)\npublic class SpcsUserDBConfig {\n\n    @Autowired\n    Environment ev;\n\n    @Autowired\n    @Qualifier(&quot;dataSource&quot;)\n    private DataSource dataSource; // 数据源\n\n    @Primary\n    @Bean(name = &quot;entityManagerSpcsUser&quot;)\n    public EntityManager entityManager(EntityManagerFactoryBuilder builder) {\n        return entityManagerFactorySpcsUserDB(builder).getObject().createEntityManager();\n    }\n\n    @Primary\n    @Bean(name = &quot;entityManagerFactorySpcsUserDB&quot;)\n    public LocalContainerEntityManagerFactoryBean entityManagerFactorySpcsUserDB(EntityManagerFactoryBuilder builder) {\n        if (ev.acceptsProfiles(&quot;dev&quot;) || ev.acceptsProfiles(&quot;test&quot;)\n                || ev.acceptsProfiles(&quot;update&quot;)) {\n            dataSource = new DataSourceSpy(dataSource); // log4jdbc打印sql日志。\n        }\n        return builder.dataSource(dataSource).properties(getVendorProperties(dataSource))\n                .packages(Constants.SPCS_USER_ENTITY_PACKAGE_PATH)\n                .persistenceUnit(&quot;spcsUserUnit&quot;).build(); //实体管理器别名,多数据元要设置。\n    }\n\n    private Map&lt;String, String&gt; getVendorProperties(DataSource dataSource) {\n        JpaProperties jpaProperties = new JpaProperties();\n        return jpaProperties.getHibernateProperties(dataSource);\n    }\n\n    /**\n     * 开启事务。\n     *\n     * @param builder\n     * @return\n     */\n    @Primary\n    @Bean(name = &quot;transactionManagerSpcsUserDB&quot;)\n    public PlatformTransactionManager transactionManagerSpcsUserDB(EntityManagerFactoryBuilder builder) {\n        return new JpaTransactionManager(entityManagerFactorySpcsUserDB(builder).getObject());\n    }\n\n}\n</code></pre><blockquote>\n<p><em>注意</em>: 注入的数据源为上面配置的动态数据源。<br>@Autowired<br>@Qualifier(“dataSource”)<br>private DataSource dataSource; // 数据源    </p>\n</blockquote>\n<h2 id=\"6-配置spring-jdbcTemplate\"><a href=\"#6-配置spring-jdbcTemplate\" class=\"headerlink\" title=\"6. 配置spring jdbcTemplate\"></a>6. 配置spring jdbcTemplate</h2><pre><code>package service.basic.user.config.ds;\n\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.beans.factory.annotation.Qualifier;\nimport org.springframework.boot.autoconfigure.AutoConfigureAfter;\nimport org.springframework.context.annotation.Bean;\nimport org.springframework.context.annotation.Configuration;\nimport org.springframework.jdbc.core.JdbcTemplate;\n\nimport javax.sql.DataSource;\n\n@Configuration\n@AutoConfigureAfter(DataSourceConfig.class)\npublic class JdbcTemplateConfig {\n\n    @Autowired\n    @Qualifier(value = &quot;dataSource&quot;)\n    private DataSource dataSource;\n\n    /**\n     * spring jdbc。\n     *\n     * @return\n     */\n    @Bean(name = &quot;jdbcTemplate&quot;)\n    @Qualifier(&quot;jdbcTemplate&quot;)\n    public JdbcTemplate jdbcTemplate() {\n        return new JdbcTemplate(dataSource);\n    }\n}\n</code></pre><h2 id=\"7-使用\"><a href=\"#7-使用\" class=\"headerlink\" title=\"7. 使用\"></a>7. 使用</h2><ul>\n<li>方式一：<br>可在service层，也可在dao层做。<br>在开始操作数据库前调用：</li>\n</ul>\n<pre><code>DataSourceContextHolder.setDS(DSType.SPCS_USER_SLAVE.name());\n\n//查询数据\n\nDataSourceContextHolder.clearDS();\n</code></pre><ul>\n<li>方式二：<br>通过注解，可在service层，也可在dao层做。</li>\n</ul>\n<pre><code>@DSInject(value = Constants.SPCS_USER_SLAVE)\n@Override\npublic User getUserByMobile(String mobile) {\n    return userDao.findUserByMobile(mobile);\n}    \n</code></pre>"},{"title":"TypeScript学习(一)","date":"2017-10-13T15:33:23.000Z","_content":"","source":"_posts/tslang-study-one.md","raw":"---\ntitle: TypeScript学习(一)\ndate: 2017-10-13 23:33:23\ncategories: TypeScript\ntags: \n---\n","slug":"tslang-study-one","published":1,"updated":"2017-11-14T08:30:11.854Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckpj00398orayqinq840","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"网站的高性能","date":"2017-10-13T02:33:45.000Z","_content":"_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","source":"_posts/website-high-performance.md","raw":"---\ntitle: 网站的高性能\ndate: 2017-10-13 10:33:45\ncategories: 架构\ntags: website-high-performance\n---\n_何为高性能网站:_\n简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！\n## 1. 网站高性能指标\n### 1.1 响应时间\n发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。\n### 1.2 并发数\n指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。\n> 网站系统注册用户数 > 网站在线用户数 > 网站并发用户数\n### 1.3 吞吐量\n指单位时间内系统处理的请求数量，体现系统的整体处理能力。\n\n衡量表达式：\n- 请求数/秒\n- 页面数/秒\n- 处理的业务数/小时\n\n量化指标：\n- TPS(每秒事务数)\n- HPS(每秒HTTP请求数)\n- QPS(每秒查询数)\n\n### 1.4 性能计数器\n描述服务器或操作系统性能的一些数据指标。\n\n包括（下面部分）：\n> - System Load（系统负载）\n- 对象与线程数\n- 内存使用\n- CPU使用\n- 磁盘与网络I/O\n\n这些指标也是做系统监控的指标。\n\n## 2. 性能测试\n以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。\n\n### 2.1 测试方法：\n> - 负载测试\n- 压力测试\n- 稳定性测试\n\n### 2.2 测试报告\n看下面简单示例：\n\n| 并发数 | 响应时间(ms) | TPS | 错误率(%) | Load(负载) | 内存(GB) |   备注   |\n|:------:| :-----------:|:---:| :------:  | :---------:| :-------:| :-------:|\n|   10   |      500     | 20  |    0      |     5      |    8     | 性能测试 |\n|   20   |      800     | 30  |    0      |     10     |    10    | 性能测试 |\n|   30   |      1000    | 40  |    2      |     15     |    14    | 性能测试 |\n|   40   |      1200    | 45  |   20      |     30     |    16    | 负载测试 |\n|   60   |      2000    | 30  |    40     |     50     |    16    | 压力测试 |\n|   80   |      超时    |  0  |    100    |    不详    |   不详   | 压力测试 |\n\n## 3. 性能优化策略\n系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。\n\n### 3.1 性能分析\n检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。\n\n### 3.2 性能优化方法\n通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。\n\n## 4. Web前端性能优化\n### 4.1浏览器访问优化\n1. 减少页面请求数量\n\n主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。\n\n2. 使用浏览器缓存\n\n缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。\n\n3. 启用压缩\n\n服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。\n\n4. CSS放在页面最上面、js放在页面最下面\n\n浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。\n\n5. 减少Cookie传输\n每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。\n\n### 4.2 CND加速\n\n### 4.3 反向代理\n\n## 5. ","slug":"website-high-performance","published":1,"updated":"2017-11-14T08:30:11.856Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckpm003b8oraherv20ml","content":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n</blockquote>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol>\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol>\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol>\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol>\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>","site":{"data":{}},"excerpt":"","more":"<p><em>何为高性能网站:</em><br>简单点概述就是：客户端发起请求到看到响应数据够快，最好是瞬时响应，这就是高性能。路漫漫其修远兮，吾将上下而求索！</p>\n<h2 id=\"1-网站高性能指标\"><a href=\"#1-网站高性能指标\" class=\"headerlink\" title=\"1. 网站高性能指标\"></a>1. 网站高性能指标</h2><h3 id=\"1-1-响应时间\"><a href=\"#1-1-响应时间\" class=\"headerlink\" title=\"1.1 响应时间\"></a>1.1 响应时间</h3><p>发出请求到收到响应所需要的时间(多次(如：一万次)请求的平均时间)。代表着系统的快慢。</p>\n<h3 id=\"1-2-并发数\"><a href=\"#1-2-并发数\" class=\"headerlink\" title=\"1.2 并发数\"></a>1.2 并发数</h3><p>指系统能够同时处理请求的数目，这个数字也反映了系统的负载特性。对网站而言也就是指同时提交请求的用户数目。</p>\n<blockquote>\n<p>网站系统注册用户数 &gt; 网站在线用户数 &gt; 网站并发用户数</p>\n<h3 id=\"1-3-吞吐量\"><a href=\"#1-3-吞吐量\" class=\"headerlink\" title=\"1.3 吞吐量\"></a>1.3 吞吐量</h3><p>指单位时间内系统处理的请求数量，体现系统的整体处理能力。</p>\n</blockquote>\n<p>衡量表达式：</p>\n<ul>\n<li>请求数/秒</li>\n<li>页面数/秒</li>\n<li>处理的业务数/小时</li>\n</ul>\n<p>量化指标：</p>\n<ul>\n<li>TPS(每秒事务数)</li>\n<li>HPS(每秒HTTP请求数)</li>\n<li>QPS(每秒查询数)</li>\n</ul>\n<h3 id=\"1-4-性能计数器\"><a href=\"#1-4-性能计数器\" class=\"headerlink\" title=\"1.4 性能计数器\"></a>1.4 性能计数器</h3><p>描述服务器或操作系统性能的一些数据指标。</p>\n<p>包括（下面部分）：</p>\n<blockquote>\n<ul>\n<li>System Load（系统负载）</li>\n<li>对象与线程数</li>\n<li>内存使用</li>\n<li>CPU使用</li>\n<li>磁盘与网络I/O</li>\n</ul>\n</blockquote>\n<p>这些指标也是做系统监控的指标。</p>\n<h2 id=\"2-性能测试\"><a href=\"#2-性能测试\" class=\"headerlink\" title=\"2. 性能测试\"></a>2. 性能测试</h2><p>以系统设计初期规划的性能指标为预期目标，对系统不断施加压力，验证系统在资源可接受范围内，是否能达到性能预期。</p>\n<h3 id=\"2-1-测试方法：\"><a href=\"#2-1-测试方法：\" class=\"headerlink\" title=\"2.1 测试方法：\"></a>2.1 测试方法：</h3><blockquote>\n<ul>\n<li>负载测试</li>\n<li>压力测试</li>\n<li>稳定性测试</li>\n</ul>\n</blockquote>\n<h3 id=\"2-2-测试报告\"><a href=\"#2-2-测试报告\" class=\"headerlink\" title=\"2.2 测试报告\"></a>2.2 测试报告</h3><p>看下面简单示例：</p>\n<table>\n<thead>\n<tr>\n<th style=\"text-align:center\">并发数</th>\n<th style=\"text-align:center\">响应时间(ms)</th>\n<th style=\"text-align:center\">TPS</th>\n<th style=\"text-align:center\">错误率(%)</th>\n<th style=\"text-align:center\">Load(负载)</th>\n<th style=\"text-align:center\">内存(GB)</th>\n<th style=\"text-align:center\">备注</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">500</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">5</td>\n<td style=\"text-align:center\">8</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">800</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">10</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">1000</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">2</td>\n<td style=\"text-align:center\">15</td>\n<td style=\"text-align:center\">14</td>\n<td style=\"text-align:center\">性能测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">1200</td>\n<td style=\"text-align:center\">45</td>\n<td style=\"text-align:center\">20</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">负载测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">60</td>\n<td style=\"text-align:center\">2000</td>\n<td style=\"text-align:center\">30</td>\n<td style=\"text-align:center\">40</td>\n<td style=\"text-align:center\">50</td>\n<td style=\"text-align:center\">16</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n<tr>\n<td style=\"text-align:center\">80</td>\n<td style=\"text-align:center\">超时</td>\n<td style=\"text-align:center\">0</td>\n<td style=\"text-align:center\">100</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">不详</td>\n<td style=\"text-align:center\">压力测试</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"3-性能优化策略\"><a href=\"#3-性能优化策略\" class=\"headerlink\" title=\"3. 性能优化策略\"></a>3. 性能优化策略</h2><p>系统性能测试达不到预期，则需要找出系统瓶颈，分而治之，逐步优化。</p>\n<h3 id=\"3-1-性能分析\"><a href=\"#3-1-性能分析\" class=\"headerlink\" title=\"3.1 性能分析\"></a>3.1 性能分析</h3><p>检查请求处理的各个环节的日志，分析哪个环节响应时间不合理，超过预期；然后检查监控数据，分析影响性能的主要因素是内存、磁盘、网络、还是cpu，是代码问题还是架构不合理，或者是系统资源确实不够用了。</p>\n<h3 id=\"3-2-性能优化方法\"><a href=\"#3-2-性能优化方法\" class=\"headerlink\" title=\"3.2 性能优化方法\"></a>3.2 性能优化方法</h3><p>通常情况下，web系统可分为前端性能优化、应用服务器性能优化、存储服务器性能优化三大类。</p>\n<h2 id=\"4-Web前端性能优化\"><a href=\"#4-Web前端性能优化\" class=\"headerlink\" title=\"4. Web前端性能优化\"></a>4. Web前端性能优化</h2><h3 id=\"4-1浏览器访问优化\"><a href=\"#4-1浏览器访问优化\" class=\"headerlink\" title=\"4.1浏览器访问优化\"></a>4.1浏览器访问优化</h3><ol>\n<li>减少页面请求数量</li>\n</ol>\n<p>主要手段是合并CSS、合并js，合并图片。讲浏览器一次访问需要的js、css资源合并成一个文件。多张图片也可以合并。一个页面，服务端也尽可能在一次性请求中返回全部数据，以减少多次请求获取数据。</p>\n<ol>\n<li>使用浏览器缓存</li>\n</ol>\n<p>缓存静态资源js、css、图片。通过设置HTTP头Cache-Control和Expires属性。</p>\n<ol>\n<li>启用压缩</li>\n</ol>\n<p>服务端对文件压缩返回，浏览器解压，有效减少通信传输的数据量。</p>\n<ol>\n<li>CSS放在页面最上面、js放在页面最下面</li>\n</ol>\n<p>浏览器回下载完所有css才对整个页面渲染。浏览器下载完js回马上执行，可能阻塞页面，造成页面缓慢，所以放在下面。但是在界面解析时就要用到的js则放在上面。</p>\n<ol>\n<li>减少Cookie传输<br>每次请求都包含Cookie，所以Cookie数据量大的话必然会影响传输速度。因此，要慎重使用，必要的才保存。</li>\n</ol>\n<h3 id=\"4-2-CND加速\"><a href=\"#4-2-CND加速\" class=\"headerlink\" title=\"4.2 CND加速\"></a>4.2 CND加速</h3><h3 id=\"4-3-反向代理\"><a href=\"#4-3-反向代理\" class=\"headerlink\" title=\"4.3 反向代理\"></a>4.3 反向代理</h3><h2 id=\"5\"><a href=\"#5\" class=\"headerlink\" title=\"5.\"></a>5.</h2>"},{"title":"teamcity持续集成使用","date":"2017-10-30T01:18:57.000Z","_content":"","source":"_posts/teamcity-use-start.md","raw":"---\ntitle: teamcity持续集成使用\ndate: 2017-10-30 09:18:57\ncategories: teamcity\ntags: teamcity-start\n---\n","slug":"teamcity-use-start","published":1,"updated":"2017-11-14T08:30:11.853Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjarwckpq003f8oraz8buyg29","content":"","site":{"data":{}},"excerpt":"","more":""}],"PostAsset":[{"_id":"source/_posts/api-version/a.png","post":"cjarwckmj00018orai2p9ei1k","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/apidoc-java/a.png","post":"cjarwckmo00028ora63i21kbo","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/Keepalived-LVS-Nginx/a.png","post":"cjarwckmu00058ora7i0lua8v","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/distributed-id-snowflake/a.png","post":"cjarwcknf000g8orajotthrmu","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/docker-install-centos7/a.png","post":"cjarwcknj000m8orak8qj1nn3","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/github-fork-repo-update/favicon.ico","post":"cjarwckno000s8oradjyzqkr7","slug":"favicon.ico","modified":1,"renderable":1},{"_id":"source/_posts/hashicorp-vault/a.png","post":"cjarwcknr000x8ora39wwmew2","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/redis-cluster-centos/a.png","post":"cjarwckov00288orafw18nvbh","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/restful-api-dev/a.png","post":"cjarwckox002c8orax47qi90a","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/sboot-dev-error-show/a.png","post":"cjarwckp1002h8ora20cmhe3x","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/sboot-change-contextpath/a.png","post":"cjarwckoz002d8oraqk53zzw8","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-feign-anyquestion/a.png","post":"cjarwckp3002j8ora508j4qdo","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-exception/a.png","post":"cjarwckp5002m8ora3zi9w285","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-filters/a.png","post":"cjarwckp6002q8oralzqrcj32","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/microservice-think/a.png","post":"cjarwckpa002w8orary0im9k5","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/scloud-zuul-start/a.png","post":"cjarwckpc002y8ora49vh7lgh","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/website-high-performance/favicon.ico","post":"cjarwckpm003b8oraherv20ml","slug":"favicon.ico","modified":1,"renderable":1},{"_id":"source/_posts/http-protocol-overview/a.png","post":"cjarwcknx00158orah2jj8uh9","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/http-protocol-overview/b.png","post":"cjarwcknx00158orah2jj8uh9","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/linux-command-use/a.png","post":"cjarwckoh001t8orajl7kqk09","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/linux-command-use/b.png","post":"cjarwckoh001t8orajl7kqk09","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/a.png","post":"cjarwckoq00228oraoy45ozq4","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/b.png","slug":"b.png","post":"cjarwckoq00228oraoy45ozq4","modified":1,"renderable":0},{"_id":"source/_posts/pivotal-web-service-start/c.png","post":"cjarwckoq00228oraoy45ozq4","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/pivotal-web-service-start/d.png","post":"cjarwckoq00228oraoy45ozq4","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/Shadowsocks-4.0.6.zip","slug":"Shadowsocks-4.0.6.zip","post":"cjarwckp8002s8orautizmcpv","modified":1,"renderable":0},{"_id":"source/_posts/shadowsocks-go/a.png","post":"cjarwckp8002s8orautizmcpv","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/b.png","post":"cjarwckp8002s8orautizmcpv","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/shadowsocks-go/go1.9.2.linux-amd64.tar.gz","slug":"go1.9.2.linux-amd64.tar.gz","post":"cjarwckp8002s8orautizmcpv","modified":1,"renderable":0},{"_id":"source/_posts/centos-maven-nexus/a.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/b.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/c.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/d.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"d.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/e.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/f.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"f.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/g.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"g.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/h.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"h.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/i.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"i.png","modified":1,"renderable":1},{"_id":"source/_posts/centos-maven-nexus/j.png","post":"cjarwcknh000i8oraqq0qkxy2","slug":"j.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/1.png","post":"cjarwcko7001j8oran80tacch","slug":"1.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/10.png","post":"cjarwcko7001j8oran80tacch","slug":"10.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/11.png","post":"cjarwcko7001j8oran80tacch","slug":"11.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/12.png","post":"cjarwcko7001j8oran80tacch","slug":"12.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/13.png","post":"cjarwcko7001j8oran80tacch","slug":"13.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/14.png","post":"cjarwcko7001j8oran80tacch","slug":"14.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/15.png","post":"cjarwcko7001j8oran80tacch","slug":"15.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/2.png","post":"cjarwcko7001j8oran80tacch","slug":"2.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/3.png","post":"cjarwcko7001j8oran80tacch","slug":"3.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/4.png","post":"cjarwcko7001j8oran80tacch","slug":"4.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/5.png","post":"cjarwcko7001j8oran80tacch","slug":"5.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/6.png","post":"cjarwcko7001j8oran80tacch","slug":"6.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/7.png","post":"cjarwcko7001j8oran80tacch","slug":"7.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/8.png","post":"cjarwcko7001j8oran80tacch","slug":"8.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/8_1.png","post":"cjarwcko7001j8oran80tacch","slug":"8_1.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/9.png","post":"cjarwcko7001j8oran80tacch","slug":"9.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/a.png","post":"cjarwcko7001j8oran80tacch","slug":"a.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/b.png","post":"cjarwcko7001j8oran80tacch","slug":"b.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/c.png","post":"cjarwcko7001j8oran80tacch","slug":"c.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/e.png","post":"cjarwcko7001j8oran80tacch","slug":"e.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/f.png","post":"cjarwcko7001j8oran80tacch","slug":"f.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/g.png","post":"cjarwcko7001j8oran80tacch","slug":"g.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/h.png","post":"cjarwcko7001j8oran80tacch","slug":"h.png","modified":1,"renderable":1},{"_id":"source/_posts/jenkins-java-maven/i.png","post":"cjarwcko7001j8oran80tacch","slug":"i.png","modified":1,"renderable":1}],"PostCategory":[{"post_id":"cjarwckmj00018orai2p9ei1k","category_id":"cjarwckmr00038ora05zst9a1","_id":"cjarwckne000e8oramvwi9cxo"},{"post_id":"cjarwckmo00028ora63i21kbo","category_id":"cjarwckmr00038ora05zst9a1","_id":"cjarwckni000j8ora5wzig708"},{"post_id":"cjarwckmu00058ora7i0lua8v","category_id":"cjarwckne000d8ora6bi6zwyn","_id":"cjarwcknm000p8oranvfp4b6y"},{"post_id":"cjarwckmx00068orav8f6qoor","category_id":"cjarwckni000k8oraap36ou42","_id":"cjarwcknr000w8oraqig1pn1x"},{"post_id":"cjarwckn200078ora8mv48y8e","category_id":"cjarwckni000k8oraap36ou42","_id":"cjarwcknu00118ora0b0q7mqu"},{"post_id":"cjarwckn9000b8orapvg8hqqr","category_id":"cjarwcknr000v8oraij6sgifb","_id":"cjarwcknz00178oraqnfd17n8"},{"post_id":"cjarwcknc000c8oraerw7f488","category_id":"cjarwcknv00128ora42bd423s","_id":"cjarwcko4001f8ora9ex133m8"},{"post_id":"cjarwcknf000g8orajotthrmu","category_id":"cjarwcknv00128ora42bd423s","_id":"cjarwcko9001l8ora5ps221fd"},{"post_id":"cjarwcko3001d8orank9c9qmg","category_id":"cjarwcknr000v8oraij6sgifb","_id":"cjarwckob001n8orats28h4h4"},{"post_id":"cjarwcko5001h8oraq27kzi5p","category_id":"cjarwcknr000v8oraij6sgifb","_id":"cjarwckog001r8ora010tk5xw"},{"post_id":"cjarwcknh000i8oraqq0qkxy2","category_id":"cjarwckni000k8oraap36ou42","_id":"cjarwckoj001u8oramqgdukr2"},{"post_id":"cjarwcknj000m8orak8qj1nn3","category_id":"cjarwcko8001k8oraf4tusfs5","_id":"cjarwckol001y8oraf4i3scqw"},{"post_id":"cjarwcknk000o8oragdbn4p8x","category_id":"cjarwckoh001s8ora3zanetxh","_id":"cjarwckor00248orahib5qd4m"},{"post_id":"cjarwckno000s8oradjyzqkr7","category_id":"cjarwckom001z8oralclfjab7","_id":"cjarwckox002b8orag56ptajn"},{"post_id":"cjarwcknp000u8ora31f0l04k","category_id":"cjarwckoh001s8ora3zanetxh","_id":"cjarwckp1002f8oran1e9c1jt"},{"post_id":"cjarwckox002c8orax47qi90a","category_id":"cjarwckmr00038ora05zst9a1","_id":"cjarwckp4002k8oras3o0diwz"},{"post_id":"cjarwcknr000x8ora39wwmew2","category_id":"cjarwckox002a8ora1pj392yy","_id":"cjarwckp5002n8ora4lnwg0a8"},{"post_id":"cjarwcknt00108ora5fzsf5i9","category_id":"cjarwckp2002i8oracvypewrn","_id":"cjarwckp9002t8ora2180rofr"},{"post_id":"cjarwcknx00158orah2jj8uh9","category_id":"cjarwckp6002p8oraoa4hqj4m","_id":"cjarwckpd002z8ora408i2iib"},{"post_id":"cjarwcknz00188ora3rbkk3y5","category_id":"cjarwckpa002v8ora1n1xcz1i","_id":"cjarwckph00358oraipa2fmen"},{"post_id":"cjarwcko1001b8orauf8pv6wj","category_id":"cjarwckpe00318oragegbh4ja","_id":"cjarwckpp003c8ora2i3fuzz6"},{"post_id":"cjarwcko7001j8oran80tacch","category_id":"cjarwckpi00388ora0few5aq7","_id":"cjarwckpt003h8oramfihot0w"},{"post_id":"cjarwcko9001m8orad335ksl4","category_id":"cjarwckpq003e8orazftocqqs","_id":"cjarwckpw003m8orabpzto8li"},{"post_id":"cjarwckoe001q8orafcuqslik","category_id":"cjarwckpq003e8orazftocqqs","_id":"cjarwckpz003p8orautebpwdh"},{"post_id":"cjarwckoh001t8orajl7kqk09","category_id":"cjarwckpw003l8ora8b7ysufs","_id":"cjarwckq1003t8oramn46ps71"},{"post_id":"cjarwckok001w8oradd5wbz9w","category_id":"cjarwckq0003q8oraei4eih4w","_id":"cjarwckq2003x8ora49dvv92k"},{"post_id":"cjarwckoo00208oraaraxg091","category_id":"cjarwckq1003u8orad2j6l5r0","_id":"cjarwckq300418orau6ysxq3f"},{"post_id":"cjarwckoq00228oraoy45ozq4","category_id":"cjarwckq2003y8oraqruga49u","_id":"cjarwckq600468ora6jbc3bul"},{"post_id":"cjarwckot00268ora07i4wp1v","category_id":"cjarwckq1003u8orad2j6l5r0","_id":"cjarwckq700498orajc7zsqni"},{"post_id":"cjarwckov00288orafw18nvbh","category_id":"cjarwckq600458oraoslmqz0b","_id":"cjarwckq8004d8orajfo85rsk"},{"post_id":"cjarwckoz002d8oraqk53zzw8","category_id":"cjarwckq7004a8oradz8ta34j","_id":"cjarwckqa004i8ora6cnnezi6"},{"post_id":"cjarwckp1002h8ora20cmhe3x","category_id":"cjarwckq7004a8oradz8ta34j","_id":"cjarwckqb004k8orapieevm08"},{"post_id":"cjarwckp3002j8ora508j4qdo","category_id":"cjarwckqa004h8orautgd4mi1","_id":"cjarwckqc004p8orag3ze9rmc"},{"post_id":"cjarwckp5002m8ora3zi9w285","category_id":"cjarwckqa004h8orautgd4mi1","_id":"cjarwckqe004t8oraa0dmd7wh"},{"post_id":"cjarwckp6002q8oralzqrcj32","category_id":"cjarwckqa004h8orautgd4mi1","_id":"cjarwckqf004w8oradbxggrdw"},{"post_id":"cjarwckp8002s8orautizmcpv","category_id":"cjarwckqd004s8ora8wkrht4i","_id":"cjarwckqg00508oram6i7wfus"},{"post_id":"cjarwckpa002w8orary0im9k5","category_id":"cjarwckqf004x8ora9y0p7zrr","_id":"cjarwckqi00558ora8fghrr30"},{"post_id":"cjarwckpc002y8ora49vh7lgh","category_id":"cjarwckqa004h8orautgd4mi1","_id":"cjarwckqk00598orarg0e928h"},{"post_id":"cjarwckpe00328oraf2h79g76","category_id":"cjarwckq7004a8oradz8ta34j","_id":"cjarwckql005d8oraddvbtu9g"},{"post_id":"cjarwckpf00338ora7ys2a0kg","category_id":"cjarwckq7004a8oradz8ta34j","_id":"cjarwckqn005h8ora6cic732k"},{"post_id":"cjarwckph00378orazloys5k5","category_id":"cjarwckq7004a8oradz8ta34j","_id":"cjarwckqo005j8oratjbhsyl4"},{"post_id":"cjarwckpj00398orayqinq840","category_id":"cjarwckqm005g8orajk05vshs","_id":"cjarwckqp005n8orasmxcqtwc"},{"post_id":"cjarwckpm003b8oraherv20ml","category_id":"cjarwckqo005l8oraok4p4fkv","_id":"cjarwckqq005r8oralwzsi2q3"},{"post_id":"cjarwckpq003f8oraz8buyg29","category_id":"cjarwckqp005p8ora7eepyvay","_id":"cjarwckqr005u8orarldjzppl"}],"PostTag":[{"post_id":"cjarwckmj00018orai2p9ei1k","tag_id":"cjarwckmt00048ora3qhag20j","_id":"cjarwckn9000a8orawekw318e"},{"post_id":"cjarwckmo00028ora63i21kbo","tag_id":"cjarwckn400098oracdua0eae","_id":"cjarwcknh000h8ora1xo8cak5"},{"post_id":"cjarwckmu00058ora7i0lua8v","tag_id":"cjarwcknf000f8oral28qdzyi","_id":"cjarwcknk000n8oran1rq7rpg"},{"post_id":"cjarwckmx00068orav8f6qoor","tag_id":"cjarwcknj000l8oralgxoq57u","_id":"cjarwcknp000t8orauivv65o2"},{"post_id":"cjarwckn200078ora8mv48y8e","tag_id":"cjarwcknn000r8oram8ydbivd","_id":"cjarwcknt000z8ora801z1vr0"},{"post_id":"cjarwckn9000b8orapvg8hqqr","tag_id":"cjarwckns000y8oraeecqjkwf","_id":"cjarwckny00168orak0w8iyi6"},{"post_id":"cjarwcknc000c8oraerw7f488","tag_id":"cjarwcknx00148orahb4olp8q","_id":"cjarwcko3001c8ora4ytpyi9a"},{"post_id":"cjarwcknf000g8orajotthrmu","tag_id":"cjarwcko0001a8ora9db3v5op","_id":"cjarwcko7001i8orap235sids"},{"post_id":"cjarwcknh000i8oraqq0qkxy2","tag_id":"cjarwcko5001g8ora5ymxmsvg","_id":"cjarwckod001p8ora1slil9qk"},{"post_id":"cjarwcknj000m8orak8qj1nn3","tag_id":"cjarwckob001o8ora07p6kdvo","_id":"cjarwckol001x8orampklmz4b"},{"post_id":"cjarwcknk000o8oragdbn4p8x","tag_id":"cjarwckoj001v8ora1dcf825o","_id":"cjarwckor00238oraqhekkev5"},{"post_id":"cjarwckno000s8oradjyzqkr7","tag_id":"cjarwckop00218orav9qma0se","_id":"cjarwckow00298oraexptpupy"},{"post_id":"cjarwcknp000u8ora31f0l04k","tag_id":"cjarwckov00278oranjago08j","_id":"cjarwckp1002g8ora2e6o56n4"},{"post_id":"cjarwcknr000x8ora39wwmew2","tag_id":"cjarwckp0002e8orag9d04qoo","_id":"cjarwckp6002o8orazexah9rq"},{"post_id":"cjarwcknt00108ora5fzsf5i9","tag_id":"cjarwckp4002l8oramc3iwo5h","_id":"cjarwckpa002u8oras3ichy9y"},{"post_id":"cjarwcknx00158orah2jj8uh9","tag_id":"cjarwckp7002r8ora0r9p9hjz","_id":"cjarwckpd00308oraa0z6j5pb"},{"post_id":"cjarwcknz00188ora3rbkk3y5","tag_id":"cjarwckpc002x8oranvtn7a7p","_id":"cjarwckph00368oraw4okmutw"},{"post_id":"cjarwcko1001b8orauf8pv6wj","tag_id":"cjarwckpg00348orahquc4otq","_id":"cjarwckpq003d8orahm967zs5"},{"post_id":"cjarwcko3001d8orank9c9qmg","tag_id":"cjarwckpm003a8orampqlsm9e","_id":"cjarwckpu003i8orahxhvux5w"},{"post_id":"cjarwcko5001h8oraq27kzi5p","tag_id":"cjarwckps003g8orasgtt42h6","_id":"cjarwckpx003n8orar6hlbvxv"},{"post_id":"cjarwcko7001j8oran80tacch","tag_id":"cjarwckpv003k8ora6zbrtjam","_id":"cjarwckq0003r8ora5me5iz20"},{"post_id":"cjarwcko9001m8orad335ksl4","tag_id":"cjarwckpy003o8orayyq7myvu","_id":"cjarwckq1003v8ora58wp0jz2"},{"post_id":"cjarwckoe001q8orafcuqslik","tag_id":"cjarwckq0003s8orancv66g8c","_id":"cjarwckq3003z8oraw97s7zrd"},{"post_id":"cjarwckoh001t8orajl7kqk09","tag_id":"cjarwckq2003w8ora8nlfx7eg","_id":"cjarwckq400438oram4l2k0rc"},{"post_id":"cjarwckok001w8oradd5wbz9w","tag_id":"cjarwckq300408oraea2mya73","_id":"cjarwckq600478orazzpi1ynq"},{"post_id":"cjarwckoo00208oraaraxg091","tag_id":"cjarwckq500448ora7b9bfm4w","_id":"cjarwckq8004b8ora1cuzt2iu"},{"post_id":"cjarwckoq00228oraoy45ozq4","tag_id":"cjarwckq700488ora1xg7hsgn","_id":"cjarwckq9004f8ora7wo8nuwr"},{"post_id":"cjarwckot00268ora07i4wp1v","tag_id":"cjarwckq8004c8oragy7aq7xg","_id":"cjarwckqa004j8oragp70va0m"},{"post_id":"cjarwckov00288orafw18nvbh","tag_id":"cjarwckq9004g8oravt5a88d1","_id":"cjarwckqb004n8ora7cmfx2zi"},{"post_id":"cjarwckox002c8orax47qi90a","tag_id":"cjarwckqb004l8orazmzuqstb","_id":"cjarwckqd004r8oratl1dpsuq"},{"post_id":"cjarwckoz002d8oraqk53zzw8","tag_id":"cjarwckqc004q8oraw14704fl","_id":"cjarwckqe004v8orah885v2eb"},{"post_id":"cjarwckp1002h8ora20cmhe3x","tag_id":"cjarwckqe004u8ora7xwad62d","_id":"cjarwckqg004z8ora0r0k64wn"},{"post_id":"cjarwckp3002j8ora508j4qdo","tag_id":"cjarwckqf004y8orao6m4wh8i","_id":"cjarwckqi00538oradjxfwhwo"},{"post_id":"cjarwckp5002m8ora3zi9w285","tag_id":"cjarwckqh00528ora3i6sbwd2","_id":"cjarwckqj00578ora8g4wd7et"},{"post_id":"cjarwckp6002q8oralzqrcj32","tag_id":"cjarwckqj00568ora4pau8jdb","_id":"cjarwckql005b8oraenz992ei"},{"post_id":"cjarwckp8002s8orautizmcpv","tag_id":"cjarwckqk005a8oramtcy77q5","_id":"cjarwckqm005f8ora0s9qdgqu"},{"post_id":"cjarwckpa002w8orary0im9k5","tag_id":"cjarwckqm005e8orapyrtodsc","_id":"cjarwckqo005k8ora8x64qug3"},{"post_id":"cjarwckpc002y8ora49vh7lgh","tag_id":"cjarwckqn005i8oraopalhuvl","_id":"cjarwckqp005o8orar6cubfsf"},{"post_id":"cjarwckpe00328oraf2h79g76","tag_id":"cjarwckqp005m8ora2ikmrvzw","_id":"cjarwckqq005s8orawi9vfzmu"},{"post_id":"cjarwckpf00338ora7ys2a0kg","tag_id":"cjarwckqq005q8oraey42qbe4","_id":"cjarwckqr005v8oraw2tmo7pg"},{"post_id":"cjarwckph00378orazloys5k5","tag_id":"cjarwckqr005t8ora68ubxe9y","_id":"cjarwckqs005x8orat5c05x4t"},{"post_id":"cjarwckpm003b8oraherv20ml","tag_id":"cjarwckqr005w8orasjm3sskf","_id":"cjarwckqs005z8orahzuvaeez"},{"post_id":"cjarwckpq003f8oraz8buyg29","tag_id":"cjarwckqs005y8oraabl7cndt","_id":"cjarwckqt00608orattpxn9c1"}],"Tag":[{"name":"api-version-manage","_id":"cjarwckmt00048ora3qhag20j"},{"name":"apidoc","_id":"cjarwckn400098oracdua0eae"},{"name":"nginx负载均衡","_id":"cjarwcknf000f8oral28qdzyi"},{"name":"centos-jdk8-install","_id":"cjarwcknj000l8oralgxoq57u"},{"name":"centos登录","_id":"cjarwcknn000r8oram8ydbivd"},{"name":"cron-grammar","_id":"cjarwckns000y8oraeecqjkwf"},{"name":"distributed-difficulty","_id":"cjarwcknx00148orahb4olp8q"},{"name":"snowflake算法","_id":"cjarwcko0001a8ora9db3v5op"},{"name":"centos-nexus","_id":"cjarwcko5001g8ora5ymxmsvg"},{"name":"centos-docker-install","_id":"cjarwckob001o8ora07p6kdvo"},{"name":"git-install-in-centos","_id":"cjarwckoj001v8ora1dcf825o"},{"name":"github-fork-repo-update","_id":"cjarwckop00218orav9qma0se"},{"name":"git-server-build","_id":"cjarwckov00278oranjago08j"},{"name":"hashicorp-vault","_id":"cjarwckp0002e8orag9d04qoo"},{"name":"hibernate-relation","_id":"cjarwckp4002l8oramc3iwo5h"},{"name":"http-overview","_id":"cjarwckp7002r8ora0r9p9hjz"},{"name":"idea插件利器","_id":"cjarwckpc002x8oranvtn7a7p"},{"name":"jackson","_id":"cjarwckpg00348orahquc4otq"},{"name":"cglib","_id":"cjarwckpm003a8orampqlsm9e"},{"name":"java-nio-buffer","_id":"cjarwckps003g8orasgtt42h6"},{"name":"jenkins-java-maven","_id":"cjarwckpv003k8ora6zbrtjam"},{"name":"gc垃圾回收","_id":"cjarwckpy003o8orayyq7myvu"},{"name":"jvm监控工具","_id":"cjarwckq0003s8orancv66g8c"},{"name":"linux-command","_id":"cjarwckq2003w8ora8nlfx7eg"},{"name":"maven-error","_id":"cjarwckq300408oraea2mya73"},{"name":"mysql建表规范","_id":"cjarwckq500448ora7b9bfm4w"},{"name":"pws-push","_id":"cjarwckq700488ora1xg7hsgn"},{"name":"mysql-expain","_id":"cjarwckq8004c8oragy7aq7xg"},{"name":"redis","_id":"cjarwckq9004g8oravt5a88d1"},{"name":"restful-api","_id":"cjarwckqb004l8orazmzuqstb"},{"name":"change-contextpath-way","_id":"cjarwckqc004q8oraw14704fl"},{"name":"sboot-often-error","_id":"cjarwckqe004u8ora7xwad62d"},{"name":"feign使用常见问题","_id":"cjarwckqf004y8orao6m4wh8i"},{"name":"zuul-exception","_id":"cjarwckqh00528ora3i6sbwd2"},{"name":"zuul-filters","_id":"cjarwckqj00568ora4pau8jdb"},{"name":"shadowsocks-go","_id":"cjarwckqk005a8oramtcy77q5"},{"name":"微服务实践总结","_id":"cjarwckqm005e8orapyrtodsc"},{"name":"zuul-start","_id":"cjarwckqn005i8oraopalhuvl"},{"name":"spring-boot-async","_id":"cjarwckqp005m8ora2ikmrvzw"},{"name":"spring-cors","_id":"cjarwckqq005q8oraey42qbe4"},{"name":"jpa读写分离配置","_id":"cjarwckqr005t8ora68ubxe9y"},{"name":"website-high-performance","_id":"cjarwckqr005w8orasjm3sskf"},{"name":"teamcity-start","_id":"cjarwckqs005y8oraabl7cndt"}]}}